// Generated by Haxe 4.3.7
(function ($hx_exports, $global) { "use strict";
$hx_exports["engine"] = $hx_exports["engine"] || {};
var $hxClasses = {},$estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
$hxClasses["EReg"] = EReg;
EReg.__name__ = "EReg";
EReg.prototype = {
	match: function(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	,matched: function(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw haxe_Exception.thrown("EReg::matched");
		}
	}
	,matchedPos: function() {
		if(this.r.m == null) {
			throw haxe_Exception.thrown("No string matched");
		}
		return { pos : this.r.m.index, len : this.r.m[0].length};
	}
	,matchSub: function(s,pos,len) {
		if(len == null) {
			len = -1;
		}
		if(this.r.global) {
			this.r.lastIndex = pos;
			this.r.m = this.r.exec(len < 0 ? s : HxOverrides.substr(s,0,pos + len));
			var b = this.r.m != null;
			if(b) {
				this.r.s = s;
			}
			return b;
		} else {
			var b = this.match(len < 0 ? HxOverrides.substr(s,pos,null) : HxOverrides.substr(s,pos,len));
			if(b) {
				this.r.s = s;
				this.r.m.index += pos;
			}
			return b;
		}
	}
	,split: function(s) {
		var d = "#__delim__#";
		return s.replace(this.r,d).split(d);
	}
	,__class__: EReg
};
var HxOverrides = function() { };
$hxClasses["HxOverrides"] = HxOverrides;
HxOverrides.__name__ = "HxOverrides";
HxOverrides.strDate = function(s) {
	switch(s.length) {
	case 8:
		var k = s.split(":");
		var d = new Date();
		d["setTime"](0);
		d["setUTCHours"](k[0]);
		d["setUTCMinutes"](k[1]);
		d["setUTCSeconds"](k[2]);
		return d;
	case 10:
		var k = s.split("-");
		return new Date(k[0],k[1] - 1,k[2],0,0,0);
	case 19:
		var k = s.split(" ");
		var y = k[0].split("-");
		var t = k[1].split(":");
		return new Date(y[0],y[1] - 1,y[2],t[0],t[1],t[2]);
	default:
		throw haxe_Exception.thrown("Invalid date format : " + s);
	}
};
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.now = function() {
	return Date.now();
};
var Lambda = function() { };
$hxClasses["Lambda"] = Lambda;
Lambda.__name__ = "Lambda";
Lambda.array = function(it) {
	var a = [];
	var i = $getIterator(it);
	while(i.hasNext()) {
		var i1 = i.next();
		a.push(i1);
	}
	return a;
};
var h3d_IDrawable = function() { };
$hxClasses["h3d.IDrawable"] = h3d_IDrawable;
h3d_IDrawable.__name__ = "h3d.IDrawable";
h3d_IDrawable.__isInterface__ = true;
h3d_IDrawable.prototype = {
	__class__: h3d_IDrawable
};
var hxd_App = function() {
	var _gthis = this;
	var engine = h3d_Engine.CURRENT;
	if(engine != null) {
		this.engine = engine;
		engine.onReady = $bind(this,this.setup);
		haxe_Timer.delay($bind(this,this.setup),0);
	} else {
		hxd_System.start(function() {
			engine = new h3d_Engine();
			_gthis.engine = engine;
			engine.onReady = $bind(_gthis,_gthis.setup);
			engine.init();
		});
	}
};
$hxClasses["hxd.App"] = hxd_App;
hxd_App.__name__ = "hxd.App";
hxd_App.__interfaces__ = [h3d_IDrawable];
hxd_App.staticHandler = function() {
};
hxd_App.prototype = {
	onResize: function() {
	}
	,setScene: function(scene,disposePrevious) {
		if(disposePrevious == null) {
			disposePrevious = true;
		}
		var new2D = ((scene) instanceof h2d_Scene) ? scene : null;
		var new3D = ((scene) instanceof h3d_scene_Scene) ? scene : null;
		if(new2D != null) {
			this.sevents.removeScene(this.s2d);
			this.sevents.addScene(scene,0);
		} else if(new3D != null) {
			this.sevents.removeScene(this.s3d);
			this.sevents.addScene(scene);
		}
		if(disposePrevious) {
			if(new2D != null) {
				this.s2d.dispose();
			} else if(new3D != null) {
				this.s3d.dispose();
			} else {
				throw haxe_Exception.thrown("Can't dispose previous scene");
			}
		}
		if(new2D != null) {
			this.s2d = new2D;
		}
		if(new3D != null) {
			this.s3d = new3D;
		}
	}
	,setCurrent: function() {
		var _gthis = this;
		this.engine = h3d_Engine.CURRENT;
		this.isDisposed = false;
		this.engine.onReady = hxd_App.staticHandler;
		this.engine.onContextLost = $bind(this,this.onContextLost);
		this.engine.onResized = function() {
			if(_gthis.s2d == null) {
				return;
			}
			_gthis.s2d.checkResize();
			_gthis.onResize();
		};
		hxd_System.setLoop($bind(this,this.mainLoop));
	}
	,onContextLost: function() {
		if(this.s3d != null) {
			this.s3d.onContextLost();
		}
	}
	,setScene2D: function(s2d,disposePrevious) {
		if(disposePrevious == null) {
			disposePrevious = true;
		}
		this.sevents.removeScene(this.s2d);
		this.sevents.addScene(s2d,0);
		if(disposePrevious) {
			this.s2d.dispose();
		}
		this.s2d = s2d;
		s2d.mark = $bind(this,this.mark);
	}
	,setScene3D: function(s3d,disposePrevious) {
		if(disposePrevious == null) {
			disposePrevious = true;
		}
		this.sevents.removeScene(this.s3d);
		this.sevents.addScene(s3d);
		if(disposePrevious) {
			this.s3d.dispose();
		}
		this.s3d = s3d;
	}
	,render: function(e) {
		this.s3d.render(e);
		this.s2d.render(e);
	}
	,mark: function(name) {
		this.s3d.mark(name);
	}
	,setup: function() {
		var _gthis = this;
		var initDone = false;
		this.engine.onReady = hxd_App.staticHandler;
		this.engine.onContextLost = $bind(this,this.onContextLost);
		this.engine.onResized = function() {
			if(_gthis.s2d == null) {
				return;
			}
			_gthis.s2d.checkResize();
			if(initDone) {
				_gthis.onResize();
			}
		};
		this.s3d = new h3d_scene_Scene();
		this.s2d = new h2d_Scene();
		this.s2d.mark = $bind(this,this.mark);
		this.sevents = new hxd_SceneEvents();
		this.sevents.addScene(this.s2d);
		this.sevents.addScene(this.s3d);
		this.loadAssets(function() {
			initDone = true;
			_gthis.init();
			hxd_Timer.skip();
			_gthis.mainLoop();
			hxd_System.setLoop($bind(_gthis,_gthis.mainLoop));
			hxd_Key.initialize();
		});
	}
	,dispose: function() {
		this.engine.onResized = hxd_App.staticHandler;
		this.engine.onContextLost = hxd_App.staticHandler;
		this.isDisposed = true;
		if(this.s2d != null) {
			this.s2d.dispose();
		}
		if(this.s3d != null) {
			this.s3d.dispose();
		}
		if(this.sevents != null) {
			this.sevents.dispose();
		}
	}
	,loadAssets: function(onLoaded) {
		onLoaded();
	}
	,init: function() {
	}
	,mainLoop: function() {
		hxd_Timer.update();
		this.sevents.checkEvents();
		if(this.isDisposed) {
			return;
		}
		this.update(hxd_Timer.dt);
		if(this.isDisposed) {
			return;
		}
		var dt = hxd_Timer.dt;
		if(this.s2d != null) {
			this.s2d.setElapsedTime(dt);
		}
		if(this.s3d != null) {
			this.s3d.setElapsedTime(dt);
		}
		this.engine.render(this);
	}
	,update: function(dt) {
	}
	,__class__: hxd_App
};
var Main = function() {
	hxd_App.call(this);
};
$hxClasses["Main"] = Main;
Main.__name__ = "Main";
Main.main = function() {
	hxd_Res.set_loader(new hxd_res_Loader(new hxd_fs_EmbedFileSystem(haxe_Unserializer.run("oy9:README.mdty10:marius.pngtg"))));
	new Main();
};
Main.__super__ = hxd_App;
Main.prototype = $extend(hxd_App.prototype,{
	init: function() {
		var _gthis = this;
		this.engine.backgroundColor = 16777215;
		this.sceneManager = new game_scene_SceneManager(function(scene) {
			_gthis.setScene2D(scene);
		});
	}
	,onResize: function() {
		this.updateViewport();
	}
	,updateViewport: function() {
	}
	,update: function(dt) {
		hxd_App.prototype.update.call(this,dt);
		if(this.sceneManager != null) {
			this.sceneManager.getCurrentScene().customUpdate(dt,this.engine.get_fps());
		}
	}
	,__class__: Main
});
Math.__name__ = "Math";
var Reflect = function() { };
$hxClasses["Reflect"] = Reflect;
Reflect.__name__ = "Reflect";
Reflect.field = function(o,field) {
	try {
		return o[field];
	} catch( _g ) {
		return null;
	}
};
Reflect.fields = function(o) {
	var a = [];
	if(o != null) {
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		for( var f in o ) {
		if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
			a.push(f);
		}
		}
	}
	return a;
};
Reflect.isFunction = function(f) {
	if(typeof(f) == "function") {
		return !(f.__name__ || f.__ename__);
	} else {
		return false;
	}
};
Reflect.compare = function(a,b) {
	if(a == b) {
		return 0;
	} else if(a > b) {
		return 1;
	} else {
		return -1;
	}
};
Reflect.isEnumValue = function(v) {
	if(v != null) {
		return v.__enum__ != null;
	} else {
		return false;
	}
};
Reflect.deleteField = function(o,field) {
	if(!Object.prototype.hasOwnProperty.call(o,field)) {
		return false;
	}
	delete(o[field]);
	return true;
};
Reflect.copy = function(o) {
	if(o == null) {
		return null;
	}
	var o2 = { };
	var _g = 0;
	var _g1 = Reflect.fields(o);
	while(_g < _g1.length) {
		var f = _g1[_g];
		++_g;
		o2[f] = Reflect.field(o,f);
	}
	return o2;
};
var Std = function() { };
$hxClasses["Std"] = Std;
Std.__name__ = "Std";
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	var v = parseInt(x);
	if(isNaN(v)) {
		return null;
	}
	return v;
};
Std.random = function(x) {
	if(x <= 0) {
		return 0;
	} else {
		return Math.floor(Math.random() * x);
	}
};
var StringBuf = function() {
	this.b = "";
};
$hxClasses["StringBuf"] = StringBuf;
StringBuf.__name__ = "StringBuf";
StringBuf.prototype = {
	__class__: StringBuf
};
var StringTools = function() { };
$hxClasses["StringTools"] = StringTools;
StringTools.__name__ = "StringTools";
StringTools.htmlEscape = function(s,quotes) {
	var buf_b = "";
	var _g_offset = 0;
	var _g_s = s;
	while(_g_offset < _g_s.length) {
		var s = _g_s;
		var index = _g_offset++;
		var c = s.charCodeAt(index);
		if(c >= 55296 && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
		}
		var c1 = c;
		if(c1 >= 65536) {
			++_g_offset;
		}
		var code = c1;
		switch(code) {
		case 34:
			if(quotes) {
				buf_b += "&quot;";
			} else {
				buf_b += String.fromCodePoint(code);
			}
			break;
		case 38:
			buf_b += "&amp;";
			break;
		case 39:
			if(quotes) {
				buf_b += "&#039;";
			} else {
				buf_b += String.fromCodePoint(code);
			}
			break;
		case 60:
			buf_b += "&lt;";
			break;
		case 62:
			buf_b += "&gt;";
			break;
		default:
			buf_b += String.fromCodePoint(code);
		}
	}
	return buf_b;
};
StringTools.startsWith = function(s,start) {
	if(s.length >= start.length) {
		return s.lastIndexOf(start,0) == 0;
	} else {
		return false;
	}
};
StringTools.endsWith = function(s,end) {
	var elen = end.length;
	var slen = s.length;
	if(slen >= elen) {
		return s.indexOf(end,slen - elen) == slen - elen;
	} else {
		return false;
	}
};
StringTools.isSpace = function(s,pos) {
	var c = HxOverrides.cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
};
StringTools.ltrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,r)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,r,l - r);
	} else {
		return s;
	}
};
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,0,l - r);
	} else {
		return s;
	}
};
StringTools.trim = function(s) {
	return StringTools.ltrim(StringTools.rtrim(s));
};
StringTools.replace = function(s,sub,by) {
	return s.split(sub).join(by);
};
StringTools.hex = function(n,digits) {
	var s = "";
	var hexChars = "0123456789ABCDEF";
	do {
		s = hexChars.charAt(n & 15) + s;
		n >>>= 4;
	} while(n > 0);
	if(digits != null) {
		while(s.length < digits) s = "0" + s;
	}
	return s;
};
var Type = function() { };
$hxClasses["Type"] = Type;
Type.__name__ = "Type";
Type.createInstance = function(cl,args) {
	var ctor = Function.prototype.bind.apply(cl,[null].concat(args));
	return new (ctor);
};
Type.createEnum = function(e,constr,params) {
	var f = Reflect.field(e,constr);
	if(f == null) {
		throw haxe_Exception.thrown("No such constructor " + constr);
	}
	if(Reflect.isFunction(f)) {
		if(params == null) {
			throw haxe_Exception.thrown("Constructor " + constr + " need parameters");
		}
		return f.apply(e,params);
	}
	if(params != null && params.length != 0) {
		throw haxe_Exception.thrown("Constructor " + constr + " does not need parameters");
	}
	return f;
};
Type.createEnumIndex = function(e,index,params) {
	var c;
	var _g = e.__constructs__[index];
	if(_g == null) {
		c = null;
	} else {
		var ctor = _g;
		c = ctor._hx_name;
	}
	if(c == null) {
		throw haxe_Exception.thrown(index + " is not a valid enum constructor index");
	}
	return Type.createEnum(e,c,params);
};
Type.enumEq = function(a,b) {
	if(a == b) {
		return true;
	}
	try {
		var e = a.__enum__;
		if(e == null || e != b.__enum__) {
			return false;
		}
		if(a._hx_index != b._hx_index) {
			return false;
		}
		var enm = $hxEnums[e];
		var params = enm.__constructs__[a._hx_index].__params__;
		var _g = 0;
		while(_g < params.length) {
			var f = params[_g];
			++_g;
			if(!Type.enumEq(a[f],b[f])) {
				return false;
			}
		}
	} catch( _g ) {
		return false;
	}
	return true;
};
Type.enumParameters = function(e) {
	var enm = $hxEnums[e.__enum__];
	var params = enm.__constructs__[e._hx_index].__params__;
	if(params != null) {
		var _g = [];
		var _g1 = 0;
		while(_g1 < params.length) {
			var p = params[_g1];
			++_g1;
			_g.push(e[p]);
		}
		return _g;
	} else {
		return [];
	}
};
var XmlType = {};
XmlType.toString = function(this1) {
	switch(this1) {
	case 0:
		return "Element";
	case 1:
		return "PCData";
	case 2:
		return "CData";
	case 3:
		return "Comment";
	case 4:
		return "DocType";
	case 5:
		return "ProcessingInstruction";
	case 6:
		return "Document";
	}
};
var Xml = function(nodeType) {
	this.nodeType = nodeType;
	this.children = [];
	this.attributeMap = new haxe_ds_StringMap();
};
$hxClasses["Xml"] = Xml;
Xml.__name__ = "Xml";
Xml.parse = function(str) {
	return haxe_xml_Parser.parse(str);
};
Xml.createElement = function(name) {
	var xml = new Xml(Xml.Element);
	if(xml.nodeType != Xml.Element) {
		throw haxe_Exception.thrown("Bad node type, expected Element but found " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
	}
	xml.nodeName = name;
	return xml;
};
Xml.createPCData = function(data) {
	var xml = new Xml(Xml.PCData);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createCData = function(data) {
	var xml = new Xml(Xml.CData);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createComment = function(data) {
	var xml = new Xml(Xml.Comment);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createDocType = function(data) {
	var xml = new Xml(Xml.DocType);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createProcessingInstruction = function(data) {
	var xml = new Xml(Xml.ProcessingInstruction);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createDocument = function() {
	return new Xml(Xml.Document);
};
Xml.prototype = {
	get: function(att) {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		return this.attributeMap.h[att];
	}
	,set: function(att,value) {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		this.attributeMap.h[att] = value;
	}
	,exists: function(att) {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		return Object.prototype.hasOwnProperty.call(this.attributeMap.h,att);
	}
	,attributes: function() {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		return new haxe_ds__$StringMap_StringMapKeyIterator(this.attributeMap.h);
	}
	,elements: function() {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = this.children;
		while(_g1 < _g2.length) {
			var child = _g2[_g1];
			++_g1;
			if(child.nodeType == Xml.Element) {
				_g.push(child);
			}
		}
		var ret = _g;
		return new haxe_iterators_ArrayIterator(ret);
	}
	,elementsNamed: function(name) {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = this.children;
		while(_g1 < _g2.length) {
			var child = _g2[_g1];
			++_g1;
			var tmp;
			if(child.nodeType == Xml.Element) {
				if(child.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (child.nodeType == null ? "null" : XmlType.toString(child.nodeType)));
				}
				tmp = child.nodeName == name;
			} else {
				tmp = false;
			}
			if(tmp) {
				_g.push(child);
			}
		}
		var ret = _g;
		return new haxe_iterators_ArrayIterator(ret);
	}
	,firstElement: function() {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			if(child.nodeType == Xml.Element) {
				return child;
			}
		}
		return null;
	}
	,addChild: function(x) {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		if(x.parent != null) {
			x.parent.removeChild(x);
		}
		this.children.push(x);
		x.parent = this;
	}
	,removeChild: function(x) {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		if(HxOverrides.remove(this.children,x)) {
			x.parent = null;
			return true;
		}
		return false;
	}
	,toString: function() {
		return haxe_xml_Printer.print(this);
	}
	,__class__: Xml
};
var engine_EngineMode = $hxEnums["engine.EngineMode"] = { __ename__:true,__constructs__:null
	,SINGLEPLAYER: {_hx_name:"SINGLEPLAYER",_hx_index:0,__enum__:"engine.EngineMode",toString:$estr}
	,SERVER: {_hx_name:"SERVER",_hx_index:1,__enum__:"engine.EngineMode",toString:$estr}
	,CLIENT_PREDICTION: {_hx_name:"CLIENT_PREDICTION",_hx_index:2,__enum__:"engine.EngineMode",toString:$estr}
};
engine_EngineMode.__constructs__ = [engine_EngineMode.SINGLEPLAYER,engine_EngineMode.SERVER,engine_EngineMode.CLIENT_PREDICTION];
engine_EngineMode.__empty_constructs__ = [engine_EngineMode.SINGLEPLAYER,engine_EngineMode.SERVER,engine_EngineMode.CLIENT_PREDICTION];
var engine_NecrotonEngine = function(config) {
	engine_NecrotonEngine.Config = config;
	this.state = new engine_model_GameModelState(engine_NecrotonEngine.Config.rngSeed);
	this.modules = new engine_modules_ModuleRegistry();
	this.eventBus = new engine_view_EventBus();
	this.snapshotManager = new engine_presenter_SnapshotManager(engine_NecrotonEngine.Config.snapshotBufferSize);
	this.running = false;
	this.setupModules();
	this.gameLoop = new engine_presenter_GameLoop(this.state,this.modules,this.eventBus);
};
$hxClasses["engine.NecrotonEngine"] = engine_NecrotonEngine;
$hx_exports["engine"]["NecrotonEngine"] = engine_NecrotonEngine;
engine_NecrotonEngine.__name__ = "engine.NecrotonEngine";
engine_NecrotonEngine.create = function(config) {
	return new engine_NecrotonEngine(config);
};
engine_NecrotonEngine.main = function() {
	haxe_Log.trace("Necroton Engine compiled successfully",{ fileName : "src/engine/NecrotonEngine.hx", lineNumber : 104, className : "engine.NecrotonEngine", methodName : "main"});
};
engine_NecrotonEngine.prototype = {
	start: function() {
		this.running = true;
		this.gameLoop.start();
	}
	,stop: function() {
		this.running = false;
		this.gameLoop.stop();
	}
	,stopSimulation: function() {
		this.stop();
	}
	,step: function(dt) {
		this.stepFixed();
	}
	,queueInput: function(input) {
		var inputModule = js_Boot.__cast(this.modules.get("input") , engine_modules_InputModule);
		if(inputModule != null) {
			inputModule.queueInput(input);
		}
	}
	,spawnEntity: function(spec) {
		var entityId = this.state.allocateEntityId();
		spec.id = entityId;
		var manager = this.state.managers.get(spec.type);
		if(manager != null) {
			var entity = manager.create(spec);
			this.eventBus.emit("entity:spawn",{ tick : this.state.tick, entityId : entity.id, type : entity.type, pos : entity.pos, ownerId : entity.ownerId});
			return entity.id;
		}
		return 0;
	}
	,despawnEntity: function(entityId) {
		var _g = 0;
		var _g1 = this.state.managers.getAll();
		while(_g < _g1.length) {
			var manager = _g1[_g];
			++_g;
			var entity = manager.find(entityId);
			if(entity != null) {
				this.eventBus.emit("entity:death",{ tick : this.state.tick, entityId : entityId, killerId : 0});
				manager.destroy(entityId);
				break;
			}
		}
	}
	,subscribeEvent: function(topic,handler) {
		return this.eventBus.subscribe(topic,handler);
	}
	,subscribeEventDynamic: function(topic,handler) {
		return this.eventBus.subscribeDynamic(topic,handler);
	}
	,unsubscribeEvent: function(token) {
		this.eventBus.unsubscribe(token);
	}
	,getSnapshot: function() {
		return this.state.saveMemento();
	}
	,getEventBus: function() {
		return this.eventBus;
	}
	,getInputModule: function() {
		return js_Boot.__cast(this.modules.get("input") , engine_modules_InputModule);
	}
	,getCharacterById: function(id) {
		var manager = this.state.managers.get("character");
		return manager.find(id);
	}
	,getColliderById: function(id) {
		var manager = this.state.managers.get("collider");
		return manager.find(id);
	}
	,getCurrentTick: function() {
		return this.state.tick;
	}
	,getAllEntities: function() {
		var entities = [];
		var _g = 0;
		var _g1 = this.state.managers.getAll();
		while(_g < _g1.length) {
			var manager = _g1[_g];
			++_g;
			manager.iterate(function(entity) {
				entities.push(entity);
			});
		}
		return entities;
	}
	,rollbackAndReplay: function(anchorTick,pendingInputs) {
		var anchorMemento = this.snapshotManager.load(anchorTick);
		if(anchorMemento == null) {
			haxe_Log.trace("Warning: No snapshot found for anchor tick " + anchorTick,{ fileName : "src/engine/NecrotonEngine.hx", lineNumber : 303, className : "engine.NecrotonEngine", methodName : "rollbackAndReplay"});
			return;
		}
		this.state.restoreMemento(anchorMemento);
		var _g = 0;
		while(_g < pendingInputs.length) {
			var input = pendingInputs[_g];
			++_g;
			if(input.intendedServerTick > anchorTick) {
				this.queueInput(input);
			}
		}
		var currentTick = this.state.tick;
		while(this.state.tick < currentTick) this.gameLoop.stepFixed();
		this.emitCorrectionEvents();
	}
	,stepFixed: function() {
		this.gameLoop.stepFixed();
		this.snapshotManager.store(this.state.tick,this.state.saveMemento());
		this.emitSnapshotEvents();
	}
	,setupModules: function() {
		var inputModule = new engine_modules_InputModule();
		var physicsModule = new engine_modules_PhysicsModule();
		var aiModule = new engine_modules_AIModule();
		var spawnModule = new engine_modules_SpawnModule();
		this.modules.register("input",inputModule);
		this.modules.register("physics",physicsModule);
		this.modules.register("ai",aiModule);
		this.modules.register("spawn",spawnModule);
	}
	,emitSnapshotEvents: function() {
		switch(engine_NecrotonEngine.Config.mode._hx_index) {
		case 0:
			break;
		case 1:
			if(this.state.tick % engine_NecrotonEngine.Config.snapshotEmissionInterval == 0) {
				this.eventBus.emit("snapshot",{ tick : this.state.tick, serializedState : this.state.saveMemento()});
			}
			break;
		case 2:
			this.eventBus.emit("snapshot",{ tick : this.state.tick, serializedState : this.state.saveMemento()});
			break;
		}
	}
	,emitCorrectionEvents: function() {
		var _gthis = this;
		var _g = 0;
		var _g1 = this.state.managers.getAll();
		while(_g < _g1.length) {
			var manager = _g1[_g];
			++_g;
			manager.iterate(function(entity) {
				_gthis.eventBus.emit("entity:correction",{ tick : _gthis.state.tick, entityId : entity.id, correctedPos : entity.pos, correctedVel : entity.vel});
			});
		}
	}
	,__class__: engine_NecrotonEngine
};
var engine_geometry_RectUtils = function() { };
$hxClasses["engine.geometry.RectUtils"] = engine_geometry_RectUtils;
engine_geometry_RectUtils.__name__ = "engine.geometry.RectUtils";
engine_geometry_RectUtils.create = function(x,y,width,height) {
	return { x : x, y : y, width : width, height : height};
};
engine_geometry_RectUtils.fromMinMax = function(minX,minY,maxX,maxY) {
	return { x : (minX + maxX) / 2, y : (minY + maxY) / 2, width : maxX - minX, height : maxY - minY};
};
engine_geometry_RectUtils.getBounds = function(rect) {
	var halfWidth = rect.width / 2;
	var halfHeight = rect.height / 2;
	return { minX : rect.x - halfWidth | 0, minY : rect.y - halfHeight | 0, maxX : rect.x + halfWidth | 0, maxY : rect.y + halfHeight | 0};
};
engine_geometry_RectUtils.contains = function(rect,point) {
	var bounds = engine_geometry_RectUtils.getBounds(rect);
	if(point.x >= bounds.minX && point.x <= bounds.maxX && point.y >= bounds.minY) {
		return point.y <= bounds.maxY;
	} else {
		return false;
	}
};
engine_geometry_RectUtils.intersectsRect = function(rectA,rectB) {
	var boundsA = engine_geometry_RectUtils.getBounds(rectA);
	var boundsB = engine_geometry_RectUtils.getBounds(rectB);
	if(boundsA.minX < boundsB.maxX && boundsA.maxX > boundsB.minX && boundsA.minY < boundsB.maxY) {
		return boundsA.maxY > boundsB.minY;
	} else {
		return false;
	}
};
engine_geometry_RectUtils.intersectsLine = function(rect,lineStart,lineEnd) {
	var bounds = engine_geometry_RectUtils.getBounds(rect);
	var dx = lineEnd.x - lineStart.x;
	var dy = lineEnd.y - lineStart.y;
	if(dx == 0) {
		if(lineStart.x >= bounds.minX && lineStart.x <= bounds.maxX) {
			if(!(lineStart.y >= bounds.minY && lineStart.y <= bounds.maxY || lineEnd.y >= bounds.minY && lineEnd.y <= bounds.maxY)) {
				if(lineStart.y < bounds.minY) {
					return lineEnd.y > bounds.maxY;
				} else {
					return false;
				}
			} else {
				return true;
			}
		} else {
			return false;
		}
	}
	if(dy == 0) {
		if(lineStart.y >= bounds.minY && lineStart.y <= bounds.maxY) {
			if(!(lineStart.x >= bounds.minX && lineStart.x <= bounds.maxX || lineEnd.x >= bounds.minX && lineEnd.x <= bounds.maxX)) {
				if(lineStart.x < bounds.minX) {
					return lineEnd.x > bounds.maxX;
				} else {
					return false;
				}
			} else {
				return true;
			}
		} else {
			return false;
		}
	}
	var t0 = 0.0;
	var t1 = 1.0;
	var p_0 = -dx;
	var p_1 = dx;
	var p_2 = -dy;
	var p_3 = dy;
	var q_0 = lineStart.x - bounds.minX;
	var q_1 = bounds.maxX - lineStart.x;
	var q_2 = lineStart.y - bounds.minY;
	var q_3 = bounds.maxY - lineStart.y;
	if(p_0 == 0) {
		if(q_0 < 0) {
			return false;
		}
	} else {
		var t = q_0 / p_0;
		if(p_0 < 0) {
			if(t > t1) {
				return false;
			}
			if(t > t0) {
				t0 = t;
			}
		} else {
			if(t < t0) {
				return false;
			}
			if(t < t1) {
				t1 = t;
			}
		}
	}
	if(p_1 == 0) {
		if(q_1 < 0) {
			return false;
		}
	} else {
		var t = q_1 / p_1;
		if(p_1 < 0) {
			if(t > t1) {
				return false;
			}
			if(t > t0) {
				t0 = t;
			}
		} else {
			if(t < t0) {
				return false;
			}
			if(t < t1) {
				t1 = t;
			}
		}
	}
	if(p_2 == 0) {
		if(q_2 < 0) {
			return false;
		}
	} else {
		var t = q_2 / p_2;
		if(p_2 < 0) {
			if(t > t1) {
				return false;
			}
			if(t > t0) {
				t0 = t;
			}
		} else {
			if(t < t0) {
				return false;
			}
			if(t < t1) {
				t1 = t;
			}
		}
	}
	if(p_3 == 0) {
		if(q_3 < 0) {
			return false;
		}
	} else {
		var t = q_3 / p_3;
		if(p_3 < 0) {
			if(t > t1) {
				return false;
			}
			if(t > t0) {
				t0 = t;
			}
		} else {
			if(t < t0) {
				return false;
			}
			if(t < t1) {
				t1 = t;
			}
		}
	}
	return t0 <= t1;
};
engine_geometry_RectUtils.intersectsCircle = function(rect,circleCenter,radius) {
	var bounds = engine_geometry_RectUtils.getBounds(rect);
	var closestX = Math.max(bounds.minX,Math.min(circleCenter.x,bounds.maxX));
	var closestY = Math.max(bounds.minY,Math.min(circleCenter.y,bounds.maxY));
	var dx = circleCenter.x - closestX;
	var dy = circleCenter.y - closestY;
	var distanceSquared = dx * dx + dy * dy;
	return distanceSquared <= radius * radius;
};
engine_geometry_RectUtils.getIntersectionDepth = function(rectA,rectB) {
	var boundsA = engine_geometry_RectUtils.getBounds(rectA);
	var boundsB = engine_geometry_RectUtils.getBounds(rectB);
	var overlapX = Math.min(boundsA.maxX,boundsB.maxX) - Math.max(boundsA.minX,boundsB.minX);
	var overlapY = Math.min(boundsA.maxY,boundsB.maxY) - Math.max(boundsA.minY,boundsB.minY);
	if(overlapX < overlapY) {
		var direction = boundsA.minX < boundsB.minX ? -1 : 1;
		return { x : overlapX * direction | 0, y : 0};
	} else {
		var direction = boundsA.minY < boundsB.minY ? -1 : 1;
		return { x : 0, y : overlapY * direction | 0};
	}
};
engine_geometry_RectUtils.getArea = function(rect) {
	return rect.width * rect.height;
};
engine_geometry_RectUtils.isValid = function(rect) {
	if(rect.width > 0) {
		return rect.height > 0;
	} else {
		return false;
	}
};
var engine_geometry_Vec2Utils = function() { };
$hxClasses["engine.geometry.Vec2Utils"] = engine_geometry_Vec2Utils;
engine_geometry_Vec2Utils.__name__ = "engine.geometry.Vec2Utils";
engine_geometry_Vec2Utils.create = function(x,y) {
	return { x : x, y : y};
};
engine_geometry_Vec2Utils.add = function(a,b) {
	return { x : a.x + b.x, y : a.y + b.y};
};
engine_geometry_Vec2Utils.sub = function(a,b) {
	return { x : a.x - b.x, y : a.y + b.y};
};
engine_geometry_Vec2Utils.scale = function(v,s) {
	return { x : v.x * s | 0, y : v.y * s | 0};
};
engine_geometry_Vec2Utils.$length = function(v) {
	return Math.sqrt(v.x * v.x + v.y * v.y) | 0;
};
engine_geometry_Vec2Utils.normalize = function(v) {
	var len = engine_geometry_Vec2Utils.$length(v);
	if(len == 0) {
		return { x : 0, y : 0};
	}
	return { x : v.x / len | 0, y : v.y / len | 0};
};
engine_geometry_Vec2Utils.dot = function(a,b) {
	return a.x * b.x + a.y * b.y;
};
engine_geometry_Vec2Utils.clone = function(v) {
	return { x : v.x, y : v.y};
};
engine_geometry_Vec2Utils.distanceSquared = function(a,b) {
	var dx = a.x - b.x;
	var dy = a.y - b.y;
	return dx * dx + dy * dy;
};
var engine_model_DeterministicRng = function(seed) {
	this.seed = seed;
	this.state = seed;
};
$hxClasses["engine.model.DeterministicRng"] = engine_model_DeterministicRng;
engine_model_DeterministicRng.__name__ = "engine.model.DeterministicRng";
engine_model_DeterministicRng.prototype = {
	nextInt: function() {
		this.state = this.state * 1103515245 + 12345 & 2147483647;
		return this.state;
	}
	,nextFloat: function() {
		return this.nextInt() / 2147483647.0;
	}
	,nextFloatRange: function(min,max) {
		return min + this.nextFloat() * (max - min);
	}
	,nextIntRange: function(min,max) {
		return min + this.nextInt() % (max - min);
	}
	,clone: function() {
		var cloned = new engine_model_DeterministicRng(this.seed);
		cloned.state = this.state;
		return cloned;
	}
	,serialize: function() {
		return { seed : this.seed, state : this.state};
	}
	,deserialize: function(data) {
		this.seed = data.seed;
		this.state = data.state;
	}
	,__class__: engine_model_DeterministicRng
};
var engine_model_GameModelState = function(seed) {
	this.tick = 0;
	this.nextEntityId = 1;
	this.rng = new engine_model_DeterministicRng(seed);
	this.transientColliders = [];
	this.objectPool = new engine_model_ObjectPool();
	this.entityFactory = new engine_model_entities_base_EngineEntityFactory(this.objectPool);
	this.managers = new engine_model_managers_EngineEntityManagerRegistry();
	this.setupManagers();
};
$hxClasses["engine.model.GameModelState"] = engine_model_GameModelState;
engine_model_GameModelState.__name__ = "engine.model.GameModelState";
engine_model_GameModelState.prototype = {
	allocateEntityId: function() {
		return this.nextEntityId++;
	}
	,saveMemento: function() {
		return { tick : this.tick, nextEntityId : this.nextEntityId, rng : this.rng.serialize(), transientColliders : this.transientColliders, managers : this.managers.saveMemento()};
	}
	,restoreMemento: function(memento) {
		this.tick = memento.tick;
		this.nextEntityId = memento.nextEntityId;
		this.rng.deserialize(memento.rng);
		this.transientColliders = memento.transientColliders;
		this.managers.restoreMemento(memento.managers);
	}
	,getCharacterManager: function() {
		return this.managers.get("character");
	}
	,getConsumableManager: function() {
		return this.managers.get("consumable");
	}
	,getEffectManager: function() {
		return this.managers.get("effect");
	}
	,getColliderManager: function() {
		return this.managers.get("collider");
	}
	,setupManagers: function() {
		this.managers.register("character",new engine_model_managers_BaseEngineEntityManager(this.entityFactory));
		this.managers.register("consumable",new engine_model_managers_BaseEngineEntityManager(this.entityFactory));
		this.managers.register("effect",new engine_model_managers_BaseEngineEntityManager(this.entityFactory));
		this.managers.register("collider",new engine_model_managers_BaseEngineEntityManager(this.entityFactory));
	}
	,__class__: engine_model_GameModelState
};
var engine_model_ObjectPool = function() {
	this.pools = new haxe_ds_StringMap();
};
$hxClasses["engine.model.ObjectPool"] = engine_model_ObjectPool;
engine_model_ObjectPool.__name__ = "engine.model.ObjectPool";
engine_model_ObjectPool.prototype = {
	prewarm: function(kind,count,factory) {
		if(!Object.prototype.hasOwnProperty.call(this.pools.h,kind)) {
			this.pools.h[kind] = [];
		}
		var pool = this.pools.h[kind];
		var _g = 0;
		var _g1 = count;
		while(_g < _g1) {
			var i = _g++;
			pool.push(factory());
		}
	}
	,acquire: function(kind,factory) {
		if(!Object.prototype.hasOwnProperty.call(this.pools.h,kind)) {
			this.pools.h[kind] = [];
		}
		var pool = this.pools.h[kind];
		if(pool.length > 0) {
			return pool.pop();
		}
		return factory();
	}
	,release: function(kind,obj) {
		if(!Object.prototype.hasOwnProperty.call(this.pools.h,kind)) {
			this.pools.h[kind] = [];
		}
		obj.reset({ id : 0, type : kind, pos : { x : 0, y : 0}, vel : { x : 0, y : 0}, rotation : 0, ownerId : "", isAlive : false});
		this.pools.h[kind].push(obj);
	}
	,__class__: engine_model_ObjectPool
};
var engine_model_entities_EngineEntitySpecs = function() { };
$hxClasses["engine.model.entities.EngineEntitySpecs"] = engine_model_entities_EngineEntitySpecs;
engine_model_entities_EngineEntitySpecs.__name__ = "engine.model.entities.EngineEntitySpecs";
engine_model_entities_EngineEntitySpecs.getPlayerCharacterSpec = function() {
	return { type : "character", pos : { x : 100, y : 100}, ownerId : "player1", level : 1, maxHp : 100, hp : 100, stats : { speed : 8, power : 25, armor : 15, castSpeed : 1}, attackDefs : [], spellBook : [], aiProfile : "player"};
};
engine_model_entities_EngineEntitySpecs.getIdleAcolyteSpec = function() {
	return { type : "character", pos : { x : 150, y : 100}, ownerId : "ai", level : 1, maxHp : 80, hp : 80, stats : { speed : 8, power : 20, armor : 10, castSpeed : 1}, attackDefs : [], spellBook : [], aiProfile : "idle"};
};
engine_model_entities_EngineEntitySpecs.getMonsterSpec = function() {
	return { type : "character", pos : { x : 200, y : 200}, ownerId : "ai", level : 1, maxHp : 50, hp : 50, stats : { speed : 8, power : 15, armor : 5, castSpeed : 1}, attackDefs : [], spellBook : [], aiProfile : "aggressive"};
};
engine_model_entities_EngineEntitySpecs.getHealthPotionSpec = function() {
	return { type : "consumable", pos : { x : 250, y : 150}, ownerId : "world", consumableType : "health_potion", quantity : 1, effectValue : 25};
};
engine_model_entities_EngineEntitySpecs.getManaPotionSpec = function() {
	return { type : "consumable", pos : { x : 300, y : 150}, ownerId : "world", consumableType : "mana_potion", quantity : 1, effectValue : 20};
};
engine_model_entities_EngineEntitySpecs.getSpeedBoostEffectSpec = function() {
	return { type : "effect", pos : { x : 200, y : 100}, ownerId : "world", effectType : "speed_boost", duration : 10, effectValue : 1.5};
};
engine_model_entities_EngineEntitySpecs.getDamageEffectSpec = function() {
	return { type : "effect", pos : { x : 250, y : 200}, ownerId : "world", effectType : "damage", duration : 2, effectValue : 10};
};
engine_model_entities_EngineEntitySpecs.getSpawnPositions = function() {
	return { player : [{ x : 100, y : 100}], acolytes : [{ x : 150, y : 100},{ x : 120, y : 150}], monsters : [{ x : 200, y : 200},{ x : 300, y : 150},{ x : 250, y : 300},{ x : 180, y : 250},{ x : 320, y : 280}], consumables : [{ x : 250, y : 150},{ x : 300, y : 150},{ x : 350, y : 200}], effects : [{ x : 200, y : 100},{ x : 250, y : 200}]};
};
engine_model_entities_EngineEntitySpecs.getColliderSpec = function(x,y,passable,isTrigger) {
	return { type : "collider", pos : { x : x, y : y}, ownerId : "world", isAlive : true, passable : passable, isTrigger : isTrigger, colliderWidth : 2, colliderHeight : 2};
};
engine_model_entities_EngineEntitySpecs.generateMapColliders = function(rows,cols) {
	var colliders = [];
	var spacing = 10 * engine_NecrotonEngine.Config.unitPixels;
	var _g = 1;
	var _g1 = rows + 1;
	while(_g < _g1) {
		var row = _g++;
		var _g2 = 1;
		var _g3 = cols + 1;
		while(_g2 < _g3) {
			var col = _g2++;
			var x = col * spacing;
			var y = row * spacing;
			var passable = false;
			var isTrigger = false;
			colliders.push(engine_model_entities_EngineEntitySpecs.getColliderSpec(x,y,passable,isTrigger));
		}
	}
	return colliders;
};
engine_model_entities_EngineEntitySpecs.getDefaultEntitySpec = function(type,index) {
	if(index == null) {
		index = 0;
	}
	switch(type) {
	case "character":
		switch(index) {
		case 0:
			return engine_model_entities_EngineEntitySpecs.getPlayerCharacterSpec();
		case 1:
			return engine_model_entities_EngineEntitySpecs.getIdleAcolyteSpec();
		default:
			return engine_model_entities_EngineEntitySpecs.getMonsterSpec();
		}
		break;
	case "collider":
		return engine_model_entities_EngineEntitySpecs.getColliderSpec(0,0,false,false);
	case "consumable":
		switch(index) {
		case 0:
			return engine_model_entities_EngineEntitySpecs.getHealthPotionSpec();
		case 1:
			return engine_model_entities_EngineEntitySpecs.getManaPotionSpec();
		default:
			return engine_model_entities_EngineEntitySpecs.getHealthPotionSpec();
		}
		break;
	case "effect":
		switch(index) {
		case 0:
			return engine_model_entities_EngineEntitySpecs.getSpeedBoostEffectSpec();
		case 1:
			return engine_model_entities_EngineEntitySpecs.getDamageEffectSpec();
		default:
			return engine_model_entities_EngineEntitySpecs.getSpeedBoostEffectSpec();
		}
		break;
	default:
		return engine_model_entities_EngineEntitySpecs.getPlayerCharacterSpec();
	}
};
var engine_model_entities_base_AbstractEngineEntity = function() { };
$hxClasses["engine.model.entities.base.AbstractEngineEntity"] = engine_model_entities_base_AbstractEngineEntity;
engine_model_entities_base_AbstractEngineEntity.__name__ = "engine.model.entities.base.AbstractEngineEntity";
engine_model_entities_base_AbstractEngineEntity.prototype = {
	__class__: engine_model_entities_base_AbstractEngineEntity
};
var engine_model_entities_base_BaseEngineEntity = function() {
	this.movementCorrection = engine_geometry_Vec2Utils.create(0,0);
	this.reset(null);
};
$hxClasses["engine.model.entities.base.BaseEngineEntity"] = engine_model_entities_base_BaseEngineEntity;
engine_model_entities_base_BaseEngineEntity.__name__ = "engine.model.entities.base.BaseEngineEntity";
engine_model_entities_base_BaseEngineEntity.__super__ = engine_model_entities_base_AbstractEngineEntity;
engine_model_entities_base_BaseEngineEntity.prototype = $extend(engine_model_entities_base_AbstractEngineEntity.prototype,{
	serialize: function() {
		return { id : this.id, type : this.type, pos : { x : this.pos.x, y : this.pos.y}, vel : { x : this.vel.x, y : this.vel.y}, rotation : this.rotation, ownerId : this.ownerId, isAlive : this.isAlive, isInputDriven : this.isInputDriven, colliderWidth : this.colliderWidth, colliderHeight : this.colliderHeight};
	}
	,deserialize: function(data) {
		this.id = data.id;
		this.type = data.type;
		this.pos = { x : data.pos.x, y : data.pos.y};
		this.vel = { x : data.vel.x, y : data.vel.y};
		this.rotation = data.rotation;
		this.ownerId = data.ownerId;
		this.isAlive = data.isAlive;
		this.isInputDriven = data.isInputDriven != null && data.isInputDriven;
		this.colliderWidth = data.colliderWidth != null ? data.colliderWidth : 1;
		this.colliderHeight = data.colliderHeight != null ? data.colliderHeight : 1;
	}
	,reset: function(spec) {
		if(spec == null) {
			this.id = 0;
			this.type = "generic";
			this.pos = engine_geometry_Vec2Utils.create(0,0);
			this.vel = engine_geometry_Vec2Utils.create(0,0);
			this.rotation = 0;
			this.ownerId = "";
			this.isAlive = false;
			this.isInputDriven = false;
			this.colliderWidth = 1;
			this.colliderHeight = 1;
			return;
		}
		this.id = spec.id != null ? spec.id : 0;
		this.type = spec.type != null ? spec.type : "generic";
		this.pos = spec.pos != null ? { x : spec.pos.x, y : spec.pos.y} : engine_geometry_Vec2Utils.create(0,0);
		this.vel = spec.vel != null ? { x : spec.vel.x, y : spec.vel.y} : engine_geometry_Vec2Utils.create(0,0);
		this.rotation = spec.rotation != null ? spec.rotation : 0;
		this.ownerId = spec.ownerId != null ? spec.ownerId : "";
		this.isAlive = spec.isAlive != null ? spec.isAlive : true;
		this.isInputDriven = spec.isInputDriven != null && spec.isInputDriven;
		this.colliderWidth = spec.colliderWidth != null ? spec.colliderWidth : 1;
		this.colliderHeight = spec.colliderHeight != null ? spec.colliderHeight : 1;
	}
	,applyMovementCorrection: function(correction) {
		this.movementCorrection = correction;
	}
	,clearMovementCorrection: function() {
		this.movementCorrection = engine_geometry_Vec2Utils.create(0,0);
	}
	,__class__: engine_model_entities_base_BaseEngineEntity
});
var engine_model_entities_base_EngineEntityFactory = function(pool) {
	this.pool = pool;
	this.factories = new haxe_ds_StringMap();
	this.registerCoreTypes();
};
$hxClasses["engine.model.entities.base.EngineEntityFactory"] = engine_model_entities_base_EngineEntityFactory;
engine_model_entities_base_EngineEntityFactory.__name__ = "engine.model.entities.base.EngineEntityFactory";
engine_model_entities_base_EngineEntityFactory.prototype = {
	register: function(type,factory) {
		this.factories.h[type] = factory;
	}
	,create: function(type,spec) {
		haxe_Log.trace("Creating entity of type: " + type,{ fileName : "src/engine/model/entities/base/EngineEntityFactory.hx", lineNumber : 43, className : "engine.model.entities.base.EngineEntityFactory", methodName : "create"});
		if(!Object.prototype.hasOwnProperty.call(this.factories.h,type)) {
			throw haxe_Exception.thrown("Unknown entity type: " + type);
		}
		var entity = this.pool.acquire(type,this.factories.h[type]);
		entity.reset(spec);
		return entity;
	}
	,release: function(entity) {
		this.pool.release(entity.type,entity);
	}
	,registerCoreTypes: function() {
		this.register("character",function() {
			return new engine_model_entities_impl_EngineCharacterEntity();
		});
		this.register("consumable",function() {
			return new engine_model_entities_impl_EngineConsumableEntity();
		});
		this.register("effect",function() {
			return new engine_model_entities_impl_EngineEffectEntity();
		});
		this.register("collider",function() {
			return new engine_model_entities_impl_EngineColliderEntity();
		});
	}
	,__class__: engine_model_entities_base_EngineEntityFactory
};
var engine_model_entities_impl_EngineCharacterEntity = function() {
	engine_model_entities_base_BaseEngineEntity.call(this);
};
$hxClasses["engine.model.entities.impl.EngineCharacterEntity"] = engine_model_entities_impl_EngineCharacterEntity;
engine_model_entities_impl_EngineCharacterEntity.__name__ = "engine.model.entities.impl.EngineCharacterEntity";
engine_model_entities_impl_EngineCharacterEntity.__super__ = engine_model_entities_base_BaseEngineEntity;
engine_model_entities_impl_EngineCharacterEntity.prototype = $extend(engine_model_entities_base_BaseEngineEntity.prototype,{
	serialize: function() {
		var base = engine_model_entities_base_BaseEngineEntity.prototype.serialize.call(this);
		base.maxHp = this.maxHp;
		base.hp = this.hp;
		base.level = this.level;
		base.stats = this.stats;
		base.attackDefs = this.attackDefs;
		base.spellBook = this.spellBook;
		base.aiProfile = this.aiProfile;
		return base;
	}
	,deserialize: function(data) {
		engine_model_entities_base_BaseEngineEntity.prototype.deserialize.call(this,data);
		this.maxHp = data.maxHp;
		this.hp = data.hp;
		this.level = data.level;
		this.stats = data.stats;
		this.attackDefs = data.attackDefs;
		this.spellBook = data.spellBook;
		this.aiProfile = data.aiProfile;
	}
	,reset: function(spec) {
		engine_model_entities_base_BaseEngineEntity.prototype.reset.call(this,spec);
		if(spec == null) {
			this.maxHp = 100;
			this.hp = this.maxHp;
			this.level = 1;
			this.stats = { };
			this.attackDefs = [];
			this.spellBook = [];
			this.aiProfile = "";
			this.colliderWidth = 3;
			this.colliderHeight = 5;
			this.isInputDriven = true;
			return;
		}
		this.maxHp = spec.maxHp != null ? spec.maxHp : 100;
		this.hp = spec.hp != null ? spec.hp : this.maxHp;
		this.level = spec.level != null ? spec.level : 1;
		this.stats = spec.stats != null ? spec.stats : { };
		this.attackDefs = spec.attackDefs != null ? spec.attackDefs : [];
		this.spellBook = spec.spellBook != null ? spec.spellBook : [];
		this.aiProfile = spec.aiProfile != null ? spec.aiProfile : "";
		if(spec.colliderWidth == null) {
			this.colliderWidth = 3;
		}
		if(spec.colliderHeight == null) {
			this.colliderHeight = 5;
		}
		this.isInputDriven = spec.isInputDriven != null ? spec.isInputDriven : true;
	}
	,applyMovementStep: function(movementX,movementY,dt) {
		var movementStep = engine_geometry_Vec2Utils.add(this.calculateMovementStep(movementX,movementY,dt),this.movementCorrection);
		this.pos.x += movementStep.x;
		this.pos.y += movementStep.y;
		this.vel.x = 0;
		this.vel.y = 0;
		this.clearMovementCorrection();
	}
	,calculateMovementStep: function(movementX,movementY,dt) {
		var speed = (this.stats != null && this.stats.speed != null ? this.stats.speed : 1.0) * engine_NecrotonEngine.Config.unitPixels;
		return { x : movementX * speed * dt | 0, y : movementY * speed * dt | 0};
	}
	,__class__: engine_model_entities_impl_EngineCharacterEntity
});
var engine_model_entities_impl_EngineColliderEntity = function() {
	engine_model_entities_base_BaseEngineEntity.call(this);
};
$hxClasses["engine.model.entities.impl.EngineColliderEntity"] = engine_model_entities_impl_EngineColliderEntity;
engine_model_entities_impl_EngineColliderEntity.__name__ = "engine.model.entities.impl.EngineColliderEntity";
engine_model_entities_impl_EngineColliderEntity.__super__ = engine_model_entities_base_BaseEngineEntity;
engine_model_entities_impl_EngineColliderEntity.prototype = $extend(engine_model_entities_base_BaseEngineEntity.prototype,{
	serialize: function() {
		var base = engine_model_entities_base_BaseEngineEntity.prototype.serialize.call(this);
		base.passable = this.passable;
		base.isTrigger = this.isTrigger;
		return base;
	}
	,deserialize: function(data) {
		engine_model_entities_base_BaseEngineEntity.prototype.deserialize.call(this,data);
		this.passable = data.passable != null && data.passable;
		this.isTrigger = data.isTrigger != null && data.isTrigger;
	}
	,reset: function(spec) {
		engine_model_entities_base_BaseEngineEntity.prototype.reset.call(this,spec);
		if(spec == null) {
			this.passable = false;
			this.isTrigger = false;
			this.isInputDriven = false;
			this.vel.x = 0;
			this.vel.y = 0;
			this.colliderWidth = 1;
			this.colliderHeight = 1;
			return;
		}
		this.passable = spec.passable != null && spec.passable;
		this.isTrigger = spec.isTrigger != null && spec.isTrigger;
		this.isInputDriven = false;
		this.vel.x = 0;
		this.vel.y = 0;
		this.colliderWidth = spec.colliderWidth != null ? spec.colliderWidth : 1;
		this.colliderHeight = spec.colliderHeight != null ? spec.colliderHeight : 1;
	}
	,__class__: engine_model_entities_impl_EngineColliderEntity
});
var engine_model_entities_impl_EngineConsumableEntity = function() {
	engine_model_entities_base_BaseEngineEntity.call(this);
};
$hxClasses["engine.model.entities.impl.EngineConsumableEntity"] = engine_model_entities_impl_EngineConsumableEntity;
engine_model_entities_impl_EngineConsumableEntity.__name__ = "engine.model.entities.impl.EngineConsumableEntity";
engine_model_entities_impl_EngineConsumableEntity.__super__ = engine_model_entities_base_BaseEngineEntity;
engine_model_entities_impl_EngineConsumableEntity.prototype = $extend(engine_model_entities_base_BaseEngineEntity.prototype,{
	serialize: function() {
		var base = engine_model_entities_base_BaseEngineEntity.prototype.serialize.call(this);
		base.effectId = this.effectId;
		base.durationTicks = this.durationTicks;
		base.stackable = this.stackable;
		base.charges = this.charges;
		base.useRange = this.useRange;
		return base;
	}
	,deserialize: function(data) {
		engine_model_entities_base_BaseEngineEntity.prototype.deserialize.call(this,data);
		this.effectId = data.effectId;
		this.durationTicks = data.durationTicks;
		this.stackable = data.stackable;
		this.charges = data.charges;
		this.useRange = data.useRange;
	}
	,reset: function(spec) {
		engine_model_entities_base_BaseEngineEntity.prototype.reset.call(this,spec);
		this.effectId = spec.effectId != null ? spec.effectId : "";
		this.durationTicks = spec.durationTicks != null ? spec.durationTicks : 0;
		this.stackable = spec.stackable != null && spec.stackable;
		this.charges = spec.charges != null ? spec.charges : 1;
		this.useRange = spec.useRange != null ? spec.useRange : 16;
	}
	,__class__: engine_model_entities_impl_EngineConsumableEntity
});
var engine_model_entities_impl_EngineEffectEntity = function() {
	engine_model_entities_base_BaseEngineEntity.call(this);
};
$hxClasses["engine.model.entities.impl.EngineEffectEntity"] = engine_model_entities_impl_EngineEffectEntity;
engine_model_entities_impl_EngineEffectEntity.__name__ = "engine.model.entities.impl.EngineEffectEntity";
engine_model_entities_impl_EngineEffectEntity.__super__ = engine_model_entities_base_BaseEngineEntity;
engine_model_entities_impl_EngineEffectEntity.prototype = $extend(engine_model_entities_base_BaseEngineEntity.prototype,{
	serialize: function() {
		var base = engine_model_entities_base_BaseEngineEntity.prototype.serialize.call(this);
		base.effectType = this.effectType;
		base.durationTicks = this.durationTicks;
		base.intensity = this.intensity;
		base.targetId = this.targetId;
		base.casterId = this.casterId;
		return base;
	}
	,deserialize: function(data) {
		engine_model_entities_base_BaseEngineEntity.prototype.deserialize.call(this,data);
		this.effectType = data.effectType;
		this.durationTicks = data.durationTicks;
		this.intensity = data.intensity;
		this.targetId = data.targetId;
		this.casterId = data.casterId;
	}
	,reset: function(spec) {
		engine_model_entities_base_BaseEngineEntity.prototype.reset.call(this,spec);
		this.effectType = spec.effectType != null ? spec.effectType : "";
		this.durationTicks = spec.durationTicks != null ? spec.durationTicks : 0;
		this.intensity = spec.intensity != null ? spec.intensity : 1.0;
		this.targetId = spec.targetId != null ? spec.targetId : 0;
		this.casterId = spec.casterId != null ? spec.casterId : 0;
	}
	,__class__: engine_model_entities_impl_EngineEffectEntity
});
var engine_model_managers_IEngineEntityManager = function() { };
$hxClasses["engine.model.managers.IEngineEntityManager"] = engine_model_managers_IEngineEntityManager;
engine_model_managers_IEngineEntityManager.__name__ = "engine.model.managers.IEngineEntityManager";
engine_model_managers_IEngineEntityManager.__isInterface__ = true;
engine_model_managers_IEngineEntityManager.prototype = {
	__class__: engine_model_managers_IEngineEntityManager
};
var engine_model_managers_BaseEngineEntityManager = function(factory) {
	this.factory = factory;
	this.entities = new haxe_ds_IntMap();
	this.nextId = 1;
};
$hxClasses["engine.model.managers.BaseEngineEntityManager"] = engine_model_managers_BaseEngineEntityManager;
engine_model_managers_BaseEngineEntityManager.__name__ = "engine.model.managers.BaseEngineEntityManager";
engine_model_managers_BaseEngineEntityManager.__interfaces__ = [engine_model_managers_IEngineEntityManager];
engine_model_managers_BaseEngineEntityManager.prototype = {
	create: function(spec) {
		var entity = this.factory.create(spec.type,spec);
		if(entity.id == 0) {
			entity.id = this.allocateId();
		}
		this.entities.h[entity.id] = entity;
		return entity;
	}
	,destroy: function(id) {
		if(this.entities.h.hasOwnProperty(id)) {
			var entity = this.entities.h[id];
			this.entities.remove(id);
			this.factory.release(entity);
		}
	}
	,find: function(id) {
		if(this.entities.h.hasOwnProperty(id)) {
			return this.entities.h[id];
		} else {
			return null;
		}
	}
	,iterate: function(fn) {
		var entity = this.entities.iterator();
		while(entity.hasNext()) {
			var entity1 = entity.next();
			fn(entity1);
		}
	}
	,updateTick: function(dt,tick,state) {
	}
	,saveMemento: function() {
		var result = [];
		var id = this.entities.keys();
		while(id.hasNext()) {
			var id1 = id.next();
			var entity = this.entities.h[id1];
			result.push(entity.serialize());
		}
		return result;
	}
	,restoreMemento: function(mementos) {
		this.clear();
		var _g = 0;
		while(_g < mementos.length) {
			var memento = mementos[_g];
			++_g;
			var spec = { id : memento.id, type : memento.type, pos : memento.pos, vel : memento.vel, rotation : memento.rotation, ownerId : memento.ownerId, isAlive : memento.isAlive, maxHp : memento.maxHp, hp : memento.hp, level : memento.level, stats : memento.stats, attackDefs : memento.attackDefs, spellBook : memento.spellBook, aiProfile : memento.aiProfile, effectType : memento.effectType, duration : memento.duration, consumableType : memento.consumableType, quantity : memento.quantity};
			var entity = this.factory.create(memento.type,spec);
			this.entities.h[entity.id] = entity;
		}
	}
	,clear: function() {
		var id = this.entities.keys();
		while(id.hasNext()) {
			var id1 = id.next();
			var entity = this.entities.h[id1];
			this.factory.release(entity);
		}
		this.entities.h = { };
	}
	,allocateId: function() {
		return this.nextId++;
	}
	,__class__: engine_model_managers_BaseEngineEntityManager
};
var engine_model_managers_IEngineEntityManagerRegistry = function() { };
$hxClasses["engine.model.managers.IEngineEntityManagerRegistry"] = engine_model_managers_IEngineEntityManagerRegistry;
engine_model_managers_IEngineEntityManagerRegistry.__name__ = "engine.model.managers.IEngineEntityManagerRegistry";
engine_model_managers_IEngineEntityManagerRegistry.__isInterface__ = true;
engine_model_managers_IEngineEntityManagerRegistry.prototype = {
	__class__: engine_model_managers_IEngineEntityManagerRegistry
};
var engine_model_managers_EngineEntityManagerRegistry = function() {
	this.managers = new haxe_ds_StringMap();
};
$hxClasses["engine.model.managers.EngineEntityManagerRegistry"] = engine_model_managers_EngineEntityManagerRegistry;
engine_model_managers_EngineEntityManagerRegistry.__name__ = "engine.model.managers.EngineEntityManagerRegistry";
engine_model_managers_EngineEntityManagerRegistry.__interfaces__ = [engine_model_managers_IEngineEntityManagerRegistry];
engine_model_managers_EngineEntityManagerRegistry.prototype = {
	register: function(type,manager) {
		this.managers.h[type] = manager;
	}
	,get: function(type) {
		return this.managers.h[type];
	}
	,getAll: function() {
		var result = [];
		var h = this.managers.h;
		var manager_h = h;
		var manager_keys = Object.keys(h);
		var manager_length = manager_keys.length;
		var manager_current = 0;
		while(manager_current < manager_length) {
			var manager = manager_h[manager_keys[manager_current++]];
			result.push(manager);
		}
		return result;
	}
	,updateAll: function(dt,tick,state) {
		var h = this.managers.h;
		var manager_h = h;
		var manager_keys = Object.keys(h);
		var manager_length = manager_keys.length;
		var manager_current = 0;
		while(manager_current < manager_length) {
			var manager = manager_h[manager_keys[manager_current++]];
			manager.updateTick(dt,tick,state);
		}
	}
	,saveMemento: function() {
		var result = [];
		var h = this.managers.h;
		var type_h = h;
		var type_keys = Object.keys(h);
		var type_length = type_keys.length;
		var type_current = 0;
		while(type_current < type_length) {
			var type = type_keys[type_current++];
			var manager = this.managers.h[type];
			result.push({ type : type, entities : manager.saveMemento()});
		}
		return result;
	}
	,restoreMemento: function(mementos) {
		this.clear();
		var _g = 0;
		while(_g < mementos.length) {
			var memento = mementos[_g];
			++_g;
			var manager = this.managers.h[memento.type];
			if(manager != null) {
				manager.restoreMemento(memento.entities);
			}
		}
	}
	,clear: function() {
		var h = this.managers.h;
		var type_h = h;
		var type_keys = Object.keys(h);
		var type_length = type_keys.length;
		var type_current = 0;
		while(type_current < type_length) {
			var type = type_keys[type_current++];
			this.managers.h[type].clear();
		}
	}
	,__class__: engine_model_managers_EngineEntityManagerRegistry
};
var engine_modules_IModule = function() { };
$hxClasses["engine.modules.IModule"] = engine_modules_IModule;
engine_modules_IModule.__name__ = "engine.modules.IModule";
engine_modules_IModule.__isInterface__ = true;
engine_modules_IModule.prototype = {
	__class__: engine_modules_IModule
};
var engine_modules_AIModule = function() {
	this.aiProfiles = new haxe_ds_StringMap();
};
$hxClasses["engine.modules.AIModule"] = engine_modules_AIModule;
engine_modules_AIModule.__name__ = "engine.modules.AIModule";
engine_modules_AIModule.__interfaces__ = [engine_modules_IModule];
engine_modules_AIModule.prototype = {
	update: function(state,tick,dt) {
		var _gthis = this;
		if(tick % engine_NecrotonEngine.Config.aiUpdateInterval != 0) {
			return;
		}
		var _g = 0;
		var _g1 = state.managers.getAll();
		while(_g < _g1.length) {
			var manager = _g1[_g];
			++_g;
			manager.iterate(function(entity) {
				if(entity.isAlive && entity.ownerId == "") {
					_gthis.updateEntityAI(entity,state,tick);
				}
			});
		}
	}
	,shutdown: function() {
		this.aiProfiles.h = Object.create(null);
	}
	,registerProfile: function(profileName,behavior) {
		this.aiProfiles.h[profileName] = behavior;
	}
	,updateEntityAI: function(entity,state,tick) {
		if(entity.type == "character") {
			var character = js_Boot.__cast(entity , engine_model_entities_impl_EngineCharacterEntity);
			if(character.aiProfile != "" && Object.prototype.hasOwnProperty.call(this.aiProfiles.h,character.aiProfile)) {
				var profile = this.aiProfiles.h[character.aiProfile];
				this.applyAIBehavior(character,profile,state);
			} else {
				this.wanderBehavior(character,state);
			}
		}
	}
	,applyAIBehavior: function(character,profile,state) {
	}
	,wanderBehavior: function(character,state) {
		if(state.rng.nextFloat() < 0.1) {
			var angle = state.rng.nextFloatRange(0,Math.PI * 2);
			var speed = 50.0;
			character.vel = { x : Math.cos(angle) * speed, y : Math.sin(angle) * speed};
		}
	}
	,__class__: engine_modules_AIModule
};
var engine_modules_InputModule = function() {
	this.clientEntityMap = new haxe_ds_StringMap();
	this.inputBuffers = new haxe_ds_StringMap();
};
$hxClasses["engine.modules.InputModule"] = engine_modules_InputModule;
engine_modules_InputModule.__name__ = "engine.modules.InputModule";
engine_modules_InputModule.__interfaces__ = [engine_modules_IModule];
engine_modules_InputModule.prototype = {
	update: function(state,tick,dt) {
		var inputs = this.collectForTick(tick);
		if(inputs.length > 0) {
			this.applyInputs(inputs,state,dt);
		}
	}
	,shutdown: function() {
		this.inputBuffers.h = Object.create(null);
	}
	,queueInput: function(input) {
		if(!Object.prototype.hasOwnProperty.call(this.inputBuffers.h,input.clientId)) {
			var this1 = this.inputBuffers;
			var key = input.clientId;
			var value = new engine_presenter_InputBuffer();
			this1.h[key] = value;
		}
		this.inputBuffers.h[input.clientId].push(input);
	}
	,setClientEntity: function(clientId,entityId) {
		this.clientEntityMap.h[clientId] = entityId;
	}
	,collectForTick: function(tick) {
		var result = [];
		var h = this.inputBuffers.h;
		var clientId_h = h;
		var clientId_keys = Object.keys(h);
		var clientId_length = clientId_keys.length;
		var clientId_current = 0;
		while(clientId_current < clientId_length) {
			var clientId = clientId_keys[clientId_current++];
			var buffer = this.inputBuffers.h[clientId];
			var inputs = buffer.collectForTick(tick);
			result = result.concat(inputs);
		}
		return result;
	}
	,applyInputs: function(inputs,state,dt) {
		var characterManager = state.managers.get("character");
		var _g = 0;
		while(_g < inputs.length) {
			var input = inputs[_g];
			++_g;
			var entityId = this.clientEntityMap.h[input.clientId];
			if(entityId != null && characterManager != null) {
				var character = characterManager.find(entityId);
				if(character != null) {
					character.applyMovementStep(input.movement.x,input.movement.y,dt);
					var _g1 = 0;
					var _g2 = input.actions;
					while(_g1 < _g2.length) {
						var action = _g2[_g1];
						++_g1;
						switch(action.type) {
						case "ability":
							haxe_Log.trace("Ability from " + input.clientId,{ fileName : "src/engine/modules/InputModule.hx", lineNumber : 103, className : "engine.modules.InputModule", methodName : "applyInputs"});
							break;
						case "primary_action":
							haxe_Log.trace("Primary action from " + input.clientId,{ fileName : "src/engine/modules/InputModule.hx", lineNumber : 97, className : "engine.modules.InputModule", methodName : "applyInputs"});
							break;
						case "secondary_action":
							haxe_Log.trace("Secondary action from " + input.clientId,{ fileName : "src/engine/modules/InputModule.hx", lineNumber : 100, className : "engine.modules.InputModule", methodName : "applyInputs"});
							break;
						default:
							haxe_Log.trace("Unknown action: " + Std.string(action.type) + " from " + input.clientId,{ fileName : "src/engine/modules/InputModule.hx", lineNumber : 106, className : "engine.modules.InputModule", methodName : "applyInputs"});
						}
					}
				}
			}
		}
	}
	,dropAcknowledged: function(clientId,sequence) {
		if(Object.prototype.hasOwnProperty.call(this.inputBuffers.h,clientId)) {
			this.inputBuffers.h[clientId].dropUpToSequence(sequence);
		}
	}
	,__class__: engine_modules_InputModule
};
var engine_modules_ModuleRegistry = function() {
	this.modules = new haxe_ds_StringMap();
};
$hxClasses["engine.modules.ModuleRegistry"] = engine_modules_ModuleRegistry;
engine_modules_ModuleRegistry.__name__ = "engine.modules.ModuleRegistry";
engine_modules_ModuleRegistry.prototype = {
	register: function(name,module) {
		this.modules.h[name] = module;
	}
	,get: function(name) {
		if(Object.prototype.hasOwnProperty.call(this.modules.h,name)) {
			return this.modules.h[name];
		} else {
			return null;
		}
	}
	,getAll: function() {
		var result = [];
		var h = this.modules.h;
		var module_h = h;
		var module_keys = Object.keys(h);
		var module_length = module_keys.length;
		var module_current = 0;
		while(module_current < module_length) {
			var module = module_h[module_keys[module_current++]];
			result.push(module);
		}
		return result;
	}
	,__class__: engine_modules_ModuleRegistry
};
var engine_modules_PhysicsModule = function() {
};
$hxClasses["engine.modules.PhysicsModule"] = engine_modules_PhysicsModule;
engine_modules_PhysicsModule.__name__ = "engine.modules.PhysicsModule";
engine_modules_PhysicsModule.__interfaces__ = [engine_modules_IModule];
engine_modules_PhysicsModule.prototype = {
	update: function(state,tick,dt) {
		this.integrate(state,dt);
		this.stepCollision(state,tick);
	}
	,shutdown: function() {
	}
	,integrate: function(state,dt) {
		var _g = 0;
		var _g1 = state.managers.getAll();
		while(_g < _g1.length) {
			var manager = _g1[_g];
			++_g;
			manager.iterate(function(entity) {
				if(entity.isAlive) {
					if(!entity.isInputDriven) {
						entity.pos = engine_geometry_Vec2Utils.add(entity.pos,engine_geometry_Vec2Utils.scale(entity.vel,dt));
					}
				}
			});
		}
	}
	,stepCollision: function(state,tick) {
		var entities = [];
		var _g = 0;
		var _g1 = state.managers.getAll();
		while(_g < _g1.length) {
			var manager = _g1[_g];
			++_g;
			manager.iterate(function(entity) {
				if(entity.isAlive) {
					entities.push(entity);
				}
			});
		}
		var unitPixels = engine_NecrotonEngine.Config.unitPixels;
		var _g = 0;
		var _g1 = entities.length;
		while(_g < _g1) {
			var i = _g++;
			var _g2 = i + 1;
			var _g3 = entities.length;
			while(_g2 < _g3) {
				var j = _g2++;
				var a = entities[i];
				var b = entities[j];
				var widthA = a.colliderWidth * unitPixels;
				var heightA = a.colliderHeight * unitPixels;
				var widthB = b.colliderWidth * unitPixels;
				var heightB = b.colliderHeight * unitPixels;
				var maxDistanceX = (widthA + widthB) / 2;
				var maxDistanceY = (heightA + heightB) / 2;
				var maxDistanceSquared = maxDistanceX * maxDistanceX + maxDistanceY * maxDistanceY;
				var distanceSquared = engine_geometry_Vec2Utils.distanceSquared(a.pos,b.pos);
				if(distanceSquared > maxDistanceSquared) {
					continue;
				}
				var collisionResult = this.checkCollision(a,b);
				if(collisionResult.intersects) {
					this.resolveCollision(collisionResult.rectA,a,collisionResult.rectB,b);
				}
			}
		}
	}
	,registerCollider: function(entity) {
	}
	,unregisterCollider: function(entityId) {
	}
	,checkCollision: function(a,b) {
		var unitPixels = engine_NecrotonEngine.Config.unitPixels;
		var colliderAWidth = a.colliderWidth * unitPixels | 0;
		var colliderAHeight = a.colliderHeight * unitPixels | 0;
		var colliderBWidth = b.colliderWidth * unitPixels | 0;
		var colliderBHeight = b.colliderHeight * unitPixels | 0;
		var rectA = engine_geometry_RectUtils.create(a.pos.x,a.pos.y,colliderAWidth,colliderAHeight);
		var rectB = engine_geometry_RectUtils.create(b.pos.x,b.pos.y,colliderBWidth,colliderBHeight);
		var intersects = engine_geometry_RectUtils.intersectsRect(rectA,rectB);
		return { intersects : intersects, rectA : rectA, rectB : rectB};
	}
	,resolveCollision: function(rectA,entityA,rectB,entityB) {
		var separation = engine_geometry_RectUtils.getIntersectionDepth(rectA,rectB);
		var aIsCollider = entityA.type == "collider";
		var bIsCollider = entityB.type == "collider";
		if(aIsCollider || bIsCollider) {
			var collider = js_Boot.__cast(aIsCollider ? entityA : entityB , engine_model_entities_impl_EngineColliderEntity);
			var entity = aIsCollider ? entityB : entityA;
			if(!collider.passable) {
				entity.applyMovementCorrection(separation);
			}
			if(collider.isTrigger) {
				haxe_Log.trace("Collider trigger activated: " + collider.id + " by entity: " + entity.id,{ fileName : "src/engine/modules/PhysicsModule.hx", lineNumber : 161, className : "engine.modules.PhysicsModule", methodName : "resolveCollision"});
			}
		}
	}
	,__class__: engine_modules_PhysicsModule
};
var engine_modules_SpawnModule = function() {
};
$hxClasses["engine.modules.SpawnModule"] = engine_modules_SpawnModule;
engine_modules_SpawnModule.__name__ = "engine.modules.SpawnModule";
engine_modules_SpawnModule.__interfaces__ = [engine_modules_IModule];
engine_modules_SpawnModule.prototype = {
	update: function(state,tick,dt) {
		this.cleanupDeadEntities(state);
	}
	,shutdown: function() {
	}
	,spawn: function(spec) {
		return null;
	}
	,despawn: function(entityId) {
	}
	,cleanupDeadEntities: function(state) {
		var _g = 0;
		var _g1 = state.managers.getAll();
		while(_g < _g1.length) {
			var manager = _g1[_g];
			++_g;
			var toRemove = [[]];
			manager.iterate((function(toRemove) {
				return function(entity) {
					if(!entity.isAlive) {
						toRemove[0].push(entity.id);
					}
				};
			})(toRemove));
			var _g2 = 0;
			while(_g2 < toRemove[0].length) {
				var id = toRemove[0][_g2];
				++_g2;
				manager.destroy(id);
			}
		}
	}
	,__class__: engine_modules_SpawnModule
};
var engine_presenter_GameLoop = function(state,modules,eventBus) {
	this.state = state;
	this.modules = modules;
	this.eventBus = eventBus;
	this.running = false;
	this.fixedDt = 1.0 / engine_NecrotonEngine.Config.tickRate;
};
$hxClasses["engine.presenter.GameLoop"] = engine_presenter_GameLoop;
engine_presenter_GameLoop.__name__ = "engine.presenter.GameLoop";
engine_presenter_GameLoop.prototype = {
	start: function() {
		this.running = true;
	}
	,stop: function() {
		this.running = false;
	}
	,stepFixed: function() {
		if(!this.running) {
			return;
		}
		this.state.tick++;
		var currentTick = this.state.tick;
		this.executeModules(currentTick,this.fixedDt);
		this.state.managers.updateAll(this.fixedDt,currentTick,this.state);
		this.eventBus.emit("tick:complete",{ tick : currentTick});
	}
	,executeModules: function(tick,dt) {
		var inputModule = js_Boot.__cast(this.modules.get("input") , engine_modules_InputModule);
		if(inputModule != null) {
			inputModule.update(this.state,tick,dt);
		}
		var aiModule = js_Boot.__cast(this.modules.get("ai") , engine_modules_AIModule);
		if(aiModule != null) {
			aiModule.update(this.state,tick,dt);
		}
		var physicsModule = js_Boot.__cast(this.modules.get("physics") , engine_modules_PhysicsModule);
		if(physicsModule != null) {
			physicsModule.update(this.state,tick,dt);
		}
		var spawnModule = js_Boot.__cast(this.modules.get("spawn") , engine_modules_SpawnModule);
		if(spawnModule != null) {
			spawnModule.update(this.state,tick,dt);
		}
	}
	,__class__: engine_presenter_GameLoop
};
var engine_presenter_InputBuffer = function() {
	this.inputs = [];
};
$hxClasses["engine.presenter.InputBuffer"] = engine_presenter_InputBuffer;
engine_presenter_InputBuffer.__name__ = "engine.presenter.InputBuffer";
engine_presenter_InputBuffer.prototype = {
	push: function(input) {
		this.inputs.push(input);
		this.inputs.sort(function(a,b) {
			if(a.intendedServerTick != b.intendedServerTick) {
				return a.intendedServerTick - b.intendedServerTick;
			}
			return a.sequence - b.sequence;
		});
	}
	,collectForTick: function(tick) {
		var result = [];
		var toRemove = [];
		var _g = 0;
		var _g1 = this.inputs.length;
		while(_g < _g1) {
			var i = _g++;
			var input = this.inputs[i];
			if(input.intendedServerTick == tick) {
				result.push(input);
				toRemove.push(i);
			} else if(input.intendedServerTick > tick) {
				break;
			}
		}
		var i = toRemove.length - 1;
		while(i >= 0) {
			this.inputs.splice(toRemove[i],1);
			--i;
		}
		return result;
	}
	,dropUpToSequence: function(sequence) {
		var toRemove = [];
		var _g = 0;
		var _g1 = this.inputs.length;
		while(_g < _g1) {
			var i = _g++;
			if(this.inputs[i].sequence <= sequence) {
				toRemove.push(i);
			}
		}
		var _g = toRemove.length - 1;
		var _g1 = -1;
		while(_g < _g1) {
			var i = _g++;
			this.inputs.splice(toRemove[i],1);
		}
	}
	,__class__: engine_presenter_InputBuffer
};
var engine_presenter_SnapshotManager = function(maxSize) {
	this.maxSize = maxSize;
	this.snapshots = [];
	this.head = 0;
	this.count = 0;
};
$hxClasses["engine.presenter.SnapshotManager"] = engine_presenter_SnapshotManager;
engine_presenter_SnapshotManager.__name__ = "engine.presenter.SnapshotManager";
engine_presenter_SnapshotManager.prototype = {
	store: function(tick,memento) {
		var snapshot = { tick : tick, memento : memento};
		if(this.count < this.maxSize) {
			this.snapshots.push(snapshot);
			this.count++;
		} else {
			this.snapshots[this.head] = snapshot;
			this.head = (this.head + 1) % this.maxSize;
		}
	}
	,load: function(tick) {
		var _g = 0;
		var _g1 = this.snapshots;
		while(_g < _g1.length) {
			var snapshot = _g1[_g];
			++_g;
			if(snapshot.tick == tick) {
				return snapshot.memento;
			}
		}
		return null;
	}
	,latest: function() {
		if(this.count == 0) {
			return 0;
		}
		var latestTick = 0;
		var _g = 0;
		var _g1 = this.snapshots;
		while(_g < _g1.length) {
			var snapshot = _g1[_g];
			++_g;
			if(snapshot.tick > latestTick) {
				latestTick = snapshot.tick;
			}
		}
		return latestTick;
	}
	,purgeBefore: function(tick) {
		var toRemove = [];
		var _g = 0;
		var _g1 = this.snapshots.length;
		while(_g < _g1) {
			var i = _g++;
			if(this.snapshots[i].tick < tick) {
				toRemove.push(i);
			}
		}
		var _g = toRemove.length - 1;
		var _g1 = -1;
		while(_g < _g1) {
			var i = _g++;
			this.snapshots.splice(toRemove[i],1);
			this.count--;
		}
	}
	,__class__: engine_presenter_SnapshotManager
};
var engine_view_IEventBus = function() { };
$hxClasses["engine.view.IEventBus"] = engine_view_IEventBus;
engine_view_IEventBus.__name__ = "engine.view.IEventBus";
engine_view_IEventBus.__isInterface__ = true;
engine_view_IEventBus.prototype = {
	__class__: engine_view_IEventBus
};
var engine_view_EventBus = function() {
	this.subscribers = new haxe_ds_StringMap();
	this.nextToken = 1;
	this.eventQueue = [];
	this.isProcessing = false;
};
$hxClasses["engine.view.EventBus"] = engine_view_EventBus;
engine_view_EventBus.__name__ = "engine.view.EventBus";
engine_view_EventBus.__interfaces__ = [engine_view_IEventBus];
engine_view_EventBus.prototype = {
	subscribe: function(topic,handler) {
		if(!Object.prototype.hasOwnProperty.call(this.subscribers.h,topic)) {
			this.subscribers.h[topic] = [];
		}
		var token = this.nextToken++;
		var dynamicHandler = function(payload) {
			handler(payload);
		};
		this.subscribers.h[topic].push({ token : token, handler : dynamicHandler});
		return token;
	}
	,subscribeDynamic: function(topic,handler) {
		if(!Object.prototype.hasOwnProperty.call(this.subscribers.h,topic)) {
			this.subscribers.h[topic] = [];
		}
		var token = this.nextToken++;
		this.subscribers.h[topic].push({ token : token, handler : handler});
		return token;
	}
	,unsubscribe: function(token) {
		var h = this.subscribers.h;
		var topic_h = h;
		var topic_keys = Object.keys(h);
		var topic_length = topic_keys.length;
		var topic_current = 0;
		while(topic_current < topic_length) {
			var topic = topic_keys[topic_current++];
			var subs = this.subscribers.h[topic];
			var _g = 0;
			var _g1 = subs.length;
			while(_g < _g1) {
				var i = _g++;
				if(subs[i].token == token) {
					subs.splice(i,1);
					return;
				}
			}
		}
	}
	,emit: function(topic,payload) {
		this.eventQueue.push({ topic : topic, payload : payload});
		if(!this.isProcessing) {
			this.processEventQueue();
		}
	}
	,processEventQueue: function() {
		this.isProcessing = true;
		while(this.eventQueue.length > 0) {
			var event = this.eventQueue.shift();
			var subs = this.subscribers.h[event.topic];
			if(subs != null) {
				var handlers = subs.slice();
				var _g = 0;
				while(_g < handlers.length) {
					var sub = handlers[_g];
					++_g;
					try {
						sub.handler(event.payload);
					} catch( _g1 ) {
						var e = haxe_Exception.caught(_g1).unwrap();
						haxe_Log.trace("Event handler error: " + Std.string(e),{ fileName : "src/engine/view/EventBus.hx", lineNumber : 80, className : "engine.view.EventBus", methodName : "processEventQueue"});
					}
				}
			}
		}
		this.isProcessing = false;
	}
	,__class__: engine_view_EventBus
};
var engine_view_EventBusConstants = function() { };
$hxClasses["engine.view.EventBusConstants"] = engine_view_EventBusConstants;
engine_view_EventBusConstants.__name__ = "engine.view.EventBusConstants";
var engine_view_EventBusTypes = function() { };
$hxClasses["engine.view.EventBusTypes"] = engine_view_EventBusTypes;
engine_view_EventBusTypes.__name__ = "engine.view.EventBusTypes";
var format_gif_Block = $hxEnums["format.gif.Block"] = { __ename__:true,__constructs__:null
	,BFrame: ($_=function(frame) { return {_hx_index:0,frame:frame,__enum__:"format.gif.Block",toString:$estr}; },$_._hx_name="BFrame",$_.__params__ = ["frame"],$_)
	,BExtension: ($_=function(extension) { return {_hx_index:1,extension:extension,__enum__:"format.gif.Block",toString:$estr}; },$_._hx_name="BExtension",$_.__params__ = ["extension"],$_)
	,BEOF: {_hx_name:"BEOF",_hx_index:2,__enum__:"format.gif.Block",toString:$estr}
};
format_gif_Block.__constructs__ = [format_gif_Block.BFrame,format_gif_Block.BExtension,format_gif_Block.BEOF];
format_gif_Block.__empty_constructs__ = [format_gif_Block.BEOF];
var format_gif_Extension = $hxEnums["format.gif.Extension"] = { __ename__:true,__constructs__:null
	,EGraphicControl: ($_=function(gce) { return {_hx_index:0,gce:gce,__enum__:"format.gif.Extension",toString:$estr}; },$_._hx_name="EGraphicControl",$_.__params__ = ["gce"],$_)
	,EComment: ($_=function(text) { return {_hx_index:1,text:text,__enum__:"format.gif.Extension",toString:$estr}; },$_._hx_name="EComment",$_.__params__ = ["text"],$_)
	,EText: ($_=function(pte) { return {_hx_index:2,pte:pte,__enum__:"format.gif.Extension",toString:$estr}; },$_._hx_name="EText",$_.__params__ = ["pte"],$_)
	,EApplicationExtension: ($_=function(ext) { return {_hx_index:3,ext:ext,__enum__:"format.gif.Extension",toString:$estr}; },$_._hx_name="EApplicationExtension",$_.__params__ = ["ext"],$_)
	,EUnknown: ($_=function(id,data) { return {_hx_index:4,id:id,data:data,__enum__:"format.gif.Extension",toString:$estr}; },$_._hx_name="EUnknown",$_.__params__ = ["id","data"],$_)
};
format_gif_Extension.__constructs__ = [format_gif_Extension.EGraphicControl,format_gif_Extension.EComment,format_gif_Extension.EText,format_gif_Extension.EApplicationExtension,format_gif_Extension.EUnknown];
format_gif_Extension.__empty_constructs__ = [];
var format_gif_ApplicationExtension = $hxEnums["format.gif.ApplicationExtension"] = { __ename__:true,__constructs__:null
	,AENetscapeLooping: ($_=function(loops) { return {_hx_index:0,loops:loops,__enum__:"format.gif.ApplicationExtension",toString:$estr}; },$_._hx_name="AENetscapeLooping",$_.__params__ = ["loops"],$_)
	,AEUnknown: ($_=function(name,version,data) { return {_hx_index:1,name:name,version:version,data:data,__enum__:"format.gif.ApplicationExtension",toString:$estr}; },$_._hx_name="AEUnknown",$_.__params__ = ["name","version","data"],$_)
};
format_gif_ApplicationExtension.__constructs__ = [format_gif_ApplicationExtension.AENetscapeLooping,format_gif_ApplicationExtension.AEUnknown];
format_gif_ApplicationExtension.__empty_constructs__ = [];
var format_gif_Version = $hxEnums["format.gif.Version"] = { __ename__:true,__constructs__:null
	,GIF87a: {_hx_name:"GIF87a",_hx_index:0,__enum__:"format.gif.Version",toString:$estr}
	,GIF89a: {_hx_name:"GIF89a",_hx_index:1,__enum__:"format.gif.Version",toString:$estr}
	,Unknown: ($_=function(version) { return {_hx_index:2,version:version,__enum__:"format.gif.Version",toString:$estr}; },$_._hx_name="Unknown",$_.__params__ = ["version"],$_)
};
format_gif_Version.__constructs__ = [format_gif_Version.GIF87a,format_gif_Version.GIF89a,format_gif_Version.Unknown];
format_gif_Version.__empty_constructs__ = [format_gif_Version.GIF87a,format_gif_Version.GIF89a];
var format_gif_DisposalMethod = $hxEnums["format.gif.DisposalMethod"] = { __ename__:true,__constructs__:null
	,UNSPECIFIED: {_hx_name:"UNSPECIFIED",_hx_index:0,__enum__:"format.gif.DisposalMethod",toString:$estr}
	,NO_ACTION: {_hx_name:"NO_ACTION",_hx_index:1,__enum__:"format.gif.DisposalMethod",toString:$estr}
	,FILL_BACKGROUND: {_hx_name:"FILL_BACKGROUND",_hx_index:2,__enum__:"format.gif.DisposalMethod",toString:$estr}
	,RENDER_PREVIOUS: {_hx_name:"RENDER_PREVIOUS",_hx_index:3,__enum__:"format.gif.DisposalMethod",toString:$estr}
	,UNDEFINED: ($_=function(index) { return {_hx_index:4,index:index,__enum__:"format.gif.DisposalMethod",toString:$estr}; },$_._hx_name="UNDEFINED",$_.__params__ = ["index"],$_)
};
format_gif_DisposalMethod.__constructs__ = [format_gif_DisposalMethod.UNSPECIFIED,format_gif_DisposalMethod.NO_ACTION,format_gif_DisposalMethod.FILL_BACKGROUND,format_gif_DisposalMethod.RENDER_PREVIOUS,format_gif_DisposalMethod.UNDEFINED];
format_gif_DisposalMethod.__empty_constructs__ = [format_gif_DisposalMethod.UNSPECIFIED,format_gif_DisposalMethod.NO_ACTION,format_gif_DisposalMethod.FILL_BACKGROUND,format_gif_DisposalMethod.RENDER_PREVIOUS];
var format_gif_Reader = function(i) {
	this.i = i;
	i.set_bigEndian(false);
};
$hxClasses["format.gif.Reader"] = format_gif_Reader;
format_gif_Reader.__name__ = "format.gif.Reader";
format_gif_Reader.prototype = {
	read: function() {
		var b = 71;
		if(this.i.readByte() != b) {
			throw haxe_Exception.thrown("Invalid header");
		}
		var b = 73;
		if(this.i.readByte() != b) {
			throw haxe_Exception.thrown("Invalid header");
		}
		var b = 70;
		if(this.i.readByte() != b) {
			throw haxe_Exception.thrown("Invalid header");
		}
		var gifVer = this.i.readString(3);
		var version = format_gif_Version.GIF89a;
		switch(gifVer) {
		case "87a":
			version = format_gif_Version.GIF87a;
			break;
		case "89a":
			version = format_gif_Version.GIF89a;
			break;
		default:
			version = format_gif_Version.Unknown(gifVer);
		}
		var width = this.i.readUInt16();
		var height = this.i.readUInt16();
		var packedField = this.i.readByte();
		var bgIndex = this.i.readByte();
		var pixelAspectRatio = this.i.readByte();
		if(pixelAspectRatio != 0) {
			pixelAspectRatio = (pixelAspectRatio + 15) / 64;
		} else {
			pixelAspectRatio = 1;
		}
		var lsd = { width : width, height : height, hasGlobalColorTable : (packedField & 128) == 128, colorResolution : (packedField & 112) >>> 4, sorted : (packedField & 8) == 8, globalColorTableSize : 2 << (packedField & 7), backgroundColorIndex : bgIndex, pixelAspectRatio : pixelAspectRatio};
		var gct = null;
		if(lsd.hasGlobalColorTable) {
			gct = this.readColorTable(lsd.globalColorTableSize);
		}
		var blocks = new haxe_ds_List();
		while(true) {
			var b = this.readBlock();
			blocks.add(b);
			if(b == format_gif_Block.BEOF) {
				break;
			}
		}
		return { version : version, logicalScreenDescriptor : lsd, globalColorTable : gct, blocks : blocks};
	}
	,readBlock: function() {
		var blockID = this.i.readByte();
		switch(blockID) {
		case 33:
			return this.readExtension();
		case 44:
			return this.readImage();
		case 59:
			return format_gif_Block.BEOF;
		}
		return format_gif_Block.BEOF;
	}
	,readImage: function() {
		var x = this.i.readUInt16();
		var y = this.i.readUInt16();
		var width = this.i.readUInt16();
		var height = this.i.readUInt16();
		var packed = this.i.readByte();
		var localColorTable = (packed & 128) == 128;
		var interlaced = (packed & 64) == 64;
		var sorted = (packed & 32) == 32;
		var localColorTableSize = 2 << (packed & 7);
		var lct = null;
		if(localColorTable) {
			lct = this.readColorTable(localColorTableSize);
		}
		return format_gif_Block.BFrame({ x : x, y : y, width : width, height : height, localColorTable : localColorTable, interlaced : interlaced, sorted : sorted, localColorTableSize : localColorTableSize, pixels : this.readPixels(width,height,interlaced), colorTable : lct});
	}
	,readPixels: function(width,height,interlaced) {
		var input = this.i;
		var pixelsCount = width * height;
		var pixels = new haxe_io_Bytes(new ArrayBuffer(pixelsCount));
		var minCodeSize = input.readByte();
		var blockSize = input.readByte() - 1;
		var bits = input.readByte();
		var bitsCount = 8;
		var clearCode = 1 << minCodeSize;
		var eoiCode = clearCode + 1;
		var codeSize = minCodeSize + 1;
		var codeSizeLimit = 1 << codeSize;
		var codeMask = codeSizeLimit - 1;
		var baseDict = [];
		var _g = 0;
		var _g1 = clearCode;
		while(_g < _g1) {
			var i = _g++;
			baseDict[i] = [i];
		}
		var dict = [];
		var dictLen = clearCode + 2;
		var newRecord;
		var i = 0;
		var code = 0;
		var last;
		while(i < pixelsCount) {
			last = code;
			while(bitsCount < codeSize) {
				if(blockSize == 0) {
					break;
				}
				bits |= input.readByte() << bitsCount;
				bitsCount += 8;
				--blockSize;
				if(blockSize == 0) {
					blockSize = input.readByte();
				}
			}
			code = bits & codeMask;
			bits >>= codeSize;
			bitsCount -= codeSize;
			if(code == clearCode) {
				dict = baseDict.slice();
				dictLen = clearCode + 2;
				codeSize = minCodeSize + 1;
				codeSizeLimit = 1 << codeSize;
				codeMask = codeSizeLimit - 1;
				continue;
			}
			if(code == eoiCode) {
				break;
			}
			if(code < dictLen) {
				if(last != clearCode) {
					newRecord = dict[last].slice();
					newRecord.push(dict[code][0]);
					dict[dictLen++] = newRecord;
				}
			} else {
				if(code != dictLen) {
					throw haxe_Exception.thrown("Invalid LZW code. Excepted: " + dictLen + ", got: " + code);
				}
				newRecord = dict[last].slice();
				newRecord.push(newRecord[0]);
				dict[dictLen++] = newRecord;
			}
			newRecord = dict[code];
			var _g = 0;
			while(_g < newRecord.length) {
				var item = newRecord[_g];
				++_g;
				pixels.b[i++] = item;
			}
			if(dictLen == codeSizeLimit && codeSize < 12) {
				++codeSize;
				codeSizeLimit = 1 << codeSize;
				codeMask = codeSizeLimit - 1;
			}
		}
		while(blockSize > 0) {
			input.readByte();
			--blockSize;
			if(blockSize == 0) {
				blockSize = input.readByte();
			}
		}
		while(i < pixelsCount) pixels.b[i++] = 0;
		if(interlaced) {
			var buffer = new haxe_io_Bytes(new ArrayBuffer(pixelsCount));
			var offset = this.deinterlace(pixels,buffer,8,0,0,width,height);
			offset = this.deinterlace(pixels,buffer,8,4,offset,width,height);
			offset = this.deinterlace(pixels,buffer,4,2,offset,width,height);
			this.deinterlace(pixels,buffer,2,1,offset,width,height);
			pixels = buffer;
		}
		return pixels;
	}
	,deinterlace: function(input,output,step,y,offset,width,height) {
		while(y < height) {
			output.blit(y * width,input,offset,width);
			offset += width;
			y += step;
		}
		return offset;
	}
	,readExtension: function() {
		var subId = this.i.readByte();
		switch(subId) {
		case 1:
			if(this.i.readByte() != 12) {
				throw haxe_Exception.thrown("Incorrect size of Plain Text Extension introducer block.");
			}
			var tmp = this.i.readUInt16();
			var tmp1 = this.i.readUInt16();
			var tmp2 = this.i.readUInt16();
			var tmp3 = this.i.readUInt16();
			var tmp4 = this.i.readByte();
			var tmp5 = this.i.readByte();
			var tmp6 = this.i.readByte();
			var tmp7 = this.i.readByte();
			var buffer = new haxe_io_BytesOutput();
			var bytes = new haxe_io_Bytes(new ArrayBuffer(255));
			var len = this.i.readByte();
			while(len != 0) {
				this.i.readBytes(bytes,0,len);
				buffer.writeBytes(bytes,0,len);
				len = this.i.readByte();
			}
			buffer.flush();
			bytes = buffer.getBytes();
			buffer.close();
			return format_gif_Block.BExtension(format_gif_Extension.EText({ textGridX : tmp, textGridY : tmp1, textGridWidth : tmp2, textGridHeight : tmp3, charCellWidth : tmp4, charCellHeight : tmp5, textForegroundColorIndex : tmp6, textBackgroundColorIndex : tmp7, text : bytes.toString()}));
		case 249:
			if(this.i.readByte() != 4) {
				throw haxe_Exception.thrown("Incorrect Graphic Control Extension block size!");
			}
			var packed = this.i.readByte();
			var disposalMethod;
			switch((packed & 28) >> 2) {
			case 0:
				disposalMethod = format_gif_DisposalMethod.UNSPECIFIED;
				break;
			case 1:
				disposalMethod = format_gif_DisposalMethod.NO_ACTION;
				break;
			case 2:
				disposalMethod = format_gif_DisposalMethod.FILL_BACKGROUND;
				break;
			case 3:
				disposalMethod = format_gif_DisposalMethod.RENDER_PREVIOUS;
				break;
			default:
				disposalMethod = format_gif_DisposalMethod.UNDEFINED((packed & 28) >> 2);
			}
			var b = format_gif_Block.BExtension(format_gif_Extension.EGraphicControl({ disposalMethod : disposalMethod, userInput : (packed & 2) == 2, hasTransparentColor : (packed & 1) == 1, delay : this.i.readUInt16(), transparentIndex : this.i.readByte()}));
			this.i.readByte();
			return b;
		case 254:
			var buffer = new haxe_io_BytesOutput();
			var bytes = new haxe_io_Bytes(new ArrayBuffer(255));
			var len = this.i.readByte();
			while(len != 0) {
				this.i.readBytes(bytes,0,len);
				buffer.writeBytes(bytes,0,len);
				len = this.i.readByte();
			}
			buffer.flush();
			bytes = buffer.getBytes();
			buffer.close();
			return format_gif_Block.BExtension(format_gif_Extension.EComment(bytes.toString()));
		case 255:
			return this.readApplicationExtension();
		default:
			var buffer = new haxe_io_BytesOutput();
			var bytes = new haxe_io_Bytes(new ArrayBuffer(255));
			var len = this.i.readByte();
			while(len != 0) {
				this.i.readBytes(bytes,0,len);
				buffer.writeBytes(bytes,0,len);
				len = this.i.readByte();
			}
			buffer.flush();
			bytes = buffer.getBytes();
			buffer.close();
			return format_gif_Block.BExtension(format_gif_Extension.EUnknown(subId,bytes));
		}
	}
	,readApplicationExtension: function() {
		if(this.i.readByte() != 11) {
			throw haxe_Exception.thrown("Incorrect size of Application Extension introducer block.");
		}
		var name = this.i.readString(8);
		var version = this.i.readString(3);
		var buffer = new haxe_io_BytesOutput();
		var bytes = new haxe_io_Bytes(new ArrayBuffer(255));
		var len = this.i.readByte();
		while(len != 0) {
			this.i.readBytes(bytes,0,len);
			buffer.writeBytes(bytes,0,len);
			len = this.i.readByte();
		}
		buffer.flush();
		bytes = buffer.getBytes();
		buffer.close();
		var data = bytes;
		if(name == "NETSCAPE" && version == "2.0" && data.b[0] == 1) {
			return format_gif_Block.BExtension(format_gif_Extension.EApplicationExtension(format_gif_ApplicationExtension.AENetscapeLooping(data.b[1] | data.b[2] << 8)));
		}
		return format_gif_Block.BExtension(format_gif_Extension.EApplicationExtension(format_gif_ApplicationExtension.AEUnknown(name,version,data)));
	}
	,readBlocks: function() {
		var buffer = new haxe_io_BytesOutput();
		var bytes = new haxe_io_Bytes(new ArrayBuffer(255));
		var len = this.i.readByte();
		while(len != 0) {
			this.i.readBytes(bytes,0,len);
			buffer.writeBytes(bytes,0,len);
			len = this.i.readByte();
		}
		buffer.flush();
		bytes = buffer.getBytes();
		buffer.close();
		return bytes;
	}
	,readColorTable: function(size) {
		size *= 3;
		var output = new haxe_io_Bytes(new ArrayBuffer(size));
		var c = 0;
		while(c < size) {
			var v = this.i.readByte();
			output.b[c] = v;
			var v1 = this.i.readByte();
			output.b[c + 1] = v1;
			var v2 = this.i.readByte();
			output.b[c + 2] = v2;
			c += 3;
		}
		return output;
	}
	,__class__: format_gif_Reader
};
var format_gif_Tools = function() { };
$hxClasses["format.gif.Tools"] = format_gif_Tools;
format_gif_Tools.__name__ = "format.gif.Tools";
format_gif_Tools.framesCount = function(data) {
	var frames = 0;
	var _g_head = data.blocks.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var block = val;
		if(block._hx_index == 0) {
			var _g = block.frame;
			++frames;
		}
	}
	return frames;
};
format_gif_Tools.frame = function(data,frameIndex) {
	var counter = 0;
	var _g_head = data.blocks.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var block = val;
		if(block._hx_index == 0) {
			var frame = block.frame;
			if(counter == frameIndex) {
				return frame;
			}
			++counter;
		}
	}
	return null;
};
format_gif_Tools.graphicControl = function(data,frameIndex) {
	var counter = 0;
	var gce = null;
	var _g_head = data.blocks.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var block = val;
		switch(block._hx_index) {
		case 0:
			var frame = block.frame;
			if(counter == frameIndex) {
				return gce;
			}
			gce = null;
			++counter;
			break;
		case 1:
			var _g = block.extension;
			if(_g._hx_index == 0) {
				var g = _g.gce;
				gce = g;
			}
			break;
		default:
		}
	}
	return null;
};
format_gif_Tools.extractBGRA = function(data,frameIndex) {
	var gce = null;
	var frameCaret = 0;
	var _g_head = data.blocks.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var block = val;
		switch(block._hx_index) {
		case 0:
			var frame = block.frame;
			if(frameCaret == frameIndex) {
				var bytes = new haxe_io_Bytes(new ArrayBuffer(frame.width * frame.height * 4));
				var ct = frame.localColorTable ? frame.colorTable : data.globalColorTable;
				if(ct == null) {
					throw haxe_Exception.thrown("Frame does not have a color table!");
				}
				var transparentIndex = gce != null && gce.hasTransparentColor ? gce.transparentIndex * 3 : -1;
				var writeCaret = 0;
				var _g = 0;
				var _g1 = frame.pixels.length;
				while(_g < _g1) {
					var i = _g++;
					var index = frame.pixels.b[i] * 3;
					bytes.b[writeCaret] = ct.b[index + 2];
					bytes.b[writeCaret + 1] = ct.b[index + 1];
					bytes.b[writeCaret + 2] = ct.b[index];
					if(transparentIndex == index) {
						bytes.b[writeCaret + 3] = 0;
					} else {
						bytes.b[writeCaret + 3] = 255;
					}
					writeCaret += 4;
				}
				return bytes;
			}
			++frameCaret;
			gce = null;
			break;
		case 1:
			var ext = block.extension;
			if(ext._hx_index == 0) {
				var g = ext.gce;
				gce = g;
			}
			break;
		default:
		}
	}
	return null;
};
format_gif_Tools.extractRGBA = function(data,frameIndex) {
	var gce = null;
	var frameCaret = 0;
	var _g_head = data.blocks.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var block = val;
		switch(block._hx_index) {
		case 0:
			var frame = block.frame;
			if(frameCaret == frameIndex) {
				var bytes = new haxe_io_Bytes(new ArrayBuffer(frame.width * frame.height * 4));
				var ct = frame.localColorTable ? frame.colorTable : data.globalColorTable;
				if(ct == null) {
					throw haxe_Exception.thrown("Frame does not have a color table!");
				}
				var transparentIndex = gce != null && gce.hasTransparentColor ? gce.transparentIndex * 3 : -1;
				var writeCaret = 0;
				var _g = 0;
				var _g1 = frame.pixels.length;
				while(_g < _g1) {
					var i = _g++;
					var index = frame.pixels.b[i] * 3;
					bytes.b[writeCaret] = ct.b[index];
					bytes.b[writeCaret + 1] = ct.b[index + 1];
					bytes.b[writeCaret + 2] = ct.b[index + 2];
					if(transparentIndex == index) {
						bytes.b[writeCaret + 3] = 0;
					} else {
						bytes.b[writeCaret + 3] = 255;
					}
					writeCaret += 4;
				}
				return bytes;
			}
			++frameCaret;
			gce = null;
			break;
		case 1:
			var ext = block.extension;
			if(ext._hx_index == 0) {
				var g = ext.gce;
				gce = g;
			}
			break;
		default:
		}
	}
	return null;
};
format_gif_Tools.extractFullBGRA = function(data,frameIndex) {
	var gce = null;
	var frameCaret = 0;
	var bytes = new haxe_io_Bytes(new ArrayBuffer(data.logicalScreenDescriptor.width * data.logicalScreenDescriptor.height * 4));
	var _g_head = data.blocks.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var block = val;
		switch(block._hx_index) {
		case 0:
			var frame = block.frame;
			var ct = frame.localColorTable ? frame.colorTable : data.globalColorTable;
			if(ct == null) {
				throw haxe_Exception.thrown("Frame does not have a color table!");
			}
			var transparentIndex = gce != null && gce.hasTransparentColor ? gce.transparentIndex * 3 : -1;
			var pixels = frame.pixels;
			var x = 0;
			var writeCaret = (frame.y * data.logicalScreenDescriptor.width + frame.x) * 4;
			var lineSkip = (data.logicalScreenDescriptor.width - frame.width) * 4 + 4;
			var disposalMethod = frameCaret != frameIndex && gce != null ? gce.disposalMethod : format_gif_DisposalMethod.NO_ACTION;
			switch(disposalMethod._hx_index) {
			case 2:
				var _g = 0;
				var _g1 = pixels.length;
				while(_g < _g1) {
					var i = _g++;
					bytes.b[writeCaret] = 0;
					bytes.b[writeCaret + 1] = 0;
					bytes.b[writeCaret + 2] = 0;
					bytes.b[writeCaret + 3] = 0;
					if(++x == frame.width) {
						x = 0;
						writeCaret += lineSkip;
					} else {
						writeCaret += 4;
					}
				}
				break;
			case 3:
				break;
			default:
				var _g2 = 0;
				var _g3 = pixels.length;
				while(_g2 < _g3) {
					var i1 = _g2++;
					var index = pixels.b[i1] * 3;
					if(transparentIndex != index) {
						bytes.b[writeCaret] = ct.b[index + 2];
						bytes.b[writeCaret + 1] = ct.b[index + 1];
						bytes.b[writeCaret + 2] = ct.b[index];
						bytes.b[writeCaret + 3] = 255;
					}
					if(++x == frame.width) {
						x = 0;
						writeCaret += lineSkip;
					} else {
						writeCaret += 4;
					}
				}
			}
			if(frameCaret == frameIndex) {
				return bytes;
			}
			++frameCaret;
			gce = null;
			break;
		case 1:
			var ext = block.extension;
			if(ext._hx_index == 0) {
				var g = ext.gce;
				gce = g;
			}
			break;
		default:
		}
	}
	return bytes;
};
format_gif_Tools.extractFullRGBA = function(data,frameIndex) {
	var gce = null;
	var frameCaret = 0;
	var bytes = new haxe_io_Bytes(new ArrayBuffer(data.logicalScreenDescriptor.width * data.logicalScreenDescriptor.height * 4));
	var _g_head = data.blocks.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var block = val;
		switch(block._hx_index) {
		case 0:
			var frame = block.frame;
			var ct = frame.localColorTable ? frame.colorTable : data.globalColorTable;
			if(ct == null) {
				throw haxe_Exception.thrown("Frame does not have a color table!");
			}
			var transparentIndex = gce != null && gce.hasTransparentColor ? gce.transparentIndex * 3 : -1;
			var pixels = frame.pixels;
			var x = 0;
			var writeCaret = (frame.y * data.logicalScreenDescriptor.width + frame.x) * 4;
			var lineSkip = (data.logicalScreenDescriptor.width - frame.width) * 4 + 4;
			var disposalMethod = frameCaret != frameIndex && gce != null ? gce.disposalMethod : format_gif_DisposalMethod.NO_ACTION;
			switch(disposalMethod._hx_index) {
			case 2:
				var _g = 0;
				var _g1 = pixels.length;
				while(_g < _g1) {
					var i = _g++;
					bytes.b[writeCaret] = 0;
					bytes.b[writeCaret + 1] = 0;
					bytes.b[writeCaret + 2] = 0;
					bytes.b[writeCaret + 3] = 0;
					if(++x == frame.width) {
						x = 0;
						writeCaret += lineSkip;
					} else {
						writeCaret += 4;
					}
				}
				break;
			case 3:
				break;
			default:
				var _g2 = 0;
				var _g3 = pixels.length;
				while(_g2 < _g3) {
					var i1 = _g2++;
					var index = pixels.b[i1] * 3;
					if(transparentIndex != index) {
						bytes.b[writeCaret] = ct.b[index];
						bytes.b[writeCaret + 1] = ct.b[index + 1];
						bytes.b[writeCaret + 2] = ct.b[index + 2];
						bytes.b[writeCaret + 3] = 255;
					}
					if(++x == frame.width) {
						x = 0;
						writeCaret += lineSkip;
					} else {
						writeCaret += 4;
					}
				}
			}
			if(frameCaret == frameIndex) {
				return bytes;
			}
			++frameCaret;
			gce = null;
			break;
		case 1:
			var ext = block.extension;
			if(ext._hx_index == 0) {
				var g = ext.gce;
				gce = g;
			}
			break;
		default:
		}
	}
	return bytes;
};
format_gif_Tools.loopCount = function(data) {
	var _g_head = data.blocks.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var block = val;
		if(block._hx_index == 1) {
			var _g = block.extension;
			if(_g._hx_index == 3) {
				var _g1 = _g.ext;
				if(_g1._hx_index == 0) {
					var loops = _g1.loops;
					return loops;
				}
			}
		}
	}
	return 1;
};
format_gif_Tools.log2 = function(val) {
	return Math.log(val) / format_gif_Tools.LN2;
};
var format_mp3_SamplingRate = $hxEnums["format.mp3.SamplingRate"] = { __ename__:true,__constructs__:null
	,SR_8000: {_hx_name:"SR_8000",_hx_index:0,__enum__:"format.mp3.SamplingRate",toString:$estr}
	,SR_11025: {_hx_name:"SR_11025",_hx_index:1,__enum__:"format.mp3.SamplingRate",toString:$estr}
	,SR_12000: {_hx_name:"SR_12000",_hx_index:2,__enum__:"format.mp3.SamplingRate",toString:$estr}
	,SR_22050: {_hx_name:"SR_22050",_hx_index:3,__enum__:"format.mp3.SamplingRate",toString:$estr}
	,SR_24000: {_hx_name:"SR_24000",_hx_index:4,__enum__:"format.mp3.SamplingRate",toString:$estr}
	,SR_32000: {_hx_name:"SR_32000",_hx_index:5,__enum__:"format.mp3.SamplingRate",toString:$estr}
	,SR_44100: {_hx_name:"SR_44100",_hx_index:6,__enum__:"format.mp3.SamplingRate",toString:$estr}
	,SR_48000: {_hx_name:"SR_48000",_hx_index:7,__enum__:"format.mp3.SamplingRate",toString:$estr}
	,SR_Bad: {_hx_name:"SR_Bad",_hx_index:8,__enum__:"format.mp3.SamplingRate",toString:$estr}
};
format_mp3_SamplingRate.__constructs__ = [format_mp3_SamplingRate.SR_8000,format_mp3_SamplingRate.SR_11025,format_mp3_SamplingRate.SR_12000,format_mp3_SamplingRate.SR_22050,format_mp3_SamplingRate.SR_24000,format_mp3_SamplingRate.SR_32000,format_mp3_SamplingRate.SR_44100,format_mp3_SamplingRate.SR_48000,format_mp3_SamplingRate.SR_Bad];
format_mp3_SamplingRate.__empty_constructs__ = [format_mp3_SamplingRate.SR_8000,format_mp3_SamplingRate.SR_11025,format_mp3_SamplingRate.SR_12000,format_mp3_SamplingRate.SR_22050,format_mp3_SamplingRate.SR_24000,format_mp3_SamplingRate.SR_32000,format_mp3_SamplingRate.SR_44100,format_mp3_SamplingRate.SR_48000,format_mp3_SamplingRate.SR_Bad];
var format_mp3_Bitrate = $hxEnums["format.mp3.Bitrate"] = { __ename__:true,__constructs__:null
	,BR_8: {_hx_name:"BR_8",_hx_index:0,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_16: {_hx_name:"BR_16",_hx_index:1,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_24: {_hx_name:"BR_24",_hx_index:2,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_32: {_hx_name:"BR_32",_hx_index:3,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_40: {_hx_name:"BR_40",_hx_index:4,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_48: {_hx_name:"BR_48",_hx_index:5,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_56: {_hx_name:"BR_56",_hx_index:6,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_64: {_hx_name:"BR_64",_hx_index:7,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_80: {_hx_name:"BR_80",_hx_index:8,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_96: {_hx_name:"BR_96",_hx_index:9,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_112: {_hx_name:"BR_112",_hx_index:10,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_128: {_hx_name:"BR_128",_hx_index:11,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_144: {_hx_name:"BR_144",_hx_index:12,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_160: {_hx_name:"BR_160",_hx_index:13,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_176: {_hx_name:"BR_176",_hx_index:14,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_192: {_hx_name:"BR_192",_hx_index:15,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_224: {_hx_name:"BR_224",_hx_index:16,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_256: {_hx_name:"BR_256",_hx_index:17,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_288: {_hx_name:"BR_288",_hx_index:18,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_320: {_hx_name:"BR_320",_hx_index:19,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_352: {_hx_name:"BR_352",_hx_index:20,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_384: {_hx_name:"BR_384",_hx_index:21,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_416: {_hx_name:"BR_416",_hx_index:22,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_448: {_hx_name:"BR_448",_hx_index:23,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_Free: {_hx_name:"BR_Free",_hx_index:24,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_Bad: {_hx_name:"BR_Bad",_hx_index:25,__enum__:"format.mp3.Bitrate",toString:$estr}
};
format_mp3_Bitrate.__constructs__ = [format_mp3_Bitrate.BR_8,format_mp3_Bitrate.BR_16,format_mp3_Bitrate.BR_24,format_mp3_Bitrate.BR_32,format_mp3_Bitrate.BR_40,format_mp3_Bitrate.BR_48,format_mp3_Bitrate.BR_56,format_mp3_Bitrate.BR_64,format_mp3_Bitrate.BR_80,format_mp3_Bitrate.BR_96,format_mp3_Bitrate.BR_112,format_mp3_Bitrate.BR_128,format_mp3_Bitrate.BR_144,format_mp3_Bitrate.BR_160,format_mp3_Bitrate.BR_176,format_mp3_Bitrate.BR_192,format_mp3_Bitrate.BR_224,format_mp3_Bitrate.BR_256,format_mp3_Bitrate.BR_288,format_mp3_Bitrate.BR_320,format_mp3_Bitrate.BR_352,format_mp3_Bitrate.BR_384,format_mp3_Bitrate.BR_416,format_mp3_Bitrate.BR_448,format_mp3_Bitrate.BR_Free,format_mp3_Bitrate.BR_Bad];
format_mp3_Bitrate.__empty_constructs__ = [format_mp3_Bitrate.BR_8,format_mp3_Bitrate.BR_16,format_mp3_Bitrate.BR_24,format_mp3_Bitrate.BR_32,format_mp3_Bitrate.BR_40,format_mp3_Bitrate.BR_48,format_mp3_Bitrate.BR_56,format_mp3_Bitrate.BR_64,format_mp3_Bitrate.BR_80,format_mp3_Bitrate.BR_96,format_mp3_Bitrate.BR_112,format_mp3_Bitrate.BR_128,format_mp3_Bitrate.BR_144,format_mp3_Bitrate.BR_160,format_mp3_Bitrate.BR_176,format_mp3_Bitrate.BR_192,format_mp3_Bitrate.BR_224,format_mp3_Bitrate.BR_256,format_mp3_Bitrate.BR_288,format_mp3_Bitrate.BR_320,format_mp3_Bitrate.BR_352,format_mp3_Bitrate.BR_384,format_mp3_Bitrate.BR_416,format_mp3_Bitrate.BR_448,format_mp3_Bitrate.BR_Free,format_mp3_Bitrate.BR_Bad];
var format_mp3_MPEG = function() { };
$hxClasses["format.mp3.MPEG"] = format_mp3_MPEG;
format_mp3_MPEG.__name__ = "format.mp3.MPEG";
format_mp3_MPEG.enum2Num = function(m) {
	switch(m._hx_index) {
	case 0:
		return 3;
	case 1:
		return 2;
	case 2:
		return 0;
	case 3:
		return format_mp3_MPEG.Reserved;
	}
};
format_mp3_MPEG.num2Enum = function(m) {
	switch(m) {
	case 0:
		return format_mp3_MPEGVersion.MPEG_V25;
	case 2:
		return format_mp3_MPEGVersion.MPEG_V2;
	case 3:
		return format_mp3_MPEGVersion.MPEG_V1;
	default:
		return format_mp3_MPEGVersion.MPEG_Reserved;
	}
};
format_mp3_MPEG.srNum2Enum = function(sr) {
	switch(sr) {
	case 8000:
		return format_mp3_SamplingRate.SR_8000;
	case 11025:
		return format_mp3_SamplingRate.SR_11025;
	case 12000:
		return format_mp3_SamplingRate.SR_12000;
	case 22050:
		return format_mp3_SamplingRate.SR_22050;
	case 24000:
		return format_mp3_SamplingRate.SR_24000;
	case 32000:
		return format_mp3_SamplingRate.SR_32000;
	case 44100:
		return format_mp3_SamplingRate.SR_44100;
	case 48000:
		return format_mp3_SamplingRate.SR_48000;
	default:
		return format_mp3_SamplingRate.SR_Bad;
	}
};
format_mp3_MPEG.srEnum2Num = function(sr) {
	switch(sr._hx_index) {
	case 0:
		return 8000;
	case 1:
		return 11025;
	case 2:
		return 12000;
	case 3:
		return 22050;
	case 4:
		return 24000;
	case 5:
		return 32000;
	case 6:
		return 44100;
	case 7:
		return 48000;
	case 8:
		return -1;
	}
};
format_mp3_MPEG.getBitrateIdx = function(br,mpeg,layer) {
	var arr = (mpeg == format_mp3_MPEGVersion.MPEG_V1 ? format_mp3_MPEG.V1_Bitrates : format_mp3_MPEG.V2_Bitrates)[format_mp3_CLayer.enum2Num(layer)];
	if(arr[0] == br) {
		return 0;
	}
	if(arr[1] == br) {
		return 1;
	}
	if(arr[2] == br) {
		return 2;
	}
	if(arr[3] == br) {
		return 3;
	}
	if(arr[4] == br) {
		return 4;
	}
	if(arr[5] == br) {
		return 5;
	}
	if(arr[6] == br) {
		return 6;
	}
	if(arr[7] == br) {
		return 7;
	}
	if(arr[8] == br) {
		return 8;
	}
	if(arr[9] == br) {
		return 9;
	}
	if(arr[10] == br) {
		return 10;
	}
	if(arr[11] == br) {
		return 11;
	}
	if(arr[12] == br) {
		return 12;
	}
	if(arr[13] == br) {
		return 13;
	}
	if(arr[14] == br) {
		return 14;
	}
	if(arr[15] == br) {
		return 15;
	}
	throw haxe_Exception.thrown("Bitrate index not found");
};
format_mp3_MPEG.getSamplingRateIdx = function(sr,mpeg) {
	var arr = format_mp3_MPEG.SamplingRates[format_mp3_MPEG.enum2Num(mpeg)];
	if(arr[0] == sr) {
		return 0;
	}
	if(arr[1] == sr) {
		return 1;
	}
	if(arr[2] == sr) {
		return 2;
	}
	if(arr[3] == sr) {
		return 3;
	}
	throw haxe_Exception.thrown("Sampling rate index not found");
};
format_mp3_MPEG.bitrateEnum2Num = function(br) {
	switch(br._hx_index) {
	case 0:
		return 8;
	case 1:
		return 16;
	case 2:
		return 24;
	case 3:
		return 32;
	case 4:
		return 40;
	case 5:
		return 48;
	case 6:
		return 56;
	case 7:
		return 64;
	case 8:
		return 80;
	case 9:
		return 96;
	case 10:
		return 112;
	case 11:
		return 128;
	case 12:
		return 144;
	case 13:
		return 160;
	case 14:
		return 176;
	case 15:
		return 192;
	case 16:
		return 224;
	case 17:
		return 256;
	case 18:
		return 288;
	case 19:
		return 320;
	case 20:
		return 352;
	case 21:
		return 384;
	case 22:
		return 416;
	case 23:
		return 448;
	case 24:
		return 0;
	case 25:
		return -1;
	}
};
format_mp3_MPEG.bitrateNum2Enum = function(br) {
	switch(br) {
	case 0:
		return format_mp3_Bitrate.BR_Free;
	case 8:
		return format_mp3_Bitrate.BR_8;
	case 16:
		return format_mp3_Bitrate.BR_16;
	case 24:
		return format_mp3_Bitrate.BR_24;
	case 32:
		return format_mp3_Bitrate.BR_32;
	case 40:
		return format_mp3_Bitrate.BR_40;
	case 48:
		return format_mp3_Bitrate.BR_48;
	case 56:
		return format_mp3_Bitrate.BR_56;
	case 64:
		return format_mp3_Bitrate.BR_64;
	case 80:
		return format_mp3_Bitrate.BR_80;
	case 96:
		return format_mp3_Bitrate.BR_96;
	case 112:
		return format_mp3_Bitrate.BR_112;
	case 128:
		return format_mp3_Bitrate.BR_128;
	case 144:
		return format_mp3_Bitrate.BR_144;
	case 160:
		return format_mp3_Bitrate.BR_160;
	case 176:
		return format_mp3_Bitrate.BR_176;
	case 192:
		return format_mp3_Bitrate.BR_192;
	case 224:
		return format_mp3_Bitrate.BR_224;
	case 256:
		return format_mp3_Bitrate.BR_256;
	case 288:
		return format_mp3_Bitrate.BR_288;
	case 320:
		return format_mp3_Bitrate.BR_320;
	case 352:
		return format_mp3_Bitrate.BR_352;
	case 384:
		return format_mp3_Bitrate.BR_384;
	case 416:
		return format_mp3_Bitrate.BR_416;
	case 448:
		return format_mp3_Bitrate.BR_448;
	default:
		return format_mp3_Bitrate.BR_Bad;
	}
};
var format_mp3_CLayer = function() { };
$hxClasses["format.mp3.CLayer"] = format_mp3_CLayer;
format_mp3_CLayer.__name__ = "format.mp3.CLayer";
format_mp3_CLayer.enum2Num = function(l) {
	switch(l._hx_index) {
	case 0:
		return format_mp3_CLayer.LReserved;
	case 1:
		return format_mp3_CLayer.LLayer3;
	case 2:
		return format_mp3_CLayer.LLayer2;
	case 3:
		return format_mp3_CLayer.LLayer1;
	}
};
format_mp3_CLayer.num2Enum = function(l) {
	switch(l) {
	case 1:
		return format_mp3_Layer.Layer3;
	case 2:
		return format_mp3_Layer.Layer2;
	case 3:
		return format_mp3_Layer.Layer1;
	default:
		return format_mp3_Layer.LayerReserved;
	}
};
var format_mp3_CChannelMode = function() { };
$hxClasses["format.mp3.CChannelMode"] = format_mp3_CChannelMode;
format_mp3_CChannelMode.__name__ = "format.mp3.CChannelMode";
format_mp3_CChannelMode.enum2Num = function(c) {
	switch(c._hx_index) {
	case 0:
		return 0;
	case 1:
		return 1;
	case 2:
		return 2;
	case 3:
		return 3;
	}
};
format_mp3_CChannelMode.num2Enum = function(c) {
	switch(c) {
	case 0:
		return format_mp3_ChannelMode.Stereo;
	case 1:
		return format_mp3_ChannelMode.JointStereo;
	case 2:
		return format_mp3_ChannelMode.DualChannel;
	case 3:
		return format_mp3_ChannelMode.Mono;
	default:
		throw haxe_Exception.thrown("assert");
	}
};
var format_mp3_CEmphasis = function() { };
$hxClasses["format.mp3.CEmphasis"] = format_mp3_CEmphasis;
format_mp3_CEmphasis.__name__ = "format.mp3.CEmphasis";
format_mp3_CEmphasis.enum2Num = function(c) {
	switch(c._hx_index) {
	case 0:
		return 0;
	case 1:
		return 1;
	case 2:
		return 3;
	case 3:
		return 2;
	}
};
format_mp3_CEmphasis.num2Enum = function(c) {
	switch(c) {
	case 0:
		return format_mp3_Emphasis.NoEmphasis;
	case 1:
		return format_mp3_Emphasis.Ms50_15;
	case 2:
		return format_mp3_Emphasis.InvalidEmphasis;
	case 3:
		return format_mp3_Emphasis.CCIT_J17;
	default:
		throw haxe_Exception.thrown("assert");
	}
};
var format_mp3_MPEGVersion = $hxEnums["format.mp3.MPEGVersion"] = { __ename__:true,__constructs__:null
	,MPEG_V1: {_hx_name:"MPEG_V1",_hx_index:0,__enum__:"format.mp3.MPEGVersion",toString:$estr}
	,MPEG_V2: {_hx_name:"MPEG_V2",_hx_index:1,__enum__:"format.mp3.MPEGVersion",toString:$estr}
	,MPEG_V25: {_hx_name:"MPEG_V25",_hx_index:2,__enum__:"format.mp3.MPEGVersion",toString:$estr}
	,MPEG_Reserved: {_hx_name:"MPEG_Reserved",_hx_index:3,__enum__:"format.mp3.MPEGVersion",toString:$estr}
};
format_mp3_MPEGVersion.__constructs__ = [format_mp3_MPEGVersion.MPEG_V1,format_mp3_MPEGVersion.MPEG_V2,format_mp3_MPEGVersion.MPEG_V25,format_mp3_MPEGVersion.MPEG_Reserved];
format_mp3_MPEGVersion.__empty_constructs__ = [format_mp3_MPEGVersion.MPEG_V1,format_mp3_MPEGVersion.MPEG_V2,format_mp3_MPEGVersion.MPEG_V25,format_mp3_MPEGVersion.MPEG_Reserved];
var format_mp3_Layer = $hxEnums["format.mp3.Layer"] = { __ename__:true,__constructs__:null
	,LayerReserved: {_hx_name:"LayerReserved",_hx_index:0,__enum__:"format.mp3.Layer",toString:$estr}
	,Layer3: {_hx_name:"Layer3",_hx_index:1,__enum__:"format.mp3.Layer",toString:$estr}
	,Layer2: {_hx_name:"Layer2",_hx_index:2,__enum__:"format.mp3.Layer",toString:$estr}
	,Layer1: {_hx_name:"Layer1",_hx_index:3,__enum__:"format.mp3.Layer",toString:$estr}
};
format_mp3_Layer.__constructs__ = [format_mp3_Layer.LayerReserved,format_mp3_Layer.Layer3,format_mp3_Layer.Layer2,format_mp3_Layer.Layer1];
format_mp3_Layer.__empty_constructs__ = [format_mp3_Layer.LayerReserved,format_mp3_Layer.Layer3,format_mp3_Layer.Layer2,format_mp3_Layer.Layer1];
var format_mp3_ChannelMode = $hxEnums["format.mp3.ChannelMode"] = { __ename__:true,__constructs__:null
	,Stereo: {_hx_name:"Stereo",_hx_index:0,__enum__:"format.mp3.ChannelMode",toString:$estr}
	,JointStereo: {_hx_name:"JointStereo",_hx_index:1,__enum__:"format.mp3.ChannelMode",toString:$estr}
	,DualChannel: {_hx_name:"DualChannel",_hx_index:2,__enum__:"format.mp3.ChannelMode",toString:$estr}
	,Mono: {_hx_name:"Mono",_hx_index:3,__enum__:"format.mp3.ChannelMode",toString:$estr}
};
format_mp3_ChannelMode.__constructs__ = [format_mp3_ChannelMode.Stereo,format_mp3_ChannelMode.JointStereo,format_mp3_ChannelMode.DualChannel,format_mp3_ChannelMode.Mono];
format_mp3_ChannelMode.__empty_constructs__ = [format_mp3_ChannelMode.Stereo,format_mp3_ChannelMode.JointStereo,format_mp3_ChannelMode.DualChannel,format_mp3_ChannelMode.Mono];
var format_mp3_Emphasis = $hxEnums["format.mp3.Emphasis"] = { __ename__:true,__constructs__:null
	,NoEmphasis: {_hx_name:"NoEmphasis",_hx_index:0,__enum__:"format.mp3.Emphasis",toString:$estr}
	,Ms50_15: {_hx_name:"Ms50_15",_hx_index:1,__enum__:"format.mp3.Emphasis",toString:$estr}
	,CCIT_J17: {_hx_name:"CCIT_J17",_hx_index:2,__enum__:"format.mp3.Emphasis",toString:$estr}
	,InvalidEmphasis: {_hx_name:"InvalidEmphasis",_hx_index:3,__enum__:"format.mp3.Emphasis",toString:$estr}
};
format_mp3_Emphasis.__constructs__ = [format_mp3_Emphasis.NoEmphasis,format_mp3_Emphasis.Ms50_15,format_mp3_Emphasis.CCIT_J17,format_mp3_Emphasis.InvalidEmphasis];
format_mp3_Emphasis.__empty_constructs__ = [format_mp3_Emphasis.NoEmphasis,format_mp3_Emphasis.Ms50_15,format_mp3_Emphasis.CCIT_J17,format_mp3_Emphasis.InvalidEmphasis];
var format_mp3_FrameType = $hxEnums["format.mp3.FrameType"] = { __ename__:true,__constructs__:null
	,FT_MP3: {_hx_name:"FT_MP3",_hx_index:0,__enum__:"format.mp3.FrameType",toString:$estr}
	,FT_NONE: {_hx_name:"FT_NONE",_hx_index:1,__enum__:"format.mp3.FrameType",toString:$estr}
};
format_mp3_FrameType.__constructs__ = [format_mp3_FrameType.FT_MP3,format_mp3_FrameType.FT_NONE];
format_mp3_FrameType.__empty_constructs__ = [format_mp3_FrameType.FT_MP3,format_mp3_FrameType.FT_NONE];
var format_mp3_Reader = function(i) {
	this.i = i;
	i.set_bigEndian(true);
	this.bits = new format_tools_BitsInput(i);
	this.samples = 0;
	this.sampleSize = 0;
	this.any_read = false;
};
$hxClasses["format.mp3.Reader"] = format_mp3_Reader;
format_mp3_Reader.__name__ = "format.mp3.Reader";
format_mp3_Reader.prototype = {
	skipID3v2: function() {
		this.id3v2_version = this.i.readUInt16();
		this.id3v2_flags = this.i.readByte();
		var size = this.i.readByte() & 127;
		size = size << 7 | this.i.readByte() & 127;
		size = size << 7 | this.i.readByte() & 127;
		size = size << 7 | this.i.readByte() & 127;
		this.id3v2_data = this.i.read(size);
	}
	,seekFrame: function() {
		var found = false;
		try {
			var b;
			while(true) {
				b = this.i.readByte();
				if(!this.any_read) {
					this.any_read = true;
					if(b == 73) {
						b = this.i.readByte();
						if(b == 68) {
							b = this.i.readByte();
							if(b == 51) {
								this.skipID3v2();
							}
						}
					}
				}
				if(b == 255) {
					this.bits.nbits = 0;
					b = this.bits.readBits(3);
					if(b == 7) {
						return format_mp3_FrameType.FT_MP3;
					}
				}
			}
		} catch( _g ) {
			if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
				return format_mp3_FrameType.FT_NONE;
			} else {
				throw _g;
			}
		}
	}
	,readFrames: function() {
		var frames = [];
		var ft;
		while(true) {
			ft = this.seekFrame();
			if(!(ft != format_mp3_FrameType.FT_NONE)) {
				break;
			}
			switch(ft._hx_index) {
			case 0:
				var f = this.readFrame();
				if(f != null) {
					frames.push(f);
				}
				break;
			case 1:
				break;
			}
		}
		return frames;
	}
	,readFrameHeader: function() {
		var version = this.bits.readBits(2);
		var layer = this.bits.readBits(2);
		var hasCrc = !this.bits.readBit();
		if(version == format_mp3_MPEG.Reserved || layer == format_mp3_CLayer.LReserved) {
			return null;
		}
		var bitrateIdx = this.bits.readBits(4);
		var bitrate = format_mp3_Tools.getBitrate(version,layer,bitrateIdx);
		var samplingRateIdx = this.bits.readBits(2);
		var samplingRate = format_mp3_Tools.getSamplingRate(version,samplingRateIdx);
		var isPadded = this.bits.readBit();
		var privateBit = this.bits.readBit();
		if(bitrate == format_mp3_Bitrate.BR_Bad || bitrate == format_mp3_Bitrate.BR_Free || samplingRate == format_mp3_SamplingRate.SR_Bad) {
			return null;
		}
		var channelMode = this.bits.readBits(2);
		var isIntensityStereo = this.bits.readBit();
		var isMSStereo = this.bits.readBit();
		var isCopyrighted = this.bits.readBit();
		var isOriginal = this.bits.readBit();
		var emphasis = this.bits.readBits(2);
		var crc16 = 0;
		if(hasCrc) {
			crc16 = this.i.readUInt16();
		}
		return { version : format_mp3_MPEG.num2Enum(version), layer : format_mp3_CLayer.num2Enum(layer), hasCrc : hasCrc, crc16 : crc16, bitrate : bitrate, samplingRate : samplingRate, isPadded : isPadded, privateBit : privateBit, channelMode : format_mp3_CChannelMode.num2Enum(channelMode), isIntensityStereo : isIntensityStereo, isMSStereo : isMSStereo, isCopyrighted : isCopyrighted, isOriginal : isOriginal, emphasis : format_mp3_CEmphasis.num2Enum(emphasis)};
	}
	,readFrame: function() {
		var header = this.readFrameHeader();
		if(header == null || format_mp3_Tools.isInvalidFrameHeader(header)) {
			return null;
		}
		try {
			var data = this.i.read(format_mp3_Tools.getSampleDataSizeHdr(header));
			this.samples += format_mp3_Tools.getSampleCountHdr(header);
			this.sampleSize += data.length;
			return { header : header, data : data};
		} catch( _g ) {
			if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
				return null;
			} else {
				throw _g;
			}
		}
	}
	,read: function() {
		var fs = this.readFrames();
		return { frames : fs, sampleCount : this.samples, sampleSize : this.sampleSize, id3v2 : this.id3v2_data == null ? null : { versionBytes : this.id3v2_version, flagByte : this.id3v2_flags, data : this.id3v2_data}};
	}
	,__class__: format_mp3_Reader
};
var format_mp3_Tools = function() { };
$hxClasses["format.mp3.Tools"] = format_mp3_Tools;
format_mp3_Tools.__name__ = "format.mp3.Tools";
format_mp3_Tools.getBitrate = function(mpegVersion,layerIdx,bitrateIdx) {
	if(mpegVersion == format_mp3_MPEG.Reserved || layerIdx == format_mp3_CLayer.LReserved) {
		return format_mp3_Bitrate.BR_Bad;
	}
	return (mpegVersion == 3 ? format_mp3_MPEG.V1_Bitrates : format_mp3_MPEG.V2_Bitrates)[layerIdx][bitrateIdx];
};
format_mp3_Tools.getSamplingRate = function(mpegVersion,samplingRateIdx) {
	return format_mp3_MPEG.SamplingRates[mpegVersion][samplingRateIdx];
};
format_mp3_Tools.isInvalidFrameHeader = function(hdr) {
	if(!(hdr.version == format_mp3_MPEGVersion.MPEG_Reserved || hdr.layer == format_mp3_Layer.LayerReserved || hdr.bitrate == format_mp3_Bitrate.BR_Bad || hdr.bitrate == format_mp3_Bitrate.BR_Free)) {
		return hdr.samplingRate == format_mp3_SamplingRate.SR_Bad;
	} else {
		return true;
	}
};
format_mp3_Tools.getSampleDataSize = function(mpegVersion,bitrate,samplingRate,isPadded,hasCrc) {
	return ((mpegVersion == 3 ? 144 : 72) * bitrate * 1000 / samplingRate | 0) + (isPadded ? 1 : 0) - (hasCrc ? 2 : 0) - 4;
};
format_mp3_Tools.getSampleDataSizeHdr = function(hdr) {
	return format_mp3_Tools.getSampleDataSize(format_mp3_MPEG.enum2Num(hdr.version),format_mp3_MPEG.bitrateEnum2Num(hdr.bitrate),format_mp3_MPEG.srEnum2Num(hdr.samplingRate),hdr.isPadded,hdr.hasCrc);
};
format_mp3_Tools.getSampleCount = function(mpegVersion) {
	if(mpegVersion == 3) {
		return 1152;
	} else {
		return 576;
	}
};
format_mp3_Tools.getSampleCountHdr = function(hdr) {
	return format_mp3_Tools.getSampleCount(format_mp3_MPEG.enum2Num(hdr.version));
};
format_mp3_Tools.getFrameInfo = function(fr) {
	return Std.string(fr.header.version) + ", " + Std.string(fr.header.layer) + ", " + Std.string(fr.header.channelMode) + ", " + Std.string(fr.header.samplingRate) + " Hz, " + Std.string(fr.header.bitrate) + " kbps " + "Emphasis: " + Std.string(fr.header.emphasis) + ", " + (fr.header.hasCrc ? "(CRC) " : "") + (fr.header.isPadded ? "(Padded) " : "") + (fr.header.isIntensityStereo ? "(Intensity Stereo) " : "") + (fr.header.isMSStereo ? "(MS Stereo) " : "") + (fr.header.isCopyrighted ? "(Copyrighted) " : "") + (fr.header.isOriginal ? "(Original) " : "");
};
var format_png_Color = $hxEnums["format.png.Color"] = { __ename__:true,__constructs__:null
	,ColGrey: ($_=function(alpha) { return {_hx_index:0,alpha:alpha,__enum__:"format.png.Color",toString:$estr}; },$_._hx_name="ColGrey",$_.__params__ = ["alpha"],$_)
	,ColTrue: ($_=function(alpha) { return {_hx_index:1,alpha:alpha,__enum__:"format.png.Color",toString:$estr}; },$_._hx_name="ColTrue",$_.__params__ = ["alpha"],$_)
	,ColIndexed: {_hx_name:"ColIndexed",_hx_index:2,__enum__:"format.png.Color",toString:$estr}
};
format_png_Color.__constructs__ = [format_png_Color.ColGrey,format_png_Color.ColTrue,format_png_Color.ColIndexed];
format_png_Color.__empty_constructs__ = [format_png_Color.ColIndexed];
var format_png_Chunk = $hxEnums["format.png.Chunk"] = { __ename__:true,__constructs__:null
	,CEnd: {_hx_name:"CEnd",_hx_index:0,__enum__:"format.png.Chunk",toString:$estr}
	,CHeader: ($_=function(h) { return {_hx_index:1,h:h,__enum__:"format.png.Chunk",toString:$estr}; },$_._hx_name="CHeader",$_.__params__ = ["h"],$_)
	,CData: ($_=function(b) { return {_hx_index:2,b:b,__enum__:"format.png.Chunk",toString:$estr}; },$_._hx_name="CData",$_.__params__ = ["b"],$_)
	,CPalette: ($_=function(b) { return {_hx_index:3,b:b,__enum__:"format.png.Chunk",toString:$estr}; },$_._hx_name="CPalette",$_.__params__ = ["b"],$_)
	,CUnknown: ($_=function(id,data) { return {_hx_index:4,id:id,data:data,__enum__:"format.png.Chunk",toString:$estr}; },$_._hx_name="CUnknown",$_.__params__ = ["id","data"],$_)
};
format_png_Chunk.__constructs__ = [format_png_Chunk.CEnd,format_png_Chunk.CHeader,format_png_Chunk.CData,format_png_Chunk.CPalette,format_png_Chunk.CUnknown];
format_png_Chunk.__empty_constructs__ = [format_png_Chunk.CEnd];
var format_png_Reader = function(i) {
	this.i = i;
	i.set_bigEndian(true);
	this.checkCRC = true;
};
$hxClasses["format.png.Reader"] = format_png_Reader;
format_png_Reader.__name__ = "format.png.Reader";
format_png_Reader.prototype = {
	read: function() {
		var b = 137;
		if(this.i.readByte() != b) {
			throw haxe_Exception.thrown("Invalid header");
		}
		var b = 80;
		if(this.i.readByte() != b) {
			throw haxe_Exception.thrown("Invalid header");
		}
		var b = 78;
		if(this.i.readByte() != b) {
			throw haxe_Exception.thrown("Invalid header");
		}
		var b = 71;
		if(this.i.readByte() != b) {
			throw haxe_Exception.thrown("Invalid header");
		}
		var b = 13;
		if(this.i.readByte() != b) {
			throw haxe_Exception.thrown("Invalid header");
		}
		var b = 10;
		if(this.i.readByte() != b) {
			throw haxe_Exception.thrown("Invalid header");
		}
		var b = 26;
		if(this.i.readByte() != b) {
			throw haxe_Exception.thrown("Invalid header");
		}
		var b = 10;
		if(this.i.readByte() != b) {
			throw haxe_Exception.thrown("Invalid header");
		}
		var l = new haxe_ds_List();
		while(true) {
			var c = this.readChunk();
			l.add(c);
			if(c == format_png_Chunk.CEnd) {
				break;
			}
		}
		return l;
	}
	,readHeader: function(i) {
		i.set_bigEndian(true);
		var width = i.readInt32();
		var height = i.readInt32();
		var colbits = i.readByte();
		var color = i.readByte();
		var color1;
		switch(color) {
		case 0:
			color1 = format_png_Color.ColGrey(false);
			break;
		case 2:
			color1 = format_png_Color.ColTrue(false);
			break;
		case 3:
			color1 = format_png_Color.ColIndexed;
			break;
		case 4:
			color1 = format_png_Color.ColGrey(true);
			break;
		case 6:
			color1 = format_png_Color.ColTrue(true);
			break;
		default:
			throw haxe_Exception.thrown("Unknown color model " + color + ":" + colbits);
		}
		var compress = i.readByte();
		var filter = i.readByte();
		if(compress != 0 || filter != 0) {
			throw haxe_Exception.thrown("Invalid header");
		}
		var interlace = i.readByte();
		if(interlace != 0 && interlace != 1) {
			throw haxe_Exception.thrown("Invalid header");
		}
		return { width : width, height : height, colbits : colbits, color : color1, interlaced : interlace == 1};
	}
	,readChunk: function() {
		var dataLen = this.i.readInt32();
		var id = this.i.readString(4);
		var data = this.i.read(dataLen);
		var crc = this.i.readInt32();
		if(this.checkCRC) {
			var c_crc = -1;
			var tmp = (c_crc ^ HxOverrides.cca(id,0)) & 255;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			c_crc = c_crc >>> 8 ^ tmp;
			var tmp = (c_crc ^ HxOverrides.cca(id,1)) & 255;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			c_crc = c_crc >>> 8 ^ tmp;
			var tmp = (c_crc ^ HxOverrides.cca(id,2)) & 255;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			c_crc = c_crc >>> 8 ^ tmp;
			var tmp = (c_crc ^ HxOverrides.cca(id,3)) & 255;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			c_crc = c_crc >>> 8 ^ tmp;
			var b = data.b.bufferValue;
			var _g = 0;
			var _g1 = data.length;
			while(_g < _g1) {
				var i = _g++;
				var tmp = (c_crc ^ b.bytes[i]) & 255;
				tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
				tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
				tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
				tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
				tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
				tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
				tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
				tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
				c_crc = c_crc >>> 8 ^ tmp;
			}
			if((c_crc ^ -1) != crc) {
				throw haxe_Exception.thrown("CRC check failure");
			}
		}
		switch(id) {
		case "IDAT":
			return format_png_Chunk.CData(data);
		case "IEND":
			return format_png_Chunk.CEnd;
		case "IHDR":
			return format_png_Chunk.CHeader(this.readHeader(new haxe_io_BytesInput(data)));
		case "PLTE":
			return format_png_Chunk.CPalette(data);
		default:
			return format_png_Chunk.CUnknown(id,data);
		}
	}
	,__class__: format_png_Reader
};
var format_png_Tools = function() { };
$hxClasses["format.png.Tools"] = format_png_Tools;
format_png_Tools.__name__ = "format.png.Tools";
format_png_Tools.getHeader = function(d) {
	var _g_head = d.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var c = val;
		if(c._hx_index == 1) {
			var h = c.h;
			return h;
		}
	}
	throw haxe_Exception.thrown("Header not found");
};
format_png_Tools.getPalette = function(d) {
	var _g_head = d.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var c = val;
		if(c._hx_index == 3) {
			var b = c.b;
			return b;
		}
	}
	return null;
};
format_png_Tools.filter = function(data,x,y,stride,prev,p,numChannels) {
	if(numChannels == null) {
		numChannels = 4;
	}
	var b = y == 0 ? 0 : data.b[p - stride];
	var c = x == 0 || y == 0 ? 0 : data.b[p - stride - numChannels];
	var k = prev + b - c;
	var pa = k - prev;
	if(pa < 0) {
		pa = -pa;
	}
	var pb = k - b;
	if(pb < 0) {
		pb = -pb;
	}
	var pc = k - c;
	if(pc < 0) {
		pc = -pc;
	}
	if(pa <= pb && pa <= pc) {
		return prev;
	} else if(pb <= pc) {
		return b;
	} else {
		return c;
	}
};
format_png_Tools.reverseBytes = function(b) {
	var p = 0;
	var _g = 0;
	var _g1 = b.length >> 2;
	while(_g < _g1) {
		var i = _g++;
		var b1 = b.b[p];
		var g = b.b[p + 1];
		var r = b.b[p + 2];
		var a = b.b[p + 3];
		b.b[p++] = a;
		b.b[p++] = r;
		b.b[p++] = g;
		b.b[p++] = b1;
	}
};
format_png_Tools.extractGrey = function(d) {
	var h = format_png_Tools.getHeader(d);
	var grey = new haxe_io_Bytes(new ArrayBuffer(h.width * h.height));
	var data = null;
	var fullData = null;
	var _g_head = d.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var c = val;
		if(c._hx_index == 2) {
			var b = c.b;
			if(fullData != null) {
				fullData.add(b);
			} else if(data == null) {
				data = b;
			} else {
				fullData = new haxe_io_BytesBuffer();
				fullData.add(data);
				fullData.add(b);
				data = null;
			}
		}
	}
	if(fullData != null) {
		data = fullData.getBytes();
	}
	if(data == null) {
		throw haxe_Exception.thrown("Data not found");
	}
	data = format_tools_Inflate.run(data);
	var r = 0;
	var w = 0;
	var _g = h.color;
	if(_g._hx_index == 0) {
		var alpha = _g.alpha;
		if(h.colbits != 8) {
			throw haxe_Exception.thrown("Unsupported color mode");
		}
		var width = h.width;
		var stride = (alpha ? 2 : 1) * width + 1;
		if(data.length < h.height * stride) {
			throw haxe_Exception.thrown("Not enough data");
		}
		var rinc = alpha ? 2 : 1;
		var _g = 0;
		var _g1 = h.height;
		while(_g < _g1) {
			var y = _g++;
			var f = data.b[r++];
			switch(f) {
			case 0:
				var _g2 = 0;
				var _g3 = width;
				while(_g2 < _g3) {
					var x = _g2++;
					var v = data.b[r];
					r += rinc;
					grey.b[w++] = v;
				}
				break;
			case 1:
				var cv = 0;
				var _g4 = 0;
				var _g5 = width;
				while(_g4 < _g5) {
					var x1 = _g4++;
					cv += data.b[r];
					r += rinc;
					grey.b[w++] = cv;
				}
				break;
			case 2:
				var stride = y == 0 ? 0 : width;
				var _g6 = 0;
				var _g7 = width;
				while(_g6 < _g7) {
					var x2 = _g6++;
					var v1 = data.b[r] + grey.b[w - stride];
					r += rinc;
					grey.b[w++] = v1;
				}
				break;
			case 3:
				var cv1 = 0;
				var stride1 = y == 0 ? 0 : width;
				var _g8 = 0;
				var _g9 = width;
				while(_g8 < _g9) {
					var x3 = _g8++;
					cv1 = data.b[r] + (cv1 + grey.b[w - stride1] >> 1) & 255;
					r += rinc;
					grey.b[w++] = cv1;
				}
				break;
			case 4:
				var stride2 = width;
				var cv2 = 0;
				var _g10 = 0;
				var _g11 = width;
				while(_g10 < _g11) {
					var x4 = _g10++;
					var numChannels = 1;
					if(numChannels == null) {
						numChannels = 4;
					}
					var b = y == 0 ? 0 : grey.b[w - stride2];
					var c = x4 == 0 || y == 0 ? 0 : grey.b[w - stride2 - numChannels];
					var k = cv2 + b - c;
					var pa = k - cv2;
					if(pa < 0) {
						pa = -pa;
					}
					var pb = k - b;
					if(pb < 0) {
						pb = -pb;
					}
					var pc = k - c;
					if(pc < 0) {
						pc = -pc;
					}
					cv2 = (pa <= pb && pa <= pc ? cv2 : pb <= pc ? b : c) + data.b[r] & 255;
					r += rinc;
					grey.b[w++] = cv2;
				}
				break;
			default:
				throw haxe_Exception.thrown("Invalid filter " + f);
			}
		}
	} else {
		throw haxe_Exception.thrown("Unsupported color mode");
	}
	return grey;
};
format_png_Tools.extract32 = function(d,bytes,flipY) {
	var h = format_png_Tools.getHeader(d);
	var bgra = bytes == null ? new haxe_io_Bytes(new ArrayBuffer(h.width * h.height * 4)) : bytes;
	var data = null;
	var fullData = null;
	var _g_head = d.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var c = val;
		if(c._hx_index == 2) {
			var b = c.b;
			if(fullData != null) {
				fullData.add(b);
			} else if(data == null) {
				data = b;
			} else {
				fullData = new haxe_io_BytesBuffer();
				fullData.add(data);
				fullData.add(b);
				data = null;
			}
		}
	}
	if(fullData != null) {
		data = fullData.getBytes();
	}
	if(data == null) {
		throw haxe_Exception.thrown("Data not found");
	}
	data = format_tools_Inflate.run(data);
	var r = 0;
	var w = 0;
	var lineDelta = 0;
	if(flipY) {
		lineDelta = -h.width * 8;
		w = (h.height - 1) * (h.width * 4);
	}
	var flipY1 = flipY ? -1 : 1;
	var _g = h.color;
	switch(_g._hx_index) {
	case 0:
		var alpha = _g.alpha;
		if(h.colbits != 8) {
			throw haxe_Exception.thrown("Unsupported color mode");
		}
		var width = h.width;
		var stride = (alpha ? 2 : 1) * width + 1;
		if(data.length < h.height * stride) {
			throw haxe_Exception.thrown("Not enough data");
		}
		var alphvaIdx = -1;
		if(!alpha) {
			var _g_head = d.h;
			while(_g_head != null) {
				var val = _g_head.item;
				_g_head = _g_head.next;
				var t = val;
				if(t._hx_index == 4) {
					if(t.id == "tRNS") {
						var data1 = t.data;
						if(data1.length >= 2) {
							alphvaIdx = data1.b[1];
						}
						break;
					}
				}
			}
		}
		var _g1 = 0;
		var _g2 = h.height;
		while(_g1 < _g2) {
			var y = _g1++;
			var f = data.b[r++];
			switch(f) {
			case 0:
				if(alpha) {
					var _g3 = 0;
					var _g4 = width;
					while(_g3 < _g4) {
						var x = _g3++;
						var v = data.b[r++];
						bgra.b[w++] = v;
						bgra.b[w++] = v;
						bgra.b[w++] = v;
						bgra.b[w++] = data.b[r++];
					}
				} else {
					var _g5 = 0;
					var _g6 = width;
					while(_g5 < _g6) {
						var x1 = _g5++;
						var v1 = data.b[r++];
						bgra.b[w++] = v1;
						bgra.b[w++] = v1;
						bgra.b[w++] = v1;
						bgra.b[w++] = v1 == alphvaIdx ? 0 : 255;
					}
				}
				break;
			case 1:
				var cv = 0;
				var ca = 0;
				if(alpha) {
					var _g7 = 0;
					var _g8 = width;
					while(_g7 < _g8) {
						var x2 = _g7++;
						cv += data.b[r++];
						bgra.b[w++] = cv;
						bgra.b[w++] = cv;
						bgra.b[w++] = cv;
						ca += data.b[r++];
						bgra.b[w++] = ca;
					}
				} else {
					var _g9 = 0;
					var _g10 = width;
					while(_g9 < _g10) {
						var x3 = _g9++;
						cv += data.b[r++];
						bgra.b[w++] = cv;
						bgra.b[w++] = cv;
						bgra.b[w++] = cv;
						bgra.b[w++] = cv == alphvaIdx ? 0 : 255;
					}
				}
				break;
			case 2:
				var stride = y == 0 ? 0 : width * 4 * flipY1;
				if(alpha) {
					var _g11 = 0;
					var _g12 = width;
					while(_g11 < _g12) {
						var x4 = _g11++;
						var v2 = data.b[r++] + bgra.b[w - stride];
						bgra.b[w++] = v2;
						bgra.b[w++] = v2;
						bgra.b[w++] = v2;
						var va = data.b[r++] + bgra.b[w - stride];
						bgra.b[w++] = va;
					}
				} else {
					var _g13 = 0;
					var _g14 = width;
					while(_g13 < _g14) {
						var x5 = _g13++;
						var v3 = data.b[r++] + bgra.b[w - stride];
						bgra.b[w++] = v3;
						bgra.b[w++] = v3;
						bgra.b[w++] = v3;
						bgra.b[w++] = v3 == alphvaIdx ? 0 : 255;
					}
				}
				break;
			case 3:
				var cv1 = 0;
				var ca1 = 0;
				var stride1 = y == 0 ? 0 : width * 4 * flipY1;
				if(alpha) {
					var _g15 = 0;
					var _g16 = width;
					while(_g15 < _g16) {
						var x6 = _g15++;
						cv1 = data.b[r++] + (cv1 + bgra.b[w - stride1] >> 1) & 255;
						bgra.b[w++] = cv1;
						bgra.b[w++] = cv1;
						bgra.b[w++] = cv1;
						ca1 = data.b[r++] + (ca1 + bgra.b[w - stride1] >> 1) & 255;
						bgra.b[w++] = ca1;
					}
				} else {
					var _g17 = 0;
					var _g18 = width;
					while(_g17 < _g18) {
						var x7 = _g17++;
						cv1 = data.b[r++] + (cv1 + bgra.b[w - stride1] >> 1) & 255;
						bgra.b[w++] = cv1;
						bgra.b[w++] = cv1;
						bgra.b[w++] = cv1;
						bgra.b[w++] = cv1 == alphvaIdx ? 0 : 255;
					}
				}
				break;
			case 4:
				var stride2 = width * 4 * flipY1;
				var cv2 = 0;
				var ca2 = 0;
				if(alpha) {
					var _g19 = 0;
					var _g20 = width;
					while(_g19 < _g20) {
						var x8 = _g19++;
						var b = y == 0 ? 0 : bgra.b[w - stride2];
						var c = x8 == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
						var k = cv2 + b - c;
						var pa = k - cv2;
						if(pa < 0) {
							pa = -pa;
						}
						var pb = k - b;
						if(pb < 0) {
							pb = -pb;
						}
						var pc = k - c;
						if(pc < 0) {
							pc = -pc;
						}
						var pos = r++;
						cv2 = (pa <= pb && pa <= pc ? cv2 : pb <= pc ? b : c) + data.b[pos] & 255;
						bgra.b[w++] = cv2;
						bgra.b[w++] = cv2;
						bgra.b[w++] = cv2;
						var b1 = y == 0 ? 0 : bgra.b[w - stride2];
						var c1 = x8 == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
						var k1 = ca2 + b1 - c1;
						var pa1 = k1 - ca2;
						if(pa1 < 0) {
							pa1 = -pa1;
						}
						var pb1 = k1 - b1;
						if(pb1 < 0) {
							pb1 = -pb1;
						}
						var pc1 = k1 - c1;
						if(pc1 < 0) {
							pc1 = -pc1;
						}
						var pos1 = r++;
						ca2 = (pa1 <= pb1 && pa1 <= pc1 ? ca2 : pb1 <= pc1 ? b1 : c1) + data.b[pos1] & 255;
						bgra.b[w++] = ca2;
					}
				} else {
					var _g21 = 0;
					var _g22 = width;
					while(_g21 < _g22) {
						var x9 = _g21++;
						var b2 = y == 0 ? 0 : bgra.b[w - stride2];
						var c2 = x9 == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
						var k2 = cv2 + b2 - c2;
						var pa2 = k2 - cv2;
						if(pa2 < 0) {
							pa2 = -pa2;
						}
						var pb2 = k2 - b2;
						if(pb2 < 0) {
							pb2 = -pb2;
						}
						var pc2 = k2 - c2;
						if(pc2 < 0) {
							pc2 = -pc2;
						}
						var pos2 = r++;
						cv2 = (pa2 <= pb2 && pa2 <= pc2 ? cv2 : pb2 <= pc2 ? b2 : c2) + data.b[pos2] & 255;
						bgra.b[w++] = cv2;
						bgra.b[w++] = cv2;
						bgra.b[w++] = cv2;
						bgra.b[w++] = cv2 == alphvaIdx ? 0 : 255;
					}
				}
				break;
			default:
				throw haxe_Exception.thrown("Invalid filter " + f);
			}
			w += lineDelta;
		}
		break;
	case 1:
		var alpha = _g.alpha;
		if(h.colbits != 8) {
			throw haxe_Exception.thrown("Unsupported color mode");
		}
		var width = h.width;
		var stride = (alpha ? 4 : 3) * width + 1;
		if(data.length < h.height * stride) {
			throw haxe_Exception.thrown("Not enough data");
		}
		var alphaRed = -1;
		var alphaGreen = -1;
		var alphaBlue = -1;
		if(!alpha) {
			var _g_head = d.h;
			while(_g_head != null) {
				var val = _g_head.item;
				_g_head = _g_head.next;
				var t = val;
				if(t._hx_index == 4) {
					if(t.id == "tRNS") {
						var data1 = t.data;
						if(data1.length >= 6) {
							alphaRed = data1.b[1];
							alphaGreen = data1.b[3];
							alphaBlue = data1.b[5];
						}
						break;
					}
				}
			}
		}
		var cr = 0;
		var cg = 0;
		var cb = 0;
		var ca = 0;
		var _g = 0;
		var _g1 = h.height;
		while(_g < _g1) {
			var y = _g++;
			var f = data.b[r++];
			switch(f) {
			case 0:
				if(alpha) {
					var _g2 = 0;
					var _g3 = width;
					while(_g2 < _g3) {
						var x = _g2++;
						bgra.b[w++] = data.b[r + 2];
						bgra.b[w++] = data.b[r + 1];
						bgra.b[w++] = data.b[r];
						bgra.b[w++] = data.b[r + 3];
						r += 4;
					}
				} else {
					var _g4 = 0;
					var _g5 = width;
					while(_g4 < _g5) {
						var x1 = _g4++;
						cb = data.b[r + 2];
						bgra.b[w++] = cb;
						cg = data.b[r + 1];
						bgra.b[w++] = cg;
						cr = data.b[r];
						bgra.b[w++] = cr;
						bgra.b[w++] = cr == alphaRed && cg == alphaGreen && cb == alphaBlue ? 0 : 255;
						r += 3;
					}
				}
				break;
			case 1:
				ca = 0;
				cb = ca;
				cg = cb;
				cr = cg;
				if(alpha) {
					var _g6 = 0;
					var _g7 = width;
					while(_g6 < _g7) {
						var x2 = _g6++;
						cb += data.b[r + 2];
						bgra.b[w++] = cb;
						cg += data.b[r + 1];
						bgra.b[w++] = cg;
						cr += data.b[r];
						bgra.b[w++] = cr;
						ca += data.b[r + 3];
						bgra.b[w++] = ca;
						r += 4;
					}
				} else {
					var _g8 = 0;
					var _g9 = width;
					while(_g8 < _g9) {
						var x3 = _g8++;
						cb += data.b[r + 2];
						bgra.b[w++] = cb;
						cg += data.b[r + 1];
						bgra.b[w++] = cg;
						cr += data.b[r];
						bgra.b[w++] = cr;
						bgra.b[w++] = cr == alphaRed && cg == alphaGreen && cb == alphaBlue ? 0 : 255;
						r += 3;
					}
				}
				break;
			case 2:
				var stride = y == 0 ? 0 : width * 4 * flipY1;
				if(alpha) {
					var _g10 = 0;
					var _g11 = width;
					while(_g10 < _g11) {
						var x4 = _g10++;
						bgra.b[w] = data.b[r + 2] + bgra.b[w - stride];
						++w;
						bgra.b[w] = data.b[r + 1] + bgra.b[w - stride];
						++w;
						bgra.b[w] = data.b[r] + bgra.b[w - stride];
						++w;
						bgra.b[w] = data.b[r + 3] + bgra.b[w - stride];
						++w;
						r += 4;
					}
				} else {
					var _g12 = 0;
					var _g13 = width;
					while(_g12 < _g13) {
						var x5 = _g12++;
						cb = data.b[r + 2] + bgra.b[w - stride];
						bgra.b[w] = cb;
						++w;
						cg = data.b[r + 1] + bgra.b[w - stride];
						bgra.b[w] = cg;
						++w;
						cr = data.b[r] + bgra.b[w - stride];
						bgra.b[w] = cr;
						++w;
						bgra.b[w++] = cr == alphaRed && cg == alphaGreen && cb == alphaBlue ? 0 : 255;
						r += 3;
					}
				}
				break;
			case 3:
				ca = 0;
				cb = ca;
				cg = cb;
				cr = cg;
				var stride1 = y == 0 ? 0 : width * 4 * flipY1;
				if(alpha) {
					var _g14 = 0;
					var _g15 = width;
					while(_g14 < _g15) {
						var x6 = _g14++;
						cb = data.b[r + 2] + (cb + bgra.b[w - stride1] >> 1) & 255;
						bgra.b[w++] = cb;
						cg = data.b[r + 1] + (cg + bgra.b[w - stride1] >> 1) & 255;
						bgra.b[w++] = cg;
						cr = data.b[r] + (cr + bgra.b[w - stride1] >> 1) & 255;
						bgra.b[w++] = cr;
						ca = data.b[r + 3] + (ca + bgra.b[w - stride1] >> 1) & 255;
						bgra.b[w++] = ca;
						r += 4;
					}
				} else {
					var _g16 = 0;
					var _g17 = width;
					while(_g16 < _g17) {
						var x7 = _g16++;
						cb = data.b[r + 2] + (cb + bgra.b[w - stride1] >> 1) & 255;
						bgra.b[w++] = cb;
						cg = data.b[r + 1] + (cg + bgra.b[w - stride1] >> 1) & 255;
						bgra.b[w++] = cg;
						cr = data.b[r] + (cr + bgra.b[w - stride1] >> 1) & 255;
						bgra.b[w++] = cr;
						bgra.b[w++] = cr == alphaRed && cg == alphaGreen && cb == alphaBlue ? 0 : 255;
						r += 3;
					}
				}
				break;
			case 4:
				var stride2 = width * 4 * flipY1;
				ca = 0;
				cb = ca;
				cg = cb;
				cr = cg;
				if(alpha) {
					var _g18 = 0;
					var _g19 = width;
					while(_g18 < _g19) {
						var x8 = _g18++;
						var b = y == 0 ? 0 : bgra.b[w - stride2];
						var c = x8 == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
						var k = cb + b - c;
						var pa = k - cb;
						if(pa < 0) {
							pa = -pa;
						}
						var pb = k - b;
						if(pb < 0) {
							pb = -pb;
						}
						var pc = k - c;
						if(pc < 0) {
							pc = -pc;
						}
						cb = (pa <= pb && pa <= pc ? cb : pb <= pc ? b : c) + data.b[r + 2] & 255;
						bgra.b[w++] = cb;
						var b1 = y == 0 ? 0 : bgra.b[w - stride2];
						var c1 = x8 == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
						var k1 = cg + b1 - c1;
						var pa1 = k1 - cg;
						if(pa1 < 0) {
							pa1 = -pa1;
						}
						var pb1 = k1 - b1;
						if(pb1 < 0) {
							pb1 = -pb1;
						}
						var pc1 = k1 - c1;
						if(pc1 < 0) {
							pc1 = -pc1;
						}
						cg = (pa1 <= pb1 && pa1 <= pc1 ? cg : pb1 <= pc1 ? b1 : c1) + data.b[r + 1] & 255;
						bgra.b[w++] = cg;
						var b2 = y == 0 ? 0 : bgra.b[w - stride2];
						var c2 = x8 == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
						var k2 = cr + b2 - c2;
						var pa2 = k2 - cr;
						if(pa2 < 0) {
							pa2 = -pa2;
						}
						var pb2 = k2 - b2;
						if(pb2 < 0) {
							pb2 = -pb2;
						}
						var pc2 = k2 - c2;
						if(pc2 < 0) {
							pc2 = -pc2;
						}
						cr = (pa2 <= pb2 && pa2 <= pc2 ? cr : pb2 <= pc2 ? b2 : c2) + data.b[r] & 255;
						bgra.b[w++] = cr;
						var b3 = y == 0 ? 0 : bgra.b[w - stride2];
						var c3 = x8 == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
						var k3 = ca + b3 - c3;
						var pa3 = k3 - ca;
						if(pa3 < 0) {
							pa3 = -pa3;
						}
						var pb3 = k3 - b3;
						if(pb3 < 0) {
							pb3 = -pb3;
						}
						var pc3 = k3 - c3;
						if(pc3 < 0) {
							pc3 = -pc3;
						}
						ca = (pa3 <= pb3 && pa3 <= pc3 ? ca : pb3 <= pc3 ? b3 : c3) + data.b[r + 3] & 255;
						bgra.b[w++] = ca;
						r += 4;
					}
				} else {
					var _g20 = 0;
					var _g21 = width;
					while(_g20 < _g21) {
						var x9 = _g20++;
						var b4 = y == 0 ? 0 : bgra.b[w - stride2];
						var c4 = x9 == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
						var k4 = cb + b4 - c4;
						var pa4 = k4 - cb;
						if(pa4 < 0) {
							pa4 = -pa4;
						}
						var pb4 = k4 - b4;
						if(pb4 < 0) {
							pb4 = -pb4;
						}
						var pc4 = k4 - c4;
						if(pc4 < 0) {
							pc4 = -pc4;
						}
						cb = (pa4 <= pb4 && pa4 <= pc4 ? cb : pb4 <= pc4 ? b4 : c4) + data.b[r + 2] & 255;
						bgra.b[w++] = cb;
						var b5 = y == 0 ? 0 : bgra.b[w - stride2];
						var c5 = x9 == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
						var k5 = cg + b5 - c5;
						var pa5 = k5 - cg;
						if(pa5 < 0) {
							pa5 = -pa5;
						}
						var pb5 = k5 - b5;
						if(pb5 < 0) {
							pb5 = -pb5;
						}
						var pc5 = k5 - c5;
						if(pc5 < 0) {
							pc5 = -pc5;
						}
						cg = (pa5 <= pb5 && pa5 <= pc5 ? cg : pb5 <= pc5 ? b5 : c5) + data.b[r + 1] & 255;
						bgra.b[w++] = cg;
						var b6 = y == 0 ? 0 : bgra.b[w - stride2];
						var c6 = x9 == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
						var k6 = cr + b6 - c6;
						var pa6 = k6 - cr;
						if(pa6 < 0) {
							pa6 = -pa6;
						}
						var pb6 = k6 - b6;
						if(pb6 < 0) {
							pb6 = -pb6;
						}
						var pc6 = k6 - c6;
						if(pc6 < 0) {
							pc6 = -pc6;
						}
						cr = (pa6 <= pb6 && pa6 <= pc6 ? cr : pb6 <= pc6 ? b6 : c6) + data.b[r] & 255;
						bgra.b[w++] = cr;
						bgra.b[w++] = cr == alphaRed && cg == alphaGreen && cb == alphaBlue ? 0 : 255;
						r += 3;
					}
				}
				break;
			default:
				throw haxe_Exception.thrown("Invalid filter " + f);
			}
			w += lineDelta;
		}
		break;
	case 2:
		var pal = format_png_Tools.getPalette(d);
		if(pal == null) {
			throw haxe_Exception.thrown("PNG Palette is missing");
		}
		var alpha = null;
		var _g_head = d.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var t = val;
			if(t._hx_index == 4) {
				if(t.id == "tRNS") {
					var data1 = t.data;
					alpha = data1;
					break;
				}
			}
		}
		if(alpha != null && alpha.length < 1 << h.colbits) {
			var alpha2 = new haxe_io_Bytes(new ArrayBuffer(1 << h.colbits));
			alpha2.blit(0,alpha,0,alpha.length);
			alpha2.fill(alpha.length,alpha2.length - alpha.length,255);
			alpha = alpha2;
		}
		var width = h.width;
		var stride = Math.ceil(width * h.colbits / 8) + 1;
		if(data.length < h.height * stride) {
			throw haxe_Exception.thrown("Not enough data");
		}
		var rline = stride - 1;
		var _g = 0;
		var _g1 = h.height;
		while(_g < _g1) {
			var y = _g++;
			var f = data.b[r++];
			if(f == 0) {
				r += rline;
				continue;
			}
			switch(f) {
			case 1:
				var c = 0;
				var _g2 = 0;
				var _g3 = width;
				while(_g2 < _g3) {
					var x = _g2++;
					var v = data.b[r];
					c += v;
					data.b[r++] = c & 255;
				}
				break;
			case 2:
				var stride = y == 0 ? 0 : rline + 1;
				var _g4 = 0;
				var _g5 = width;
				while(_g4 < _g5) {
					var x1 = _g4++;
					var v1 = data.b[r];
					data.b[r] = v1 + data.b[r - stride];
					++r;
				}
				break;
			case 3:
				var c1 = 0;
				var stride1 = y == 0 ? 0 : rline + 1;
				var _g6 = 0;
				var _g7 = width;
				while(_g6 < _g7) {
					var x2 = _g6++;
					var v2 = data.b[r];
					c1 = v2 + (c1 + data.b[r - stride1] >> 1) & 255;
					data.b[r++] = c1;
				}
				break;
			case 4:
				var stride2 = rline + 1;
				var c2 = 0;
				var _g8 = 0;
				var _g9 = width;
				while(_g8 < _g9) {
					var x3 = _g8++;
					var v3 = data.b[r];
					var numChannels = 1;
					if(numChannels == null) {
						numChannels = 4;
					}
					var b = y == 0 ? 0 : data.b[r - stride2];
					var c3 = x3 == 0 || y == 0 ? 0 : data.b[r - stride2 - numChannels];
					var k = c2 + b - c3;
					var pa = k - c2;
					if(pa < 0) {
						pa = -pa;
					}
					var pb = k - b;
					if(pb < 0) {
						pb = -pb;
					}
					var pc = k - c3;
					if(pc < 0) {
						pc = -pc;
					}
					c2 = (pa <= pb && pa <= pc ? c2 : pb <= pc ? b : c3) + v3 & 255;
					data.b[r++] = c2;
				}
				break;
			default:
				throw haxe_Exception.thrown("Invalid filter " + f);
			}
		}
		var r = 0;
		if(h.colbits == 8) {
			var _g = 0;
			var _g1 = h.height;
			while(_g < _g1) {
				var y = _g++;
				++r;
				var _g2 = 0;
				var _g3 = h.width;
				while(_g2 < _g3) {
					var x = _g2++;
					var c = data.b[r++];
					bgra.b[w++] = pal.b[c * 3 + 2];
					bgra.b[w++] = pal.b[c * 3 + 1];
					bgra.b[w++] = pal.b[c * 3];
					bgra.b[w++] = alpha != null ? alpha.b[c] : 255;
				}
				w += lineDelta;
			}
		} else if(h.colbits < 8) {
			var req = h.colbits;
			var mask = (1 << req) - 1;
			var _g = 0;
			var _g1 = h.height;
			while(_g < _g1) {
				var y = _g++;
				++r;
				var bits = 0;
				var nbits = 0;
				var _g2 = 0;
				var _g3 = h.width;
				while(_g2 < _g3) {
					var x = _g2++;
					if(nbits < req) {
						bits = bits << 8 | data.b[r++];
						nbits += 8;
					}
					var c = bits >>> nbits - req & mask;
					nbits -= req;
					bgra.b[w++] = pal.b[c * 3 + 2];
					bgra.b[w++] = pal.b[c * 3 + 1];
					bgra.b[w++] = pal.b[c * 3];
					bgra.b[w++] = alpha != null ? alpha.b[c] : 255;
				}
				w += lineDelta;
			}
		} else {
			throw haxe_Exception.thrown(h.colbits + " indexed bits per pixel not supported");
		}
		break;
	}
	return bgra;
};
format_png_Tools.extract = function(d,output,expandAlpha) {
	if(expandAlpha == null) {
		expandAlpha = false;
	}
	var h = format_png_Tools.getHeader(d);
	var hasAlpha = false;
	var channels;
	var _g = h.color;
	switch(_g._hx_index) {
	case 0:
		var alpha = _g.alpha;
		hasAlpha = alpha;
		channels = alpha ? 2 : 1;
		break;
	case 1:
		var alpha = _g.alpha;
		hasAlpha = alpha;
		channels = alpha ? 4 : 3;
		break;
	case 2:
		throw haxe_Exception.thrown("assert");
	}
	if(expandAlpha && hasAlpha) {
		expandAlpha = false;
	}
	var bpp = h.colbits >> 3;
	var outChannels = expandAlpha ? channels + 1 : channels;
	if(output == null) {
		output = new haxe_io_Bytes(new ArrayBuffer(outChannels * bpp * h.width * h.height));
	}
	var data = null;
	var fullData = null;
	var _g_head = d.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var c = val;
		if(c._hx_index == 2) {
			var b = c.b;
			if(fullData != null) {
				fullData.add(b);
			} else if(data == null) {
				data = b;
			} else {
				fullData = new haxe_io_BytesBuffer();
				fullData.add(data);
				fullData.add(b);
				data = null;
			}
		}
	}
	if(fullData != null) {
		data = fullData.getBytes();
	}
	if(data == null) {
		throw haxe_Exception.thrown("Data not found");
	}
	data = format_tools_Inflate.run(data);
	var r = 0;
	var w = 0;
	var width = h.width;
	var ncomps = channels * bpp;
	var upperLine = outChannels * bpp * width;
	var leftPixel = outChannels * bpp;
	if(data.length < h.height * (ncomps * width + 1)) {
		throw haxe_Exception.thrown("Not enough data");
	}
	var _g = [];
	var _g1 = 0;
	var _g2 = ncomps;
	while(_g1 < _g2) {
		var i = _g1++;
		_g.push(0);
	}
	var tmp = _g;
	var _g = 0;
	var _g1 = h.height;
	while(_g < _g1) {
		var y = _g++;
		var f = data.b[r++];
		if(f != 0 && f != 2) {
			var _g2 = 0;
			var _g3 = ncomps;
			while(_g2 < _g3) {
				var i = _g2++;
				tmp[i] = 0;
			}
		}
		switch(f) {
		case 0:
			var _g4 = 0;
			var _g5 = width;
			while(_g4 < _g5) {
				var x = _g4++;
				var _g6 = 0;
				var _g7 = ncomps;
				while(_g6 < _g7) {
					var i1 = _g6++;
					output.b[w++] = data.b[r++];
				}
				if(expandAlpha) {
					output.b[w++] = 255;
					if(bpp == 2) {
						output.b[w++] = 255;
					}
				}
			}
			break;
		case 1:
			var _g8 = 0;
			var _g9 = width;
			while(_g8 < _g9) {
				var x1 = _g8++;
				var _g10 = 0;
				var _g11 = ncomps;
				while(_g10 < _g11) {
					var i2 = _g10++;
					tmp[i2] += data.b[r++];
					output.b[w++] = tmp[i2];
				}
				if(expandAlpha) {
					output.b[w++] = 255;
					if(bpp == 2) {
						output.b[w++] = 255;
					}
				}
			}
			break;
		case 2:
			var stride = y == 0 ? 0 : upperLine;
			var _g12 = 0;
			var _g13 = width;
			while(_g12 < _g13) {
				var x2 = _g12++;
				var _g14 = 0;
				var _g15 = ncomps;
				while(_g14 < _g15) {
					var i3 = _g14++;
					var v = data.b[r++] + output.b[w - stride];
					output.b[w++] = v;
				}
				if(expandAlpha) {
					output.b[w++] = 255;
					if(bpp == 2) {
						output.b[w++] = 255;
					}
				}
			}
			break;
		case 3:
			var stride1 = y == 0 ? 0 : upperLine;
			var _g16 = 0;
			var _g17 = width;
			while(_g16 < _g17) {
				var x3 = _g16++;
				var _g18 = 0;
				var _g19 = ncomps;
				while(_g18 < _g19) {
					var i4 = _g18++;
					tmp[i4] = data.b[r++] + (tmp[i4] + output.b[w - stride1] >> 1) & 255;
					output.b[w++] = tmp[i4];
				}
				if(expandAlpha) {
					output.b[w++] = 255;
					if(bpp == 2) {
						output.b[w++] = 255;
					}
				}
			}
			break;
		case 4:
			var _g20 = 0;
			var _g21 = width;
			while(_g20 < _g21) {
				var x4 = _g20++;
				var _g22 = 0;
				var _g23 = ncomps;
				while(_g22 < _g23) {
					var i5 = _g22++;
					var prev = tmp[i5];
					var b = y == 0 ? 0 : output.b[w - upperLine];
					var c = x4 == 0 || y == 0 ? 0 : output.b[w - upperLine - leftPixel];
					var k = prev + b - c;
					var pa = k - prev;
					if(pa < 0) {
						pa = -pa;
					}
					var pb = k - b;
					if(pb < 0) {
						pb = -pb;
					}
					var pc = k - c;
					if(pc < 0) {
						pc = -pc;
					}
					var pos = r++;
					tmp[i5] = (pa <= pb && pa <= pc ? prev : pb <= pc ? b : c) + data.b[pos] & 255;
					output.b[w++] = tmp[i5];
				}
				if(expandAlpha) {
					output.b[w++] = 255;
					if(bpp == 2) {
						output.b[w++] = 255;
					}
				}
			}
			break;
		default:
			throw haxe_Exception.thrown("Invalid filter " + f);
		}
	}
	if(h.colbits == 16) {
		var w = 0;
		var _g = 0;
		var _g1 = h.height * width * outChannels;
		while(_g < _g1) {
			var x = _g++;
			var a = output.b[w];
			var b = output.b[w + 1];
			output.b[w++] = b;
			output.b[w++] = a;
		}
	}
	return output;
};
format_png_Tools.buildGrey = function(width,height,data,level) {
	if(level == null) {
		level = 9;
	}
	var rgb = new haxe_io_Bytes(new ArrayBuffer(width * height + height));
	var w = 0;
	var r = 0;
	var _g = 0;
	var _g1 = height;
	while(_g < _g1) {
		var y = _g++;
		rgb.b[w++] = 0;
		var _g2 = 0;
		var _g3 = width;
		while(_g2 < _g3) {
			var x = _g2++;
			rgb.b[w++] = data.b[r++];
		}
	}
	var l = new haxe_ds_List();
	l.add(format_png_Chunk.CHeader({ width : width, height : height, colbits : 8, color : format_png_Color.ColGrey(false), interlaced : false}));
	l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgb,level)));
	l.add(format_png_Chunk.CEnd);
	return l;
};
format_png_Tools.buildIndexed = function(width,height,data,palette,level) {
	if(level == null) {
		level = 9;
	}
	var rgb = new haxe_io_Bytes(new ArrayBuffer(width * height + height));
	var w = 0;
	var r = 0;
	var _g = 0;
	var _g1 = height;
	while(_g < _g1) {
		var y = _g++;
		rgb.b[w++] = 0;
		var _g2 = 0;
		var _g3 = width;
		while(_g2 < _g3) {
			var x = _g2++;
			rgb.b[w++] = data.b[r++];
		}
	}
	var l = new haxe_ds_List();
	l.add(format_png_Chunk.CHeader({ width : width, height : height, colbits : 8, color : format_png_Color.ColIndexed, interlaced : false}));
	l.add(format_png_Chunk.CPalette(palette));
	l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgb,level)));
	l.add(format_png_Chunk.CEnd);
	return l;
};
format_png_Tools.buildRGB = function(width,height,data,level) {
	if(level == null) {
		level = 9;
	}
	var rgb = new haxe_io_Bytes(new ArrayBuffer(width * height * 3 + height));
	var w = 0;
	var r = 0;
	var _g = 0;
	var _g1 = height;
	while(_g < _g1) {
		var y = _g++;
		rgb.b[w++] = 0;
		var _g2 = 0;
		var _g3 = width;
		while(_g2 < _g3) {
			var x = _g2++;
			rgb.b[w++] = data.b[r + 2];
			rgb.b[w++] = data.b[r + 1];
			rgb.b[w++] = data.b[r];
			r += 3;
		}
	}
	var l = new haxe_ds_List();
	l.add(format_png_Chunk.CHeader({ width : width, height : height, colbits : 8, color : format_png_Color.ColTrue(false), interlaced : false}));
	l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgb,level)));
	l.add(format_png_Chunk.CEnd);
	return l;
};
format_png_Tools.build32ARGB = function(width,height,data,level) {
	if(level == null) {
		level = 9;
	}
	var rgba = new haxe_io_Bytes(new ArrayBuffer(width * height * 4 + height));
	var w = 0;
	var r = 0;
	var _g = 0;
	var _g1 = height;
	while(_g < _g1) {
		var y = _g++;
		rgba.b[w++] = 0;
		var _g2 = 0;
		var _g3 = width;
		while(_g2 < _g3) {
			var x = _g2++;
			rgba.b[w++] = data.b[r + 1];
			rgba.b[w++] = data.b[r + 2];
			rgba.b[w++] = data.b[r + 3];
			rgba.b[w++] = data.b[r];
			r += 4;
		}
	}
	var l = new haxe_ds_List();
	l.add(format_png_Chunk.CHeader({ width : width, height : height, colbits : 8, color : format_png_Color.ColTrue(true), interlaced : false}));
	l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgba,level)));
	l.add(format_png_Chunk.CEnd);
	return l;
};
format_png_Tools.build32BGRA = function(width,height,data,level) {
	if(level == null) {
		level = 9;
	}
	var rgba = new haxe_io_Bytes(new ArrayBuffer(width * height * 4 + height));
	var w = 0;
	var r = 0;
	var _g = 0;
	var _g1 = height;
	while(_g < _g1) {
		var y = _g++;
		rgba.b[w++] = 0;
		var _g2 = 0;
		var _g3 = width;
		while(_g2 < _g3) {
			var x = _g2++;
			rgba.b[w++] = data.b[r + 2];
			rgba.b[w++] = data.b[r + 1];
			rgba.b[w++] = data.b[r];
			rgba.b[w++] = data.b[r + 3];
			r += 4;
		}
	}
	var l = new haxe_ds_List();
	l.add(format_png_Chunk.CHeader({ width : width, height : height, colbits : 8, color : format_png_Color.ColTrue(true), interlaced : false}));
	l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgba,level)));
	l.add(format_png_Chunk.CEnd);
	return l;
};
var format_png_Writer = function(o) {
	this.o = o;
	o.set_bigEndian(true);
};
$hxClasses["format.png.Writer"] = format_png_Writer;
format_png_Writer.__name__ = "format.png.Writer";
format_png_Writer.prototype = {
	write: function(png) {
		var b = 137;
		this.o.writeByte(b);
		var b = 80;
		this.o.writeByte(b);
		var b = 78;
		this.o.writeByte(b);
		var b = 71;
		this.o.writeByte(b);
		var b = 13;
		this.o.writeByte(b);
		var b = 10;
		this.o.writeByte(b);
		var b = 26;
		this.o.writeByte(b);
		var b = 10;
		this.o.writeByte(b);
		var _g_head = png.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var c = val;
			switch(c._hx_index) {
			case 0:
				this.writeChunk("IEND",new haxe_io_Bytes(new ArrayBuffer(0)));
				break;
			case 1:
				var h = c.h;
				var b = new haxe_io_BytesOutput();
				b.set_bigEndian(true);
				b.writeInt32(h.width);
				b.writeInt32(h.height);
				b.writeByte(h.colbits);
				var _g = h.color;
				var tmp;
				switch(_g._hx_index) {
				case 0:
					var alpha = _g.alpha;
					tmp = alpha ? 4 : 0;
					break;
				case 1:
					var alpha1 = _g.alpha;
					tmp = alpha1 ? 6 : 2;
					break;
				case 2:
					tmp = 3;
					break;
				}
				b.writeByte(tmp);
				b.writeByte(0);
				b.writeByte(0);
				b.writeByte(h.interlaced ? 1 : 0);
				this.writeChunk("IHDR",b.getBytes());
				break;
			case 2:
				var d = c.b;
				this.writeChunk("IDAT",d);
				break;
			case 3:
				var b1 = c.b;
				this.writeChunk("PLTE",b1);
				break;
			case 4:
				var id = c.id;
				var data = c.data;
				this.writeChunk(id,data);
				break;
			}
		}
	}
	,writeChunk: function(id,data) {
		this.o.writeInt32(data.length);
		this.o.writeString(id);
		this.o.write(data);
		var crc_crc = -1;
		var tmp = (crc_crc ^ HxOverrides.cca(id,0)) & 255;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		crc_crc = crc_crc >>> 8 ^ tmp;
		var tmp = (crc_crc ^ HxOverrides.cca(id,1)) & 255;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		crc_crc = crc_crc >>> 8 ^ tmp;
		var tmp = (crc_crc ^ HxOverrides.cca(id,2)) & 255;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		crc_crc = crc_crc >>> 8 ^ tmp;
		var tmp = (crc_crc ^ HxOverrides.cca(id,3)) & 255;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		crc_crc = crc_crc >>> 8 ^ tmp;
		var b = data.b.bufferValue;
		var _g = 0;
		var _g1 = data.length;
		while(_g < _g1) {
			var i = _g++;
			var tmp = (crc_crc ^ b.bytes[i]) & 255;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			crc_crc = crc_crc >>> 8 ^ tmp;
		}
		this.o.writeInt32(crc_crc ^ -1);
	}
	,__class__: format_png_Writer
};
var format_tga_ImageOrigin = $hxEnums["format.tga.ImageOrigin"] = { __ename__:true,__constructs__:null
	,BottomLeft: {_hx_name:"BottomLeft",_hx_index:0,__enum__:"format.tga.ImageOrigin",toString:$estr}
	,BottomRight: {_hx_name:"BottomRight",_hx_index:1,__enum__:"format.tga.ImageOrigin",toString:$estr}
	,TopLeft: {_hx_name:"TopLeft",_hx_index:2,__enum__:"format.tga.ImageOrigin",toString:$estr}
	,TopRight: {_hx_name:"TopRight",_hx_index:3,__enum__:"format.tga.ImageOrigin",toString:$estr}
};
format_tga_ImageOrigin.__constructs__ = [format_tga_ImageOrigin.BottomLeft,format_tga_ImageOrigin.BottomRight,format_tga_ImageOrigin.TopLeft,format_tga_ImageOrigin.TopRight];
format_tga_ImageOrigin.__empty_constructs__ = [format_tga_ImageOrigin.BottomLeft,format_tga_ImageOrigin.BottomRight,format_tga_ImageOrigin.TopLeft,format_tga_ImageOrigin.TopRight];
var format_tga_ImageType = $hxEnums["format.tga.ImageType"] = { __ename__:true,__constructs__:null
	,NoImage: {_hx_name:"NoImage",_hx_index:0,__enum__:"format.tga.ImageType",toString:$estr}
	,UncompressedColorMapped: {_hx_name:"UncompressedColorMapped",_hx_index:1,__enum__:"format.tga.ImageType",toString:$estr}
	,UncompressedTrueColor: {_hx_name:"UncompressedTrueColor",_hx_index:2,__enum__:"format.tga.ImageType",toString:$estr}
	,UncompressedBlackAndWhite: {_hx_name:"UncompressedBlackAndWhite",_hx_index:3,__enum__:"format.tga.ImageType",toString:$estr}
	,RunLengthColorMapped: {_hx_name:"RunLengthColorMapped",_hx_index:4,__enum__:"format.tga.ImageType",toString:$estr}
	,RunLengthTrueColor: {_hx_name:"RunLengthTrueColor",_hx_index:5,__enum__:"format.tga.ImageType",toString:$estr}
	,RunLengthBlackAndWhite: {_hx_name:"RunLengthBlackAndWhite",_hx_index:6,__enum__:"format.tga.ImageType",toString:$estr}
	,Unknown: ($_=function(type) { return {_hx_index:7,type:type,__enum__:"format.tga.ImageType",toString:$estr}; },$_._hx_name="Unknown",$_.__params__ = ["type"],$_)
};
format_tga_ImageType.__constructs__ = [format_tga_ImageType.NoImage,format_tga_ImageType.UncompressedColorMapped,format_tga_ImageType.UncompressedTrueColor,format_tga_ImageType.UncompressedBlackAndWhite,format_tga_ImageType.RunLengthColorMapped,format_tga_ImageType.RunLengthTrueColor,format_tga_ImageType.RunLengthBlackAndWhite,format_tga_ImageType.Unknown];
format_tga_ImageType.__empty_constructs__ = [format_tga_ImageType.NoImage,format_tga_ImageType.UncompressedColorMapped,format_tga_ImageType.UncompressedTrueColor,format_tga_ImageType.UncompressedBlackAndWhite,format_tga_ImageType.RunLengthColorMapped,format_tga_ImageType.RunLengthTrueColor,format_tga_ImageType.RunLengthBlackAndWhite];
var format_tga_Reader = function(i) {
	this.i = i;
	i.set_bigEndian(false);
};
$hxClasses["format.tga.Reader"] = format_tga_Reader;
format_tga_Reader.__name__ = "format.tga.Reader";
format_tga_Reader.prototype = {
	read: function() {
		var idLength = this.i.readByte();
		var header = this.readHeader();
		var id = idLength == 0 ? "" : this.i.readString(idLength);
		var colorMap = this.readColorMapData(header);
		return { header : header, imageId : id, colorMapData : colorMap, imageData : this.readImageData(header,colorMap), developerData : null};
	}
	,readHeader: function() {
		var colorMapType = this.i.readByte();
		var dataType;
		var dataId = this.i.readByte();
		switch(dataId) {
		case 0:
			dataType = format_tga_ImageType.NoImage;
			break;
		case 1:
			dataType = format_tga_ImageType.UncompressedColorMapped;
			break;
		case 2:
			dataType = format_tga_ImageType.UncompressedTrueColor;
			break;
		case 3:
			dataType = format_tga_ImageType.UncompressedBlackAndWhite;
			break;
		case 9:
			dataType = format_tga_ImageType.RunLengthColorMapped;
			break;
		case 10:
			dataType = format_tga_ImageType.RunLengthTrueColor;
			break;
		case 11:
			dataType = format_tga_ImageType.RunLengthBlackAndWhite;
			break;
		default:
			dataType = format_tga_ImageType.Unknown(dataId);
		}
		var colorMapOrigin = this.i.readInt16();
		var colorMapLength = this.i.readInt16();
		var colorMapDepth = this.i.readByte();
		var xOrigin = this.i.readInt16();
		var yOrigin = this.i.readInt16();
		var width = this.i.readInt16();
		var height = this.i.readInt16();
		var depth = this.i.readByte();
		var descriptor = this.i.readByte();
		var origin;
		switch(descriptor & 48) {
		case 16:
			origin = format_tga_ImageOrigin.BottomRight;
			break;
		case 32:
			origin = format_tga_ImageOrigin.TopLeft;
			break;
		case 48:
			origin = format_tga_ImageOrigin.TopRight;
			break;
		default:
			origin = format_tga_ImageOrigin.BottomLeft;
		}
		return { colorMapType : colorMapType, imageType : dataType, colorMapFirstIndex : colorMapOrigin, colorMapLength : colorMapLength, colorMapEntrySize : colorMapDepth, xOrigin : xOrigin, yOrigin : yOrigin, width : width, height : height, bitsPerPixel : depth, alphaChannelBits : descriptor & 15, imageOrigin : origin};
	}
	,readColorMapData: function(header) {
		if(header.colorMapType == 0) {
			return null;
		}
		return this.readPixels(header.colorMapEntrySize,header.colorMapLength,header.alphaChannelBits,false);
	}
	,readImageData: function(header,colorMap) {
		switch(header.imageType._hx_index) {
		case 0:
			return null;
		case 1:
			return this.readIndexes(header.bitsPerPixel,header.width * header.height,colorMap,header.colorMapFirstIndex,false);
		case 2:
			return this.readPixels(header.bitsPerPixel,header.width * header.height,header.alphaChannelBits,false);
		case 3:
			return this.readMono(header.bitsPerPixel,header.width * header.height,header.alphaChannelBits,false);
		case 4:
			return this.readIndexes(header.bitsPerPixel,header.width * header.height,colorMap,header.colorMapFirstIndex,true);
		case 5:
			return this.readPixels(header.bitsPerPixel,header.width * header.height,header.alphaChannelBits,true);
		case 6:
			return this.readMono(header.bitsPerPixel,header.width * header.height,header.alphaChannelBits,true);
		default:
			throw haxe_Exception.thrown("Unsupported image data type!");
		}
	}
	,readPixels: function(bitsPerPixel,amount,alphaChannelBits,rle) {
		var list = new Array(amount);
		var alpha = alphaChannelBits != 0;
		var bitFieldSize = bitsPerPixel / 3 | 0;
		if(bitFieldSize > 8) {
			bitFieldSize = 8;
		}
		var parsePixel;
		var readEntry;
		switch(bitsPerPixel) {
		case 8:
			readEntry = ($_=this.i,$bind($_,$_.readByte));
			parsePixel = $bind(this,this.parsePixel1);
			break;
		case 16:
			readEntry = ($_=this.i,$bind($_,$_.readUInt16));
			parsePixel = $bind(this,this.parsePixel2);
			break;
		case 24:
			readEntry = ($_=this.i,$bind($_,$_.readUInt24));
			parsePixel = $bind(this,this.parsePixel3);
			break;
		case 32:
			readEntry = ($_=this.i,$bind($_,$_.readInt32));
			parsePixel = $bind(this,this.parsePixel4);
			break;
		default:
			throw haxe_Exception.thrown("Unsupported bits per pixels amount!");
		}
		if(rle) {
			var rleChunk;
			var i = 0;
			while(i < amount) {
				rleChunk = this.i.readByte();
				if((rleChunk & 128) != 0) {
					rleChunk &= 127;
					var pixel = parsePixel(readEntry(),alpha);
					while(rleChunk >= 0) {
						list[i++] = pixel;
						--rleChunk;
					}
				} else {
					rleChunk &= 127;
					while(rleChunk >= 0) {
						list[i++] = parsePixel(readEntry(),alpha);
						--rleChunk;
					}
				}
			}
		} else {
			var _g = 0;
			var _g1 = amount;
			while(_g < _g1) {
				var i = _g++;
				list[i] = parsePixel(readEntry(),alpha);
			}
		}
		return list;
	}
	,readMono: function(bitsPerPixel,amount,alphaChannelBits,rle) {
		var list = new Array(amount);
		var alpha = alphaChannelBits != 0;
		var parsePixel;
		var readEntry;
		switch(bitsPerPixel) {
		case 8:
			readEntry = ($_=this.i,$bind($_,$_.readByte));
			parsePixel = $bind(this,this.parsePixel1);
			break;
		case 16:
			readEntry = ($_=this.i,$bind($_,$_.readUInt16));
			parsePixel = $bind(this,this.parsePixelGreyAlpha);
			break;
		default:
			throw haxe_Exception.thrown("Unsupported bits per pixels amount!");
		}
		if(rle) {
			var rleChunk;
			var i = 0;
			while(i < amount) {
				rleChunk = this.i.readByte();
				if((rleChunk & 128) != 0) {
					rleChunk &= 127;
					var pixel = parsePixel(readEntry(),alpha);
					while(rleChunk >= 0) {
						list[i++] = pixel;
						--rleChunk;
					}
				} else {
					rleChunk &= 127;
					while(rleChunk >= 0) {
						list[i++] = parsePixel(readEntry(),alpha);
						--rleChunk;
					}
				}
			}
		} else {
			var _g = 0;
			var _g1 = amount;
			while(_g < _g1) {
				var i = _g++;
				list[i] = parsePixel(readEntry(),alpha);
			}
		}
		return list;
	}
	,readIndexes: function(bitsPerPixel,amount,colorMap,offset,rle) {
		var list = new Array(amount);
		var readEntry;
		switch(bitsPerPixel) {
		case 8:
			readEntry = ($_=this.i,$bind($_,$_.readByte));
			break;
		case 16:
			readEntry = ($_=this.i,$bind($_,$_.readUInt16));
			break;
		case 24:
			readEntry = ($_=this.i,$bind($_,$_.readUInt24));
			break;
		case 32:
			readEntry = ($_=this.i,$bind($_,$_.readInt32));
			break;
		default:
			throw haxe_Exception.thrown("Unsupported bits per pixels amount!");
		}
		if(rle) {
			var i = 0;
			var rleChunk;
			while(i < amount) {
				rleChunk = this.i.readByte();
				if((rleChunk & 128) != 0) {
					rleChunk &= 127;
					var pixel = colorMap[offset + readEntry()];
					while(rleChunk >= 0) {
						list[i++] = pixel;
						--rleChunk;
					}
				} else {
					rleChunk &= 127;
					while(rleChunk >= 0) {
						list[i++] = colorMap[offset + readEntry()];
						--rleChunk;
					}
				}
			}
		} else {
			var _g = 0;
			var _g1 = amount;
			while(_g < _g1) {
				var i = _g++;
				list[i] = colorMap[offset + readEntry()];
			}
		}
		return list;
	}
	,parsePixel1: function(value,alpha) {
		return value << 16 | value << 8 | value;
	}
	,parsePixelGreyAlpha: function(value,alpha) {
		return (alpha ? (value & 65280) << 16 : 0) | this.parsePixel1(value & 255,false);
	}
	,parsePixel2: function(value,alpha) {
		return (alpha ? (value & 32768) == 1 ? -16777216 : 0 : 0) | (((value & 31744) >> 10) / 31 * 255 | 0) << 16 | (((value & 992) >> 5) / 31 * 255 | 0) << 8 | ((value & 31) / 31 * 255 | 0);
	}
	,parsePixel3: function(value,alpha) {
		return value;
	}
	,parsePixel4: function(value,alpha) {
		return value;
	}
	,__class__: format_tga_Reader
};
var format_tools_BitsInput = function(i) {
	this.i = i;
	this.nbits = 0;
	this.bits = 0;
};
$hxClasses["format.tools.BitsInput"] = format_tools_BitsInput;
format_tools_BitsInput.__name__ = "format.tools.BitsInput";
format_tools_BitsInput.prototype = {
	readBits: function(n) {
		if(this.nbits >= n) {
			var c = this.nbits - n;
			var k = this.bits >>> c & (1 << n) - 1;
			this.nbits = c;
			return k;
		}
		var k = this.i.readByte();
		if(this.nbits >= 24) {
			if(n > 31) {
				throw haxe_Exception.thrown("Bits error");
			}
			var c = 8 + this.nbits - n;
			var d = this.bits & (1 << this.nbits) - 1;
			d = d << 8 - c | k << c;
			this.bits = k;
			this.nbits = c;
			return d;
		}
		this.bits = this.bits << 8 | k;
		this.nbits += 8;
		return this.readBits(n);
	}
	,readBit: function() {
		if(this.nbits == 0) {
			this.bits = this.i.readByte();
			this.nbits = 8;
		}
		this.nbits--;
		return (this.bits >>> this.nbits & 1) == 1;
	}
	,reset: function() {
		this.nbits = 0;
	}
	,__class__: format_tools_BitsInput
};
var format_tools_Deflate = function() { };
$hxClasses["format.tools.Deflate"] = format_tools_Deflate;
format_tools_Deflate.__name__ = "format.tools.Deflate";
format_tools_Deflate.run = function(b,level) {
	if(level == null) {
		level = 9;
	}
	return haxe_zip_Compress.run(b,level);
};
var format_tools_Inflate = function() { };
$hxClasses["format.tools.Inflate"] = format_tools_Inflate;
format_tools_Inflate.__name__ = "format.tools.Inflate";
format_tools_Inflate.run = function(bytes) {
	return haxe_zip_Uncompress.run(bytes);
};
var format_wav_WAVEFormat = $hxEnums["format.wav.WAVEFormat"] = { __ename__:true,__constructs__:null
	,WF_PCM: {_hx_name:"WF_PCM",_hx_index:0,__enum__:"format.wav.WAVEFormat",toString:$estr}
};
format_wav_WAVEFormat.__constructs__ = [format_wav_WAVEFormat.WF_PCM];
format_wav_WAVEFormat.__empty_constructs__ = [format_wav_WAVEFormat.WF_PCM];
var format_wav_Reader = function(i) {
	this.i = i;
	i.set_bigEndian(false);
};
$hxClasses["format.wav.Reader"] = format_wav_Reader;
format_wav_Reader.__name__ = "format.wav.Reader";
format_wav_Reader.prototype = {
	readInt: function() {
		return this.i.readInt32();
	}
	,read: function() {
		if(this.i.readString(4) != "RIFF") {
			throw haxe_Exception.thrown("RIFF header expected");
		}
		var len = this.i.readInt32();
		if(this.i.readString(4) != "WAVE") {
			throw haxe_Exception.thrown("WAVE signature not found");
		}
		var fmt = this.i.readString(4);
		_hx_loop1: while(fmt != "fmt ") switch(fmt) {
		case "JUNK":
			var junkLen = this.i.readInt32();
			this.i.read(junkLen);
			fmt = this.i.readString(4);
			break;
		case "bext":
			var bextLen = this.i.readInt32();
			this.i.read(bextLen);
			fmt = this.i.readString(4);
			break;
		default:
			break _hx_loop1;
		}
		if(fmt != "fmt ") {
			throw haxe_Exception.thrown("unsupported wave chunk " + fmt);
		}
		var fmtlen = this.i.readInt32();
		var format;
		switch(this.i.readUInt16()) {
		case 1:case 3:
			format = format_wav_WAVEFormat.WF_PCM;
			break;
		default:
			throw haxe_Exception.thrown("only PCM (uncompressed) WAV files are supported");
		}
		var channels = this.i.readUInt16();
		var samplingRate = this.i.readInt32();
		var byteRate = this.i.readInt32();
		var blockAlign = this.i.readUInt16();
		var bitsPerSample = this.i.readUInt16();
		if(fmtlen > 16) {
			this.i.read(fmtlen - 16);
		}
		var nextChunk = this.i.readString(4);
		while(nextChunk != "data") {
			this.i.read(this.i.readInt32());
			nextChunk = this.i.readString(4);
		}
		if(nextChunk != "data") {
			throw haxe_Exception.thrown("expected data subchunk");
		}
		var datalen = this.i.readInt32();
		var data;
		try {
			data = this.i.read(datalen);
		} catch( _g ) {
			if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
				throw haxe_Exception.thrown("Invalid chunk data length");
			} else {
				throw _g;
			}
		}
		var cuePoints = [];
		try {
			while(true) {
				var nextChunk = this.i.readString(4);
				if(nextChunk == "cue ") {
					this.i.readInt32();
					var nbCuePoints = this.i.readInt32();
					var _g = 0;
					var _g1 = nbCuePoints;
					while(_g < _g1) {
						var _ = _g++;
						var cueId = this.i.readInt32();
						this.i.readInt32();
						this.i.readString(4);
						this.i.readInt32();
						this.i.readInt32();
						var cueSampleOffset = this.i.readInt32();
						cuePoints.push({ id : cueId, sampleOffset : cueSampleOffset});
					}
				} else {
					var n = this.i.readInt32();
					if(n < 0) {
						break;
					}
					this.i.read(n);
				}
			}
		} catch( _g ) {
			if(!((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
				throw _g;
			}
		}
		return { header : { format : format, channels : channels, samplingRate : samplingRate, byteRate : byteRate, blockAlign : blockAlign, bitsPerSample : bitsPerSample}, data : data, cuePoints : cuePoints};
	}
	,__class__: format_wav_Reader
};
var game_config_GameClientConfig = function() {
	this.visualSettings = new game_config_VisualSettings();
	this.engineConfig = { mode : engine_EngineMode.SINGLEPLAYER, tickRate : 60, unitPixels : 32, aiUpdateInterval : 10, snapshotBufferSize : 1000, rngSeed : 12345, snapshotEmissionInterval : 5};
	this.gameMode = game_config_GameMode.SINGLEPLAYER;
};
$hxClasses["game.config.GameClientConfig"] = game_config_GameClientConfig;
game_config_GameClientConfig.__name__ = "game.config.GameClientConfig";
game_config_GameClientConfig.createSingleplayer = function() {
	var config = new game_config_GameClientConfig();
	config.gameMode = game_config_GameMode.SINGLEPLAYER;
	config.engineConfig.mode = engine_EngineMode.SINGLEPLAYER;
	return config;
};
game_config_GameClientConfig.createServer = function() {
	var config = new game_config_GameClientConfig();
	config.gameMode = game_config_GameMode.SERVER;
	config.engineConfig.mode = engine_EngineMode.SERVER;
	return config;
};
game_config_GameClientConfig.createClientPrediction = function() {
	var config = new game_config_GameClientConfig();
	config.gameMode = game_config_GameMode.CLIENT_PREDICTION;
	config.engineConfig.mode = engine_EngineMode.CLIENT_PREDICTION;
	return config;
};
game_config_GameClientConfig.prototype = {
	__class__: game_config_GameClientConfig
};
var game_config_GameMode = $hxEnums["game.config.GameMode"] = { __ename__:true,__constructs__:null
	,SINGLEPLAYER: {_hx_name:"SINGLEPLAYER",_hx_index:0,__enum__:"game.config.GameMode",toString:$estr}
	,SERVER: {_hx_name:"SERVER",_hx_index:1,__enum__:"game.config.GameMode",toString:$estr}
	,CLIENT_PREDICTION: {_hx_name:"CLIENT_PREDICTION",_hx_index:2,__enum__:"game.config.GameMode",toString:$estr}
};
game_config_GameMode.__constructs__ = [game_config_GameMode.SINGLEPLAYER,game_config_GameMode.SERVER,game_config_GameMode.CLIENT_PREDICTION];
game_config_GameMode.__empty_constructs__ = [game_config_GameMode.SINGLEPLAYER,game_config_GameMode.SERVER,game_config_GameMode.CLIENT_PREDICTION];
var game_config_VisualSettings = function() {
	this.pixelsPerUnit = 6.75;
	this.viewportWidthUnits = 160.0;
	this.viewportHeightUnits = 90.0;
	this.characterHeight = 80.0;
	this.drawPhysicsShapes = true;
	this.drawHealthBars = true;
	this.colorPlayer = 65280;
	this.colorAcolyte = 35071;
	this.colorMonster = 16711680;
	this.colorConsumable = 16776960;
	this.colorEffect = 16711935;
	this.colorPhysicsShape = 16776960;
};
$hxClasses["game.config.VisualSettings"] = game_config_VisualSettings;
game_config_VisualSettings.__name__ = "game.config.VisualSettings";
game_config_VisualSettings.prototype = {
	worldToPixels: function(worldUnits) {
		return worldUnits * this.pixelsPerUnit;
	}
	,pixelsToWorld: function(pixels) {
		return pixels / this.pixelsPerUnit;
	}
	,__class__: game_config_VisualSettings
};
var game_event_EventListener = function() { };
$hxClasses["game.event.EventListener"] = game_event_EventListener;
game_event_EventListener.__name__ = "game.event.EventListener";
game_event_EventListener.__isInterface__ = true;
game_event_EventListener.prototype = {
	__class__: game_event_EventListener
};
var game_event_EventManager = function() {
	this.listeners = new haxe_ds_StringMap();
};
$hxClasses["game.event.EventManager"] = game_event_EventManager;
game_event_EventManager.__name__ = "game.event.EventManager";
game_event_EventManager.prototype = {
	subscribe: function(eventType,listener) {
		if(Object.prototype.hasOwnProperty.call(this.listeners.h,eventType)) {
			var users = this.listeners.h[eventType];
			users.add(listener);
		} else {
			var newList = new haxe_ds_List();
			newList.add(listener);
			this.listeners.h[eventType] = newList;
		}
	}
	,unsubscribe: function(eventType,listener) {
		var users = this.listeners.h[eventType];
		users.remove(listener);
	}
	,notify: function(eventType,params) {
		var ls = this.listeners.h[eventType];
		var _g_head = ls.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var listener = val;
			listener.notify(eventType,params);
		}
	}
	,__class__: game_event_EventManager
};
var game_mvp_model_GameClientState = function() {
	this.entities = new haxe_ds_IntMap();
	this.characters = new haxe_ds_IntMap();
	this.colliders = new haxe_ds_IntMap();
	this.consumables = new haxe_ds_IntMap();
	this.effects = new haxe_ds_IntMap();
	this.nextLocalId = 1;
	this.lastUpdateTick = 0;
	this.pendingInputs = [];
	this.predictionHistory = [];
	this.maxPredictionHistory = 50;
	this.lastAcknowledgedSequence = -1;
};
$hxClasses["game.mvp.model.GameClientState"] = game_mvp_model_GameClientState;
game_mvp_model_GameClientState.__name__ = "game.mvp.model.GameClientState";
game_mvp_model_GameClientState.prototype = {
	addEntity: function(model) {
		this.entities.h[model.engineEntity.id] = model;
		switch(model.get_type()) {
		case "character":
			this.characters.h[model.engineEntity.id] = model;
			break;
		case "collider":
			this.colliders.h[model.engineEntity.id] = model;
			break;
		case "consumable":
			this.consumables.h[model.engineEntity.id] = model;
			break;
		case "effect":
			this.effects.h[model.engineEntity.id] = model;
			break;
		default:
			haxe_Log.trace("Unknown entity type: " + model.get_type(),{ fileName : "src/game/mvp/model/GameClientState.hx", lineNumber : 71, className : "game.mvp.model.GameClientState", methodName : "addEntity"});
		}
	}
	,removeEntity: function(entityId) {
		var model = this.entities.h[entityId];
		if(model != null) {
			switch(model.get_type()) {
			case "character":
				this.characters.remove(entityId);
				break;
			case "collider":
				this.colliders.remove(entityId);
				break;
			case "consumable":
				this.consumables.remove(entityId);
				break;
			case "effect":
				this.effects.remove(entityId);
				break;
			default:
			}
			this.entities.remove(entityId);
		}
	}
	,getEntity: function(entityId) {
		return this.entities.h[entityId];
	}
	,getCharacter: function(entityId) {
		return this.characters.h[entityId];
	}
	,getCollider: function(entityId) {
		return this.colliders.h[entityId];
	}
	,getConsumable: function(entityId) {
		return this.consumables.h[entityId];
	}
	,getEffect: function(entityId) {
		return this.effects.h[entityId];
	}
	,getEntitiesByType: function(type) {
		var result = [];
		var entity = this.entities.iterator();
		while(entity.hasNext()) {
			var entity1 = entity.next();
			if(entity1.get_type() == type) {
				result.push(entity1);
			}
		}
		return result;
	}
	,getAllCharacters: function() {
		var result = [];
		var character = this.characters.iterator();
		while(character.hasNext()) {
			var character1 = character.next();
			result.push(character1);
		}
		return result;
	}
	,getAllColliders: function() {
		var result = [];
		var collider = this.colliders.iterator();
		while(collider.hasNext()) {
			var collider1 = collider.next();
			result.push(collider1);
		}
		return result;
	}
	,getAllConsumables: function() {
		var result = [];
		var consumable = this.consumables.iterator();
		while(consumable.hasNext()) {
			var consumable1 = consumable.next();
			result.push(consumable1);
		}
		return result;
	}
	,getAllEffects: function() {
		var result = [];
		var effect = this.effects.iterator();
		while(effect.hasNext()) {
			var effect1 = effect.next();
			result.push(effect1);
		}
		return result;
	}
	,getAliveEntities: function() {
		var result = [];
		var entity = this.entities.iterator();
		while(entity.hasNext()) {
			var entity1 = entity.next();
			if(entity1.get_isAlive()) {
				result.push(entity1);
			}
		}
		return result;
	}
	,getEntitiesByOwner: function(ownerId) {
		var result = [];
		var entity = this.entities.iterator();
		while(entity.hasNext()) {
			var entity1 = entity.next();
			if(entity1.get_ownerId() == ownerId) {
				result.push(entity1);
			}
		}
		return result;
	}
	,getPlayerCharacter: function() {
		var character = this.characters.iterator();
		while(character.hasNext()) {
			var character1 = character.next();
			if(character1.get_ownerId() == "player1") {
				return character1;
			}
		}
		return null;
	}
	,getAICharacters: function() {
		var result = [];
		var character = this.characters.iterator();
		while(character.hasNext()) {
			var character1 = character.next();
			if(character1.get_ownerId() == "ai") {
				result.push(character1);
			}
		}
		return result;
	}
	,setPlayerControlledEntity: function(entityId) {
		this.playerControlledEntityId = entityId;
	}
	,getPlayerControlledEntity: function() {
		if(this.playerControlledEntityId != null) {
			return this.characters.h[this.playerControlledEntityId];
		}
		return null;
	}
	,update: function(dt,currentTick) {
		this.lastUpdateTick = currentTick;
		var entity = this.entities.iterator();
		while(entity.hasNext()) {
			var entity1 = entity.next();
			if(entity1.get_isAlive()) {
				entity1.updateFromEngine();
			}
		}
		var consumable = this.consumables.iterator();
		while(consumable.hasNext()) {
			var consumable1 = consumable.next();
			if(consumable1.get_isAlive()) {
				consumable1.update(dt);
			}
		}
		var effect = this.effects.iterator();
		while(effect.hasNext()) {
			var effect1 = effect.next();
			if(effect1.get_isAlive()) {
				effect1.update(dt);
				if(effect1.isExpired()) {
					if(effect1.get_effectEntity() != null) {
						effect1.get_effectEntity().isAlive = false;
					}
				}
			}
		}
	}
	,cleanupDeadEntities: function() {
		var toRemove = [];
		var entityId = this.entities.keys();
		while(entityId.hasNext()) {
			var entityId1 = entityId.next();
			var entity = this.entities.h[entityId1];
			if(!entity.get_isAlive()) {
				toRemove.push(entityId1);
			}
		}
		var _g = 0;
		while(_g < toRemove.length) {
			var entityId = toRemove[_g];
			++_g;
			this.removeEntity(entityId);
		}
	}
	,getEntityCount: function(type) {
		return this.getEntitiesByType(type).length;
	}
	,getTotalEntityCount: function() {
		var count = 0;
		var entity = this.entities.iterator();
		while(entity.hasNext()) {
			var entity1 = entity.next();
			++count;
		}
		return count;
	}
	,clear: function() {
		this.entities.h = { };
		this.characters.h = { };
		this.colliders.h = { };
		this.consumables.h = { };
		this.effects.h = { };
		this.nextLocalId = 1;
		this.playerControlledEntityId = null;
		this.pendingInputs = [];
		this.predictionHistory = [];
		this.lastAcknowledgedSequence = -1;
	}
	,addPendingInput: function(input) {
		this.pendingInputs.push(input);
	}
	,getPendingInputs: function() {
		return this.pendingInputs.slice();
	}
	,clearAcknowledgedInputs: function(sequence) {
		this.lastAcknowledgedSequence = sequence;
		var _g = [];
		var _g1 = 0;
		var _g2 = this.pendingInputs;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(v.sequence > sequence) {
				_g.push(v);
			}
		}
		this.pendingInputs = _g;
	}
	,addPrediction: function(prediction) {
		this.predictionHistory.push(prediction);
		if(this.predictionHistory.length > this.maxPredictionHistory) {
			this.predictionHistory.shift();
		}
	}
	,getPredictionHistory: function() {
		return this.predictionHistory.slice();
	}
	,clearPredictionHistory: function() {
		this.predictionHistory = [];
	}
	,getStateSummary: function() {
		return { totalEntities : this.getTotalEntityCount(), characters : this.getEntityCount("character"), colliders : this.getEntityCount("collider"), consumables : this.getEntityCount("consumable"), effects : this.getEntityCount("effect"), aliveEntities : this.getAliveEntities().length, lastUpdateTick : this.lastUpdateTick, pendingInputs : this.pendingInputs.length, predictionHistory : this.predictionHistory.length, lastAcknowledgedSequence : this.lastAcknowledgedSequence};
	}
	,serialize: function() {
		var serializedEntities = [];
		var entity = this.entities.iterator();
		while(entity.hasNext()) {
			var entity1 = entity.next();
			if(entity1.engineEntity != null) {
				serializedEntities.push(entity1.engineEntity.serialize());
			}
		}
		return { entities : serializedEntities, nextLocalId : this.nextLocalId, lastUpdateTick : this.lastUpdateTick};
	}
	,deserialize: function(data) {
		this.clear();
		if(data.entities != null) {
			var entitiesArray = data.entities;
			var _g = 0;
			while(_g < entitiesArray.length) {
				var entityData = entitiesArray[_g];
				++_g;
				var model = this.createModelFromData(entityData);
				if(model != null) {
					this.addEntity(model);
				}
			}
		}
		this.nextLocalId = data.nextLocalId;
		this.lastUpdateTick = data.lastUpdateTick;
	}
	,createModelFromData: function(data) {
		var model = null;
		switch(data.type) {
		case "character":
			model = new game_mvp_model_entities_CharacterModel();
			break;
		case "collider":
			model = new game_mvp_model_entities_ColliderModel();
			break;
		case "consumable":
			model = new game_mvp_model_entities_ConsumableModel();
			break;
		case "effect":
			model = new game_mvp_model_entities_EffectModel();
			break;
		default:
			return null;
		}
		if(model.engineEntity != null) {
			model.engineEntity.deserialize(data);
		}
		return model;
	}
	,__class__: game_mvp_model_GameClientState
};
var game_mvp_model_entities_BaseEntityModel = function() {
	this.color = 16777215;
	this.visualScale = 1.0;
	this.previousPos = engine_geometry_Vec2Utils.create(0,0);
	this.renderPos = engine_geometry_Vec2Utils.create(0,0);
	this.positionHistory = [];
	this.interpolationAlpha = 0.0;
	this.needsVisualUpdate = true;
	this.lastUpdateTick = 0;
};
$hxClasses["game.mvp.model.entities.BaseEntityModel"] = game_mvp_model_entities_BaseEntityModel;
game_mvp_model_entities_BaseEntityModel.__name__ = "game.mvp.model.entities.BaseEntityModel";
game_mvp_model_entities_BaseEntityModel.prototype = {
	initialize: function(engineEntity) {
		this.engineEntity = engineEntity;
		this.setVisualProperties();
		this.previousPos = engine_geometry_Vec2Utils.create(engineEntity.pos.x,engineEntity.pos.y);
		this.renderPos = engine_geometry_Vec2Utils.create(engineEntity.pos.x,engineEntity.pos.y);
		this.positionHistory = [{ tick : 0, pos : engine_geometry_Vec2Utils.create(engineEntity.pos.x,engineEntity.pos.y)}];
		this.interpolationAlpha = 0.0;
		this.needsVisualUpdate = true;
		this.lastUpdateTick = 0;
	}
	,updateFromEngine: function() {
		if(this.engineEntity == null) {
			return;
		}
		this.needsVisualUpdate = true;
		this.lastUpdateTick++;
	}
	,setVisualProperties: function() {
		if(this.engineEntity == null) {
			return;
		}
		switch(this.engineEntity.type) {
		case "character":
			this.color = 65280;
			break;
		case "consumable":
			this.color = 16776960;
			break;
		case "effect":
			this.color = 16711935;
			break;
		default:
			this.color = 16777215;
		}
	}
	,reset: function() {
		this.engineEntity = null;
		this.color = 16777215;
		this.visualScale = 1.0;
		this.previousPos = engine_geometry_Vec2Utils.create(0,0);
		this.renderPos = engine_geometry_Vec2Utils.create(0,0);
		this.positionHistory = [];
		this.interpolationAlpha = 0.0;
		this.needsVisualUpdate = true;
		this.lastUpdateTick = 0;
	}
	,get_id: function() {
		if(this.engineEntity != null) {
			return this.engineEntity.id;
		} else {
			return 0;
		}
	}
	,get_type: function() {
		if(this.engineEntity != null) {
			return this.engineEntity.type;
		} else {
			return "character";
		}
	}
	,get_pos: function() {
		if(this.engineEntity != null) {
			return this.engineEntity.pos;
		} else {
			return engine_geometry_Vec2Utils.create(0,0);
		}
	}
	,get_vel: function() {
		if(this.engineEntity != null) {
			return this.engineEntity.vel;
		} else {
			return engine_geometry_Vec2Utils.create(0,0);
		}
	}
	,get_rotation: function() {
		if(this.engineEntity != null) {
			return this.engineEntity.rotation;
		} else {
			return 0;
		}
	}
	,get_ownerId: function() {
		if(this.engineEntity != null) {
			return this.engineEntity.ownerId;
		} else {
			return "";
		}
	}
	,get_isAlive: function() {
		if(this.engineEntity != null) {
			return this.engineEntity.isAlive;
		} else {
			return false;
		}
	}
	,get_colliderWidth: function() {
		if(this.engineEntity != null) {
			return this.engineEntity.colliderWidth;
		} else {
			return 1.0;
		}
	}
	,get_colliderHeight: function() {
		if(this.engineEntity != null) {
			return this.engineEntity.colliderHeight;
		} else {
			return 1.0;
		}
	}
	,__class__: game_mvp_model_entities_BaseEntityModel
};
var game_mvp_model_entities_CharacterModel = function() {
	game_mvp_model_entities_BaseEntityModel.call(this);
	this.isMoving = false;
	this.lastMoveTime = 0;
};
$hxClasses["game.mvp.model.entities.CharacterModel"] = game_mvp_model_entities_CharacterModel;
game_mvp_model_entities_CharacterModel.__name__ = "game.mvp.model.entities.CharacterModel";
game_mvp_model_entities_CharacterModel.__super__ = game_mvp_model_entities_BaseEntityModel;
game_mvp_model_entities_CharacterModel.prototype = $extend(game_mvp_model_entities_BaseEntityModel.prototype,{
	get_characterEntity: function() {
		return js_Boot.__cast(this.engineEntity , engine_model_entities_impl_EngineCharacterEntity);
	}
	,updateFromEngine: function() {
		game_mvp_model_entities_BaseEntityModel.prototype.updateFromEngine.call(this);
		if(this.get_characterEntity() == null) {
			return;
		}
		if(this.previousPos.x != this.get_characterEntity().pos.x || this.previousPos.y != this.get_characterEntity().pos.y) {
			this.previousPos.x = this.renderPos.x;
			this.previousPos.y = this.renderPos.y;
			this.interpolationAlpha = 0.0;
		}
		var interpSpeed = 0.3;
		this.interpolationAlpha = Math.min(1.0,this.interpolationAlpha + interpSpeed);
		var tmp = this.previousPos.x + (this.get_characterEntity().pos.x - this.previousPos.x) * this.interpolationAlpha | 0;
		this.renderPos.x = tmp;
		var tmp = this.previousPos.y + (this.get_characterEntity().pos.y - this.previousPos.y) * this.interpolationAlpha | 0;
		this.renderPos.y = tmp;
		var speed = Math.sqrt(this.get_vel().x * this.get_vel().x + this.get_vel().y * this.get_vel().y);
		this.isMoving = speed > 0.1;
		if(this.isMoving) {
			this.lastMoveTime = 0;
		} else {
			this.lastMoveTime += 0.016;
		}
	}
	,takeDamage: function(damage) {
		if(this.get_characterEntity() != null) {
			var tmp = Math.max(0,this.get_characterEntity().hp - damage) | 0;
			this.get_characterEntity().hp = tmp;
			this.needsVisualUpdate = true;
		}
	}
	,heal: function(amount) {
		if(this.get_characterEntity() != null) {
			var tmp = Math.min(this.get_characterEntity().maxHp,this.get_characterEntity().hp + amount) | 0;
			this.get_characterEntity().hp = tmp;
			this.needsVisualUpdate = true;
		}
	}
	,isDead: function() {
		if(this.get_characterEntity() != null) {
			if(this.get_characterEntity().hp > 0) {
				return !this.get_isAlive();
			} else {
				return true;
			}
		} else {
			return true;
		}
	}
	,getHealthPercentage: function() {
		if(this.get_characterEntity() == null) {
			return 0.0;
		}
		if(this.get_characterEntity().maxHp > 0) {
			return this.get_characterEntity().hp / this.get_characterEntity().maxHp;
		} else {
			return 0.0;
		}
	}
	,get_maxHp: function() {
		if(this.get_characterEntity() != null) {
			return this.get_characterEntity().maxHp;
		} else {
			return 0;
		}
	}
	,get_hp: function() {
		if(this.get_characterEntity() != null) {
			return this.get_characterEntity().hp;
		} else {
			return 0;
		}
	}
	,get_level: function() {
		if(this.get_characterEntity() != null) {
			return this.get_characterEntity().level;
		} else {
			return 0;
		}
	}
	,get_stats: function() {
		if(this.get_characterEntity() != null) {
			return this.get_characterEntity().stats;
		} else {
			return { };
		}
	}
	,get_attackDefs: function() {
		if(this.get_characterEntity() != null) {
			return this.get_characterEntity().attackDefs;
		} else {
			return [];
		}
	}
	,get_spellBook: function() {
		if(this.get_characterEntity() != null) {
			return this.get_characterEntity().spellBook;
		} else {
			return [];
		}
	}
	,get_aiProfile: function() {
		if(this.get_characterEntity() != null) {
			return this.get_characterEntity().aiProfile;
		} else {
			return "";
		}
	}
	,reset: function() {
		game_mvp_model_entities_BaseEntityModel.prototype.reset.call(this);
		this.isMoving = false;
		this.lastMoveTime = 0;
	}
	,getCharacterModel: function() {
		return this;
	}
	,__class__: game_mvp_model_entities_CharacterModel
});
var game_mvp_model_entities_ColliderModel = function() {
	game_mvp_model_entities_BaseEntityModel.call(this);
	this.setVisualProperties();
};
$hxClasses["game.mvp.model.entities.ColliderModel"] = game_mvp_model_entities_ColliderModel;
game_mvp_model_entities_ColliderModel.__name__ = "game.mvp.model.entities.ColliderModel";
game_mvp_model_entities_ColliderModel.__super__ = game_mvp_model_entities_BaseEntityModel;
game_mvp_model_entities_ColliderModel.prototype = $extend(game_mvp_model_entities_BaseEntityModel.prototype,{
	get_colliderEntity: function() {
		return js_Boot.__cast(this.engineEntity , engine_model_entities_impl_EngineColliderEntity);
	}
	,initialize: function(engineEntity) {
		game_mvp_model_entities_BaseEntityModel.prototype.initialize.call(this,engineEntity);
		if(this.get_colliderEntity() != null) {
			this.renderPos.x = this.get_colliderEntity().pos.x;
			this.renderPos.y = this.get_colliderEntity().pos.y;
			this.previousPos.x = this.get_colliderEntity().pos.x;
			this.previousPos.y = this.get_colliderEntity().pos.y;
			haxe_Log.trace(this.get_colliderEntity().pos,{ fileName : "src/game/mvp/model/entities/ColliderModel.hx", lineNumber : 39, className : "game.mvp.model.entities.ColliderModel", methodName : "initialize"});
		}
	}
	,updateFromEngine: function() {
		game_mvp_model_entities_BaseEntityModel.prototype.updateFromEngine.call(this);
		if(this.get_colliderEntity() == null) {
			return;
		}
	}
	,setVisualProperties: function() {
		if(this.engineEntity == null) {
			return;
		}
		this.color = 16711680;
		this.visualScale = 1.0;
	}
	,get_passable: function() {
		if(this.get_colliderEntity() != null) {
			return this.get_colliderEntity().passable;
		} else {
			return false;
		}
	}
	,get_isTrigger: function() {
		if(this.get_colliderEntity() != null) {
			return this.get_colliderEntity().isTrigger;
		} else {
			return false;
		}
	}
	,reset: function() {
		game_mvp_model_entities_BaseEntityModel.prototype.reset.call(this);
	}
	,__class__: game_mvp_model_entities_ColliderModel
});
var game_mvp_model_entities_ConsumableModel = function() {
	game_mvp_model_entities_BaseEntityModel.call(this);
	this.glowIntensity = 0.0;
	this.pulsePhase = 0.0;
};
$hxClasses["game.mvp.model.entities.ConsumableModel"] = game_mvp_model_entities_ConsumableModel;
game_mvp_model_entities_ConsumableModel.__name__ = "game.mvp.model.entities.ConsumableModel";
game_mvp_model_entities_ConsumableModel.__super__ = game_mvp_model_entities_BaseEntityModel;
game_mvp_model_entities_ConsumableModel.prototype = $extend(game_mvp_model_entities_BaseEntityModel.prototype,{
	get_consumableEntity: function() {
		return js_Boot.__cast(this.engineEntity , engine_model_entities_impl_EngineConsumableEntity);
	}
	,initializeConsumable: function(consumableEntity) {
		game_mvp_model_entities_BaseEntityModel.prototype.initialize.call(this,consumableEntity);
		this.setConsumableVisuals();
	}
	,setConsumableVisuals: function() {
		if(this.get_consumableEntity() == null) {
			return;
		}
		switch(this.get_consumableEntity().effectId) {
		case "health_potion":
			this.color = 16711680;
			break;
		case "mana_potion":
			this.color = 255;
			break;
		case "strength_potion":
			this.color = 16744448;
			break;
		default:
			this.color = 16776960;
		}
		this.glowIntensity = Math.min(1.0,this.get_consumableEntity().charges / 10.0);
	}
	,update: function(dt) {
		this.pulsePhase += dt * 3.0;
		if(this.pulsePhase > Math.PI * 2) {
			this.pulsePhase -= Math.PI * 2;
		}
		var pulseScale = 1.0 + Math.sin(this.pulsePhase) * 0.1;
		this.visualScale = pulseScale;
		this.needsVisualUpdate = true;
	}
	,consume: function() {
		if(this.get_consumableEntity() != null && this.canConsume()) {
			var fh = this.get_consumableEntity();
			fh.charges--;
			if(this.get_consumableEntity().charges <= 0) {
				this.get_consumableEntity().isAlive = false;
			}
			this.needsVisualUpdate = true;
			return true;
		}
		return false;
	}
	,canConsume: function() {
		if(this.get_consumableEntity() != null && this.get_consumableEntity().charges > 0) {
			return this.get_isAlive();
		} else {
			return false;
		}
	}
	,getEffectDescription: function() {
		if(this.get_consumableEntity() == null) {
			return "Unknown effect";
		}
		switch(this.get_consumableEntity().effectId) {
		case "health_potion":
			return "Restores health";
		case "mana_potion":
			return "Restores mana";
		case "strength_potion":
			return "Increases power";
		default:
			return "Unknown effect";
		}
	}
	,get_effectId: function() {
		if(this.get_consumableEntity() != null) {
			return this.get_consumableEntity().effectId;
		} else {
			return "";
		}
	}
	,get_charges: function() {
		if(this.get_consumableEntity() != null) {
			return this.get_consumableEntity().charges;
		} else {
			return 0;
		}
	}
	,get_stackable: function() {
		if(this.get_consumableEntity() != null) {
			return this.get_consumableEntity().stackable;
		} else {
			return false;
		}
	}
	,get_useRange: function() {
		if(this.get_consumableEntity() != null) {
			return this.get_consumableEntity().useRange;
		} else {
			return 0;
		}
	}
	,get_quantity: function() {
		if(this.get_consumableEntity() != null) {
			return this.get_consumableEntity().charges;
		} else {
			return 0;
		}
	}
	,get_rarity: function() {
		return "common";
	}
	,get_consumableType: function() {
		if(this.get_consumableEntity() != null) {
			return this.get_consumableEntity().effectId;
		} else {
			return "";
		}
	}
	,get_effectValue: function() {
		return 10.0;
	}
	,reset: function() {
		game_mvp_model_entities_BaseEntityModel.prototype.reset.call(this);
		this.glowIntensity = 0.0;
		this.pulsePhase = 0.0;
	}
	,__class__: game_mvp_model_entities_ConsumableModel
});
var game_mvp_model_entities_EffectModel = function() {
	game_mvp_model_entities_BaseEntityModel.call(this);
	this.particleCount = 5;
	this.animationPhase = 0.0;
	this.intensity = 1.0;
};
$hxClasses["game.mvp.model.entities.EffectModel"] = game_mvp_model_entities_EffectModel;
game_mvp_model_entities_EffectModel.__name__ = "game.mvp.model.entities.EffectModel";
game_mvp_model_entities_EffectModel.__super__ = game_mvp_model_entities_BaseEntityModel;
game_mvp_model_entities_EffectModel.prototype = $extend(game_mvp_model_entities_BaseEntityModel.prototype,{
	get_effectEntity: function() {
		return js_Boot.__cast(this.engineEntity , engine_model_entities_impl_EngineEffectEntity);
	}
	,initializeEffect: function(effectEntity) {
		game_mvp_model_entities_BaseEntityModel.prototype.initialize.call(this,effectEntity);
		this.setEffectVisuals();
	}
	,setEffectVisuals: function() {
		if(this.get_effectEntity() == null) {
			return;
		}
		switch(this.get_effectEntity().effectType) {
		case "damage":
			this.color = 16711680;
			this.particleCount = 8;
			break;
		case "heal":
			this.color = 65280;
			this.particleCount = 6;
			break;
		case "shield":
			this.color = 255;
			this.particleCount = 10;
			break;
		case "speed_boost":
			this.color = 65535;
			this.particleCount = 4;
			break;
		default:
			this.color = 16711935;
			this.particleCount = 5;
		}
	}
	,update: function(dt) {
		if(this.get_effectEntity() == null) {
			return;
		}
		this.animationPhase += dt * 4.0;
		if(this.animationPhase > Math.PI * 2) {
			this.animationPhase -= Math.PI * 2;
		}
		this.intensity = this.getDurationPercentage();
		var animScale = 1.0 + Math.sin(this.animationPhase) * 0.2 * this.intensity;
		this.visualScale = animScale;
		this.needsVisualUpdate = true;
	}
	,isExpired: function() {
		if(this.get_effectEntity() != null) {
			if(this.get_effectEntity().durationTicks > 0) {
				return !this.get_isAlive();
			} else {
				return true;
			}
		} else {
			return true;
		}
	}
	,getDurationPercentage: function() {
		if(this.get_effectEntity() == null) {
			return 0.0;
		}
		var maxDurationTicks = this.get_effectEntity().durationTicks * 60;
		if(maxDurationTicks > 0) {
			return this.get_effectEntity().durationTicks / maxDurationTicks;
		} else {
			return 0.0;
		}
	}
	,getEffectDescription: function() {
		if(this.get_effectEntity() == null) {
			return "Unknown effect";
		}
		switch(this.get_effectEntity().effectType) {
		case "damage":
			return "Deals damage over time";
		case "heal":
			return "Heals over time";
		case "shield":
			return "Provides damage absorption";
		case "speed_boost":
			return "Increases speed";
		default:
			return "Unknown effect";
		}
	}
	,applyEffect: function() {
		if(this.get_effectEntity() != null) {
			return this.get_effectEntity().intensity;
		} else {
			return 0.0;
		}
	}
	,get_effectType: function() {
		if(this.get_effectEntity() != null) {
			return this.get_effectEntity().effectType;
		} else {
			return "";
		}
	}
	,get_durationTicks: function() {
		if(this.get_effectEntity() != null) {
			return this.get_effectEntity().durationTicks;
		} else {
			return 0;
		}
	}
	,get_effectIntensity: function() {
		if(this.get_effectEntity() != null) {
			return this.get_effectEntity().intensity;
		} else {
			return 0.0;
		}
	}
	,get_targetId: function() {
		if(this.get_effectEntity() != null) {
			return this.get_effectEntity().targetId;
		} else {
			return 0;
		}
	}
	,get_casterId: function() {
		if(this.get_effectEntity() != null) {
			return this.get_effectEntity().casterId;
		} else {
			return 0;
		}
	}
	,get_duration: function() {
		if(this.get_effectEntity() != null) {
			return this.get_effectEntity().durationTicks / 60.0;
		} else {
			return 0.0;
		}
	}
	,reset: function() {
		game_mvp_model_entities_BaseEntityModel.prototype.reset.call(this);
		this.particleCount = 5;
		this.animationPhase = 0.0;
		this.intensity = 1.0;
	}
	,__class__: game_mvp_model_entities_EffectModel
});
var game_mvp_presenter_EntitySyncPresenter = function(engine,gameClientState) {
	this.engine = engine;
	this.gameClientState = gameClientState;
	this.eventBus = engine.getEventBus();
	this.eventTokens = [];
	this.isSubscribed = false;
	this.lastSyncTick = 0;
	this.lastServerSnapshot = null;
	this.reconciliationThreshold = 0.1;
	this.isReconciling = false;
};
$hxClasses["game.mvp.presenter.EntitySyncPresenter"] = game_mvp_presenter_EntitySyncPresenter;
game_mvp_presenter_EntitySyncPresenter.__name__ = "game.mvp.presenter.EntitySyncPresenter";
game_mvp_presenter_EntitySyncPresenter.prototype = {
	subscribeToEvents: function(eventBus) {
		if(this.isSubscribed) {
			return;
		}
		this.eventBus = eventBus;
		var spawnToken = eventBus.subscribe("entity:spawn",$bind(this,this.onEntitySpawn));
		var deathToken = eventBus.subscribe("entity:death",$bind(this,this.onEntityDeath));
		var moveToken = eventBus.subscribe("entity:move",$bind(this,this.onEntityMove));
		var correctionToken = eventBus.subscribe("entity:correction",$bind(this,this.onEntityCorrection));
		var damageToken = eventBus.subscribe("entity:damage",$bind(this,this.onEntityDamage));
		var collisionToken = eventBus.subscribe("entity:collision",$bind(this,this.onEntityCollision));
		var triggerToken = eventBus.subscribe("collider:trigger",$bind(this,this.onColliderTrigger));
		this.eventTokens.push(spawnToken);
		this.eventTokens.push(deathToken);
		this.eventTokens.push(moveToken);
		this.eventTokens.push(correctionToken);
		this.eventTokens.push(damageToken);
		this.eventTokens.push(collisionToken);
		this.eventTokens.push(triggerToken);
		this.isSubscribed = true;
		haxe_Log.trace("EntitySyncPresenter subscribed to engine events",{ fileName : "src/game/mvp/presenter/EntitySyncPresenter.hx", lineNumber : 82, className : "game.mvp.presenter.EntitySyncPresenter", methodName : "subscribeToEvents"});
	}
	,unsubscribeFromEvents: function() {
		if(!this.isSubscribed) {
			return;
		}
		var _g = 0;
		var _g1 = this.eventTokens;
		while(_g < _g1.length) {
			var token = _g1[_g];
			++_g;
			this.eventBus.unsubscribe(token);
		}
		this.eventTokens = [];
		this.isSubscribed = false;
		haxe_Log.trace("EntitySyncPresenter unsubscribed from engine events",{ fileName : "src/game/mvp/presenter/EntitySyncPresenter.hx", lineNumber : 97, className : "game.mvp.presenter.EntitySyncPresenter", methodName : "unsubscribeFromEvents"});
	}
	,processEvents: function() {
	}
	,handleServerSnapshot: function(snapshot) {
		if(this.isReconciling) {
			return;
		}
		this.lastServerSnapshot = snapshot;
		if(this.shouldReconcile(snapshot)) {
			this.performReconciliation(snapshot);
		}
	}
	,shouldReconcile: function(serverSnapshot) {
		var engineConfig = game_mvp_presenter_GamePresenter.Config.engineConfig;
		if(engineConfig == null || engineConfig.mode != engine_EngineMode.CLIENT_PREDICTION) {
			return false;
		}
		var pendingInputs = this.gameClientState.getPendingInputs();
		if(pendingInputs.length == 0) {
			return false;
		}
		var playerEntity = this.gameClientState.getPlayerControlledEntity();
		if(playerEntity == null) {
			return false;
		}
		var serverEntity = this.findEntityInSnapshot(serverSnapshot,playerEntity.engineEntity.id);
		if(serverEntity == null) {
			return false;
		}
		var posDiff = Math.sqrt(Math.pow(playerEntity.engineEntity.pos.x - serverEntity.pos.x,2) + Math.pow(playerEntity.engineEntity.pos.y - serverEntity.pos.y,2));
		return posDiff > this.reconciliationThreshold;
	}
	,performReconciliation: function(serverSnapshot) {
		this.isReconciling = true;
		var pendingInputs = this.gameClientState.getPendingInputs();
		var anchorTick = this.findAnchorTick(pendingInputs);
		if(anchorTick > 0) {
			this.engine.rollbackAndReplay(anchorTick,pendingInputs);
			var lastSequence = this.getLastSequenceFromInputs(pendingInputs);
			if(lastSequence > 0) {
				this.gameClientState.clearAcknowledgedInputs(lastSequence);
			}
		}
		this.updateClientStateFromSnapshot(serverSnapshot);
		this.isReconciling = false;
	}
	,findAnchorTick: function(pendingInputs) {
		if(pendingInputs.length == 0) {
			return 0;
		}
		var minTick = pendingInputs[0].intendedServerTick;
		var _g = 0;
		while(_g < pendingInputs.length) {
			var input = pendingInputs[_g];
			++_g;
			if(input.intendedServerTick < minTick) {
				minTick = input.intendedServerTick;
			}
		}
		return minTick;
	}
	,getLastSequenceFromInputs: function(pendingInputs) {
		if(pendingInputs.length == 0) {
			return 0;
		}
		var maxSequence = pendingInputs[0].sequence;
		var _g = 0;
		while(_g < pendingInputs.length) {
			var input = pendingInputs[_g];
			++_g;
			if(input.sequence > maxSequence) {
				maxSequence = input.sequence;
			}
		}
		return maxSequence;
	}
	,findEntityInSnapshot: function(snapshot,entityId) {
		if(snapshot.entities == null) {
			return null;
		}
		var entities = snapshot.entities;
		var _g = 0;
		while(_g < entities.length) {
			var entity = entities[_g];
			++_g;
			if(entity.id == entityId) {
				return entity;
			}
		}
		return null;
	}
	,updateClientStateFromSnapshot: function(serverSnapshot) {
		if(serverSnapshot.entities == null) {
			return;
		}
		var entities = serverSnapshot.entities;
		var _g = 0;
		while(_g < entities.length) {
			var serverEntity = entities[_g];
			++_g;
			var clientModel = this.gameClientState.getEntity(serverEntity.id);
			if(clientModel != null && clientModel.engineEntity != null) {
				clientModel.engineEntity.pos.x = serverEntity.pos.x;
				clientModel.engineEntity.pos.y = serverEntity.pos.y;
				clientModel.engineEntity.vel.x = serverEntity.vel.x;
				clientModel.engineEntity.vel.y = serverEntity.vel.y;
				clientModel.needsVisualUpdate = true;
			}
		}
	}
	,onEntitySpawn: function(event) {
		var entityId = event.entityId;
		var entityType = event.type;
		var pos = event.pos;
		var ownerId = event.ownerId;
		var engineEntity;
		switch(entityType) {
		case "character":
			engineEntity = this.engine.getCharacterById(entityId);
			break;
		case "collider":
			engineEntity = this.engine.getColliderById(entityId);
			break;
		default:
			engineEntity = null;
		}
		if(engineEntity == null) {
			haxe_Log.trace("Warning: Could not get engine entity for id: " + entityId,{ fileName : "src/game/mvp/presenter/EntitySyncPresenter.hx", lineNumber : 271, className : "game.mvp.presenter.EntitySyncPresenter", methodName : "onEntitySpawn"});
			return;
		}
		var model = this.createModelForTypeAndInitialize(entityType,engineEntity);
		if(model == null) {
			haxe_Log.trace("Warning: Could not create model for entity type: " + entityType,{ fileName : "src/game/mvp/presenter/EntitySyncPresenter.hx", lineNumber : 278, className : "game.mvp.presenter.EntitySyncPresenter", methodName : "onEntitySpawn"});
			return;
		}
		if(model.engineEntity != null) {
			model.engineEntity.id = entityId;
			model.engineEntity.type = entityType;
			model.engineEntity.pos.x = pos.x;
			model.engineEntity.pos.y = pos.y;
			model.engineEntity.ownerId = ownerId;
			model.engineEntity.isAlive = true;
		}
		model.setVisualProperties();
		this.gameClientState.addEntity(model);
	}
	,onEntityDeath: function(event) {
		var entityId = event.entityId;
		var killerId = event.killerId;
		haxe_Log.trace("Entity died: ID=" + entityId + ", Killer=" + killerId,{ fileName : "src/game/mvp/presenter/EntitySyncPresenter.hx", lineNumber : 306, className : "game.mvp.presenter.EntitySyncPresenter", methodName : "onEntityDeath"});
		var model = this.gameClientState.getEntity(entityId);
		if(model != null && model.engineEntity != null) {
			model.engineEntity.isAlive = false;
			model.needsVisualUpdate = true;
		}
	}
	,onEntityMove: function(event) {
		var entityId = event.entityId;
		var pos = event.pos;
		var vel = event.vel;
		var model = this.gameClientState.getEntity(entityId);
		if(model != null && model.engineEntity != null) {
			model.engineEntity.pos.x = pos.x;
			model.engineEntity.pos.y = pos.y;
			model.engineEntity.vel.x = vel.x;
			model.engineEntity.vel.y = vel.y;
			model.needsVisualUpdate = true;
		}
	}
	,onEntityCorrection: function(event) {
		var entityId = event.entityId;
		var correctedPos = event.correctedPos;
		var correctedVel = event.correctedVel;
		haxe_Log.trace("Entity correction: ID=" + entityId + ", Pos=" + Std.string(correctedPos),{ fileName : "src/game/mvp/presenter/EntitySyncPresenter.hx", lineNumber : 343, className : "game.mvp.presenter.EntitySyncPresenter", methodName : "onEntityCorrection"});
		var model = this.gameClientState.getEntity(entityId);
		if(model != null && model.engineEntity != null) {
			model.engineEntity.pos.x = correctedPos.x;
			model.engineEntity.pos.y = correctedPos.y;
			model.engineEntity.vel.x = correctedVel.x;
			model.engineEntity.vel.y = correctedVel.y;
			model.needsVisualUpdate = true;
		}
	}
	,onEntityDamage: function(event) {
		var entityId = event.entityId;
		var damage = event.damage;
		var attackerId = event.attackerId;
		haxe_Log.trace("Entity damage: ID=" + entityId + ", Damage=" + damage + ", Attacker=" + attackerId,{ fileName : "src/game/mvp/presenter/EntitySyncPresenter.hx", lineNumber : 364, className : "game.mvp.presenter.EntitySyncPresenter", methodName : "onEntityDamage"});
		var model = this.gameClientState.getEntity(entityId);
		if(model != null && ((model) instanceof game_mvp_model_entities_CharacterModel)) {
			var characterModel = js_Boot.__cast(model , game_mvp_model_entities_CharacterModel);
			characterModel.takeDamage(damage);
		}
	}
	,onEntityCollision: function(event) {
		var entityIdA = event.entityIdA;
		var entityIdB = event.entityIdB;
		var contactPoint = event.contactPoint;
		var normal = event.normal;
		haxe_Log.trace("Entity collision: " + entityIdA + " vs " + entityIdB + ", Contact=" + Std.string(contactPoint),{ fileName : "src/game/mvp/presenter/EntitySyncPresenter.hx", lineNumber : 383, className : "game.mvp.presenter.EntitySyncPresenter", methodName : "onEntityCollision"});
		this.handleCollision(entityIdA == null ? "null" : "" + entityIdA,entityIdB == null ? "null" : "" + entityIdB,"collision");
	}
	,handleCollision: function(entityId1,entityId2,collisionType) {
		var model1 = this.gameClientState.getEntity(Std.parseInt(entityId1));
		var model2 = this.gameClientState.getEntity(Std.parseInt(entityId2));
		if(model1 == null || model2 == null) {
			return;
		}
		if(((model1) instanceof game_mvp_model_entities_CharacterModel) && ((model2) instanceof game_mvp_model_entities_ConsumableModel)) {
			this.handleCharacterConsumableCollision(js_Boot.__cast(model1 , game_mvp_model_entities_CharacterModel),js_Boot.__cast(model2 , game_mvp_model_entities_ConsumableModel));
		} else if(((model2) instanceof game_mvp_model_entities_CharacterModel) && ((model1) instanceof game_mvp_model_entities_ConsumableModel)) {
			this.handleCharacterConsumableCollision(js_Boot.__cast(model2 , game_mvp_model_entities_CharacterModel),js_Boot.__cast(model1 , game_mvp_model_entities_ConsumableModel));
		}
		if(((model1) instanceof game_mvp_model_entities_CharacterModel) && ((model2) instanceof game_mvp_model_entities_EffectModel)) {
			this.handleCharacterEffectCollision(js_Boot.__cast(model1 , game_mvp_model_entities_CharacterModel),js_Boot.__cast(model2 , game_mvp_model_entities_EffectModel));
		} else if(((model2) instanceof game_mvp_model_entities_CharacterModel) && ((model1) instanceof game_mvp_model_entities_EffectModel)) {
			this.handleCharacterEffectCollision(js_Boot.__cast(model2 , game_mvp_model_entities_CharacterModel),js_Boot.__cast(model1 , game_mvp_model_entities_EffectModel));
		}
	}
	,handleCharacterConsumableCollision: function(character,consumable) {
		if(consumable.canConsume()) {
			switch(consumable.get_consumableType()) {
			case "health_potion":
				character.heal(consumable.get_effectValue() | 0);
				break;
			case "mana_potion":
				break;
			case "strength_potion":
				break;
			}
			consumable.consume();
			haxe_Log.trace("Character " + character.get_id() + " consumed " + consumable.get_consumableType(),{ fileName : "src/game/mvp/presenter/EntitySyncPresenter.hx", lineNumber : 431, className : "game.mvp.presenter.EntitySyncPresenter", methodName : "handleCharacterConsumableCollision"});
		}
	}
	,handleCharacterEffectCollision: function(character,effect) {
		if(!effect.isExpired()) {
			var effectValue = effect.applyEffect();
			switch(effect.get_effectType()) {
			case "damage":
				character.takeDamage(effectValue | 0);
				break;
			case "heal":
				character.heal(effectValue | 0);
				break;
			case "shield":
				break;
			case "speed_boost":
				break;
			}
			haxe_Log.trace("Character " + character.get_id() + " affected by " + effect.get_effectType(),{ fileName : "src/game/mvp/presenter/EntitySyncPresenter.hx", lineNumber : 454, className : "game.mvp.presenter.EntitySyncPresenter", methodName : "handleCharacterEffectCollision"});
		}
	}
	,onColliderTrigger: function(event) {
		var entityId = event.entityId;
		var colliderId = event.colliderId;
		var triggerPos = event.triggerPos;
		haxe_Log.trace("Collider trigger: Entity=" + entityId + ", Collider=" + colliderId + ", Pos=" + Std.string(triggerPos),{ fileName : "src/game/mvp/presenter/EntitySyncPresenter.hx", lineNumber : 466, className : "game.mvp.presenter.EntitySyncPresenter", methodName : "onColliderTrigger"});
	}
	,createModelForTypeAndInitialize: function(entityType,engineEntity) {
		var clientModel = null;
		switch(entityType) {
		case "character":
			clientModel = new game_mvp_model_entities_CharacterModel();
			break;
		case "collider":
			clientModel = new game_mvp_model_entities_ColliderModel();
			break;
		case "consumable":
			clientModel = new game_mvp_model_entities_ConsumableModel();
			break;
		case "effect":
			clientModel = new game_mvp_model_entities_EffectModel();
			break;
		default:
		}
		if(clientModel == null) {
			haxe_Log.trace("Warning: Could not create model for entity type: " + entityType,{ fileName : "src/game/mvp/presenter/EntitySyncPresenter.hx", lineNumber : 489, className : "game.mvp.presenter.EntitySyncPresenter", methodName : "createModelForTypeAndInitialize"});
			return null;
		}
		clientModel.initialize(engineEntity);
		return clientModel;
	}
	,getSyncStats: function() {
		return { isSubscribed : this.isSubscribed, eventTokenCount : this.eventTokens.length, lastSyncTick : this.lastSyncTick, gameClientStateCount : this.gameClientState.getTotalEntityCount()};
	}
	,destroy: function() {
		this.unsubscribeFromEvents();
		this.engine = null;
		this.gameClientState = null;
		this.eventBus = null;
	}
	,__class__: game_mvp_presenter_EntitySyncPresenter
};
var game_mvp_presenter_GamePresenter = function(parent) {
	this.isRunning = false;
	this.currentTick = 0;
	this.lastUpdateTime = 0;
	this.frameCount = 0;
	this.fps = 0;
	this.initializeComponents(parent);
};
$hxClasses["game.mvp.presenter.GamePresenter"] = game_mvp_presenter_GamePresenter;
game_mvp_presenter_GamePresenter.__name__ = "game.mvp.presenter.GamePresenter";
game_mvp_presenter_GamePresenter.prototype = {
	initializeComponents: function(parent) {
		this.gameClientState = new game_mvp_model_GameClientState();
		this.viewOrchestrator = new game_mvp_view_GameViewOrchestrator(this.gameClientState,parent,js_Boot.__cast(parent , h2d_Scene));
		this.engine = engine_NecrotonEngine.create(game_mvp_presenter_GamePresenter.Config.engineConfig);
		this.inputPresenter = new game_mvp_presenter_InputPresenter(this.engine,this.gameClientState);
		this.entitySyncPresenter = new game_mvp_presenter_EntitySyncPresenter(this.engine,this.gameClientState);
		this.setupEventSubscriptions();
	}
	,setupEventSubscriptions: function() {
		var eventBus = this.engine.getEventBus();
		this.entitySyncPresenter.subscribeToEvents(eventBus);
	}
	,start: function() {
		if(this.isRunning) {
			return;
		}
		this.isRunning = true;
		this.engine.start();
		this.spawnInitialEntities();
		haxe_Log.trace("GamePresenter started",{ fileName : "src/game/mvp/presenter/GamePresenter.hx", lineNumber : 93, className : "game.mvp.presenter.GamePresenter", methodName : "start"});
	}
	,stop: function() {
		if(!this.isRunning) {
			return;
		}
		this.isRunning = false;
		this.engine.stop();
		haxe_Log.trace("GamePresenter stopped",{ fileName : "src/game/mvp/presenter/GamePresenter.hx", lineNumber : 105, className : "game.mvp.presenter.GamePresenter", methodName : "stop"});
	}
	,update: function(dt) {
		if(!this.isRunning) {
			return;
		}
		this.updatePerformanceTracking(dt);
		this.inputPresenter.update(dt,this.engine.getCurrentTick());
		this.engine.step(dt);
		this.entitySyncPresenter.processEvents();
		this.gameClientState.update(dt,this.currentTick);
		this.viewOrchestrator.syncWithModels();
		this.viewOrchestrator.update(dt);
		this.gameClientState.cleanupDeadEntities();
		this.currentTick++;
	}
	,updatePerformanceTracking: function(dt) {
		this.frameCount++;
		this.lastUpdateTime += dt;
		if(this.lastUpdateTime >= 1.0) {
			this.fps = this.frameCount / this.lastUpdateTime;
			this.frameCount = 0;
			this.lastUpdateTime = 0;
		}
	}
	,spawnInitialEntities: function() {
		var playerSpec = engine_model_entities_EngineEntitySpecs.getPlayerCharacterSpec();
		var playerId = this.engine.spawnEntity(playerSpec);
		this.gameClientState.setPlayerControlledEntity(playerId);
		this.inputPresenter.setControlledEntity(playerId,"player1");
		var inputModule = this.engine.getInputModule();
		if(inputModule != null) {
			inputModule.setClientEntity("player1",playerId);
		}
		var cameraController = this.viewOrchestrator.getCameraController();
		if(cameraController != null) {
			cameraController.followEntity(playerId);
		}
		this.spawnMapColliders();
	}
	,spawnEntity: function(spec) {
		return this.engine.spawnEntity(spec);
	}
	,despawnEntity: function(entityId) {
		this.engine.despawnEntity(entityId);
	}
	,getGameClientState: function() {
		return this.gameClientState;
	}
	,getViewOrchestrator: function() {
		return this.viewOrchestrator;
	}
	,getEngine: function() {
		return this.engine;
	}
	,getInputPresenter: function() {
		return this.inputPresenter;
	}
	,getEntitySyncPresenter: function() {
		return this.entitySyncPresenter;
	}
	,getCameraController: function() {
		return this.viewOrchestrator.getCameraController();
	}
	,updateCameraCentering: function() {
		this.viewOrchestrator.updateCameraCentering();
	}
	,isGameRunning: function() {
		return this.isRunning;
	}
	,getCurrentTick: function() {
		return this.currentTick;
	}
	,getFPS: function() {
		return this.fps;
	}
	,getGameStateSummary: function() {
		return { isRunning : this.isRunning, currentTick : this.currentTick, fps : this.fps, gameClientState : this.gameClientState.getStateSummary(), viewOrchestrator : this.viewOrchestrator.getOrchestratorSummary()};
	}
	,setDebugInfoVisible: function(visible) {
		this.viewOrchestrator.setDebugInfoVisible(visible);
	}
	,setObjectPoolingEnabled: function(enabled) {
		this.viewOrchestrator.setObjectPoolingEnabled(enabled);
	}
	,handleServerSnapshot: function(snapshot) {
		this.entitySyncPresenter.handleServerSnapshot(snapshot);
	}
	,handleServerAcknowledgment: function(acknowledgedSequence) {
		this.inputPresenter.handleServerAcknowledgment(acknowledgedSequence);
	}
	,destroy: function() {
		this.stop();
		if(this.viewOrchestrator != null) {
			this.viewOrchestrator.destroy();
		}
		if(this.entitySyncPresenter != null) {
			this.entitySyncPresenter.destroy();
		}
		if(this.inputPresenter != null) {
			this.inputPresenter.destroy();
		}
		this.engine = null;
		this.gameClientState = null;
	}
	,spawnMapColliders: function() {
		var colliderSpecs = engine_model_entities_EngineEntitySpecs.generateMapColliders(1,1);
		var _g = 0;
		while(_g < colliderSpecs.length) {
			var spec = colliderSpecs[_g];
			++_g;
			this.engine.spawnEntity(spec);
		}
		haxe_Log.trace("Spawned " + colliderSpecs.length + " map colliders in chess pattern",{ fileName : "src/game/mvp/presenter/GamePresenter.hx", lineNumber : 378, className : "game.mvp.presenter.GamePresenter", methodName : "spawnMapColliders"});
	}
	,__class__: game_mvp_presenter_GamePresenter
};
var game_mvp_presenter_InputPresenter = function(engine,gameClientState) {
	this.engine = engine;
	this.gameClientState = gameClientState;
	this.clientId = "player1";
	this.sequenceNumber = 0;
	this.lastInputTime = 0;
	this.inputBuffer = [];
	this.maxBufferSize = 10;
	this.inputSensitivity = 1.0;
	this.inputDeadzone = 0.1;
	this.lastMovement = { x : 0.0, y : 0.0};
	this.inputFrameCounter = 0;
	this.inputSamplingRate = 1;
	this.estimatedLatency = 2;
	this.predictionHistory = [];
	this.maxPredictionHistory = 50;
};
$hxClasses["game.mvp.presenter.InputPresenter"] = game_mvp_presenter_InputPresenter;
game_mvp_presenter_InputPresenter.__name__ = "game.mvp.presenter.InputPresenter";
game_mvp_presenter_InputPresenter.prototype = {
	update: function(dt,engineTick) {
		this.inputFrameCounter++;
		var inputState = this.captureInputState();
		if(this.shouldSendInput(inputState)) {
			var inputMessage = this.createInputMessage(inputState,engineTick);
			this.queueInput(inputMessage);
			this.applyLocalPrediction(inputMessage);
		}
		this.lastMovement = { x : inputState.movement.x, y : inputState.movement.y};
		this.processInputBuffer();
	}
	,captureInputState: function() {
		var inputState = new game_mvp_presenter_InputState();
		inputState.movement = this.captureMovementInput();
		inputState.actions = this.captureActionInput();
		inputState.other = this.captureOtherInput();
		return inputState;
	}
	,captureMovementInput: function() {
		var movement = { x : 0.0, y : 0.0};
		if(hxd_Key.isDown(65) || hxd_Key.isDown(37)) {
			movement.x -= 1.0;
		}
		if(hxd_Key.isDown(68) || hxd_Key.isDown(39)) {
			movement.x += 1.0;
		}
		if(hxd_Key.isDown(87) || hxd_Key.isDown(38)) {
			movement.y -= 1.0;
		}
		if(hxd_Key.isDown(83) || hxd_Key.isDown(40)) {
			movement.y += 1.0;
		}
		if(Math.abs(movement.x) < this.inputDeadzone) {
			movement.x = 0.0;
		}
		if(Math.abs(movement.y) < this.inputDeadzone) {
			movement.y = 0.0;
		}
		movement.x *= this.inputSensitivity;
		movement.y *= this.inputSensitivity;
		return movement;
	}
	,captureActionInput: function() {
		var actions = [];
		if(hxd_Key.isPressed(32)) {
			actions.push({ type : "primary_action", timestamp : hxd_Timer.lastTimeStamp});
		}
		if(hxd_Key.isPressed(16)) {
			actions.push({ type : "secondary_action", timestamp : hxd_Timer.lastTimeStamp});
		}
		if(hxd_Key.isPressed(49)) {
			actions.push({ type : "ability", timestamp : hxd_Timer.lastTimeStamp});
		}
		if(hxd_Key.isPressed(50)) {
			actions.push({ type : "ability", timestamp : hxd_Timer.lastTimeStamp});
		}
		if(hxd_Key.isPressed(51)) {
			actions.push({ type : "ability", timestamp : hxd_Timer.lastTimeStamp});
		}
		return actions;
	}
	,captureOtherInput: function() {
		var other = [];
		if(hxd_Key.isPressed(27)) {
			other.push({ type : "menu", timestamp : hxd_Timer.lastTimeStamp});
		}
		if(hxd_Key.isPressed(9)) {
			other.push({ type : "inventory", timestamp : hxd_Timer.lastTimeStamp});
		}
		return other;
	}
	,hasInput: function(inputState) {
		var hasMovement = Math.abs(inputState.movement.x) > 0 || Math.abs(inputState.movement.y) > 0;
		var hasActions = inputState.actions.length > 0;
		var hasOther = inputState.other.length > 0;
		if(!(hasMovement || hasActions)) {
			return hasOther;
		} else {
			return true;
		}
	}
	,shouldSendInput: function(inputState) {
		if(!this.hasInput(inputState)) {
			return false;
		}
		if(inputState.actions.length > 0 || inputState.other.length > 0) {
			return true;
		}
		var movementChanged = inputState.movement.x != this.lastMovement.x || inputState.movement.y != this.lastMovement.y;
		var intervalReached = this.inputFrameCounter % this.inputSamplingRate == 0;
		if(!movementChanged) {
			return intervalReached;
		} else {
			return true;
		}
	}
	,createInputMessage: function(inputState,engineTick) {
		var currentTime = hxd_Timer.lastTimeStamp;
		var latencyOffset = 0;
		var engineConfig = game_mvp_presenter_GamePresenter.Config.engineConfig;
		if(engineConfig != null && engineConfig.mode == engine_EngineMode.CLIENT_PREDICTION) {
			latencyOffset = this.estimatedLatency;
		}
		var intendedTick = engineTick + 1 + latencyOffset;
		return { clientId : this.clientId, sequence : this.sequenceNumber++, clientTick : engineTick, intendedServerTick : intendedTick, movement : inputState.movement, actions : inputState.actions.concat(inputState.other), timestamp : currentTime};
	}
	,queueInput: function(inputMessage) {
		this.inputBuffer.push(inputMessage);
		if(this.inputBuffer.length > this.maxBufferSize) {
			this.inputBuffer.shift();
		}
		this.gameClientState.addPendingInput(inputMessage);
		this.engine.queueInput(inputMessage);
		this.lastInputTime = hxd_Timer.lastTimeStamp;
	}
	,processInputBuffer: function() {
		var currentTime = hxd_Timer.lastTimeStamp;
		var _g = [];
		var _g1 = 0;
		var _g2 = this.inputBuffer;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(currentTime - v.clientTick / 60.0 < 1.0) {
				_g.push(v);
			}
		}
		this.inputBuffer = _g;
	}
	,getInputBuffer: function() {
		return this.inputBuffer.slice();
	}
	,clearInputBuffer: function() {
		this.inputBuffer = [];
	}
	,setClientId: function(clientId) {
		this.clientId = clientId;
	}
	,getClientId: function() {
		return this.clientId;
	}
	,setControlledEntity: function(entityId,clientId) {
		this.controlledEntityId = entityId;
		this.clientId = clientId;
	}
	,getControlledEntityId: function() {
		return this.controlledEntityId;
	}
	,setInputSensitivity: function(sensitivity) {
		this.inputSensitivity = sensitivity;
	}
	,setInputDeadzone: function(deadzone) {
		this.inputDeadzone = deadzone;
	}
	,applyLocalPrediction: function(inputMessage) {
		var engineConfig = game_mvp_presenter_GamePresenter.Config.engineConfig;
		if(engineConfig == null || engineConfig.mode != engine_EngineMode.CLIENT_PREDICTION) {
			return;
		}
		if(this.controlledEntityId != null) {
			var character = this.engine.getCharacterById(this.controlledEntityId);
			if(character != null) {
				var dt = 0.016666666666666666;
				character.applyMovementStep(inputMessage.movement.x,inputMessage.movement.y,dt);
				this.predictionHistory.push({ sequence : inputMessage.sequence, input : inputMessage, predictedPos : { x : character.pos.x, y : character.pos.y}, predictedVel : { x : character.vel.x, y : character.vel.y}});
				if(this.predictionHistory.length > this.maxPredictionHistory) {
					this.predictionHistory.shift();
				}
			}
		}
	}
	,handleServerAcknowledgment: function(acknowledgedSequence) {
		this.gameClientState.clearAcknowledgedInputs(acknowledgedSequence);
		var _g = [];
		var _g1 = 0;
		var _g2 = this.predictionHistory;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(v.sequence > acknowledgedSequence) {
				_g.push(v);
			}
		}
		this.predictionHistory = _g;
	}
	,getInputStats: function() {
		return { clientId : this.clientId, sequenceNumber : this.sequenceNumber, bufferSize : this.inputBuffer.length, lastInputTime : this.lastInputTime, sensitivity : this.inputSensitivity, deadzone : this.inputDeadzone, predictionHistorySize : this.predictionHistory.length, pendingInputs : this.gameClientState.getPendingInputs().length};
	}
	,destroy: function() {
		this.inputBuffer = [];
		this.engine = null;
	}
	,__class__: game_mvp_presenter_InputPresenter
};
var game_mvp_presenter_InputState = function() {
	this.movement = { x : 0.0, y : 0.0};
	this.actions = [];
	this.other = [];
};
$hxClasses["game.mvp.presenter.InputState"] = game_mvp_presenter_InputState;
game_mvp_presenter_InputState.__name__ = "game.mvp.presenter.InputState";
game_mvp_presenter_InputState.prototype = {
	__class__: game_mvp_presenter_InputState
};
var game_mvp_view_EntityViewPool = function(maxPoolSize,initialPoolSize) {
	if(initialPoolSize == null) {
		initialPoolSize = 5;
	}
	if(maxPoolSize == null) {
		maxPoolSize = 50;
	}
	this.maxPoolSize = maxPoolSize;
	this.initialPoolSize = initialPoolSize;
	this.characterPool = [];
	this.consumablePool = [];
	this.effectPool = [];
	this.poolStats = new haxe_ds_StringMap();
	var this1 = this.poolStats;
	var value = new game_mvp_view_PoolStats();
	this1.h["character"] = value;
	var this1 = this.poolStats;
	var value = new game_mvp_view_PoolStats();
	this1.h["consumable"] = value;
	var this1 = this.poolStats;
	var value = new game_mvp_view_PoolStats();
	this1.h["effect"] = value;
	this.initializePools();
};
$hxClasses["game.mvp.view.EntityViewPool"] = game_mvp_view_EntityViewPool;
game_mvp_view_EntityViewPool.__name__ = "game.mvp.view.EntityViewPool";
game_mvp_view_EntityViewPool.prototype = {
	initializePools: function() {
		var _g = 0;
		var _g1 = this.initialPoolSize;
		while(_g < _g1) {
			var i = _g++;
			var view = new game_mvp_view_entities_CharacterEntityView();
			view.setPoolType("character");
			view.reset();
			this.characterPool.push(view);
		}
		var _g = 0;
		var _g1 = this.initialPoolSize;
		while(_g < _g1) {
			var i = _g++;
			var view = new game_mvp_view_entities_ConsumableEntityView();
			view.setPoolType("consumable");
			view.reset();
			this.consumablePool.push(view);
		}
		var _g = 0;
		var _g1 = this.initialPoolSize;
		while(_g < _g1) {
			var i = _g++;
			var view = new game_mvp_view_entities_EffectEntityView();
			view.setPoolType("effect");
			view.reset();
			this.effectPool.push(view);
		}
	}
	,acquire: function(type,parent) {
		var view = null;
		switch(type) {
		case "character":
			view = this.getFromPool(this.characterPool);
			if(view == null) {
				view = new game_mvp_view_entities_CharacterEntityView(parent);
				view.setPoolType("character");
			}
			break;
		case "consumable":
			view = this.getFromPool(this.consumablePool);
			if(view == null) {
				view = new game_mvp_view_entities_ConsumableEntityView(parent);
				view.setPoolType("consumable");
			}
			break;
		case "effect":
			view = this.getFromPool(this.effectPool);
			if(view == null) {
				view = new game_mvp_view_entities_EffectEntityView(parent);
				view.setPoolType("effect");
			}
			break;
		default:
			view = null;
		}
		if(view != null) {
			if(parent != null && view.parent != parent) {
				parent.addChild(view);
			}
			view.acquire();
			var stats = this.poolStats.h[type];
			stats.acquired++;
			stats.activeCount++;
		}
		return view;
	}
	,release: function(view) {
		if(view == null || !view.isInObjectPool()) {
			return;
		}
		var type = view.getPoolType();
		var stats = this.poolStats.h[type];
		view.release();
		switch(type) {
		case "character":
			if(this.characterPool.length < this.maxPoolSize) {
				this.characterPool.push(view);
			} else {
				view.destroy();
			}
			break;
		case "consumable":
			if(this.consumablePool.length < this.maxPoolSize) {
				this.consumablePool.push(view);
			} else {
				view.destroy();
			}
			break;
		case "effect":
			if(this.effectPool.length < this.maxPoolSize) {
				this.effectPool.push(view);
			} else {
				view.destroy();
			}
			break;
		default:
			view.destroy();
		}
		stats.released++;
		stats.activeCount--;
	}
	,getFromPool: function(pool) {
		if(pool.length > 0) {
			return pool.pop();
		}
		return null;
	}
	,getPoolSize: function(type) {
		switch(type) {
		case "character":
			return this.characterPool.length;
		case "consumable":
			return this.consumablePool.length;
		case "effect":
			return this.effectPool.length;
		default:
			return 0;
		}
	}
	,getTotalPoolSize: function() {
		return this.characterPool.length + this.consumablePool.length + this.effectPool.length;
	}
	,getActiveCount: function(type) {
		var stats = this.poolStats.h[type];
		return stats.activeCount;
	}
	,getTotalActiveCount: function() {
		var total = 0;
		var h = this.poolStats.h;
		var stats_h = h;
		var stats_keys = Object.keys(h);
		var stats_length = stats_keys.length;
		var stats_current = 0;
		while(stats_current < stats_length) {
			var stats = stats_h[stats_keys[stats_current++]];
			total += stats.activeCount;
		}
		return total;
	}
	,getPoolStats: function(type) {
		return this.poolStats.h[type];
	}
	,getAllPoolStats: function() {
		return this.poolStats;
	}
	,clear: function() {
		var _g = 0;
		var _g1 = this.characterPool;
		while(_g < _g1.length) {
			var view = _g1[_g];
			++_g;
			view.destroy();
		}
		var _g = 0;
		var _g1 = this.consumablePool;
		while(_g < _g1.length) {
			var view = _g1[_g];
			++_g;
			view.destroy();
		}
		var _g = 0;
		var _g1 = this.effectPool;
		while(_g < _g1.length) {
			var view = _g1[_g];
			++_g;
			view.destroy();
		}
		this.characterPool = [];
		this.consumablePool = [];
		this.effectPool = [];
		var h = this.poolStats.h;
		var stats_h = h;
		var stats_keys = Object.keys(h);
		var stats_length = stats_keys.length;
		var stats_current = 0;
		while(stats_current < stats_length) {
			var stats = stats_h[stats_keys[stats_current++]];
			stats.reset();
		}
	}
	,cleanup: function() {
		while(this.characterPool.length > this.initialPoolSize) {
			var view = this.characterPool.pop();
			view.destroy();
		}
		while(this.consumablePool.length > this.initialPoolSize) {
			var view = this.consumablePool.pop();
			view.destroy();
		}
		while(this.effectPool.length > this.initialPoolSize) {
			var view = this.effectPool.pop();
			view.destroy();
		}
	}
	,getPoolSummary: function() {
		return { totalPooled : this.getTotalPoolSize(), totalActive : this.getTotalActiveCount(), characterPool : { pooled : this.characterPool.length, active : this.getActiveCount("character"), acquired : this.poolStats.h["character"].acquired, released : this.poolStats.h["character"].released}, consumablePool : { pooled : this.consumablePool.length, active : this.getActiveCount("consumable"), acquired : this.poolStats.h["consumable"].acquired, released : this.poolStats.h["consumable"].released}, effectPool : { pooled : this.effectPool.length, active : this.getActiveCount("effect"), acquired : this.poolStats.h["effect"].acquired, released : this.poolStats.h["effect"].released}};
	}
	,__class__: game_mvp_view_EntityViewPool
};
var game_mvp_view_PoolStats = function() {
	this.acquired = 0;
	this.released = 0;
	this.activeCount = 0;
};
$hxClasses["game.mvp.view.PoolStats"] = game_mvp_view_PoolStats;
game_mvp_view_PoolStats.__name__ = "game.mvp.view.PoolStats";
game_mvp_view_PoolStats.prototype = {
	reset: function() {
		this.acquired = 0;
		this.released = 0;
		this.activeCount = 0;
	}
	,__class__: game_mvp_view_PoolStats
};
var game_mvp_view_GameViewOrchestrator = function(gameClientState,parent,scene) {
	this.gameClientState = gameClientState;
	this.parent = parent;
	this.scene = scene;
	this.entityViewPool = new game_mvp_view_EntityViewPool();
	this.entityViews = new haxe_ds_IntMap();
	this.viewLayers = new haxe_ds_StringMap();
	this.enableObjectPooling = true;
	this.enableInterpolation = true;
	this.showDebugInfo = false;
	this.createViewLayers();
	this.debugGraphics = new h2d_Graphics(parent);
	this.initializeCameraController();
};
$hxClasses["game.mvp.view.GameViewOrchestrator"] = game_mvp_view_GameViewOrchestrator;
game_mvp_view_GameViewOrchestrator.__name__ = "game.mvp.view.GameViewOrchestrator";
game_mvp_view_GameViewOrchestrator.prototype = {
	createViewLayers: function() {
		var characterLayer = new h2d_Object(this.parent);
		this.viewLayers.h["character"] = characterLayer;
		var consumableLayer = new h2d_Object(this.parent);
		this.viewLayers.h["consumable"] = consumableLayer;
		var effectLayer = new h2d_Object(this.parent);
		this.viewLayers.h["effect"] = effectLayer;
		var colliderLayer = new h2d_Object(this.parent);
		this.viewLayers.h["collider"] = colliderLayer;
	}
	,initializeCameraController: function() {
		var cameraConfig = game_mvp_view_camera_CameraConfig.createLerpConfig(0.15);
		var screenWidth = this.scene.width;
		var screenHeight = this.scene.height;
		cameraConfig.setViewportOffset(-screenWidth * 0.5,-screenHeight * 0.5);
		this.cameraController = new game_mvp_view_camera_CameraController(this.scene,this.gameClientState,cameraConfig);
	}
	,update: function(dt) {
		var view = this.entityViews.iterator();
		while(view.hasNext()) {
			var view1 = view.next();
			if(view1.isViewInitialized()) {
				view1.update();
			}
		}
		if(this.cameraController != null) {
			this.cameraController.update(dt);
		}
		if(this.showDebugInfo) {
			this.updateDebugGraphics();
		}
	}
	,syncWithModels: function() {
		var allModels = this.gameClientState.getAliveEntities();
		var modelsWithViews_h = { };
		var _g = 0;
		while(_g < allModels.length) {
			var model = allModels[_g];
			++_g;
			var this1 = this.entityViews;
			var key = model.get_id();
			var view = this1.h[key];
			if(view != null) {
				view.update();
				modelsWithViews_h[model.get_id()] = true;
			} else {
				this.createViewForModel(model);
				modelsWithViews_h[model.get_id()] = true;
			}
		}
		var viewsToRemove = [];
		var entityId = this.entityViews.keys();
		while(entityId.hasNext()) {
			var entityId1 = entityId.next();
			if(!modelsWithViews_h.hasOwnProperty(entityId1)) {
				viewsToRemove.push(entityId1);
			}
		}
		var _g = 0;
		while(_g < viewsToRemove.length) {
			var entityId = viewsToRemove[_g];
			++_g;
			this.removeView(entityId);
		}
	}
	,createViewForModel: function(model) {
		var view = null;
		var layer = null;
		switch(model.get_type()) {
		case "character":
			layer = this.viewLayers.h["character"];
			break;
		case "collider":
			layer = this.viewLayers.h["collider"];
			break;
		case "consumable":
			layer = this.viewLayers.h["consumable"];
			break;
		case "effect":
			layer = this.viewLayers.h["effect"];
			break;
		default:
			layer = this.viewLayers.h["character"];
		}
		if(layer == null) {
			return;
		}
		if(this.enableObjectPooling && model.get_type() != "collider") {
			view = this.entityViewPool.acquire(model.get_type(),layer);
		} else {
			switch(model.get_type()) {
			case "character":
				view = new game_mvp_view_entities_CharacterEntityView(layer);
				break;
			case "collider":
				view = new game_mvp_view_entities_ColliderEntityView(layer);
				break;
			case "consumable":
				view = new game_mvp_view_entities_ConsumableEntityView(layer);
				break;
			case "effect":
				view = new game_mvp_view_entities_EffectEntityView(layer);
				break;
			default:
				view = new game_mvp_view_entities_CharacterEntityView(layer);
			}
		}
		if(view != null) {
			view.initialize(model);
			var this1 = this.entityViews;
			var key = model.get_id();
			this1.h[key] = view;
		}
	}
	,removeView: function(entityId) {
		var view = this.entityViews.h[entityId];
		if(view != null) {
			this.entityViews.remove(entityId);
			if(this.enableObjectPooling) {
				this.entityViewPool.release(view);
			} else {
				view.destroy();
			}
		}
	}
	,getView: function(entityId) {
		return this.entityViews.h[entityId];
	}
	,getViewsByType: function(type) {
		var result = [];
		var view = this.entityViews.iterator();
		while(view.hasNext()) {
			var view1 = view.next();
			if(view1.getModel() != null && view1.getModel().get_type() == type) {
				result.push(view1);
			}
		}
		return result;
	}
	,getCharacterViews: function() {
		var result = [];
		var view = this.entityViews.iterator();
		while(view.hasNext()) {
			var view1 = view.next();
			if(((view1) instanceof game_mvp_view_entities_CharacterEntityView)) {
				result.push(view1);
			}
		}
		return result;
	}
	,getConsumableViews: function() {
		var result = [];
		var view = this.entityViews.iterator();
		while(view.hasNext()) {
			var view1 = view.next();
			if(((view1) instanceof game_mvp_view_entities_ConsumableEntityView)) {
				result.push(view1);
			}
		}
		return result;
	}
	,getEffectViews: function() {
		var result = [];
		var view = this.entityViews.iterator();
		while(view.hasNext()) {
			var view1 = view.next();
			if(((view1) instanceof game_mvp_view_entities_EffectEntityView)) {
				result.push(view1);
			}
		}
		return result;
	}
	,updateDebugGraphics: function() {
		this.debugGraphics.clear();
		var y = 10;
		var lineHeight = 15;
		this.debugGraphics.beginFill(0,0.7);
		this.debugGraphics.drawRect(10,10,200,100);
		this.debugGraphics.endFill();
		var poolSummary = this.entityViewPool.getPoolSummary();
		var _this = this.debugGraphics;
		_this.curA = 1.;
		_this.curR = 1.;
		_this.curG = 1.;
		_this.curB = 1.;
		this.debugGraphics.drawRect(15,y,10,10);
		y += lineHeight;
		this.debugGraphics.drawRect(15,y,10,10);
		y += lineHeight;
		this.debugGraphics.drawRect(15,y,10,10);
		y += lineHeight;
		this.debugGraphics.drawRect(15,y,10,10);
		y += lineHeight;
		this.debugGraphics.drawRect(15,y,10,10);
		y += lineHeight;
		this.debugGraphics.drawRect(15,y,10,10);
	}
	,setDebugInfoVisible: function(visible) {
		this.showDebugInfo = visible;
		if(this.debugGraphics != null) {
			this.debugGraphics.set_visible(visible);
		}
	}
	,setObjectPoolingEnabled: function(enabled) {
		this.enableObjectPooling = enabled;
	}
	,setInterpolationEnabled: function(enabled) {
		this.enableInterpolation = enabled;
	}
	,getViewCount: function() {
		var count = 0;
		var view = this.entityViews.iterator();
		while(view.hasNext()) {
			var view1 = view.next();
			++count;
		}
		return count;
	}
	,getViewCountByType: function(type) {
		return this.getViewsByType(type).length;
	}
	,clear: function() {
		var entityId = this.entityViews.keys();
		while(entityId.hasNext()) {
			var entityId1 = entityId.next();
			this.removeView(entityId1);
		}
		this.entityViews.h = { };
	}
	,destroy: function() {
		this.clear();
		var h = this.viewLayers.h;
		var layer_h = h;
		var layer_keys = Object.keys(h);
		var layer_length = layer_keys.length;
		var layer_current = 0;
		while(layer_current < layer_length) {
			var layer = layer_h[layer_keys[layer_current++]];
			if(layer != null && layer.parent != null) {
				layer.parent.removeChild(layer);
			}
		}
		this.viewLayers.h = Object.create(null);
		if(this.debugGraphics != null) {
			var _this = this.debugGraphics;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
			this.debugGraphics = null;
		}
		this.entityViewPool.clear();
	}
	,getCameraController: function() {
		return this.cameraController;
	}
	,updateCameraCentering: function() {
		if(this.cameraController != null) {
			var screenWidth = this.scene.width;
			var screenHeight = this.scene.height;
			this.cameraController.setViewportOffset(-screenWidth * 0.5,-screenHeight * 0.5);
		}
	}
	,getOrchestratorSummary: function() {
		return { viewCount : this.getViewCount(), characterViews : this.getViewCountByType("character"), consumableViews : this.getViewCountByType("consumable"), effectViews : this.getViewCountByType("effect"), poolSummary : this.entityViewPool.getPoolSummary(), objectPoolingEnabled : this.enableObjectPooling, interpolationEnabled : this.enableInterpolation, cameraState : this.cameraController != null ? this.cameraController.getCameraState() : null};
	}
	,__class__: game_mvp_view_GameViewOrchestrator
};
var game_mvp_view_camera_CameraConfig = function() {
	this.enabled = true;
	this.smoothingMode = game_mvp_view_camera_CameraSmoothingMode.LERP;
	this.smoothingValue = 0.15;
	this.viewportOffsetX = 0.0;
	this.viewportOffsetY = 0.0;
};
$hxClasses["game.mvp.view.camera.CameraConfig"] = game_mvp_view_camera_CameraConfig;
game_mvp_view_camera_CameraConfig.__name__ = "game.mvp.view.camera.CameraConfig";
game_mvp_view_camera_CameraConfig.createLerpConfig = function(lerpFactor) {
	var config = new game_mvp_view_camera_CameraConfig();
	config.smoothingMode = game_mvp_view_camera_CameraSmoothingMode.LERP;
	config.smoothingValue = lerpFactor;
	return config;
};
game_mvp_view_camera_CameraConfig.createDampingConfig = function(dampingTime) {
	var config = new game_mvp_view_camera_CameraConfig();
	config.smoothingMode = game_mvp_view_camera_CameraSmoothingMode.TIME_BASED_DAMPING;
	config.smoothingValue = dampingTime;
	return config;
};
game_mvp_view_camera_CameraConfig.createInstantConfig = function() {
	var config = new game_mvp_view_camera_CameraConfig();
	config.smoothingMode = game_mvp_view_camera_CameraSmoothingMode.LERP;
	config.smoothingValue = 0.0;
	return config;
};
game_mvp_view_camera_CameraConfig.prototype = {
	setViewportOffset: function(offsetX,offsetY) {
		this.viewportOffsetX = offsetX;
		this.viewportOffsetY = offsetY;
		return this;
	}
	,setSmoothing: function(mode,value) {
		this.smoothingMode = mode;
		this.smoothingValue = value;
		return this;
	}
	,setEnabled: function(enabled) {
		this.enabled = enabled;
		return this;
	}
	,__class__: game_mvp_view_camera_CameraConfig
};
var game_mvp_view_camera_CameraController = function(scene,gameClientState,config) {
	this.scene = scene;
	this.gameClientState = gameClientState;
	this.config = config;
	this.targetEntityId = null;
	this.isFollowing = false;
	this.currentX = scene._cameras[0].x;
	this.currentY = scene._cameras[0].y;
	this.velocityX = 0.0;
	this.velocityY = 0.0;
};
$hxClasses["game.mvp.view.camera.CameraController"] = game_mvp_view_camera_CameraController;
game_mvp_view_camera_CameraController.__name__ = "game.mvp.view.camera.CameraController";
game_mvp_view_camera_CameraController.prototype = {
	update: function(dt) {
		if(!this.config.enabled) {
			return;
		}
		if(this.isFollowing && this.targetEntityId != null) {
			var targetEntity = this.gameClientState.getEntity(this.targetEntityId);
			if(targetEntity != null && targetEntity.get_isAlive()) {
				this.updateCameraToTarget(targetEntity,dt);
			}
		}
	}
	,followEntity: function(entityId) {
		this.targetEntityId = entityId;
		this.isFollowing = true;
		var targetEntity = this.gameClientState.getEntity(entityId);
		if(targetEntity != null && targetEntity.get_isAlive()) {
			var targetPos = this.getTargetPosition(targetEntity);
			this.setCameraPosition(targetPos.x,targetPos.y);
		}
	}
	,stopFollowing: function() {
		this.isFollowing = false;
		this.targetEntityId = null;
	}
	,setFollowSmoothing: function(value) {
		this.config.smoothingValue = value;
	}
	,setSmoothingMode: function(mode) {
		this.config.smoothingMode = mode;
	}
	,getCameraPosition: function() {
		return { x : this.currentX, y : this.currentY};
	}
	,setCameraPosition: function(x,y) {
		this.currentX = x;
		this.currentY = y;
		var _this = this.scene._cameras[0];
		_this.posChanged = true;
		_this.x = x;
		var _this = this.scene._cameras[0];
		_this.posChanged = true;
		_this.y = y;
	}
	,getTargetEntityId: function() {
		return this.targetEntityId;
	}
	,isFollowingEntity: function() {
		if(this.isFollowing) {
			return this.targetEntityId != null;
		} else {
			return false;
		}
	}
	,updateCameraToTarget: function(targetEntity,dt) {
		var targetPos = this.getTargetPosition(targetEntity);
		var targetX = targetPos.x;
		var targetY = targetPos.y;
		switch(this.config.smoothingMode._hx_index) {
		case 0:
			this.updateCameraLerp(targetX,targetY,dt);
			break;
		case 1:
			this.updateCameraDamping(targetX,targetY,dt);
			break;
		}
	}
	,updateCameraLerp: function(targetX,targetY,dt) {
		var lerpFactor = this.config.smoothingValue;
		this.currentX += (targetX - this.currentX) * lerpFactor;
		this.currentY += (targetY - this.currentY) * lerpFactor;
		var _this = this.scene._cameras[0];
		_this.posChanged = true;
		_this.x = this.currentX;
		var _this = this.scene._cameras[0];
		_this.posChanged = true;
		_this.y = this.currentY;
	}
	,updateCameraDamping: function(targetX,targetY,dt) {
		var dampingTime = this.config.smoothingValue;
		var dampingFactor = 1.0 - Math.exp(-dt / dampingTime);
		this.velocityX += (targetX - this.currentX) * dampingFactor;
		this.velocityY += (targetY - this.currentY) * dampingFactor;
		this.currentX += this.velocityX * dt;
		this.currentY += this.velocityY * dt;
		var _this = this.scene._cameras[0];
		_this.posChanged = true;
		_this.x = this.currentX;
		var _this = this.scene._cameras[0];
		_this.posChanged = true;
		_this.y = this.currentY;
	}
	,getTargetPosition: function(entity) {
		return { x : entity.renderPos.x + this.config.viewportOffsetX, y : entity.renderPos.y + this.config.viewportOffsetY};
	}
	,setViewportOffset: function(offsetX,offsetY) {
		this.config.viewportOffsetX = offsetX;
		this.config.viewportOffsetY = offsetY;
	}
	,getConfig: function() {
		return this.config;
	}
	,setConfig: function(newConfig) {
		this.config = newConfig;
	}
	,resetToOrigin: function() {
		this.setCameraPosition(0,0);
		this.velocityX = 0.0;
		this.velocityY = 0.0;
	}
	,getCameraState: function() {
		return { isFollowing : this.isFollowing, targetEntityId : this.targetEntityId, currentPosition : { x : this.currentX, y : this.currentY}, smoothingMode : this.config.smoothingMode, smoothingValue : this.config.smoothingValue, enabled : this.config.enabled};
	}
	,__class__: game_mvp_view_camera_CameraController
};
var game_mvp_view_camera_CameraSmoothingMode = $hxEnums["game.mvp.view.camera.CameraSmoothingMode"] = { __ename__:true,__constructs__:null
	,LERP: {_hx_name:"LERP",_hx_index:0,__enum__:"game.mvp.view.camera.CameraSmoothingMode",toString:$estr}
	,TIME_BASED_DAMPING: {_hx_name:"TIME_BASED_DAMPING",_hx_index:1,__enum__:"game.mvp.view.camera.CameraSmoothingMode",toString:$estr}
};
game_mvp_view_camera_CameraSmoothingMode.__constructs__ = [game_mvp_view_camera_CameraSmoothingMode.LERP,game_mvp_view_camera_CameraSmoothingMode.TIME_BASED_DAMPING];
game_mvp_view_camera_CameraSmoothingMode.__empty_constructs__ = [game_mvp_view_camera_CameraSmoothingMode.LERP,game_mvp_view_camera_CameraSmoothingMode.TIME_BASED_DAMPING];
var h2d_col_PointImpl = function(x,y) {
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.x = x;
	this.y = y;
};
$hxClasses["h2d.col.PointImpl"] = h2d_col_PointImpl;
h2d_col_PointImpl.__name__ = "h2d.col.PointImpl";
h2d_col_PointImpl.prototype = {
	distanceSq: function(p) {
		var dx = this.x - p.x;
		var dy = this.y - p.y;
		return dx * dx + dy * dy;
	}
	,distance: function(p) {
		var dx = this.x - p.x;
		var dy = this.y - p.y;
		return Math.sqrt(dx * dx + dy * dy);
	}
	,toString: function() {
		return "{" + hxd_Math.fmt(this.x) + "," + hxd_Math.fmt(this.y) + "}";
	}
	,sub: function(p) {
		var x = this.x - p.x;
		var y = this.y - p.y;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h2d_col_PointImpl(x,y);
	}
	,add: function(p) {
		var x = this.x + p.x;
		var y = this.y + p.y;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h2d_col_PointImpl(x,y);
	}
	,scaled: function(v) {
		var x = this.x * v;
		var y = this.y * v;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h2d_col_PointImpl(x,y);
	}
	,equals: function(other) {
		if(this.x == other.x) {
			return this.y == other.y;
		} else {
			return false;
		}
	}
	,dot: function(p) {
		return this.x * p.x + this.y * p.y;
	}
	,lengthSq: function() {
		return this.x * this.x + this.y * this.y;
	}
	,length: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	}
	,normalize: function() {
		var k = this.x * this.x + this.y * this.y;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		this.x *= k;
		this.y *= k;
	}
	,normalized: function() {
		var k = this.x * this.x + this.y * this.y;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		var x = this.x * k;
		var y = this.y * k;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h2d_col_PointImpl(x,y);
	}
	,set: function(x,y) {
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		this.x = x;
		this.y = y;
	}
	,load: function(p) {
		this.x = p.x;
		this.y = p.y;
	}
	,scale: function(f) {
		this.x *= f;
		this.y *= f;
	}
	,clone: function() {
		var x = this.x;
		var y = this.y;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h2d_col_PointImpl(x,y);
	}
	,cross: function(p) {
		return this.x * p.y - this.y * p.x;
	}
	,lerp: function(a,b,k) {
		var a1 = a.x;
		this.x = a1 + k * (b.x - a1);
		var a1 = a.y;
		this.y = a1 + k * (b.y - a1);
	}
	,transform: function(m) {
		var mx = m.a * this.x + m.c * this.y + m.x;
		var my = m.b * this.x + m.d * this.y + m.y;
		this.x = mx;
		this.y = my;
	}
	,transformed: function(m) {
		var mx = m.a * this.x + m.c * this.y + m.x;
		var my = m.b * this.x + m.d * this.y + m.y;
		var x = mx;
		var y = my;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h2d_col_PointImpl(x,y);
	}
	,transform2x2: function(m) {
		var mx = m.a * this.x + m.c * this.y;
		var my = m.b * this.x + m.d * this.y;
		this.x = mx;
		this.y = my;
	}
	,transformed2x2: function(m) {
		var mx = m.a * this.x + m.c * this.y;
		var my = m.b * this.x + m.d * this.y;
		var x = mx;
		var y = my;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h2d_col_PointImpl(x,y);
	}
	,toIPoint: function(scale) {
		if(scale == null) {
			scale = 1.;
		}
		return new h2d_col_IPoint(Math.round(this.x * scale),Math.round(this.y * scale));
	}
	,rotate: function(angle) {
		var c = Math.cos(angle);
		var s = Math.sin(angle);
		var x2 = this.x * c - this.y * s;
		var y2 = this.x * s + this.y * c;
		this.x = x2;
		this.y = y2;
	}
	,__class__: h2d_col_PointImpl
};
var h2d_Object = function(parent) {
	this.blendMode = h2d_BlendMode.Alpha;
	this.alpha = 1.;
	this.visible = true;
	this.rotation = 0;
	this.scaleY = 1;
	this.scaleX = 1;
	this.y = 0;
	this.x = 0;
	this.matA = 1;
	this.matB = 0;
	this.matC = 0;
	this.matD = 1;
	this.absX = 0;
	this.absY = 0;
	this.posChanged = parent != null;
	this.children = [];
	if(parent != null) {
		parent.addChild(this);
	}
};
$hxClasses["h2d.Object"] = h2d_Object;
h2d_Object.__name__ = "h2d.Object";
h2d_Object.prototype = {
	getBounds: function(relativeTo,out) {
		if(out == null) {
			out = new h2d_col_Bounds();
		} else {
			out.xMin = 1e20;
			out.yMin = 1e20;
			out.xMax = -1e20;
			out.yMax = -1e20;
		}
		if(relativeTo != null) {
			relativeTo.syncPos();
		}
		if(relativeTo != this) {
			this.syncPos();
		}
		this.getBoundsRec(relativeTo,out,false);
		if(out.xMax <= out.xMin || out.yMax <= out.yMin) {
			this.addBounds(relativeTo,out,-1,-1,2,2);
			out.xMax = out.xMin = (out.xMax + out.xMin) * 0.5;
			out.yMax = out.yMin = (out.yMax + out.yMin) * 0.5;
		}
		return out;
	}
	,getSize: function(out) {
		if(out == null) {
			out = new h2d_col_Bounds();
		} else {
			out.xMin = 1e20;
			out.yMin = 1e20;
			out.xMax = -1e20;
			out.yMax = -1e20;
		}
		this.syncPos();
		this.getBoundsRec(this.parent,out,true);
		if(out.xMax <= out.xMin || out.yMax <= out.yMin) {
			this.addBounds(this.parent,out,-1,-1,2,2);
			out.xMax = out.xMin = (out.xMax + out.xMin) * 0.5;
			out.yMax = out.yMin = (out.yMax + out.yMin) * 0.5;
		}
		var dx = -this.x;
		var dy = -this.y;
		out.xMin += dx;
		out.xMax += dx;
		out.yMin += dy;
		out.yMax += dy;
		return out;
	}
	,getAbsPos: function() {
		this.syncPos();
		var m = new h2d_col_Matrix();
		m.a = this.matA;
		m.b = this.matB;
		m.c = this.matC;
		m.d = this.matD;
		m.x = this.absX;
		m.y = this.absY;
		return m;
	}
	,contains: function(o) {
		while(o != null) {
			o = o.parent;
			if(o == this) {
				return true;
			}
		}
		return false;
	}
	,find: function(f) {
		var v = f(this);
		if(v != null) {
			return v;
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var o = _g1[_g];
			++_g;
			var v = o.find(f);
			if(v != null) {
				return v;
			}
		}
		return null;
	}
	,findAll: function(f,arr) {
		if(arr == null) {
			arr = [];
		}
		var v = f(this);
		if(v != null) {
			arr.push(v);
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var o = _g1[_g];
			++_g;
			o.findAll(f,arr);
		}
		return arr;
	}
	,set_filter: function(f) {
		if(this.filter != null && this.allocated) {
			this.filter.unbind(this);
		}
		this.filter = f;
		if(f != null && this.allocated) {
			f.bind(this);
		}
		return f;
	}
	,getBoundsRec: function(relativeTo,out,forSize) {
		if(this.posChanged) {
			this.calcAbsPos();
			var _g = 0;
			var _g1 = this.children;
			while(_g < _g1.length) {
				var c = _g1[_g];
				++_g;
				c.posChanged = true;
			}
			this.posChanged = false;
		}
		var n = this.children.length;
		if(n == 0) {
			out.xMin = 1e20;
			out.yMin = 1e20;
			out.xMax = -1e20;
			out.yMax = -1e20;
			return;
		}
		if(n == 1) {
			var c = this.children[0];
			if(c.visible) {
				c.getBoundsRec(relativeTo,out,forSize);
			} else {
				out.xMin = 1e20;
				out.yMin = 1e20;
				out.xMax = -1e20;
				out.yMax = -1e20;
			}
			return;
		}
		var xmin = Infinity;
		var ymin = Infinity;
		var xmax = -Infinity;
		var ymax = -Infinity;
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			if(!c.visible) {
				continue;
			}
			c.getBoundsRec(relativeTo,out,forSize);
			if(out.xMin < xmin) {
				xmin = out.xMin;
			}
			if(out.yMin < ymin) {
				ymin = out.yMin;
			}
			if(out.xMax > xmax) {
				xmax = out.xMax;
			}
			if(out.yMax > ymax) {
				ymax = out.yMax;
			}
		}
		out.xMin = xmin;
		out.yMin = ymin;
		out.xMax = xmax;
		out.yMax = ymax;
	}
	,addBounds: function(relativeTo,out,dx,dy,width,height) {
		if(width <= 0 || height <= 0) {
			return;
		}
		if(relativeTo == null) {
			var x = dx * this.matA + dy * this.matC + this.absX;
			var y = dx * this.matB + dy * this.matD + this.absY;
			if(x < out.xMin) {
				out.xMin = x;
			}
			if(x > out.xMax) {
				out.xMax = x;
			}
			if(y < out.yMin) {
				out.yMin = y;
			}
			if(y > out.yMax) {
				out.yMax = y;
			}
			var x = (dx + width) * this.matA + dy * this.matC + this.absX;
			var y = (dx + width) * this.matB + dy * this.matD + this.absY;
			if(x < out.xMin) {
				out.xMin = x;
			}
			if(x > out.xMax) {
				out.xMax = x;
			}
			if(y < out.yMin) {
				out.yMin = y;
			}
			if(y > out.yMax) {
				out.yMax = y;
			}
			var x = dx * this.matA + (dy + height) * this.matC + this.absX;
			var y = dx * this.matB + (dy + height) * this.matD + this.absY;
			if(x < out.xMin) {
				out.xMin = x;
			}
			if(x > out.xMax) {
				out.xMax = x;
			}
			if(y < out.yMin) {
				out.yMin = y;
			}
			if(y > out.yMax) {
				out.yMax = y;
			}
			var x = (dx + width) * this.matA + (dy + height) * this.matC + this.absX;
			var y = (dx + width) * this.matB + (dy + height) * this.matD + this.absY;
			if(x < out.xMin) {
				out.xMin = x;
			}
			if(x > out.xMax) {
				out.xMax = x;
			}
			if(y < out.yMin) {
				out.yMin = y;
			}
			if(y > out.yMax) {
				out.yMax = y;
			}
			return;
		}
		if(relativeTo == this) {
			if(out.xMin > dx) {
				out.xMin = dx;
			}
			if(out.yMin > dy) {
				out.yMin = dy;
			}
			if(out.xMax < dx + width) {
				out.xMax = dx + width;
			}
			if(out.yMax < dy + height) {
				out.yMax = dy + height;
			}
			return;
		}
		var r = relativeTo.matA * relativeTo.matD - relativeTo.matB * relativeTo.matC;
		if(r == 0) {
			return;
		}
		var det = 1 / r;
		var rA = relativeTo.matD * det;
		var rB = -relativeTo.matB * det;
		var rC = -relativeTo.matC * det;
		var rD = relativeTo.matA * det;
		var rX = this.absX - relativeTo.absX;
		var rY = this.absY - relativeTo.absY;
		var x = dx * this.matA + dy * this.matC + rX;
		var y = dx * this.matB + dy * this.matD + rY;
		var x1 = x * rA + y * rC;
		var y1 = x * rB + y * rD;
		if(x1 < out.xMin) {
			out.xMin = x1;
		}
		if(x1 > out.xMax) {
			out.xMax = x1;
		}
		if(y1 < out.yMin) {
			out.yMin = y1;
		}
		if(y1 > out.yMax) {
			out.yMax = y1;
		}
		x = (dx + width) * this.matA + dy * this.matC + rX;
		y = (dx + width) * this.matB + dy * this.matD + rY;
		var x1 = x * rA + y * rC;
		var y1 = x * rB + y * rD;
		if(x1 < out.xMin) {
			out.xMin = x1;
		}
		if(x1 > out.xMax) {
			out.xMax = x1;
		}
		if(y1 < out.yMin) {
			out.yMin = y1;
		}
		if(y1 > out.yMax) {
			out.yMax = y1;
		}
		x = dx * this.matA + (dy + height) * this.matC + rX;
		y = dx * this.matB + (dy + height) * this.matD + rY;
		var x1 = x * rA + y * rC;
		var y1 = x * rB + y * rD;
		if(x1 < out.xMin) {
			out.xMin = x1;
		}
		if(x1 > out.xMax) {
			out.xMax = x1;
		}
		if(y1 < out.yMin) {
			out.yMin = y1;
		}
		if(y1 > out.yMax) {
			out.yMax = y1;
		}
		x = (dx + width) * this.matA + (dy + height) * this.matC + rX;
		y = (dx + width) * this.matB + (dy + height) * this.matD + rY;
		var x1 = x * rA + y * rC;
		var y1 = x * rB + y * rD;
		if(x1 < out.xMin) {
			out.xMin = x1;
		}
		if(x1 > out.xMax) {
			out.xMax = x1;
		}
		if(y1 < out.yMin) {
			out.yMin = y1;
		}
		if(y1 > out.yMax) {
			out.yMax = y1;
		}
	}
	,getObjectsCount: function() {
		var k = 0;
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			k += c.getObjectsCount() + 1;
		}
		return k;
	}
	,localToGlobal: function(pt) {
		this.syncPos();
		if(pt == null) {
			pt = new h2d_col_PointImpl(0.,0.);
		}
		var px = pt.x * this.matA + pt.y * this.matC + this.absX;
		var py = pt.x * this.matB + pt.y * this.matD + this.absY;
		pt.x = px;
		pt.y = py;
		return pt;
	}
	,globalToLocal: function(pt) {
		this.syncPos();
		pt.x -= this.absX;
		pt.y -= this.absY;
		var invDet = 1 / (this.matA * this.matD - this.matB * this.matC);
		var px = (pt.x * this.matD - pt.y * this.matC) * invDet;
		var py = (-pt.x * this.matB + pt.y * this.matA) * invDet;
		pt.x = px;
		pt.y = py;
		return pt;
	}
	,getScene: function() {
		var p = this;
		while(p.parent != null) p = p.parent;
		if(((p) instanceof h2d_Scene)) {
			return p;
		} else {
			return null;
		}
	}
	,set_visible: function(b) {
		if(this.visible == b) {
			return b;
		}
		this.visible = b;
		if(this.parentContainer != null) {
			this.parentContainer.contentChanged(this);
		}
		return b;
	}
	,addChild: function(s) {
		this.addChildAt(s,this.children.length);
	}
	,addChildAt: function(s,pos) {
		if(pos < 0) {
			pos = 0;
		}
		if(pos > this.children.length) {
			pos = this.children.length;
		}
		var p = this;
		while(p != null) {
			if(p == s) {
				throw haxe_Exception.thrown("Recursive addChild");
			}
			p = p.parent;
		}
		if(s.parent != null) {
			var old = s.allocated;
			s.allocated = false;
			s.parent.removeChild(s);
			s.allocated = old;
		}
		this.children.splice(pos,0,s);
		if(!this.allocated && s.allocated) {
			s.onRemove();
		}
		s.parent = this;
		s.parentContainer = this.parentContainer;
		s.posChanged = true;
		if(this.allocated) {
			if(!s.allocated) {
				s.onAdd();
			} else {
				s.onHierarchyMoved(true);
			}
		}
		if(this.parentContainer != null) {
			this.parentContainer.contentChanged(this);
		}
	}
	,onContentChanged: function() {
		if(this.parentContainer != null) {
			this.parentContainer.contentChanged(this);
		}
	}
	,onHierarchyMoved: function(parentChanged) {
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			c.onHierarchyMoved(parentChanged);
		}
	}
	,onAdd: function() {
		this.allocated = true;
		if(this.filter != null) {
			this.filter.bind(this);
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			c.onAdd();
		}
	}
	,onRemove: function() {
		this.allocated = false;
		if(this.filter != null) {
			this.filter.unbind(this);
		}
		var i = this.children.length - 1;
		while(i >= 0) {
			var c = this.children[i--];
			if(c != null) {
				c.onRemove();
			}
		}
	}
	,getMatrix: function(m) {
		m.a = this.matA;
		m.b = this.matB;
		m.c = this.matC;
		m.d = this.matD;
		m.x = this.absX;
		m.y = this.absY;
	}
	,removeChild: function(s) {
		if(HxOverrides.remove(this.children,s)) {
			if(s.allocated) {
				s.onRemove();
			}
			s.parent = null;
			if(s.parentContainer != null) {
				s.setParentContainer(null);
			}
			s.posChanged = true;
			if(this.parentContainer != null) {
				this.parentContainer.contentChanged(this);
			}
		}
	}
	,setParentContainer: function(c) {
		this.parentContainer = c;
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			s.setParentContainer(c);
		}
	}
	,removeChildren: function() {
		while(this.children.length > 0) this.removeChild(this.getChildAt(0));
	}
	,remove: function() {
		if(this.parent != null) {
			this.parent.removeChild(this);
		}
	}
	,drawTo: function(t) {
		var s = this.getScene();
		var needDispose = s == null;
		if(s == null) {
			s = new h2d_Scene();
		}
		s.drawImplTo(this,[t]);
		if(needDispose) {
			s.dispose();
			this.onRemove();
		}
	}
	,drawToTextures: function(texs,outputs) {
		var s = this.getScene();
		var needDispose = s == null;
		if(s == null) {
			s = new h2d_Scene();
		}
		s.drawImplTo(this,texs,outputs);
		if(needDispose) {
			s.dispose();
			this.onRemove();
		}
	}
	,draw: function(ctx) {
	}
	,sync: function(ctx) {
		var changed = this.posChanged;
		if(changed) {
			this.calcAbsPos();
			this.posChanged = false;
		}
		this.lastFrame = ctx.frame;
		var p = 0;
		var len = this.children.length;
		while(p < len) {
			var c = this.children[p];
			if(c == null) {
				break;
			}
			if(c.lastFrame != ctx.frame) {
				if(changed) {
					c.posChanged = true;
				}
				c.sync(ctx);
			}
			if(this.children[p] != c) {
				p = 0;
				len = this.children.length;
			} else {
				++p;
			}
		}
	}
	,syncPos: function() {
		if(this.parent != null) {
			this.parent.syncPos();
		}
		if(this.posChanged) {
			this.calcAbsPos();
			var _g = 0;
			var _g1 = this.children;
			while(_g < _g1.length) {
				var c = _g1[_g];
				++_g;
				c.posChanged = true;
			}
			this.posChanged = false;
		}
	}
	,calcAbsPos: function() {
		if(this.parent == null) {
			var cr;
			var sr;
			if(this.rotation == 0) {
				cr = 1.;
				sr = 0.;
				this.matA = this.scaleX;
				this.matB = 0;
				this.matC = 0;
				this.matD = this.scaleY;
			} else {
				cr = Math.cos(this.rotation);
				sr = Math.sin(this.rotation);
				this.matA = this.scaleX * cr;
				this.matB = this.scaleX * sr;
				this.matC = this.scaleY * -sr;
				this.matD = this.scaleY * cr;
			}
			this.absX = this.x;
			this.absY = this.y;
		} else {
			if(this.rotation == 0) {
				this.matA = this.scaleX * this.parent.matA;
				this.matB = this.scaleX * this.parent.matB;
				this.matC = this.scaleY * this.parent.matC;
				this.matD = this.scaleY * this.parent.matD;
			} else {
				var cr = Math.cos(this.rotation);
				var sr = Math.sin(this.rotation);
				var tmpA = this.scaleX * cr;
				var tmpB = this.scaleX * sr;
				var tmpC = this.scaleY * -sr;
				var tmpD = this.scaleY * cr;
				this.matA = tmpA * this.parent.matA + tmpB * this.parent.matC;
				this.matB = tmpA * this.parent.matB + tmpB * this.parent.matD;
				this.matC = tmpC * this.parent.matA + tmpD * this.parent.matC;
				this.matD = tmpC * this.parent.matB + tmpD * this.parent.matD;
			}
			this.absX = this.x * this.parent.matA + this.y * this.parent.matC + this.parent.absX;
			this.absY = this.x * this.parent.matB + this.y * this.parent.matD + this.parent.absY;
		}
	}
	,emitTile: function(ctx,tile) {
		if(h2d_Object.nullDrawable == null) {
			h2d_Object.nullDrawable = new h2d_Drawable(null);
		}
		h2d_Object.nullDrawable.smooth = this.filter != null && this.filter.smooth ? true : null;
		h2d_Object.nullDrawable.absX = this.absX;
		h2d_Object.nullDrawable.absY = this.absY;
		h2d_Object.nullDrawable.matA = this.matA;
		h2d_Object.nullDrawable.matB = this.matB;
		h2d_Object.nullDrawable.matC = this.matC;
		h2d_Object.nullDrawable.matD = this.matD;
		ctx.drawTile(h2d_Object.nullDrawable,tile);
	}
	,clipBounds: function(ctx,bounds,scaleX,scaleY) {
		if(scaleY == null) {
			scaleY = 1.;
		}
		if(scaleX == null) {
			scaleX = 1.;
		}
		var view = ctx.tmpBounds;
		var matA;
		var matB;
		var matC;
		var matD;
		var absX;
		var absY;
		if(ctx.inFilter != null) {
			var f1 = ctx.baseShader.filterMatrixA__;
			var f2 = ctx.baseShader.filterMatrixB__;
			var tmpA = this.matA * f1.x + this.matB * f1.y;
			var tmpB = this.matA * f2.x + this.matB * f2.y;
			var tmpC = this.matC * f1.x + this.matD * f1.y;
			var tmpD = this.matC * f2.x + this.matD * f2.y;
			var tmpX = this.absX * f1.x + this.absY * f1.y + f1.z;
			var tmpY = this.absX * f2.x + this.absY * f2.y + f2.z;
			matA = (tmpA * ctx.viewA + tmpB * ctx.viewC) / scaleX;
			matB = (tmpA * ctx.viewB + tmpB * ctx.viewD) / scaleY;
			matC = (tmpC * ctx.viewA + tmpD * ctx.viewC) / scaleX;
			matD = (tmpC * ctx.viewB + tmpD * ctx.viewD) / scaleY;
			absX = tmpX * ctx.viewA + tmpY * ctx.viewC + ctx.viewX;
			absY = tmpX * ctx.viewB + tmpY * ctx.viewD + ctx.viewY;
		} else {
			matA = (this.matA * ctx.viewA + this.matB * ctx.viewC) / scaleX;
			matB = (this.matA * ctx.viewB + this.matB * ctx.viewD) / scaleY;
			matC = (this.matC * ctx.viewA + this.matD * ctx.viewC) / scaleX;
			matD = (this.matC * ctx.viewB + this.matD * ctx.viewD) / scaleY;
			absX = this.absX * ctx.viewA + this.absY * ctx.viewC + ctx.viewX;
			absY = this.absX * ctx.viewB + this.absY * ctx.viewD + ctx.viewY;
		}
		view.xMin = 1e20;
		view.yMin = 1e20;
		view.xMax = -1e20;
		view.yMax = -1e20;
		var x = bounds.xMin;
		var y = bounds.yMin;
		var x1 = x * matA + y * matC + absX;
		var y1 = x * matB + y * matD + absY;
		if(x1 < view.xMin) {
			view.xMin = x1;
		}
		if(x1 > view.xMax) {
			view.xMax = x1;
		}
		if(y1 < view.yMin) {
			view.yMin = y1;
		}
		if(y1 > view.yMax) {
			view.yMax = y1;
		}
		var x = bounds.xMax;
		var y = bounds.yMin;
		var x1 = x * matA + y * matC + absX;
		var y1 = x * matB + y * matD + absY;
		if(x1 < view.xMin) {
			view.xMin = x1;
		}
		if(x1 > view.xMax) {
			view.xMax = x1;
		}
		if(y1 < view.yMin) {
			view.yMin = y1;
		}
		if(y1 > view.yMax) {
			view.yMax = y1;
		}
		var x = bounds.xMin;
		var y = bounds.yMax;
		var x1 = x * matA + y * matC + absX;
		var y1 = x * matB + y * matD + absY;
		if(x1 < view.xMin) {
			view.xMin = x1;
		}
		if(x1 > view.xMax) {
			view.xMax = x1;
		}
		if(y1 < view.yMin) {
			view.yMin = y1;
		}
		if(y1 > view.yMax) {
			view.yMax = y1;
		}
		var x = bounds.xMax;
		var y = bounds.yMax;
		var x1 = x * matA + y * matC + absX;
		var y1 = x * matB + y * matD + absY;
		if(x1 < view.xMin) {
			view.xMin = x1;
		}
		if(x1 > view.xMax) {
			view.xMax = x1;
		}
		if(y1 < view.yMin) {
			view.yMin = y1;
		}
		if(y1 > view.yMax) {
			view.yMax = y1;
		}
		if(view.xMin < -1) {
			view.xMin = -1;
		}
		if(view.yMin < -1) {
			view.yMin = -1;
		}
		if(view.xMax > 1) {
			view.xMax = 1;
		}
		if(view.yMax > 1) {
			view.yMax = 1;
		}
		var invDet = 1 / (matA * matD - matB * matC);
		var sxMin = view.xMin;
		var syMin = view.yMin;
		var sxMax = view.xMax;
		var syMax = view.yMax;
		view.xMin = 1e20;
		view.yMin = 1e20;
		view.xMax = -1e20;
		view.yMax = -1e20;
		var x = sxMin;
		var y = syMin;
		x -= absX;
		y -= absY;
		var x1 = (x * matD - y * matC) * invDet;
		var y1 = (-x * matB + y * matA) * invDet;
		if(x1 < view.xMin) {
			view.xMin = x1;
		}
		if(x1 > view.xMax) {
			view.xMax = x1;
		}
		if(y1 < view.yMin) {
			view.yMin = y1;
		}
		if(y1 > view.yMax) {
			view.yMax = y1;
		}
		var x = sxMax;
		var y = syMin;
		x -= absX;
		y -= absY;
		var x1 = (x * matD - y * matC) * invDet;
		var y1 = (-x * matB + y * matA) * invDet;
		if(x1 < view.xMin) {
			view.xMin = x1;
		}
		if(x1 > view.xMax) {
			view.xMax = x1;
		}
		if(y1 < view.yMin) {
			view.yMin = y1;
		}
		if(y1 > view.yMax) {
			view.yMax = y1;
		}
		var x = sxMin;
		var y = syMax;
		x -= absX;
		y -= absY;
		var x1 = (x * matD - y * matC) * invDet;
		var y1 = (-x * matB + y * matA) * invDet;
		if(x1 < view.xMin) {
			view.xMin = x1;
		}
		if(x1 > view.xMax) {
			view.xMax = x1;
		}
		if(y1 < view.yMin) {
			view.yMin = y1;
		}
		if(y1 > view.yMax) {
			view.yMax = y1;
		}
		var x = sxMax;
		var y = syMax;
		x -= absX;
		y -= absY;
		var x1 = (x * matD - y * matC) * invDet;
		var y1 = (-x * matB + y * matA) * invDet;
		if(x1 < view.xMin) {
			view.xMin = x1;
		}
		if(x1 > view.xMax) {
			view.xMax = x1;
		}
		if(y1 < view.yMin) {
			view.yMin = y1;
		}
		if(y1 > view.yMax) {
			view.yMax = y1;
		}
		var a = bounds.xMin;
		var b = view.xMin;
		bounds.xMin = a < b ? b : a;
		var a = bounds.yMin;
		var b = view.yMin;
		bounds.yMin = a < b ? b : a;
		var a = bounds.xMax;
		var b = view.xMax;
		bounds.xMax = a > b ? b : a;
		var a = bounds.yMax;
		var b = view.yMax;
		bounds.yMax = a > b ? b : a;
	}
	,drawFilters: function(ctx) {
		if(!ctx.pushFilter(this)) {
			return;
		}
		var bounds = ctx.tmpBounds;
		var total = new h2d_col_Bounds();
		this.filter.sync(ctx,this);
		var scaleX;
		var scaleY;
		if(this.filter.useScreenResolution) {
			var s = ctx.scene;
			scaleX = s.viewportScaleX * this.filter.resolutionScale;
			scaleY = s.viewportScaleY * this.filter.resolutionScale;
		} else {
			scaleX = this.filter.resolutionScale;
			scaleY = this.filter.resolutionScale;
		}
		if(this.filter.autoBounds) {
			var maxExtent = this.filter.boundsExtend;
			if(maxExtent >= 0) {
				this.getBounds(this,bounds);
				bounds.xMin = bounds.xMin * scaleX - maxExtent;
				bounds.yMin = bounds.yMin * scaleY - maxExtent;
				bounds.xMax = bounds.xMax * scaleX + maxExtent;
				bounds.yMax = bounds.yMax * scaleY + maxExtent;
				if(bounds.xMin < total.xMin) {
					total.xMin = bounds.xMin;
				}
				if(bounds.xMax > total.xMax) {
					total.xMax = bounds.xMax;
				}
				if(bounds.yMin < total.yMin) {
					total.yMin = bounds.yMin;
				}
				if(bounds.yMax > total.yMax) {
					total.yMax = bounds.yMax;
				}
			}
		} else {
			var scale = h2d_Object.tmpPoint;
			var _this = scale;
			var x = scaleX;
			var y = scaleY;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			this.filter.getBounds(this,bounds,scale);
			if(bounds.xMin < total.xMin) {
				total.xMin = bounds.xMin;
			}
			if(bounds.xMax > total.xMax) {
				total.xMax = bounds.xMax;
			}
			if(bounds.yMin < total.yMin) {
				total.yMin = bounds.yMin;
			}
			if(bounds.yMax > total.yMax) {
				total.yMax = bounds.yMax;
			}
			scaleX = scale.x;
			scaleY = scale.y;
		}
		ctx.setFilterScale(scaleX,scaleY);
		this.clipBounds(ctx,total,scaleX,scaleY);
		var xMin = Math.floor(total.xMin + 1e-10);
		var yMin = Math.floor(total.yMin + 1e-10);
		var width = Math.ceil(total.xMax - xMin - 1e-10);
		var height = Math.ceil(total.yMax - yMin - 1e-10);
		if(width <= 0 || height <= 0 || total.xMax < total.xMin) {
			ctx.popFilter();
			return;
		}
		var t = ctx.textures.allocTarget("filterTemp",width,height,false);
		ctx.pushTarget(t,xMin,yMin,width,height);
		ctx.engine.clear(0);
		var oldAlpha = ctx.globalAlpha;
		var shader = ctx.baseShader;
		var _this = shader.filterMatrixA__;
		var x = _this.x;
		var y = _this.y;
		var z = _this.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var oldA_x = x1;
		var oldA_y = y1;
		var oldA_z = z1;
		var _this = shader.filterMatrixB__;
		var x = _this.x;
		var y = _this.y;
		var z = _this.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var oldB_x = x1;
		var oldB_y = y1;
		var oldB_z = z1;
		var invDet = 1 / (this.matA * this.matD - this.matB * this.matC);
		var invA = this.matD * invDet * scaleX;
		var invB = -this.matB * invDet * scaleY;
		var invC = -this.matC * invDet * scaleX;
		var invD = this.matA * invDet * scaleY;
		var invX = -(this.absX * invA + this.absY * invC);
		var invY = -(this.absX * invB + this.absY * invD);
		var _this = shader.filterMatrixA__;
		var x = invA;
		var y = invC;
		var z = invX;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		var _this = shader.filterMatrixB__;
		var x = invB;
		var y = invD;
		var z = invY;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		ctx.globalAlpha = 1;
		this.drawContent(ctx);
		var finalTile = h2d_Tile.fromTexture(t);
		finalTile.dx = xMin / scaleX;
		finalTile.dy = yMin / scaleY;
		var prev = finalTile;
		finalTile = this.filter.draw(ctx,finalTile);
		if(finalTile != null) {
			if(finalTile != prev) {
				finalTile.dx = (finalTile.dx + xMin) / scaleX;
				finalTile.dy = (finalTile.dy + yMin) / scaleY;
			}
			finalTile.width /= scaleX;
			finalTile.height /= scaleY;
		}
		var _this = shader.filterMatrixA__;
		_this.x = oldA_x;
		_this.y = oldA_y;
		_this.z = oldA_z;
		var _this = shader.filterMatrixB__;
		_this.x = oldB_x;
		_this.y = oldB_y;
		_this.z = oldB_z;
		ctx.popTarget();
		ctx.popFilter();
		ctx.globalAlpha = oldAlpha;
		if(finalTile == null) {
			return;
		}
		this.drawFiltered(ctx,finalTile);
	}
	,drawFiltered: function(ctx,tile) {
		var oldAlpha = ctx.globalAlpha;
		ctx.currentBlend = null;
		ctx.inFilterBlend = this.blendMode;
		ctx.globalAlpha *= this.alpha;
		this.emitTile(ctx,tile);
		ctx.globalAlpha = oldAlpha;
		ctx.inFilterBlend = null;
		ctx.currentBlend = null;
	}
	,drawRec: function(ctx) {
		if(!this.visible) {
			return;
		}
		if(this.posChanged) {
			this.calcAbsPos();
			var _g = 0;
			var _g1 = this.children;
			while(_g < _g1.length) {
				var c = _g1[_g];
				++_g;
				c.posChanged = true;
			}
			this.posChanged = false;
		}
		if(this.filter != null && this.filter.get_enable()) {
			this.drawFilters(ctx);
		} else {
			var old = ctx.globalAlpha;
			ctx.globalAlpha *= this.alpha;
			this.drawContent(ctx);
			ctx.globalAlpha = old;
		}
	}
	,drawContent: function(ctx) {
		if(ctx.front2back) {
			var i = this.children.length;
			while(i-- > 0) this.children[i].drawRec(ctx);
			this.draw(ctx);
		} else {
			this.draw(ctx);
			var _g = 0;
			var _g1 = this.children;
			while(_g < _g1.length) {
				var c = _g1[_g];
				++_g;
				c.drawRec(ctx);
			}
		}
	}
	,set_x: function(v) {
		this.posChanged = true;
		return this.x = v;
	}
	,set_y: function(v) {
		this.posChanged = true;
		return this.y = v;
	}
	,set_scaleX: function(v) {
		this.posChanged = true;
		return this.scaleX = v;
	}
	,set_scaleY: function(v) {
		this.posChanged = true;
		return this.scaleY = v;
	}
	,set_rotation: function(v) {
		this.posChanged = true;
		return this.rotation = v;
	}
	,move: function(dx,dy) {
		var v = this.x + (dx * Math.cos(this.rotation) - dy * Math.sin(this.rotation));
		this.posChanged = true;
		this.x = v;
		var v = this.y + (dx * Math.sin(this.rotation) + dy * Math.cos(this.rotation));
		this.posChanged = true;
		this.y = v;
	}
	,setPosition: function(x,y) {
		this.posChanged = true;
		this.x = x;
		this.posChanged = true;
		this.y = y;
	}
	,rotate: function(v) {
		this.posChanged = true;
		this.rotation += v;
	}
	,scale: function(v) {
		this.posChanged = true;
		this.scaleX *= v;
		this.posChanged = true;
		this.scaleY *= v;
	}
	,setScale: function(v) {
		this.posChanged = true;
		this.scaleX = v;
		this.posChanged = true;
		this.scaleY = v;
	}
	,getChildAt: function(n) {
		return this.children[n];
	}
	,getChildIndex: function(o) {
		var _g = 0;
		var _g1 = this.children.length;
		while(_g < _g1) {
			var i = _g++;
			if(this.children[i] == o) {
				return i;
			}
		}
		return -1;
	}
	,getObjectByName: function(name) {
		if(this.name == name) {
			return this;
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			var o = c.getObjectByName(name);
			if(o != null) {
				return o;
			}
		}
		return null;
	}
	,get_numChildren: function() {
		return this.children.length;
	}
	,iterator: function() {
		return new hxd_impl_ArrayIterator_$h2d_$Object(this.children);
	}
	,toString: function() {
		var c = js_Boot.getClass(this);
		var c1 = c.__name__;
		if(this.name == null) {
			return c1;
		} else {
			return this.name + "(" + c1 + ")";
		}
	}
	,contentChanged: function(s) {
	}
	,constraintSize: function(maxWidth,maxHeight) {
	}
	,__class__: h2d_Object
};
var game_mvp_view_entities_BaseGameEntityView = function(parent) {
	h2d_Object.call(this,parent);
	this.graphics = new h2d_Graphics(this);
	this.healthBar = new h2d_Graphics(this);
	this.model = null;
	this.lastModelUpdate = 0;
	this.isInitialized = false;
	this.isInPool = false;
	this.poolType = "character";
};
$hxClasses["game.mvp.view.entities.BaseGameEntityView"] = game_mvp_view_entities_BaseGameEntityView;
game_mvp_view_entities_BaseGameEntityView.__name__ = "game.mvp.view.entities.BaseGameEntityView";
game_mvp_view_entities_BaseGameEntityView.__super__ = h2d_Object;
game_mvp_view_entities_BaseGameEntityView.prototype = $extend(h2d_Object.prototype,{
	initialize: function(model) {
		this.model = model;
		this.poolType = model.get_type();
		this.createVisualRepresentation();
		if(game_mvp_presenter_GamePresenter.Config.visualSettings.drawPhysicsShapes) {
			this.createBorderGraphics();
		}
		this.updatePosition();
		this.isInitialized = true;
		this.lastModelUpdate = model.lastUpdateTick;
	}
	,createVisualRepresentation: function() {
		if(this.bitmap != null) {
			var _this = this.bitmap;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
		}
		var width = Math.floor(this.model.get_colliderWidth() * game_mvp_presenter_GamePresenter.Config.engineConfig.unitPixels);
		var height = Math.floor(this.model.get_colliderHeight() * game_mvp_presenter_GamePresenter.Config.engineConfig.unitPixels);
		var tile = h2d_Tile.fromColor(this.model.color,width,height);
		this.bitmap = new h2d_Bitmap(tile,this);
		var _this = this.bitmap;
		_this.posChanged = true;
		_this.x = -width * 0.5;
		var _this = this.bitmap;
		_this.posChanged = true;
		_this.y = -height * 0.5;
	}
	,createBorderGraphics: function() {
		if(this.borderGraphics != null) {
			var _this = this.borderGraphics;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
		}
		this.borderGraphics = new h2d_Graphics(this);
		var width = this.model.get_colliderWidth() * game_mvp_presenter_GamePresenter.Config.engineConfig.unitPixels;
		var height = this.model.get_colliderHeight() * game_mvp_presenter_GamePresenter.Config.engineConfig.unitPixels;
		this.borderGraphics.lineStyle(2,255,1);
		this.borderGraphics.drawRect(-width * 0.5,-height * 0.5,width,height);
	}
	,update: function() {
		if(!this.isInitialized || this.model == null || !this.model.get_isAlive()) {
			return;
		}
		if(this.model.needsVisualUpdate || this.model.lastUpdateTick != this.lastModelUpdate) {
			this.updateVisuals();
			this.lastModelUpdate = this.model.lastUpdateTick;
		}
		this.updatePosition();
		this.updateRotation();
		this.updateScale();
	}
	,updateVisuals: function() {
		if(this.model.needsVisualUpdate) {
			this.createVisualRepresentation();
			this.model.needsVisualUpdate = false;
		}
	}
	,updatePosition: function() {
		if(this.model != null) {
			this.posChanged = true;
			this.x = this.model.renderPos.x;
			this.posChanged = true;
			this.y = this.model.renderPos.y;
		}
	}
	,updateRotation: function() {
		if(this.model != null) {
			var v = this.model.get_rotation();
			this.posChanged = true;
			this.rotation = v;
		}
	}
	,updateScale: function() {
		if(this.model != null) {
			this.posChanged = true;
			this.scaleX = this.model.visualScale;
			this.posChanged = true;
			this.scaleY = this.model.visualScale;
		}
	}
	,updateHealthBar: function() {
		if(this.model.get_type() != "character") {
			this.healthBar.clear();
			return;
		}
		var characterModel = js_Boot.__cast(this.model , game_mvp_model_entities_CharacterModel);
		if(characterModel == null) {
			return;
		}
		var healthPercent = characterModel.getHealthPercentage();
		var barWidth = 40;
		var barHeight = 4;
		this.healthBar.clear();
		var _this = this.healthBar;
		_this.posChanged = true;
		_this.x = -barWidth * 0.5;
		var _this = this.healthBar;
		var v = -this.model.get_colliderHeight() * game_mvp_presenter_GamePresenter.Config.engineConfig.unitPixels - 10;
		_this.posChanged = true;
		_this.y = v;
		this.healthBar.beginFill(16711680);
		this.healthBar.drawRect(0,0,barWidth,barHeight);
		this.healthBar.endFill();
		this.healthBar.beginFill(65280);
		this.healthBar.drawRect(0,0,barWidth * healthPercent,barHeight);
		this.healthBar.endFill();
	}
	,showHealthBar: function() {
		this.updateHealthBar();
	}
	,hideHealthBar: function() {
		this.healthBar.clear();
	}
	,setBorderVisible: function(visible) {
		if(this.borderGraphics != null) {
			this.borderGraphics.set_visible(visible);
		}
	}
	,getModel: function() {
		return this.model;
	}
	,isViewInitialized: function() {
		return this.isInitialized;
	}
	,reset: function() {
		if(this.bitmap != null) {
			var _this = this.bitmap;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
			this.bitmap = null;
		}
		this.graphics.clear();
		this.healthBar.clear();
		if(this.borderGraphics != null) {
			var _this = this.borderGraphics;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
			this.borderGraphics = null;
		}
		this.model = null;
		this.lastModelUpdate = 0;
		this.isInitialized = false;
		this.isInPool = true;
		this.posChanged = true;
		this.x = 0;
		this.posChanged = true;
		this.y = 0;
		this.posChanged = true;
		this.rotation = 0;
		this.posChanged = true;
		this.scaleX = 1;
		this.posChanged = true;
		this.scaleY = 1;
		if(this.parent != null) {
			if(this.parent != null) {
				this.parent.removeChild(this);
			}
		}
	}
	,acquire: function() {
		this.isInPool = false;
		this.isInitialized = false;
	}
	,release: function() {
		this.reset();
	}
	,isInObjectPool: function() {
		return this.isInPool;
	}
	,getPoolType: function() {
		return this.poolType;
	}
	,setPoolType: function(type) {
		this.poolType = type;
	}
	,destroy: function() {
		if(this.bitmap != null) {
			var _this = this.bitmap;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
			this.bitmap = null;
		}
		this.graphics.clear();
		this.healthBar.clear();
		if(this.borderGraphics != null) {
			var _this = this.borderGraphics;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
			this.borderGraphics = null;
		}
		if(this.parent != null) {
			if(this.parent != null) {
				this.parent.removeChild(this);
			}
		}
		this.model = null;
		this.isInitialized = false;
		this.isInPool = false;
	}
	,__class__: game_mvp_view_entities_BaseGameEntityView
});
var game_mvp_view_entities_CharacterEntityView = function(parent) {
	game_mvp_view_entities_BaseGameEntityView.call(this,parent);
	this.showName = false;
	this.showLevel = true;
	this.trailLength = 10;
	this.movementTrail = [];
};
$hxClasses["game.mvp.view.entities.CharacterEntityView"] = game_mvp_view_entities_CharacterEntityView;
game_mvp_view_entities_CharacterEntityView.__name__ = "game.mvp.view.entities.CharacterEntityView";
game_mvp_view_entities_CharacterEntityView.__super__ = game_mvp_view_entities_BaseGameEntityView;
game_mvp_view_entities_CharacterEntityView.prototype = $extend(game_mvp_view_entities_BaseGameEntityView.prototype,{
	initialize: function(model) {
		game_mvp_view_entities_BaseGameEntityView.prototype.initialize.call(this,model);
		this.createCharacterVisuals();
	}
	,createCharacterVisuals: function() {
		var characterModel = js_Boot.__cast(this.model , game_mvp_model_entities_CharacterModel);
		if(characterModel == null) {
			return;
		}
		if(this.showName) {
			this.createNameText();
		}
		if(this.showLevel) {
			this.createLevelText();
		}
		this.showHealthBar();
	}
	,createNameText: function() {
		if(this.nameText != null) {
			var _this = this.nameText;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
		}
		var characterModel = js_Boot.__cast(this.model , game_mvp_model_entities_CharacterModel);
		if(characterModel == null) {
			return;
		}
		this.nameText = new h2d_Text(hxd_res_DefaultFont.get(),this);
		this.nameText.set_text(characterModel.get_ownerId());
		this.nameText.set_textColor(16777215);
		var _this = this.nameText;
		var v = -this.nameText.get_textWidth() * 0.5;
		_this.posChanged = true;
		_this.x = v;
		var _this = this.nameText;
		var v = -this.model.get_colliderHeight() * 8 - 20;
		_this.posChanged = true;
		_this.y = v;
	}
	,createLevelText: function() {
		if(this.levelText != null) {
			var _this = this.levelText;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
		}
		var characterModel = js_Boot.__cast(this.model , game_mvp_model_entities_CharacterModel);
		if(characterModel == null) {
			return;
		}
		this.levelText = new h2d_Text(hxd_res_DefaultFont.get(),this);
		this.levelText.set_text("Lv." + characterModel.get_level());
		this.levelText.set_textColor(16776960);
		var _this = this.levelText;
		var v = -this.levelText.get_textWidth() * 0.5;
		_this.posChanged = true;
		_this.x = v;
		var _this = this.levelText;
		var v = -this.model.get_colliderHeight() * 8 - 35;
		_this.posChanged = true;
		_this.y = v;
	}
	,update: function() {
		game_mvp_view_entities_BaseGameEntityView.prototype.update.call(this);
		if(!this.isInitialized || this.model == null || !this.model.get_isAlive()) {
			return;
		}
		var characterModel = js_Boot.__cast(this.model , game_mvp_model_entities_CharacterModel);
		if(characterModel == null) {
			return;
		}
		this.updateCharacterVisuals(characterModel);
		this.updateMovementTrail();
		this.updateHealthBar();
	}
	,updateCharacterVisuals: function(characterModel) {
		if(this.levelText != null) {
			this.levelText.set_text("Lv." + characterModel.get_level());
			var _this = this.levelText;
			var v = -this.levelText.get_textWidth() * 0.5;
			_this.posChanged = true;
			_this.x = v;
		}
		var healthPercent = characterModel.getHealthPercentage();
		if(healthPercent < 0.3) {
			var flashIntensity = Math.sin(hxd_Timer.lastTimeStamp * 10) * 0.5 + 0.5;
			this.model.visualScale = 1.0 + flashIntensity * 0.2;
		} else {
			this.model.visualScale = 1.0;
		}
	}
	,updateMovementTrail: function() {
		var characterModel = js_Boot.__cast(this.model , game_mvp_model_entities_CharacterModel);
		if(characterModel == null || !characterModel.isMoving) {
			return;
		}
		this.movementTrail.push({ x : this.x, y : this.y, alpha : 1.0});
		if(this.movementTrail.length > this.trailLength) {
			this.movementTrail.shift();
		}
		var _g = 0;
		var _g1 = this.movementTrail;
		while(_g < _g1.length) {
			var point = _g1[_g];
			++_g;
			point.alpha -= 0.1;
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = this.movementTrail;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(v.alpha > 0.1) {
				_g.push(v);
			}
		}
		this.movementTrail = _g;
	}
	,renderTrail: function(graphics) {
		if(this.movementTrail.length < 2) {
			return;
		}
		graphics.clear();
		graphics.lineStyle(2,16777215,0.5);
		var _g = 1;
		var _g1 = this.movementTrail.length;
		while(_g < _g1) {
			var i = _g++;
			var prev = this.movementTrail[i - 1];
			var curr = this.movementTrail[i];
			graphics.lineStyle(2,16777215,prev.alpha);
			var x = prev.x;
			var y = prev.y;
			graphics.flush();
			graphics.addVertex(x,y,graphics.curR,graphics.curG,graphics.curB,graphics.curA,x * graphics.ma + y * graphics.mc + graphics.mx,x * graphics.mb + y * graphics.md + graphics.my);
			var x1 = curr.x;
			var y1 = curr.y;
			graphics.addVertex(x1,y1,graphics.curR,graphics.curG,graphics.curB,graphics.curA,x1 * graphics.ma + y1 * graphics.mc + graphics.mx,x1 * graphics.mb + y1 * graphics.md + graphics.my);
		}
	}
	,setNameVisible: function(visible) {
		this.showName = visible;
		if(this.nameText != null) {
			this.nameText.set_visible(visible);
		}
	}
	,setLevelVisible: function(visible) {
		this.showLevel = visible;
		if(this.levelText != null) {
			this.levelText.set_visible(visible);
		}
	}
	,setTrailLength: function(length) {
		this.trailLength = length;
		if(this.movementTrail.length > length) {
			this.movementTrail = this.movementTrail.slice(-length);
		}
	}
	,getCharacterModel: function() {
		return js_Boot.__cast(this.model , game_mvp_model_entities_CharacterModel);
	}
	,reset: function() {
		if(this.nameText != null) {
			var _this = this.nameText;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
			this.nameText = null;
		}
		if(this.levelText != null) {
			var _this = this.levelText;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
			this.levelText = null;
		}
		this.movementTrail = [];
		game_mvp_view_entities_BaseGameEntityView.prototype.reset.call(this);
	}
	,destroy: function() {
		if(this.nameText != null) {
			var _this = this.nameText;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
			this.nameText = null;
		}
		if(this.levelText != null) {
			var _this = this.levelText;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
			this.levelText = null;
		}
		this.movementTrail = [];
		game_mvp_view_entities_BaseGameEntityView.prototype.destroy.call(this);
	}
	,__class__: game_mvp_view_entities_CharacterEntityView
});
var game_mvp_view_entities_ColliderEntityView = function(parent) {
	game_mvp_view_entities_BaseGameEntityView.call(this,parent);
};
$hxClasses["game.mvp.view.entities.ColliderEntityView"] = game_mvp_view_entities_ColliderEntityView;
game_mvp_view_entities_ColliderEntityView.__name__ = "game.mvp.view.entities.ColliderEntityView";
game_mvp_view_entities_ColliderEntityView.__super__ = game_mvp_view_entities_BaseGameEntityView;
game_mvp_view_entities_ColliderEntityView.prototype = $extend(game_mvp_view_entities_BaseGameEntityView.prototype,{
	initialize: function(model) {
		game_mvp_view_entities_BaseGameEntityView.prototype.initialize.call(this,model);
	}
	,update: function() {
		if(!this.isInitialized || this.model == null || !this.model.get_isAlive()) {
			return;
		}
		this.updatePosition();
	}
	,updatePosition: function() {
		if(this.model != null) {
			var v = this.model.get_pos().x;
			this.posChanged = true;
			this.x = v;
			var v = this.model.get_pos().y;
			this.posChanged = true;
			this.y = v;
		}
	}
	,getColliderModel: function() {
		return js_Boot.__cast(this.model , game_mvp_model_entities_ColliderModel);
	}
	,reset: function() {
		game_mvp_view_entities_BaseGameEntityView.prototype.reset.call(this);
	}
	,destroy: function() {
		game_mvp_view_entities_BaseGameEntityView.prototype.destroy.call(this);
	}
	,__class__: game_mvp_view_entities_ColliderEntityView
});
var game_mvp_view_entities_ConsumableEntityView = function(parent) {
	game_mvp_view_entities_BaseGameEntityView.call(this,parent);
	this.showQuantity = true;
	this.glowIntensity = 0.0;
	this.pulsePhase = 0.0;
};
$hxClasses["game.mvp.view.entities.ConsumableEntityView"] = game_mvp_view_entities_ConsumableEntityView;
game_mvp_view_entities_ConsumableEntityView.__name__ = "game.mvp.view.entities.ConsumableEntityView";
game_mvp_view_entities_ConsumableEntityView.__super__ = game_mvp_view_entities_BaseGameEntityView;
game_mvp_view_entities_ConsumableEntityView.prototype = $extend(game_mvp_view_entities_BaseGameEntityView.prototype,{
	initialize: function(model) {
		game_mvp_view_entities_BaseGameEntityView.prototype.initialize.call(this,model);
		this.createConsumableVisuals();
	}
	,createConsumableVisuals: function() {
		var consumableModel = js_Boot.__cast(this.model , game_mvp_model_entities_ConsumableModel);
		if(consumableModel == null) {
			return;
		}
		this.createGlowEffect();
		if(this.showQuantity) {
			this.createQuantityText();
		}
		this.createRarityGlow();
	}
	,createGlowEffect: function() {
		if(this.glowEffect != null) {
			var _this = this.glowEffect;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
		}
		this.glowEffect = new h2d_Graphics(this);
		var consumableModel = js_Boot.__cast(this.model , game_mvp_model_entities_ConsumableModel);
		if(consumableModel == null) {
			return;
		}
		var glowSize = Math.max(this.model.get_colliderWidth(),this.model.get_colliderHeight()) * 20;
		var glowColor = this.model.color;
		this.glowEffect.beginFill(glowColor,0.3);
		this.glowEffect.drawCircle(0,0,glowSize);
		this.glowEffect.endFill();
	}
	,createQuantityText: function() {
		if(this.quantityText != null) {
			var _this = this.quantityText;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
		}
		var consumableModel = js_Boot.__cast(this.model , game_mvp_model_entities_ConsumableModel);
		if(consumableModel == null) {
			return;
		}
		this.quantityText = new h2d_Text(hxd_res_DefaultFont.get(),this);
		this.quantityText.set_text("x" + consumableModel.get_quantity());
		this.quantityText.set_textColor(16777215);
		var _this = this.quantityText;
		var v = -this.quantityText.get_textWidth() * 0.5;
		_this.posChanged = true;
		_this.x = v;
		var _this = this.quantityText;
		var v = -this.model.get_colliderHeight() * 8 - 10;
		_this.posChanged = true;
		_this.y = v;
	}
	,createRarityGlow: function() {
		if(this.rarityGlow != null) {
			var _this = this.rarityGlow;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
		}
		var consumableModel = js_Boot.__cast(this.model , game_mvp_model_entities_ConsumableModel);
		if(consumableModel == null) {
			return;
		}
		if(consumableModel.glowIntensity > 0) {
			this.rarityGlow = new h2d_Graphics(this);
			var glowSize = Math.max(this.model.get_colliderWidth(),this.model.get_colliderHeight()) * 25;
			var glowColor = this.getRarityColor(consumableModel.get_rarity());
			this.rarityGlow.beginFill(glowColor,consumableModel.glowIntensity * 0.5);
			this.rarityGlow.drawCircle(0,0,glowSize);
			this.rarityGlow.endFill();
		}
	}
	,getRarityColor: function(rarity) {
		switch(rarity) {
		case "common":
			return 16777215;
		case "epic":
			return 8913151;
		case "legendary":
			return 16746496;
		case "rare":
			return 35071;
		default:
			return 16777215;
		}
	}
	,update: function() {
		game_mvp_view_entities_BaseGameEntityView.prototype.update.call(this);
		if(!this.isInitialized || this.model == null || !this.model.get_isAlive()) {
			return;
		}
		var consumableModel = js_Boot.__cast(this.model , game_mvp_model_entities_ConsumableModel);
		if(consumableModel == null) {
			return;
		}
		this.updateConsumableVisuals(consumableModel);
	}
	,updateConsumableVisuals: function(consumableModel) {
		if(this.quantityText != null) {
			this.quantityText.set_text("x" + consumableModel.get_quantity());
			var _this = this.quantityText;
			var v = -this.quantityText.get_textWidth() * 0.5;
			_this.posChanged = true;
			_this.x = v;
		}
		this.updateGlowEffect(consumableModel);
		this.updateRarityGlow(consumableModel);
	}
	,updateGlowEffect: function(consumableModel) {
		if(this.glowEffect == null) {
			return;
		}
		this.pulsePhase += 0.1;
		if(this.pulsePhase > Math.PI * 2) {
			this.pulsePhase -= Math.PI * 2;
		}
		var pulseIntensity = Math.sin(this.pulsePhase) * 0.3 + 0.7;
		this.glowIntensity = pulseIntensity;
		this.glowEffect.clear();
		var glowSize = Math.max(this.model.get_colliderWidth(),this.model.get_colliderHeight()) * 20 * (0.8 + pulseIntensity * 0.4);
		this.glowEffect.beginFill(this.model.color,0.2 * pulseIntensity);
		this.glowEffect.drawCircle(0,0,glowSize);
		this.glowEffect.endFill();
	}
	,updateRarityGlow: function(consumableModel) {
		if(this.rarityGlow == null) {
			return;
		}
		this.rarityGlow.clear();
		if(consumableModel.glowIntensity > 0) {
			var glowSize = Math.max(this.model.get_colliderWidth(),this.model.get_colliderHeight()) * 25 * (1.0 + Math.sin(this.pulsePhase * 2) * 0.2);
			var glowColor = this.getRarityColor(consumableModel.get_rarity());
			var alpha = consumableModel.glowIntensity * 0.5 * (0.5 + Math.sin(this.pulsePhase * 1.5) * 0.5);
			this.rarityGlow.beginFill(glowColor,alpha);
			this.rarityGlow.drawCircle(0,0,glowSize);
			this.rarityGlow.endFill();
		}
	}
	,setQuantityVisible: function(visible) {
		this.showQuantity = visible;
		if(this.quantityText != null) {
			this.quantityText.set_visible(visible);
		}
	}
	,getConsumableModel: function() {
		return js_Boot.__cast(this.model , game_mvp_model_entities_ConsumableModel);
	}
	,reset: function() {
		if(this.glowEffect != null) {
			var _this = this.glowEffect;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
			this.glowEffect = null;
		}
		if(this.quantityText != null) {
			var _this = this.quantityText;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
			this.quantityText = null;
		}
		if(this.rarityGlow != null) {
			var _this = this.rarityGlow;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
			this.rarityGlow = null;
		}
		this.glowIntensity = 0.0;
		this.pulsePhase = 0.0;
		game_mvp_view_entities_BaseGameEntityView.prototype.reset.call(this);
	}
	,destroy: function() {
		if(this.glowEffect != null) {
			var _this = this.glowEffect;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
			this.glowEffect = null;
		}
		if(this.quantityText != null) {
			var _this = this.quantityText;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
			this.quantityText = null;
		}
		if(this.rarityGlow != null) {
			var _this = this.rarityGlow;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
			this.rarityGlow = null;
		}
		game_mvp_view_entities_BaseGameEntityView.prototype.destroy.call(this);
	}
	,__class__: game_mvp_view_entities_ConsumableEntityView
});
var game_mvp_view_entities_EffectEntityView = function(parent) {
	game_mvp_view_entities_BaseGameEntityView.call(this,parent);
	this.showDuration = true;
	this.showEffectName = false;
	this.animationPhase = 0.0;
	this.particles = [];
};
$hxClasses["game.mvp.view.entities.EffectEntityView"] = game_mvp_view_entities_EffectEntityView;
game_mvp_view_entities_EffectEntityView.__name__ = "game.mvp.view.entities.EffectEntityView";
game_mvp_view_entities_EffectEntityView.__super__ = game_mvp_view_entities_BaseGameEntityView;
game_mvp_view_entities_EffectEntityView.prototype = $extend(game_mvp_view_entities_BaseGameEntityView.prototype,{
	initialize: function(model) {
		game_mvp_view_entities_BaseGameEntityView.prototype.initialize.call(this,model);
		this.createEffectVisuals();
	}
	,createEffectVisuals: function() {
		var effectModel = js_Boot.__cast(this.model , game_mvp_model_entities_EffectModel);
		if(effectModel == null) {
			return;
		}
		this.createParticleSystem();
		if(this.showDuration) {
			this.createDurationBar();
		}
		if(this.showEffectName) {
			this.createEffectText();
		}
	}
	,createParticleSystem: function() {
		if(this.particleSystem != null) {
			var _this = this.particleSystem;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
		}
		this.particleSystem = new h2d_Graphics(this);
		var effectModel = js_Boot.__cast(this.model , game_mvp_model_entities_EffectModel);
		if(effectModel == null) {
			return;
		}
		this.initializeParticles(effectModel);
	}
	,initializeParticles: function(effectModel) {
		this.particles = [];
		var _g = 0;
		var _g1 = effectModel.particleCount;
		while(_g < _g1) {
			var i = _g++;
			var particle = new game_mvp_view_entities_Particle();
			particle.x = (Math.random() - 0.5) * Math.max(this.model.get_colliderWidth(),this.model.get_colliderHeight()) * 10;
			particle.y = (Math.random() - 0.5) * Math.max(this.model.get_colliderWidth(),this.model.get_colliderHeight()) * 10;
			particle.vx = (Math.random() - 0.5) * 50;
			particle.vy = (Math.random() - 0.5) * 50;
			particle.life = Math.random() * 2.0 + 1.0;
			particle.maxLife = particle.life;
			particle.size = Math.random() * 3 + 1;
			particle.color = this.model.color;
			this.particles.push(particle);
		}
	}
	,createDurationBar: function() {
		if(this.durationBar != null) {
			var _this = this.durationBar;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
		}
		this.durationBar = new h2d_Graphics(this);
	}
	,createEffectText: function() {
		if(this.effectText != null) {
			var _this = this.effectText;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
		}
		var effectModel = js_Boot.__cast(this.model , game_mvp_model_entities_EffectModel);
		if(effectModel == null) {
			return;
		}
		this.effectText = new h2d_Text(hxd_res_DefaultFont.get(),this);
		this.effectText.set_text(effectModel.get_effectType());
		this.effectText.set_textColor(16777215);
		var _this = this.effectText;
		var v = -this.effectText.get_textWidth() * 0.5;
		_this.posChanged = true;
		_this.x = v;
		var _this = this.effectText;
		var v = -this.model.get_colliderHeight() * 8 - 20;
		_this.posChanged = true;
		_this.y = v;
	}
	,update: function() {
		game_mvp_view_entities_BaseGameEntityView.prototype.update.call(this);
		if(!this.isInitialized || this.model == null || !this.model.get_isAlive()) {
			return;
		}
		var effectModel = js_Boot.__cast(this.model , game_mvp_model_entities_EffectModel);
		if(effectModel == null) {
			return;
		}
		this.updateEffectVisuals(effectModel);
	}
	,updateEffectVisuals: function(effectModel) {
		this.animationPhase += 0.1;
		if(this.animationPhase > Math.PI * 2) {
			this.animationPhase -= Math.PI * 2;
		}
		this.updateParticles(effectModel);
		this.updateDurationBar(effectModel);
		if(this.effectText != null) {
			this.effectText.set_text(effectModel.get_effectType() + " (" + (effectModel.get_duration() | 0) + "s)");
		}
	}
	,updateParticles: function(effectModel) {
		if(this.particleSystem == null) {
			return;
		}
		var _g = 0;
		var _g1 = this.particles;
		while(_g < _g1.length) {
			var particle = _g1[_g];
			++_g;
			particle.x += particle.vx * 0.016;
			particle.y += particle.vy * 0.016;
			particle.life -= 0.016;
			switch(effectModel.get_effectType()) {
			case "damage":
				particle.vx *= 1.02;
				particle.vy *= 1.02;
				break;
			case "heal":
				particle.vy -= 10;
				break;
			case "speed_boost":
				var angle = Math.atan2(particle.y,particle.x) + 0.1;
				var radius = Math.sqrt(particle.x * particle.x + particle.y * particle.y);
				particle.x = Math.cos(angle) * radius;
				particle.y = Math.sin(angle) * radius;
				break;
			default:
			}
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = this.particles;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(v.life > 0) {
				_g.push(v);
			}
		}
		this.particles = _g;
		while(this.particles.length < effectModel.particleCount) {
			var particle = new game_mvp_view_entities_Particle();
			particle.x = (Math.random() - 0.5) * Math.max(this.model.get_colliderWidth(),this.model.get_colliderHeight()) * 10;
			particle.y = (Math.random() - 0.5) * Math.max(this.model.get_colliderWidth(),this.model.get_colliderHeight()) * 10;
			particle.vx = (Math.random() - 0.5) * 50;
			particle.vy = (Math.random() - 0.5) * 50;
			particle.life = Math.random() * 2.0 + 1.0;
			particle.maxLife = particle.life;
			particle.size = Math.random() * 3 + 1;
			particle.color = this.model.color;
			this.particles.push(particle);
		}
		this.renderParticles();
	}
	,renderParticles: function() {
		if(this.particleSystem == null) {
			return;
		}
		this.particleSystem.clear();
		var _g = 0;
		var _g1 = this.particles;
		while(_g < _g1.length) {
			var particle = _g1[_g];
			++_g;
			var alpha = particle.life / particle.maxLife;
			var size = particle.size * alpha;
			this.particleSystem.beginFill(particle.color,alpha);
			this.particleSystem.drawCircle(particle.x,particle.y,size);
			this.particleSystem.endFill();
		}
	}
	,updateDurationBar: function(effectModel) {
		if(this.durationBar == null) {
			return;
		}
		var barWidth = 40;
		var barHeight = 3;
		var durationPercent = effectModel.getDurationPercentage();
		this.durationBar.clear();
		var _this = this.durationBar;
		_this.posChanged = true;
		_this.x = -barWidth * 0.5;
		var _this = this.durationBar;
		var v = -this.model.get_colliderHeight() * 8 - 15;
		_this.posChanged = true;
		_this.y = v;
		this.durationBar.beginFill(3355443);
		this.durationBar.drawRect(0,0,barWidth,barHeight);
		this.durationBar.endFill();
		var barColor = this.getEffectColor(effectModel.get_effectType());
		this.durationBar.beginFill(barColor);
		this.durationBar.drawRect(0,0,barWidth * durationPercent,barHeight);
		this.durationBar.endFill();
	}
	,getEffectColor: function(effectType) {
		switch(effectType) {
		case "damage":
			return 16711680;
		case "heal":
			return 65280;
		case "shield":
			return 255;
		case "speed_boost":
			return 65535;
		default:
			return 16711935;
		}
	}
	,setDurationVisible: function(visible) {
		this.showDuration = visible;
		if(this.durationBar != null) {
			this.durationBar.set_visible(visible);
		}
	}
	,setEffectNameVisible: function(visible) {
		this.showEffectName = visible;
		if(this.effectText != null) {
			this.effectText.set_visible(visible);
		}
	}
	,getEffectModel: function() {
		return js_Boot.__cast(this.model , game_mvp_model_entities_EffectModel);
	}
	,reset: function() {
		if(this.particleSystem != null) {
			var _this = this.particleSystem;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
			this.particleSystem = null;
		}
		if(this.durationBar != null) {
			var _this = this.durationBar;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
			this.durationBar = null;
		}
		if(this.effectText != null) {
			var _this = this.effectText;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
			this.effectText = null;
		}
		this.particles = [];
		this.animationPhase = 0.0;
		game_mvp_view_entities_BaseGameEntityView.prototype.reset.call(this);
	}
	,destroy: function() {
		if(this.particleSystem != null) {
			var _this = this.particleSystem;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
			this.particleSystem = null;
		}
		if(this.durationBar != null) {
			var _this = this.durationBar;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
			this.durationBar = null;
		}
		if(this.effectText != null) {
			var _this = this.effectText;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
			this.effectText = null;
		}
		this.particles = [];
		game_mvp_view_entities_BaseGameEntityView.prototype.destroy.call(this);
	}
	,__class__: game_mvp_view_entities_EffectEntityView
});
var game_mvp_view_entities_Particle = function() {
	this.x = 0;
	this.y = 0;
	this.vx = 0;
	this.vy = 0;
	this.life = 1.0;
	this.maxLife = 1.0;
	this.size = 1.0;
	this.color = 16777215;
};
$hxClasses["game.mvp.view.entities.Particle"] = game_mvp_view_entities_Particle;
game_mvp_view_entities_Particle.__name__ = "game.mvp.view.entities.Particle";
game_mvp_view_entities_Particle.prototype = {
	__class__: game_mvp_view_entities_Particle
};
var game_scene_SceneManager = function(sceneChangedCallback) {
	this.sceneChangedCallback = sceneChangedCallback;
	game_event_EventManager.instance.subscribe(game_event_EventManager.EVENT_LOAD_HOME_SCENE,this);
	game_event_EventManager.instance.subscribe(game_event_EventManager.EVENT_LOAD_GAME_SCENE,this);
	this.currentScene = new game_scene_impl_LoadingScene();
	this.currentScene.start();
	this.changeSceneCallback();
};
$hxClasses["game.scene.SceneManager"] = game_scene_SceneManager;
game_scene_SceneManager.__name__ = "game.scene.SceneManager";
game_scene_SceneManager.__interfaces__ = [game_event_EventListener];
game_scene_SceneManager.prototype = {
	notify: function(event,message) {
		switch(event) {
		case game_event_EventManager.EVENT_LOAD_GAME_SCENE:
			if(this.currentScene != null) {
				this.currentScene.destroy();
			}
			this.currentScene = new game_scene_impl_GameScene();
			this.currentScene.start();
			break;
		case game_event_EventManager.EVENT_LOAD_HOME_SCENE:
			if(this.currentScene != null) {
				this.currentScene.destroy();
			}
			this.currentScene = new game_scene_impl_HomeScene();
			this.currentScene.start();
			break;
		}
		this.changeSceneCallback();
	}
	,getCurrentScene: function() {
		return this.currentScene;
	}
	,onResize: function() {
		this.currentScene.onResize();
	}
	,changeSceneCallback: function() {
		if(this.sceneChangedCallback != null) {
			this.sceneChangedCallback(this.currentScene);
		}
	}
	,__class__: game_scene_SceneManager
};
var h2d_Layers = function(parent) {
	h2d_Object.call(this,parent);
	this.layersIndexes = [];
	this.layerCount = 0;
};
$hxClasses["h2d.Layers"] = h2d_Layers;
h2d_Layers.__name__ = "h2d.Layers";
h2d_Layers.__super__ = h2d_Object;
h2d_Layers.prototype = $extend(h2d_Object.prototype,{
	addChild: function(s) {
		this.add(s,-1);
	}
	,add: function(s,layer,index) {
		if(index == null) {
			index = -1;
		}
		if(layer == null) {
			layer = -1;
		}
		if(s.parent == this) {
			var old = s.allocated;
			s.allocated = false;
			this.removeChild(s);
			s.allocated = old;
		}
		if(layer == -1) {
			layer = this.layerCount == 0 ? 0 : this.layerCount - 1;
		}
		while(layer >= this.layerCount) this.layersIndexes[this.layerCount++] = this.children.length;
		if(index != -1) {
			if(layer == 0) {
				var b = this.layersIndexes[layer];
				var b1 = index > b ? b : index;
				h2d_Object.prototype.addChildAt.call(this,s,0 < b1 ? b1 : 0);
			} else if(index < 0) {
				h2d_Object.prototype.addChildAt.call(this,s,this.layersIndexes[layer - 1]);
			} else {
				var a = this.layersIndexes[layer - 1] + index;
				var b = this.layersIndexes[layer];
				h2d_Object.prototype.addChildAt.call(this,s,a > b ? b : a);
			}
		} else {
			h2d_Object.prototype.addChildAt.call(this,s,this.layersIndexes[layer]);
		}
		var _g = layer;
		var _g1 = this.layerCount;
		while(_g < _g1) {
			var i = _g++;
			this.layersIndexes[i]++;
		}
	}
	,addChildAt: function(s,index) {
		this.add(s,-1,index);
	}
	,removeChild: function(s) {
		var _g = 0;
		var _g1 = this.children.length;
		while(_g < _g1) {
			var i = _g++;
			if(this.children[i] == s) {
				this.children.splice(i,1);
				if(s.allocated) {
					s.onRemove();
				}
				s.parent = null;
				s.posChanged = true;
				if(s.parentContainer != null) {
					s.setParentContainer(null);
				}
				var k = this.layerCount - 1;
				while(k >= 0 && this.layersIndexes[k] > i) {
					this.layersIndexes[k]--;
					--k;
				}
				if(this.parentContainer != null) {
					this.parentContainer.contentChanged(this);
				}
				break;
			}
		}
	}
	,under: function(s) {
		var _g = 0;
		var _g1 = this.children.length;
		while(_g < _g1) {
			var i = _g++;
			if(this.children[i] == s) {
				var pos = 0;
				var _g2 = 0;
				var _g3 = this.layersIndexes;
				while(_g2 < _g3.length) {
					var l = _g3[_g2];
					++_g2;
					if(l > i) {
						break;
					} else {
						pos = l;
					}
				}
				var p = i;
				while(p > pos) {
					this.children[p] = this.children[p - 1];
					--p;
				}
				this.children[pos] = s;
				if(s.allocated) {
					s.onHierarchyMoved(false);
				}
				return;
			}
		}
	}
	,over: function(s) {
		var _g = 0;
		var _g1 = this.children.length;
		while(_g < _g1) {
			var i = _g++;
			if(this.children[i] == s) {
				var _g2 = 0;
				var _g3 = this.layersIndexes;
				while(_g2 < _g3.length) {
					var l = _g3[_g2];
					++_g2;
					if(l > i) {
						var _g4 = i;
						var _g5 = l - 1;
						while(_g4 < _g5) {
							var p = _g4++;
							this.children[p] = this.children[p + 1];
						}
						this.children[l - 1] = s;
						if(s.allocated) {
							s.onHierarchyMoved(false);
						}
						return;
					}
				}
				return;
			}
		}
	}
	,getLayer: function(layer) {
		var a;
		if(layer >= this.layerCount) {
			a = [];
		} else {
			var start = layer == 0 ? 0 : this.layersIndexes[layer - 1];
			var max = this.layersIndexes[layer];
			a = this.children.slice(start,max);
		}
		return new hxd_impl_ArrayIterator_$h2d_$Object(a);
	}
	,getChildAtLayer: function(n,layer) {
		if(layer == -1) {
			layer = this.layerCount == 0 ? 0 : this.layerCount - 1;
		}
		if(layer >= this.layerCount || n < 0 || n >= this.layersIndexes[layer]) {
			return null;
		}
		if(layer == 0) {
			return this.children[n];
		}
		return this.children[this.layersIndexes[layer - 1] + n];
	}
	,getChildLayer: function(s) {
		if(s.parent != this) {
			return -1;
		}
		var index = this.children.indexOf(s);
		var _g = 0;
		var _g1 = this.layerCount;
		while(_g < _g1) {
			var i = _g++;
			if(this.layersIndexes[i] > index) {
				return i;
			}
		}
		return -1;
	}
	,getChildIndexInLayer: function(o) {
		if(o.parent != this) {
			return -1;
		}
		var index = this.children.indexOf(o);
		if(index < this.layersIndexes[0]) {
			return index;
		}
		var _g = 1;
		var _g1 = this.layerCount;
		while(_g < _g1) {
			var i = _g++;
			if(this.layersIndexes[i] > index) {
				return index - this.layersIndexes[i - 1];
			}
		}
		return -1;
	}
	,drawLayer: function(ctx,layer) {
		if(layer >= this.layerCount) {
			return;
		}
		var old = ctx.globalAlpha;
		ctx.globalAlpha *= this.alpha;
		var start = layer == 0 ? 0 : this.layersIndexes[layer - 1];
		var max = this.layersIndexes[layer];
		if(ctx.front2back) {
			var _g = start;
			var _g1 = max;
			while(_g < _g1) {
				var i = _g++;
				this.children[max - 1 - i].drawRec(ctx);
			}
		} else {
			var _g = start;
			var _g1 = max;
			while(_g < _g1) {
				var i = _g++;
				this.children[i].drawRec(ctx);
			}
		}
		ctx.globalAlpha = old;
	}
	,ysort: function(layer) {
		if(layer >= this.layerCount) {
			return;
		}
		var start = layer == 0 ? 0 : this.layersIndexes[layer - 1];
		var max = this.layersIndexes[layer];
		if(start == max) {
			return;
		}
		var pos = start;
		var ymax = this.children[pos++].y;
		while(pos < max) {
			var c = this.children[pos];
			if(c.y < ymax) {
				var p = pos - 1;
				while(p >= start) {
					var c2 = this.children[p];
					if(c.y >= c2.y) {
						break;
					}
					this.children[p + 1] = c2;
					--p;
				}
				this.children[p + 1] = c;
				if(c.allocated) {
					c.onHierarchyMoved(false);
				}
			} else {
				ymax = c.y;
			}
			++pos;
		}
	}
	,__class__: h2d_Layers
});
var hxd_InteractiveScene = function() { };
$hxClasses["hxd.InteractiveScene"] = hxd_InteractiveScene;
hxd_InteractiveScene.__name__ = "hxd.InteractiveScene";
hxd_InteractiveScene.__isInterface__ = true;
hxd_InteractiveScene.prototype = {
	__class__: hxd_InteractiveScene
};
var h2d_Scene = function() {
	this.scaleMode = h2d_ScaleMode.Resize;
	h2d_Layers.call(this,null);
	var e = h3d_Engine.CURRENT;
	this.ctx = new h2d_RenderContext(this);
	this._cameras = [];
	new h2d_Camera(this);
	this.set_interactiveCamera(this._cameras[0]);
	this.width = e.width;
	this.height = e.height;
	this.viewportA = 2 / e.width;
	this.viewportD = 2 / e.height;
	this.viewportX = -1;
	this.viewportY = -1;
	this.viewportScaleX = 1;
	this.viewportScaleY = 1;
	this.offsetX = 0;
	this.offsetY = 0;
	this.interactive = [];
	this.eventListeners = [];
	this.shapePoint = new h2d_col_PointImpl(0.,0.);
	this.window = hxd_Window.getInstance();
	this.posChanged = true;
};
$hxClasses["h2d.Scene"] = h2d_Scene;
h2d_Scene.__name__ = "h2d.Scene";
h2d_Scene.__interfaces__ = [hxd_InteractiveScene,h3d_IDrawable];
h2d_Scene.__super__ = h2d_Layers;
h2d_Scene.prototype = $extend(h2d_Layers.prototype,{
	get_defaultSmooth: function() {
		return this.ctx.defaultSmooth;
	}
	,set_defaultSmooth: function(v) {
		return this.ctx.defaultSmooth = v;
	}
	,setEvents: function(events) {
		this.events = events;
	}
	,get_zoom: function() {
		var _g = this.scaleMode;
		if(_g._hx_index == 4) {
			var level = _g.level;
			return level | 0;
		} else {
			return 0;
		}
	}
	,set_zoom: function(v) {
		this.set_scaleMode(h2d_ScaleMode.Zoom(v));
		return v;
	}
	,set_scaleMode: function(v) {
		this.scaleMode = v;
		this.checkResize();
		return v;
	}
	,get_renderer: function() {
		return this.ctx;
	}
	,set_renderer: function(v) {
		this.ctx = v;
		return v;
	}
	,get_camera: function() {
		return this._cameras[0];
	}
	,get_cameras: function() {
		return this._cameras;
	}
	,set_interactiveCamera: function(cam) {
		if(cam == null) {
			throw haxe_Exception.thrown("Interactive cammera cannot be null!");
		}
		if(cam.scene != this) {
			this.addCamera(cam);
		}
		return this.interactiveCamera = cam;
	}
	,addCamera: function(cam,pos) {
		if(cam.scene != null) {
			cam.scene.removeCamera(cam);
		}
		cam.scene = this;
		cam.posChanged = true;
		if(pos != null) {
			this._cameras.splice(pos,0,cam);
		} else {
			this._cameras.push(cam);
		}
	}
	,removeCamera: function(cam) {
		if(cam == this.interactiveCamera) {
			throw haxe_Exception.thrown("Current interactive Camera cannot be removed from camera list!");
		}
		cam.scene = null;
		HxOverrides.remove(this._cameras,cam);
	}
	,setFixedSize: function(w,h) {
		this.set_scaleMode(h2d_ScaleMode.Stretch(w,h));
	}
	,checkResize: function() {
		var _gthis = this;
		var engine = h3d_Engine.CURRENT;
		if(engine == null) {
			return;
		}
		var _g = this.scaleMode;
		switch(_g._hx_index) {
		case 0:
			var w = engine.width;
			var h = engine.height;
			if(w != _gthis.width || h != _gthis.height) {
				_gthis.width = w;
				_gthis.height = h;
				_gthis.posChanged = true;
			}
			_gthis.viewportScaleX = 1;
			_gthis.viewportScaleY = 1;
			_gthis.viewportA = 2 / _gthis.width;
			_gthis.viewportD = 2 / _gthis.height;
			_gthis.viewportX = -1;
			_gthis.viewportY = -1;
			break;
		case 1:
			var _width = _g.width;
			var _height = _g.height;
			if(_width != _gthis.width || _height != _gthis.height) {
				_gthis.width = _width;
				_gthis.height = _height;
				_gthis.posChanged = true;
			}
			_gthis.viewportScaleX = engine.width / _width;
			_gthis.viewportScaleY = engine.height / _height;
			_gthis.viewportA = 2 / _gthis.width;
			_gthis.viewportD = 2 / _gthis.height;
			_gthis.viewportX = -1;
			_gthis.viewportY = -1;
			break;
		case 2:
			var _width = _g.width;
			var _height = _g.height;
			var integerScale = _g.integerScale;
			var horizontalAlign = _g.horizontalAlign;
			var verticalAlign = _g.verticalAlign;
			if(_width != _gthis.width || _height != _gthis.height) {
				_gthis.width = _width;
				_gthis.height = _height;
				_gthis.posChanged = true;
			}
			var a = engine.width / _width;
			var b = engine.height / _height;
			var zoom = a > b ? b : a;
			if(integerScale) {
				zoom = zoom | 0;
				if(zoom == 0) {
					zoom = 1;
				}
			}
			var horizontal = horizontalAlign;
			var vertical = verticalAlign;
			_gthis.viewportA = zoom * 2 / engine.width;
			_gthis.viewportD = zoom * 2 / engine.height;
			_gthis.viewportScaleX = zoom;
			_gthis.viewportScaleY = zoom;
			if(horizontal == null) {
				horizontal = h2d_ScaleModeAlign.Center;
			}
			switch(horizontal._hx_index) {
			case 0:
				_gthis.viewportX = -1;
				_gthis.offsetX = 0;
				break;
			case 1:
				_gthis.viewportX = 1 - _gthis.width * _gthis.viewportA;
				_gthis.offsetX = engine.width - _gthis.width * zoom;
				break;
			default:
				_gthis.viewportX = Math.floor((engine.width - _gthis.width * zoom) / (zoom * 2)) * _gthis.viewportA - 1.;
				_gthis.offsetX = Math.floor((engine.width - _gthis.width * zoom) / 2);
			}
			if(vertical == null) {
				vertical = h2d_ScaleModeAlign.Center;
			}
			switch(vertical._hx_index) {
			case 3:
				_gthis.viewportY = -1;
				_gthis.offsetY = 0;
				break;
			case 4:
				_gthis.viewportY = 1 - _gthis.height * _gthis.viewportD;
				_gthis.offsetY = engine.height - _gthis.height * zoom;
				break;
			default:
				_gthis.viewportY = Math.floor((engine.height - _gthis.height * zoom) / (zoom * 2)) * _gthis.viewportD - 1.;
				_gthis.offsetY = Math.floor((engine.height - _gthis.height * zoom) / 2);
			}
			break;
		case 3:
			var _width = _g.width;
			var _height = _g.height;
			var zoom = _g.zoom;
			var horizontalAlign = _g.horizontalAlign;
			var verticalAlign = _g.verticalAlign;
			if(_width != _gthis.width || _height != _gthis.height) {
				_gthis.width = _width;
				_gthis.height = _height;
				_gthis.posChanged = true;
			}
			var horizontal = horizontalAlign;
			var vertical = verticalAlign;
			_gthis.viewportA = zoom * 2 / engine.width;
			_gthis.viewportD = zoom * 2 / engine.height;
			_gthis.viewportScaleX = zoom;
			_gthis.viewportScaleY = zoom;
			if(horizontal == null) {
				horizontal = h2d_ScaleModeAlign.Center;
			}
			switch(horizontal._hx_index) {
			case 0:
				_gthis.viewportX = -1;
				_gthis.offsetX = 0;
				break;
			case 1:
				_gthis.viewportX = 1 - _gthis.width * _gthis.viewportA;
				_gthis.offsetX = engine.width - _gthis.width * zoom;
				break;
			default:
				_gthis.viewportX = Math.floor((engine.width - _gthis.width * zoom) / (zoom * 2)) * _gthis.viewportA - 1.;
				_gthis.offsetX = Math.floor((engine.width - _gthis.width * zoom) / 2);
			}
			if(vertical == null) {
				vertical = h2d_ScaleModeAlign.Center;
			}
			switch(vertical._hx_index) {
			case 3:
				_gthis.viewportY = -1;
				_gthis.offsetY = 0;
				break;
			case 4:
				_gthis.viewportY = 1 - _gthis.height * _gthis.viewportD;
				_gthis.offsetY = engine.height - _gthis.height * zoom;
				break;
			default:
				_gthis.viewportY = Math.floor((engine.height - _gthis.height * zoom) / (zoom * 2)) * _gthis.viewportD - 1.;
				_gthis.offsetY = Math.floor((engine.height - _gthis.height * zoom) / 2);
			}
			break;
		case 4:
			var level = _g.level;
			var w = Math.ceil(engine.width / level);
			var h = Math.ceil(engine.height / level);
			if(w != _gthis.width || h != _gthis.height) {
				_gthis.width = w;
				_gthis.height = h;
				_gthis.posChanged = true;
			}
			_gthis.viewportScaleX = level;
			_gthis.viewportScaleY = level;
			_gthis.viewportA = 2 / _gthis.width;
			_gthis.viewportD = 2 / _gthis.height;
			_gthis.viewportX = -1;
			_gthis.viewportY = -1;
			break;
		case 5:
			var minWidth = _g.minWidth;
			var minHeight = _g.minHeight;
			var integerScaling = _g.integerScaling;
			var a = engine.width / minWidth;
			var b = engine.height / minHeight;
			var zoom = a > b ? b : a;
			if(integerScaling) {
				zoom = zoom | 0;
				if(zoom == 0) {
					zoom = 1;
				}
			}
			var w = Math.ceil(engine.width / zoom);
			var h = Math.ceil(engine.height / zoom);
			if(w != _gthis.width || h != _gthis.height) {
				_gthis.width = w;
				_gthis.height = h;
				_gthis.posChanged = true;
			}
			_gthis.viewportScaleX = zoom;
			_gthis.viewportScaleY = zoom;
			_gthis.viewportA = 2 / _gthis.width;
			_gthis.viewportD = 2 / _gthis.height;
			_gthis.viewportX = -1;
			_gthis.viewportY = -1;
			break;
		}
	}
	,screenXToViewport: function(mx) {
		var _this = this.interactiveCamera;
		var mx = this.window.get_mouseX();
		var my = this.window.get_mouseY();
		return (((mx - _this.scene.offsetX) / _this.scene.viewportScaleX - _this.absX) * _this.matD - ((my - _this.scene.offsetY) / _this.scene.viewportScaleY - _this.absY) * _this.matC) * _this.invDet;
	}
	,screenYToViewport: function(my) {
		var _this = this.interactiveCamera;
		var mx = this.window.get_mouseX();
		var my = this.window.get_mouseY();
		return (-((mx - _this.scene.offsetX) / _this.scene.viewportScaleX - _this.absX) * _this.matB + ((my - _this.scene.offsetY) / _this.scene.viewportScaleY - _this.absY) * _this.matA) * _this.invDet;
	}
	,get_mouseX: function() {
		this.syncPos();
		var mx = this.window.get_mouseX();
		var _this = this.interactiveCamera;
		var mx = this.window.get_mouseX();
		var my = this.window.get_mouseY();
		var dx = (((mx - _this.scene.offsetX) / _this.scene.viewportScaleX - _this.absX) * _this.matD - ((my - _this.scene.offsetY) / _this.scene.viewportScaleY - _this.absY) * _this.matC) * _this.invDet - this.absX;
		if(this.matC == 0) {
			return dx / this.matA;
		}
		var my = this.window.get_mouseY();
		var _this = this.interactiveCamera;
		var mx = this.window.get_mouseX();
		var my = this.window.get_mouseY();
		var dy = (-((mx - _this.scene.offsetX) / _this.scene.viewportScaleX - _this.absX) * _this.matB + ((my - _this.scene.offsetY) / _this.scene.viewportScaleY - _this.absY) * _this.matA) * _this.invDet - this.absY;
		return (dx * this.matD - dy * this.matC) / (this.matA * this.matD - this.matB * this.matC);
	}
	,get_mouseY: function() {
		this.syncPos();
		var my = this.window.get_mouseY();
		var _this = this.interactiveCamera;
		var mx = this.window.get_mouseX();
		var my = this.window.get_mouseY();
		var dy = (-((mx - _this.scene.offsetX) / _this.scene.viewportScaleX - _this.absX) * _this.matB + ((my - _this.scene.offsetY) / _this.scene.viewportScaleY - _this.absY) * _this.matA) * _this.invDet - this.absY;
		if(this.matB == 0) {
			return dy / this.matD;
		}
		var mx = this.window.get_mouseX();
		var _this = this.interactiveCamera;
		var mx = this.window.get_mouseX();
		var my = this.window.get_mouseY();
		var dx = (((mx - _this.scene.offsetX) / _this.scene.viewportScaleX - _this.absX) * _this.matD - ((my - _this.scene.offsetY) / _this.scene.viewportScaleY - _this.absY) * _this.matC) * _this.invDet - this.absX;
		return (dy * this.matA - dx * this.matB) / (this.matA * this.matD - this.matB * this.matC);
	}
	,dispatchListeners: function(event) {
		this.screenToViewport(event);
		var _g = 0;
		var _g1 = this.eventListeners;
		while(_g < _g1.length) {
			var l = _g1[_g];
			++_g;
			l(event);
			if(!event.propagate) {
				break;
			}
		}
	}
	,isInteractiveVisible: function(i) {
		var s = i;
		while(s != this) {
			if(s == null || !s.visible) {
				return false;
			}
			s = s.parent;
		}
		return true;
	}
	,getInteractive: function(x,y) {
		var pt = this.shapePoint;
		var _g = 0;
		var _g1 = this.interactive;
		while(_g < _g1.length) {
			var i = _g1[_g];
			++_g;
			if(i.posChanged) {
				i.syncPos();
			}
			var dx = x - i.absX;
			var dy = y - i.absY;
			var rx = (dx * i.matD - dy * i.matC) * i.invDet;
			var ry = (dy * i.matA - dx * i.matB) * i.invDet;
			if(i.shape != null) {
				var _this = pt;
				var x1 = rx + i.shapeX;
				var y1 = ry + i.shapeY;
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				_this.x = x1;
				_this.y = y1;
				if(!i.shape.contains(pt)) {
					continue;
				}
			} else if(ry < 0 || rx < 0 || rx >= i.width || ry >= i.height) {
				continue;
			}
			var visible = true;
			var p = i;
			while(p != null) {
				if(!p.visible) {
					visible = false;
					break;
				}
				p = p.parent;
			}
			if(!visible) {
				continue;
			}
			return i;
		}
		return null;
	}
	,screenToViewport: function(e) {
		this.interactiveCamera.eventToCamera(e);
	}
	,dispatchEvent: function(event,to) {
		var i = to;
		this.screenToViewport(event);
		var dx = event.relX - i.absX;
		var dy = event.relY - i.absY;
		var rx = (dx * i.matD - dy * i.matC) * i.invDet;
		var ry = (dy * i.matA - dx * i.matB) * i.invDet;
		event.relX = rx;
		event.relY = ry;
		i.handleEvent(event);
	}
	,handleEvent: function(event,last) {
		this.screenToViewport(event);
		var ex = event.relX;
		var ey = event.relY;
		var index = last == null ? 0 : this.interactive.indexOf(last) + 1;
		var pt = this.shapePoint;
		var _g = index;
		var _g1 = this.interactive.length;
		while(_g < _g1) {
			var idx = _g++;
			var i = this.interactive[idx];
			if(i == null) {
				break;
			}
			if(i.invDet == 0) {
				continue;
			}
			var dx = ex - i.absX;
			var dy = ey - i.absY;
			var rx = (dx * i.matD - dy * i.matC) * i.invDet;
			var ry = (dy * i.matA - dx * i.matB) * i.invDet;
			if(i.shape != null) {
				var _this = pt;
				var x = rx + i.shapeX;
				var y = ry + i.shapeY;
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				_this.x = x;
				_this.y = y;
				if(!i.shape.contains(pt)) {
					continue;
				}
			} else if(ry < 0 || rx < 0 || rx >= i.width || ry >= i.height) {
				continue;
			}
			var visible = true;
			var p = i;
			while(p != null) {
				if(!p.visible) {
					visible = false;
					break;
				}
				p = p.parent;
			}
			if(!visible) {
				continue;
			}
			event.relX = rx;
			event.relY = ry;
			i.handleEvent(event);
			if(event.cancel) {
				event.cancel = false;
				event.propagate = false;
				continue;
			}
			return i;
		}
		return null;
	}
	,addEventListener: function(f) {
		this.eventListeners.push(f);
	}
	,removeEventListener: function(f) {
		var _g = 0;
		var _g1 = this.eventListeners;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			if(e == f) {
				HxOverrides.remove(this.eventListeners,e);
				return true;
			}
		}
		return false;
	}
	,startCapture: function(onEvent,onCancel,touchId) {
		var _gthis = this;
		this.events.startCapture(function(e) {
			_gthis.screenToViewport(e);
			onEvent(e);
		},onCancel,touchId);
	}
	,stopCapture: function() {
		this.events.stopCapture();
	}
	,startDrag: function(onEvent,onCancel,refEvent) {
		this.startCapture(onEvent,onCancel,refEvent != null ? refEvent.touchId : null);
	}
	,stopDrag: function() {
		this.stopCapture();
	}
	,getFocus: function() {
		if(this.events == null) {
			return null;
		}
		var f = this.events.getFocus();
		if(f == null) {
			return null;
		}
		var i = ((f) instanceof h2d_Interactive) ? f : null;
		if(i == null) {
			return null;
		}
		return this.interactive[this.interactive.indexOf(i)];
	}
	,addEventTarget: function(i) {
		var i1 = i;
		var lv = 0;
		while(i1 != null) {
			i1 = i1.parent;
			++lv;
		}
		var level = lv;
		var _g = 0;
		var _g1 = this.interactive.length;
		while(_g < _g1) {
			var index = _g++;
			var i1 = i;
			var i2 = this.interactive[index];
			var lv1 = level;
			var i3 = i2;
			var lv = 0;
			while(i3 != null) {
				i3 = i3.parent;
				++lv;
			}
			var lv2 = lv;
			var p1 = i1;
			var p2 = i2;
			while(lv1 > lv2) {
				i1 = p1;
				p1 = p1.parent;
				--lv1;
			}
			while(lv2 > lv1) {
				i2 = p2;
				p2 = p2.parent;
				--lv2;
			}
			while(p1 != p2) {
				i1 = p1;
				p1 = p1.parent;
				i2 = p2;
				p2 = p2.parent;
			}
			var id = -1;
			var _g2 = 0;
			var _g3 = p1.children.length;
			while(_g2 < _g3) {
				var k = _g2++;
				if(p1.children[k] == i1) {
					id = k;
					break;
				}
			}
			var tmp = id;
			var id1 = -1;
			var _g4 = 0;
			var _g5 = p2.children.length;
			while(_g4 < _g5) {
				var k1 = _g4++;
				if(p2.children[k1] == i2) {
					id1 = k1;
					break;
				}
			}
			if(tmp > id1) {
				this.interactive.splice(index,0,i);
				return;
			}
		}
		this.interactive.push(i);
	}
	,removeEventTarget: function(i,notify) {
		if(notify == null) {
			notify = false;
		}
		HxOverrides.remove(this.interactive,i);
		if(notify && this.events != null) {
			this.events.onRemove(i);
		}
	}
	,dispose: function() {
		if(this.allocated) {
			this.onRemove();
		}
		this.ctx.dispose();
	}
	,setElapsedTime: function(v) {
		this.ctx.elapsedTime = v;
	}
	,drawImplTo: function(s,texs,outputs) {
		var _g = 0;
		while(_g < texs.length) {
			var t = texs[_g];
			++_g;
			if((t.flags & 1 << h3d_mat_TextureFlags.Target._hx_index) == 0) {
				throw haxe_Exception.thrown("Can only draw to texture created with Target flag");
			}
		}
		this.ctx.engine = h3d_Engine.CURRENT;
		var oldBG = this.ctx.engine.backgroundColor;
		var inRender = this.ctx.engine.inRender;
		this.ctx.engine.backgroundColor = null;
		this.ctx.globalAlpha = this.alpha;
		var prevCtx = h3d_impl_RenderContext.get();
		if(!inRender) {
			this.ctx.engine.begin();
			this.ctx.begin();
		} else if(this.ctx.targetFlipY == 0) {
			this.ctx.begin();
		}
		this.ctx.pushTargets(texs);
		if(outputs != null) {
			this.ctx.output.setOutput(outputs);
		}
		s.drawRec(this.ctx);
		if(outputs != null) {
			this.ctx.output.setOutput();
		}
		this.ctx.popTarget();
		this.ctx.engine.backgroundColor = oldBG;
		if(!inRender) {
			this.ctx.end();
			this.ctx.engine.end();
		}
		if(prevCtx != null) {
			prevCtx.setCurrent();
		}
	}
	,syncOnly: function(et) {
		var engine = h3d_Engine.CURRENT;
		this.setElapsedTime(et);
		this.ctx.engine = engine;
		this.ctx.frame++;
		this.ctx.time += this.ctx.elapsedTime;
		this.ctx.globalAlpha = this.alpha;
		this.sync(this.ctx);
	}
	,render: function(engine) {
		this.ctx.engine = engine;
		this.ctx.frame++;
		this.ctx.time += this.ctx.elapsedTime;
		this.ctx.globalAlpha = this.alpha;
		this.mark("s2d");
		this.sync(this.ctx);
		if(this.children.length != 0) {
			this.ctx.begin();
			this.ctx.drawScene();
			this.ctx.end();
		}
		this.mark("vsync");
	}
	,mark: function(name) {
	}
	,sync: function(ctx) {
		var forceCamSync = this.posChanged;
		if(!this.allocated) {
			this.onAdd();
		}
		h2d_Layers.prototype.sync.call(this,ctx);
		var _g = 0;
		var _g1 = this._cameras;
		while(_g < _g1.length) {
			var cam = _g1[_g];
			++_g;
			cam.sync(ctx,forceCamSync);
		}
	}
	,clipBounds: function(ctx,bounds,scaleX,scaleY) {
		if(scaleY == null) {
			scaleY = 1.;
		}
		if(scaleX == null) {
			scaleX = 1.;
		}
		var matA;
		var matB;
		var matC;
		var matD;
		var absX;
		var absY;
		if(ctx.inFilter != null) {
			var f1 = ctx.baseShader.filterMatrixA__;
			var f2 = ctx.baseShader.filterMatrixB__;
			var tmpA = this.matA * f1.x + this.matB * f1.y;
			var tmpB = this.matA * f2.x + this.matB * f2.y;
			var tmpC = this.matC * f1.x + this.matD * f1.y;
			var tmpD = this.matC * f2.x + this.matD * f2.y;
			var tmpX = this.absX * f1.x + this.absY * f1.y + f1.z;
			var tmpY = this.absX * f2.x + this.absY * f2.y + f2.z;
			matA = (tmpA * ctx.viewA + tmpB * ctx.viewC) / scaleX;
			matB = (tmpA * ctx.viewB + tmpB * ctx.viewD) / scaleY;
			matC = (tmpC * ctx.viewA + tmpD * ctx.viewC) / scaleX;
			matD = (tmpC * ctx.viewB + tmpD * ctx.viewD) / scaleY;
			absX = tmpX * ctx.viewA + tmpY * ctx.viewC + ctx.viewX;
			absY = tmpX * ctx.viewB + tmpY * ctx.viewD + ctx.viewY;
		} else {
			matA = (this.matA * ctx.viewA + this.matB * ctx.viewC) / scaleX;
			matB = (this.matA * ctx.viewB + this.matB * ctx.viewD) / scaleY;
			matC = (this.matC * ctx.viewA + this.matD * ctx.viewC) / scaleX;
			matD = (this.matC * ctx.viewB + this.matD * ctx.viewD) / scaleY;
			absX = this.absX * ctx.viewA + this.absY * ctx.viewC + ctx.viewX;
			absY = this.absX * ctx.viewB + this.absY * ctx.viewD + ctx.viewY;
		}
		var invDet = 1 / (matA * matD - matB * matC);
		bounds.xMin = ((-1 - absX) * matD + (absY + 1) * matC) * invDet;
		bounds.yMin = ((absX + 1) * matB + (-1 - absY) * matA) * invDet;
		bounds.xMax = ((1 - absX) * matD + (absY - 1) * matC) * invDet;
		bounds.yMax = ((absX - 1) * matB + (1 - absY) * matA) * invDet;
	}
	,drawContent: function(ctx) {
		if(ctx.front2back) {
			var _g = 0;
			var _g1 = this._cameras;
			while(_g < _g1.length) {
				var cam = _g1[_g];
				++_g;
				if(!cam.visible) {
					continue;
				}
				var i = this.children.length;
				var l = this.layerCount;
				cam.enter(ctx);
				while(l-- > 0) {
					var top = l == 0 ? 0 : this.layersIndexes[l - 1];
					if(cam.layerVisible(l)) {
						while(i >= top) this.children[i--].drawRec(ctx);
					} else {
						i = top - 1;
					}
				}
				cam.exit(ctx);
			}
			this.draw(ctx);
		} else {
			this.draw(ctx);
			var _g = 0;
			var _g1 = this._cameras;
			while(_g < _g1.length) {
				var cam = _g1[_g];
				++_g;
				if(!cam.visible) {
					continue;
				}
				var i = 0;
				var l = 0;
				cam.enter(ctx);
				while(l < this.layerCount) {
					var top = this.layersIndexes[l++];
					if(cam.layerVisible(l - 1)) {
						while(i < top) this.children[i++].drawRec(ctx);
					} else {
						i = top;
					}
				}
				cam.exit(ctx);
			}
		}
	}
	,onAdd: function() {
		this.checkResize();
		h2d_Layers.prototype.onAdd.call(this);
		this.window.addResizeEvent($bind(this,this.checkResize));
	}
	,onRemove: function() {
		h2d_Layers.prototype.onRemove.call(this);
		this.window.removeResizeEvent($bind(this,this.checkResize));
	}
	,captureBitmap: function(target) {
		var engine = h3d_Engine.CURRENT;
		if(target == null) {
			var tex = new h3d_mat_Texture(this.width,this.height,[h3d_mat_TextureFlags.Target]);
			target = new h2d_Tile(tex,0,0,this.width,this.height);
		}
		var tex = target.innerTex;
		engine.begin();
		engine.pushTarget(tex);
		engine.setRenderZone(target.x | 0,target.y | 0,Math.ceil(target.width),Math.ceil(target.height));
		var ow = this.width;
		var oh = this.height;
		var ova = this.viewportA;
		var ovd = this.viewportD;
		var ovx = this.viewportX;
		var ovy = this.viewportY;
		this.width = tex.width;
		this.height = tex.height;
		this.viewportA = 2 / this.width;
		this.viewportD = 2 / this.height;
		this.viewportX = -1;
		this.viewportY = -1;
		this.posChanged = true;
		this.render(engine);
		engine.popTarget();
		this.width = ow;
		this.height = oh;
		this.viewportA = ova;
		this.viewportD = ovd;
		this.viewportX = ovx;
		this.viewportY = ovy;
		this.posChanged = true;
		engine.setRenderZone();
		engine.end();
		return new h2d_Bitmap(target);
	}
	,__class__: h2d_Scene
});
var game_scene_basic_BasicScene = function() {
	h2d_Scene.call(this);
	this.debugGraphics = new h2d_Graphics(this);
};
$hxClasses["game.scene.basic.BasicScene"] = game_scene_basic_BasicScene;
game_scene_basic_BasicScene.__name__ = "game.scene.basic.BasicScene";
game_scene_basic_BasicScene.__super__ = h2d_Scene;
game_scene_basic_BasicScene.prototype = $extend(h2d_Scene.prototype,{
	render: function(e) {
		this.debugGraphics.clear();
		h2d_Scene.prototype.render.call(this,e);
	}
	,onResize: function() {
		haxe_Log.trace("BasicScene onResize",{ fileName : "src/game/scene/basic/BasicScene.hx", lineNumber : 21, className : "game.scene.basic.BasicScene", methodName : "onResize"});
	}
	,__class__: game_scene_basic_BasicScene
});
var game_scene_impl_GameScene = function() {
	game_scene_basic_BasicScene.call(this);
	this.gameUiScene = new game_scene_ui_GameUiScene();
	this.gamePresenter = new game_mvp_presenter_GamePresenter(this);
	haxe_Log.trace("GameScene created with MVP integration",{ fileName : "src/game/scene/impl/GameScene.hx", lineNumber : 20, className : "game.scene.impl.GameScene", methodName : "new"});
};
$hxClasses["game.scene.impl.GameScene"] = game_scene_impl_GameScene;
game_scene_impl_GameScene.__name__ = "game.scene.impl.GameScene";
game_scene_impl_GameScene.__super__ = game_scene_basic_BasicScene;
game_scene_impl_GameScene.prototype = $extend(game_scene_basic_BasicScene.prototype,{
	start: function() {
		haxe_Log.trace("GameScene started",{ fileName : "src/game/scene/impl/GameScene.hx", lineNumber : 24, className : "game.scene.impl.GameScene", methodName : "start"});
		this.gamePresenter.start();
		haxe_Log.trace("GameScene MVP integration complete",{ fileName : "src/game/scene/impl/GameScene.hx", lineNumber : 45, className : "game.scene.impl.GameScene", methodName : "start"});
	}
	,destroy: function() {
		haxe_Log.trace("GameScene destroyed",{ fileName : "src/game/scene/impl/GameScene.hx", lineNumber : 49, className : "game.scene.impl.GameScene", methodName : "destroy"});
		if(this.gamePresenter != null) {
			this.gamePresenter.destroy();
			this.gamePresenter = null;
		}
	}
	,customUpdate: function(dt,fps) {
		if(this.gamePresenter != null && this.gamePresenter.isGameRunning()) {
			this.gamePresenter.update(dt);
		}
	}
	,render: function(e) {
		game_scene_basic_BasicScene.prototype.render.call(this,e);
		if(this.gameUiScene != null) {
			this.gameUiScene.render(e);
		}
	}
	,__class__: game_scene_impl_GameScene
});
var game_scene_impl_HomeScene = function() {
	game_scene_basic_BasicScene.call(this);
	haxe_Log.trace("HomeScene created",{ fileName : "src/game/scene/impl/HomeScene.hx", lineNumber : 8, className : "game.scene.impl.HomeScene", methodName : "new"});
};
$hxClasses["game.scene.impl.HomeScene"] = game_scene_impl_HomeScene;
game_scene_impl_HomeScene.__name__ = "game.scene.impl.HomeScene";
game_scene_impl_HomeScene.__super__ = game_scene_basic_BasicScene;
game_scene_impl_HomeScene.prototype = $extend(game_scene_basic_BasicScene.prototype,{
	start: function() {
		haxe_Log.trace("HomeScene started",{ fileName : "src/game/scene/impl/HomeScene.hx", lineNumber : 12, className : "game.scene.impl.HomeScene", methodName : "start"});
	}
	,destroy: function() {
		haxe_Log.trace("HomeScene destroyed",{ fileName : "src/game/scene/impl/HomeScene.hx", lineNumber : 16, className : "game.scene.impl.HomeScene", methodName : "destroy"});
	}
	,customUpdate: function(dt,fps) {
		haxe_Log.trace("HomeScene updated",{ fileName : "src/game/scene/impl/HomeScene.hx", lineNumber : 20, className : "game.scene.impl.HomeScene", methodName : "customUpdate"});
	}
	,__class__: game_scene_impl_HomeScene
});
var game_scene_impl_LoadingScene = function() {
	game_scene_basic_BasicScene.call(this);
	haxe_Log.trace("LoadingScene created",{ fileName : "src/game/scene/impl/LoadingScene.hx", lineNumber : 9, className : "game.scene.impl.LoadingScene", methodName : "new"});
};
$hxClasses["game.scene.impl.LoadingScene"] = game_scene_impl_LoadingScene;
game_scene_impl_LoadingScene.__name__ = "game.scene.impl.LoadingScene";
game_scene_impl_LoadingScene.__super__ = game_scene_basic_BasicScene;
game_scene_impl_LoadingScene.prototype = $extend(game_scene_basic_BasicScene.prototype,{
	start: function() {
		haxe_Log.trace("LoadingScene started",{ fileName : "src/game/scene/impl/LoadingScene.hx", lineNumber : 13, className : "game.scene.impl.LoadingScene", methodName : "start"});
		game_event_EventManager.instance.notify(game_event_EventManager.EVENT_LOAD_GAME_SCENE,null);
	}
	,destroy: function() {
		haxe_Log.trace("LoadingScene destroyed",{ fileName : "src/game/scene/impl/LoadingScene.hx", lineNumber : 18, className : "game.scene.impl.LoadingScene", methodName : "destroy"});
	}
	,customUpdate: function(dt,fps) {
		haxe_Log.trace("LoadingScene updated",{ fileName : "src/game/scene/impl/LoadingScene.hx", lineNumber : 22, className : "game.scene.impl.LoadingScene", methodName : "customUpdate"});
	}
	,__class__: game_scene_impl_LoadingScene
});
var game_scene_ui_GameUiScene = function() {
	h2d_Scene.call(this);
	var font = hxd_res_DefaultFont.get();
	var tf = new h2d_Text(font);
	tf.set_text("Hello World\nHeaps is great!");
	tf.set_textAlign(h2d_Align.Center);
	var x = 1;
	var y = 0;
	var z = 0;
	var w = 1;
	if(w == null) {
		w = 1.;
	}
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	tf.color = new h3d_Vector4Impl(x,y,z,w);
	this.addChild(tf);
	tf.posChanged = true;
	tf.x = 100;
	tf.posChanged = true;
	tf.y = 200;
	haxe_Log.trace("GameUiScene created",{ fileName : "src/game/scene/ui/GameUiScene.hx", lineNumber : 18, className : "game.scene.ui.GameUiScene", methodName : "new"});
};
$hxClasses["game.scene.ui.GameUiScene"] = game_scene_ui_GameUiScene;
game_scene_ui_GameUiScene.__name__ = "game.scene.ui.GameUiScene";
game_scene_ui_GameUiScene.__super__ = h2d_Scene;
game_scene_ui_GameUiScene.prototype = $extend(h2d_Scene.prototype,{
	__class__: game_scene_ui_GameUiScene
});
var h2d_Drawable = function(parent) {
	h2d_Object.call(this,parent);
	var x = 1;
	var y = 1;
	var z = 1;
	var w = 1;
	if(w == null) {
		w = 1.;
	}
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.color = new h3d_Vector4Impl(x,y,z,w);
};
$hxClasses["h2d.Drawable"] = h2d_Drawable;
h2d_Drawable.__name__ = "h2d.Drawable";
h2d_Drawable.__super__ = h2d_Object;
h2d_Drawable.prototype = $extend(h2d_Object.prototype,{
	set_tileWrap: function(b) {
		return this.tileWrap = b;
	}
	,get_colorAdd: function() {
		var s = this.getShader(h3d_shader_ColorAdd);
		if(s == null) {
			return null;
		} else {
			return s.color__;
		}
	}
	,set_colorAdd: function(c) {
		var s = this.getShader(h3d_shader_ColorAdd);
		if(s == null) {
			if(c != null) {
				s = this.addShader(new h3d_shader_ColorAdd());
				s.color__ = c;
			}
		} else if(c == null) {
			this.removeShader(s);
		} else {
			s.color__ = c;
		}
		return c;
	}
	,drawFiltered: function(ctx,tile) {
		var old = this.shaders;
		this.shaders = null;
		h2d_Object.prototype.drawFiltered.call(this,ctx,tile);
		this.shaders = old;
	}
	,set_colorKey: function(v) {
		var s = this.getShader(h3d_shader_ColorKey);
		if(s == null) {
			if(v != null) {
				s = this.addShader(new h3d_shader_ColorKey(-16777216 | v));
			}
		} else if(v == null) {
			this.removeShader(s);
		} else {
			var _this = s.colorKey__;
			var c = -16777216 | v;
			_this.x = (c >> 16 & 255) / 255;
			_this.y = (c >> 8 & 255) / 255;
			_this.z = (c & 255) / 255;
			_this.w = (c >>> 24) / 255;
		}
		return this.colorKey = v;
	}
	,adjustColor: function(col) {
		if(col == null) {
			this.set_colorMatrix(null);
		} else {
			var m = this.get_colorMatrix();
			if(m == null) {
				m = new h3d_MatrixImpl();
				this.set_colorMatrix(m);
			}
			m.identity();
			m.adjustColor(col);
		}
	}
	,get_colorMatrix: function() {
		var s = this.getShader(h3d_shader_ColorMatrix);
		if(s == null) {
			return null;
		} else {
			return s.matrix__;
		}
	}
	,set_colorMatrix: function(m) {
		var s = this.getShader(h3d_shader_ColorMatrix);
		if(s == null) {
			if(m != null) {
				s = this.addShader(new h3d_shader_ColorMatrix());
				s.matrix__ = m;
			}
		} else if(m == null) {
			this.removeShader(s);
		} else {
			s.matrix__ = m;
		}
		return m;
	}
	,getShader: function(stype) {
		if(this.shaders != null) {
			var _g_l = this.shaders;
			var _g_last = null;
			while(_g_l != _g_last) {
				var s = _g_l.s;
				_g_l = _g_l.next;
				var s1 = s;
				var s2 = js_Boot.__downcastCheck(s1,stype) ? s1 : null;
				if(s2 != null) {
					return s2;
				}
			}
		}
		return null;
	}
	,getShaders: function() {
		return new hxsl__$ShaderList_ShaderIterator(this.shaders,null);
	}
	,addShader: function(s) {
		if(s == null) {
			throw haxe_Exception.thrown("Can't add null shader");
		}
		this.shaders = hxsl_ShaderList.addSort(s,this.shaders);
		return s;
	}
	,removeShader: function(s) {
		var prev = null;
		var cur = this.shaders;
		while(cur != null) {
			if(cur.s == s) {
				if(prev == null) {
					this.shaders = cur.next;
				} else {
					prev.next = cur.next;
				}
				return true;
			}
			prev = cur;
			cur = cur.next;
		}
		return false;
	}
	,emitTile: function(ctx,tile) {
		if(tile == null) {
			tile = new h2d_Tile(null,0,0,5,5);
		}
		if(!ctx.drawTile(this,tile)) {
			return;
		}
	}
	,__class__: h2d_Drawable
});
var h2d_Bitmap = function(tile,parent) {
	h2d_Drawable.call(this,parent);
	this.set_tile(tile);
};
$hxClasses["h2d.Bitmap"] = h2d_Bitmap;
h2d_Bitmap.__name__ = "h2d.Bitmap";
h2d_Bitmap.__super__ = h2d_Drawable;
h2d_Bitmap.prototype = $extend(h2d_Drawable.prototype,{
	getBoundsRec: function(relativeTo,out,forSize) {
		h2d_Drawable.prototype.getBoundsRec.call(this,relativeTo,out,forSize);
		if(this.tile != null) {
			if(this.width == null && this.height == null) {
				this.addBounds(relativeTo,out,this.tile.dx,this.tile.dy,this.tile.width,this.tile.height);
			} else {
				this.addBounds(relativeTo,out,this.tile.dx,this.tile.dy,this.width != null ? this.width : this.tile.width * this.height / this.tile.height,this.height != null ? this.height : this.tile.height * this.width / this.tile.width);
			}
		}
	}
	,set_width: function(w) {
		if(this.width == w) {
			return w;
		}
		this.width = w;
		if(this.parentContainer != null) {
			this.parentContainer.contentChanged(this);
		}
		return w;
	}
	,set_height: function(h) {
		if(this.height == h) {
			return h;
		}
		this.height = h;
		if(this.parentContainer != null) {
			this.parentContainer.contentChanged(this);
		}
		return h;
	}
	,set_tile: function(t) {
		if(this.tile == t) {
			return t;
		}
		this.tile = t;
		if(this.parentContainer != null) {
			this.parentContainer.contentChanged(this);
		}
		return t;
	}
	,draw: function(ctx) {
		if(this.width == null && this.height == null) {
			this.emitTile(ctx,this.tile);
			return;
		}
		if(this.tile == null) {
			this.set_tile(h2d_Tile.fromColor(16711935));
		}
		var ow = this.tile.width;
		var oh = this.tile.height;
		this.tile.width = this.width != null ? this.width : ow * this.height / oh;
		this.tile.height = this.height != null ? this.height : oh * this.width / ow;
		this.emitTile(ctx,this.tile);
		this.tile.width = ow;
		this.tile.height = oh;
	}
	,__class__: h2d_Bitmap
});
var h2d_BlendMode = $hxEnums["h2d.BlendMode"] = { __ename__:true,__constructs__:null
	,None: {_hx_name:"None",_hx_index:0,__enum__:"h2d.BlendMode",toString:$estr}
	,Alpha: {_hx_name:"Alpha",_hx_index:1,__enum__:"h2d.BlendMode",toString:$estr}
	,Add: {_hx_name:"Add",_hx_index:2,__enum__:"h2d.BlendMode",toString:$estr}
	,AlphaAdd: {_hx_name:"AlphaAdd",_hx_index:3,__enum__:"h2d.BlendMode",toString:$estr}
	,SoftAdd: {_hx_name:"SoftAdd",_hx_index:4,__enum__:"h2d.BlendMode",toString:$estr}
	,Multiply: {_hx_name:"Multiply",_hx_index:5,__enum__:"h2d.BlendMode",toString:$estr}
	,AlphaMultiply: {_hx_name:"AlphaMultiply",_hx_index:6,__enum__:"h2d.BlendMode",toString:$estr}
	,Erase: {_hx_name:"Erase",_hx_index:7,__enum__:"h2d.BlendMode",toString:$estr}
	,Screen: {_hx_name:"Screen",_hx_index:8,__enum__:"h2d.BlendMode",toString:$estr}
	,Sub: {_hx_name:"Sub",_hx_index:9,__enum__:"h2d.BlendMode",toString:$estr}
	,Max: {_hx_name:"Max",_hx_index:10,__enum__:"h2d.BlendMode",toString:$estr}
	,Min: {_hx_name:"Min",_hx_index:11,__enum__:"h2d.BlendMode",toString:$estr}
};
h2d_BlendMode.__constructs__ = [h2d_BlendMode.None,h2d_BlendMode.Alpha,h2d_BlendMode.Add,h2d_BlendMode.AlphaAdd,h2d_BlendMode.SoftAdd,h2d_BlendMode.Multiply,h2d_BlendMode.AlphaMultiply,h2d_BlendMode.Erase,h2d_BlendMode.Screen,h2d_BlendMode.Sub,h2d_BlendMode.Max,h2d_BlendMode.Min];
h2d_BlendMode.__empty_constructs__ = [h2d_BlendMode.None,h2d_BlendMode.Alpha,h2d_BlendMode.Add,h2d_BlendMode.AlphaAdd,h2d_BlendMode.SoftAdd,h2d_BlendMode.Multiply,h2d_BlendMode.AlphaMultiply,h2d_BlendMode.Erase,h2d_BlendMode.Screen,h2d_BlendMode.Sub,h2d_BlendMode.Max,h2d_BlendMode.Min];
var h2d_Camera = function(scene) {
	this.followRotation = false;
	this.posChanged = true;
	this.x = 0;
	this.posChanged = true;
	this.y = 0;
	this.posChanged = true;
	this.scaleX = 1;
	this.posChanged = true;
	this.scaleY = 1;
	this.posChanged = true;
	this.rotation = 0;
	this.posChanged = true;
	this.anchorX = 0;
	this.posChanged = true;
	this.anchorY = 0;
	this.viewX = 0;
	this.viewY = 0;
	this.viewW = 1;
	this.viewH = 1;
	this.visible = true;
	if(scene != null) {
		scene.addCamera(this);
	}
};
$hxClasses["h2d.Camera"] = h2d_Camera;
h2d_Camera.__name__ = "h2d.Camera";
h2d_Camera.prototype = {
	remove: function() {
		if(this.scene != null) {
			this.scene.removeCamera(this);
		}
	}
	,layerVisible: function(layer) {
		return true;
	}
	,enter: function(ctx) {
		ctx.pushCamera(this);
		if(this.clipViewport) {
			var old = ctx.inFilter;
			ctx.inFilter = null;
			ctx.pushRenderZone(this.viewX * this.scene.width,this.viewY * this.scene.height,this.viewW * this.scene.width,this.viewH * this.scene.height);
			ctx.inFilter = old;
		}
	}
	,exit: function(ctx) {
		if(this.clipViewport) {
			var old = ctx.inFilter;
			ctx.inFilter = null;
			ctx.popRenderZone();
			ctx.inFilter = old;
		}
		ctx.popCamera();
	}
	,sync: function(ctx,force) {
		if(force == null) {
			force = false;
		}
		if(this.scene == null) {
			return;
		}
		if(this.follow != null) {
			this.posChanged = true;
			this.x = this.follow.absX;
			this.posChanged = true;
			this.y = this.follow.absY;
			if(this.followRotation) {
				this.posChanged = true;
				this.rotation = -this.follow.rotation;
			}
		}
		if(this.posChanged || force) {
			if(this.rotation == 0) {
				this.matA = this.scaleX;
				this.matB = 0;
				this.matC = 0;
				this.matD = this.scaleY;
			} else {
				var cr = Math.cos(this.rotation);
				var sr = Math.sin(this.rotation);
				this.matA = this.scaleX * cr;
				this.matB = this.scaleX * sr;
				this.matC = this.scaleY * -sr;
				this.matD = this.scaleY * cr;
			}
			this.absX = Math.round(-(this.x * this.matA + this.y * this.matC) + this.scene.width * this.anchorX * this.viewW + this.scene.width * this.viewX);
			this.absY = Math.round(-(this.x * this.matB + this.y * this.matD) + this.scene.height * this.anchorY * this.viewH + this.scene.height * this.viewY);
			this.invDet = 1 / (this.matA * this.matD - this.matB * this.matC);
			this.posChanged = false;
		}
	}
	,setScale: function(x,y) {
		this.posChanged = true;
		this.scaleX = x;
		this.posChanged = true;
		this.scaleY = y;
	}
	,scale: function(x,y) {
		this.posChanged = true;
		this.scaleX *= x;
		this.posChanged = true;
		this.scaleY *= y;
	}
	,setPosition: function(x,y) {
		this.posChanged = true;
		this.x = x;
		this.posChanged = true;
		this.y = y;
	}
	,move: function(dx,dy) {
		this.posChanged = true;
		this.x += dx;
		this.posChanged = true;
		this.y += dy;
	}
	,rotate: function(angle) {
		this.posChanged = true;
		this.rotation += angle;
	}
	,setAnchor: function(x,y) {
		this.posChanged = true;
		this.anchorX = x;
		this.posChanged = true;
		this.anchorY = y;
	}
	,setViewport: function(x,y,w,h) {
		if(h == null) {
			h = 0;
		}
		if(w == null) {
			w = 0;
		}
		if(y == null) {
			y = 0;
		}
		if(x == null) {
			x = 0;
		}
		if(this.scene == null) {
			throw haxe_Exception.thrown("This method requires Camera to be added to the Scene");
		}
		if(this.scene == null) {
			throw haxe_Exception.thrown("This method requires Camera to be added to the Scene");
		}
		this.posChanged = true;
		this.viewX = Math.floor(x) / this.scene.width;
		if(this.scene == null) {
			throw haxe_Exception.thrown("This method requires Camera to be added to the Scene");
		}
		this.posChanged = true;
		this.viewY = Math.floor(y) / this.scene.height;
		var v = w == 0 ? this.scene.width : w;
		if(this.scene == null) {
			throw haxe_Exception.thrown("This method requires Camera to be added to the Scene");
		}
		this.posChanged = true;
		this.viewW = Math.ceil(v) / this.scene.width;
		var v = h == 0 ? this.scene.height : h;
		if(this.scene == null) {
			throw haxe_Exception.thrown("This method requires Camera to be added to the Scene");
		}
		this.posChanged = true;
		this.viewH = Math.ceil(v) / this.scene.height;
	}
	,setRawViewport: function(x,y,w,h) {
		if(h == null) {
			h = 1;
		}
		if(w == null) {
			w = 1;
		}
		if(y == null) {
			y = 0;
		}
		if(x == null) {
			x = 0;
		}
		this.viewX = x;
		this.viewY = y;
		this.viewW = w;
		this.viewH = h;
		this.posChanged = true;
	}
	,screenXToCamera: function(mx,my) {
		return (((mx - this.scene.offsetX) / this.scene.viewportScaleX - this.absX) * this.matD - ((my - this.scene.offsetY) / this.scene.viewportScaleY - this.absY) * this.matC) * this.invDet;
	}
	,screenYToCamera: function(mx,my) {
		return (-((mx - this.scene.offsetX) / this.scene.viewportScaleX - this.absX) * this.matB + ((my - this.scene.offsetY) / this.scene.viewportScaleY - this.absY) * this.matA) * this.invDet;
	}
	,cameraXToScreen: function(mx,my) {
		return (mx * this.matA + my * this.matC + this.absX) * this.scene.viewportScaleX + this.scene.offsetX;
	}
	,cameraYToScreen: function(mx,my) {
		return (mx * this.matB + my * this.matD + this.absY) * this.scene.viewportScaleY + this.scene.offsetY;
	}
	,sceneXToCamera: function(mx,my) {
		return ((mx - this.absX) * this.matD - (my - this.absY) * this.matC) * this.invDet;
	}
	,sceneYToCamera: function(mx,my) {
		return (-(mx - this.absX) * this.matB + (my - this.absY) * this.matA) * this.invDet;
	}
	,cameraXToScene: function(mx,my) {
		return mx * this.matA + my * this.matC + this.absX;
	}
	,cameraYToScene: function(mx,my) {
		return mx * this.matB + my * this.matD + this.absY;
	}
	,eventToCamera: function(e) {
		var x = (e.relX - this.scene.offsetX) / this.scene.viewportScaleX - this.absX;
		var y = (e.relY - this.scene.offsetY) / this.scene.viewportScaleY - this.absY;
		e.relX = (x * this.matD - y * this.matC) * this.invDet;
		e.relY = (-x * this.matB + y * this.matA) * this.invDet;
	}
	,screenToCamera: function(pt) {
		if(this.scene == null) {
			throw haxe_Exception.thrown("This method requires Camera to be added to the Scene");
		}
		var x = (pt.x - this.scene.offsetX) / this.scene.viewportScaleX - this.absX;
		var y = (pt.y - this.scene.offsetY) / this.scene.viewportScaleY - this.absY;
		pt.x = (x * this.matD - y * this.matC) * this.invDet;
		pt.y = (-x * this.matB + y * this.matA) * this.invDet;
	}
	,cameraToScreen: function(pt) {
		if(this.scene == null) {
			throw haxe_Exception.thrown("This method requires Camera to be added to the Scene");
		}
		var x = pt.x;
		var y = pt.y;
		pt.x = (x * this.matA + y * this.matC + this.absX) * this.scene.viewportScaleX + this.scene.offsetX;
		pt.y = (x * this.matB + y * this.matD + this.absY) * this.scene.viewportScaleY + this.scene.offsetY;
	}
	,sceneToCamera: function(pt) {
		if(this.scene == null) {
			throw haxe_Exception.thrown("This method requires Camera to be added to the Scene");
		}
		var x = pt.x - this.absX;
		var y = pt.y - this.absY;
		pt.x = (x * this.matD - y * this.matC) * this.invDet;
		pt.y = (-x * this.matB + y * this.matA) * this.invDet;
	}
	,cameraToScene: function(pt) {
		if(this.scene == null) {
			throw haxe_Exception.thrown("This method requires Camera to be added to the Scene");
		}
		var x = pt.x;
		var y = pt.y;
		pt.x = x * this.matA + y * this.matC + this.absX;
		pt.y = x * this.matB + y * this.matD + this.absY;
	}
	,checkScene: function() {
		if(this.scene == null) {
			throw haxe_Exception.thrown("This method requires Camera to be added to the Scene");
		}
	}
	,set_x: function(v) {
		this.posChanged = true;
		return this.x = v;
	}
	,set_y: function(v) {
		this.posChanged = true;
		return this.y = v;
	}
	,set_scaleX: function(v) {
		this.posChanged = true;
		return this.scaleX = v;
	}
	,set_scaleY: function(v) {
		this.posChanged = true;
		return this.scaleY = v;
	}
	,set_rotation: function(v) {
		this.posChanged = true;
		return this.rotation = v;
	}
	,get_viewportX: function() {
		if(this.scene == null) {
			throw haxe_Exception.thrown("This method requires Camera to be added to the Scene");
		}
		return this.viewX * this.scene.width;
	}
	,set_viewportX: function(v) {
		if(this.scene == null) {
			throw haxe_Exception.thrown("This method requires Camera to be added to the Scene");
		}
		this.posChanged = true;
		this.viewX = Math.floor(v) / this.scene.width;
		return v;
	}
	,get_viewportY: function() {
		if(this.scene == null) {
			throw haxe_Exception.thrown("This method requires Camera to be added to the Scene");
		}
		return this.viewY * this.scene.height;
	}
	,set_viewportY: function(v) {
		if(this.scene == null) {
			throw haxe_Exception.thrown("This method requires Camera to be added to the Scene");
		}
		this.posChanged = true;
		this.viewY = Math.floor(v) / this.scene.height;
		return v;
	}
	,get_viewportWidth: function() {
		if(this.scene == null) {
			throw haxe_Exception.thrown("This method requires Camera to be added to the Scene");
		}
		return this.viewW * this.scene.width;
	}
	,set_viewportWidth: function(v) {
		if(this.scene == null) {
			throw haxe_Exception.thrown("This method requires Camera to be added to the Scene");
		}
		this.posChanged = true;
		this.viewW = Math.ceil(v) / this.scene.width;
		return v;
	}
	,get_viewportHeight: function() {
		if(this.scene == null) {
			throw haxe_Exception.thrown("This method requires Camera to be added to the Scene");
		}
		return this.viewH * this.scene.height;
	}
	,set_viewportHeight: function(v) {
		if(this.scene == null) {
			throw haxe_Exception.thrown("This method requires Camera to be added to the Scene");
		}
		this.posChanged = true;
		this.viewH = Math.ceil(v) / this.scene.height;
		return v;
	}
	,set_anchorX: function(v) {
		this.posChanged = true;
		return this.anchorX = v;
	}
	,set_anchorY: function(v) {
		this.posChanged = true;
		return this.anchorY = v;
	}
	,__class__: h2d_Camera
};
var h2d_Kerning = function(c,o) {
	this.prevChar = c;
	this.offset = o;
};
$hxClasses["h2d.Kerning"] = h2d_Kerning;
h2d_Kerning.__name__ = "h2d.Kerning";
h2d_Kerning.prototype = {
	__class__: h2d_Kerning
};
var h2d_FontChar = function(t,w) {
	this.t = t;
	this.width = w;
};
$hxClasses["h2d.FontChar"] = h2d_FontChar;
h2d_FontChar.__name__ = "h2d.FontChar";
h2d_FontChar.prototype = {
	addKerning: function(prevChar,offset) {
		var k = new h2d_Kerning(prevChar,offset);
		k.next = this.kerning;
		this.kerning = k;
	}
	,getKerningOffset: function(prevChar) {
		var k = this.kerning;
		while(k != null) {
			if(k.prevChar == prevChar) {
				return k.offset;
			}
			k = k.next;
		}
		return 0;
	}
	,clone: function() {
		var c = new h2d_FontChar(this.t.clone(),this.width);
		var k = this.kerning;
		if(k != null) {
			var kc = new h2d_Kerning(k.prevChar,k.offset);
			c.kerning = kc;
			k = k.next;
			while(k != null) {
				var kn = new h2d_Kerning(k.prevChar,k.offset);
				kc = kc.next = kn;
				k = k.next;
			}
		}
		return c;
	}
	,__class__: h2d_FontChar
};
var h2d_FontType = $hxEnums["h2d.FontType"] = { __ename__:true,__constructs__:null
	,BitmapFont: {_hx_name:"BitmapFont",_hx_index:0,__enum__:"h2d.FontType",toString:$estr}
	,SignedDistanceField: ($_=function(channel,alphaCutoff,smoothing) { return {_hx_index:1,channel:channel,alphaCutoff:alphaCutoff,smoothing:smoothing,__enum__:"h2d.FontType",toString:$estr}; },$_._hx_name="SignedDistanceField",$_.__params__ = ["channel","alphaCutoff","smoothing"],$_)
};
h2d_FontType.__constructs__ = [h2d_FontType.BitmapFont,h2d_FontType.SignedDistanceField];
h2d_FontType.__empty_constructs__ = [h2d_FontType.BitmapFont];
var h2d_Font = function(name,size,type) {
	this.offsetY = 0;
	this.offsetX = 0;
	this.name = name;
	this.size = size;
	this.initSize = size;
	this.glyphs = new haxe_ds_IntMap();
	this.defaultChar = this.nullChar = new h2d_FontChar(new h2d_Tile(null,0,0,0,0),0);
	this.charset = hxd_Charset.getDefault();
	if(name != null) {
		this.tilePath = haxe_io_Path.withExtension(name,"png");
	}
	if(type == null) {
		this.type = h2d_FontType.BitmapFont;
	} else {
		this.type = type;
	}
};
$hxClasses["h2d.Font"] = h2d_Font;
h2d_Font.__name__ = "h2d.Font";
h2d_Font.prototype = {
	getChar: function(code) {
		var c = this.glyphs.h[code];
		if(c == null) {
			c = this.charset.resolveChar(code,this.glyphs);
			if(c == null) {
				c = code == 13 || code == 10 ? this.nullChar : this.defaultChar;
			}
		}
		return c;
	}
	,setOffset: function(x,y) {
		var dx = x - this.offsetX;
		var dy = y - this.offsetY;
		if(dx == 0 && dy == 0) {
			return;
		}
		var g = this.glyphs.iterator();
		while(g.hasNext()) {
			var g1 = g.next();
			g1.t.dx += dx;
			g1.t.dy += dy;
		}
		this.offsetX += dx;
		this.offsetY += dy;
	}
	,clone: function() {
		var f = new h2d_Font(this.name,this.size);
		f.baseLine = this.baseLine;
		f.lineHeight = this.lineHeight;
		f.tile = this.tile.clone();
		f.charset = this.charset;
		f.defaultChar = this.defaultChar.clone();
		f.type = this.type;
		f.offsetX = this.offsetX;
		f.offsetY = this.offsetY;
		var g = this.glyphs.keys();
		while(g.hasNext()) {
			var g1 = g.next();
			var c = this.glyphs.h[g1];
			var c2 = c.clone();
			if(c == this.defaultChar) {
				f.defaultChar = c2;
			}
			f.glyphs.h[g1] = c2;
		}
		return f;
	}
	,resizeTo: function(size) {
		var ratio = size / this.size;
		var c = this.glyphs.iterator();
		while(c.hasNext()) {
			var c1 = c.next();
			c1.width *= ratio;
			c1.t.scaleToSize(c1.t.width * ratio,c1.t.height * ratio);
			c1.t.dx *= ratio;
			c1.t.dy *= ratio;
			var k = c1.kerning;
			while(k != null) {
				k.offset *= ratio;
				k = k.next;
			}
		}
		this.lineHeight = Math.ceil(this.lineHeight * ratio);
		this.baseLine = Math.ceil(this.baseLine * ratio);
		this.size = size;
	}
	,hasChar: function(code) {
		return this.glyphs.h[code] != null;
	}
	,dispose: function() {
		this.tile.dispose();
	}
	,calcBaseLine: function() {
		var padding = 0;
		var space = this.glyphs.h[32];
		if(space != null) {
			padding = space.t.height * .5;
		}
		var a = this.glyphs.h[65];
		if(a == null) {
			a = this.glyphs.h[97];
		}
		if(a == null) {
			a = this.glyphs.h[48];
		}
		if(a == null) {
			return this.lineHeight - 2 - padding;
		}
		return a.t.dy + a.t.height - padding;
	}
	,__class__: h2d_Font
};
var h2d_GPoint = function() {
};
$hxClasses["h2d.GPoint"] = h2d_GPoint;
h2d_GPoint.__name__ = "h2d.GPoint";
h2d_GPoint.prototype = {
	load: function(x,y,r,g,b,a) {
		this.x = x;
		this.y = y;
		this.r = r;
		this.g = g;
		this.b = b;
		this.a = a;
	}
	,__class__: h2d_GPoint
};
var h3d_prim_Primitive = function() {
	this.refCount = 0;
	this.forcedLod = -1;
};
$hxClasses["h3d.prim.Primitive"] = h3d_prim_Primitive;
h3d_prim_Primitive.__name__ = "h3d.prim.Primitive";
h3d_prim_Primitive.prototype = {
	triCount: function() {
		if(this.indexes != null) {
			return this.indexes.vertices / 3 | 0;
		} else if(this.buffer == null) {
			return 0;
		} else {
			return this.buffer.vertices / 3 | 0;
		}
	}
	,vertexCount: function() {
		return 0;
	}
	,getCollider: function() {
		throw haxe_Exception.thrown("not implemented for " + Std.string(this));
	}
	,getBounds: function() {
		throw haxe_Exception.thrown("not implemented for " + Std.string(this));
	}
	,incref: function() {
		this.refCount++;
	}
	,decref: function() {
		this.refCount--;
		if(this.refCount <= 0) {
			this.refCount = 0;
			this.dispose();
		}
	}
	,alloc: function(engine) {
		throw haxe_Exception.thrown("not implemented");
	}
	,selectMaterial: function(material,lod) {
	}
	,getMaterialIndexes: function(material,lod) {
		if(lod == null) {
			lod = 0;
		}
		if(lod != 0) {
			return { start : 0, count : 0};
		}
		return { start : this.getMaterialIndexStart(material,lod), count : this.getMaterialIndexCount(material,lod)};
	}
	,getMaterialIndexStart: function(material,lod) {
		if(lod == null) {
			lod = 0;
		}
		return 0;
	}
	,getMaterialIndexCount: function(material,lod) {
		if(lod == null) {
			lod = 0;
		}
		if(this.indexes == null) {
			return this.triCount() * 3;
		} else {
			return this.indexes.vertices;
		}
	}
	,buildNormalsDisplay: function() {
		throw haxe_Exception.thrown("not implemented for " + Std.string(this));
	}
	,render: function(engine) {
		if(this.buffer == null || this.buffer.vbuf == null) {
			this.alloc(engine);
		}
		if(this.indexes == null) {
			var b = this.buffer;
			engine.renderBuffer(b,engine.mem.getTriIndexes(b.vertices),3,0,-1);
		} else {
			engine.renderIndexed(this.buffer,this.indexes);
		}
	}
	,dispose: function() {
		if(this.buffer != null) {
			this.buffer.dispose();
			this.buffer = null;
		}
		if(this.indexes != null) {
			this.indexes.dispose();
			this.indexes = null;
		}
	}
	,toString: function() {
		var c = js_Boot.getClass(this);
		return c.__name__.split(".").pop();
	}
	,lodCount: function() {
		return 1;
	}
	,screenRatioToLod: function(screenRatio) {
		return 0;
	}
	,__class__: h3d_prim_Primitive
};
var h2d__$Graphics_GraphicsContent = function() {
	h3d_prim_Primitive.call(this);
	this.buffers = [];
	this.state = new h2d_impl_BatchDrawState();
	this.allocPos = hxd_impl_AllocPos.make();
};
$hxClasses["h2d._Graphics.GraphicsContent"] = h2d__$Graphics_GraphicsContent;
h2d__$Graphics_GraphicsContent.__name__ = "h2d._Graphics.GraphicsContent";
h2d__$Graphics_GraphicsContent.__super__ = h3d_prim_Primitive;
h2d__$Graphics_GraphicsContent.prototype = $extend(h3d_prim_Primitive.prototype,{
	addIndex: function(i) {
		this.index.push(i);
		var _this = this.state;
		_this.tail.count += 1;
		_this.totalCount += 1;
		this.indexDirty = true;
	}
	,add: function(x,y,u,v,r,g,b,a) {
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = x;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = y;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = u;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = r;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = g;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = b;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = a;
		this.bufferDirty = true;
	}
	,setTile: function(tile) {
		if(tile != null) {
			this.state.setTexture(tile.innerTex);
		}
	}
	,next: function() {
		var nvect = this.tmp.pos >> 3;
		if(nvect < 32768) {
			return false;
		}
		this.buffers.push({ buf : this.tmp, idx : this.index, vbuf : null, ibuf : null, state : this.state});
		this.tmp = hxd__$FloatBuffer_Float32Expand._new(0);
		this.index = new Array(0);
		var tex = this.state.tail.texture;
		this.state = new h2d_impl_BatchDrawState();
		this.state.setTexture(tex);
		h3d_prim_Primitive.prototype.dispose.call(this);
		return true;
	}
	,alloc: function(engine) {
		if(this.index.length <= 0) {
			return;
		}
		var alloc = hxd_impl_Allocator.get();
		this.buffer = alloc.ofFloats(this.tmp,hxd_BufferFormat.get_XY_UV_RGBA());
		this.buffer.allocPos = this.allocPos;
		this.indexes = alloc.ofIndexes(this.index);
		var _g = 0;
		var _g1 = this.buffers;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			if(b.vbuf == null || b.vbuf.vbuf == null) {
				b.vbuf = alloc.ofFloats(b.buf,hxd_BufferFormat.get_XY_UV_RGBA());
			}
			if(b.ibuf == null || b.ibuf.vbuf == null) {
				b.ibuf = alloc.ofIndexes(b.idx);
			}
		}
		this.bufferDirty = false;
		this.indexDirty = false;
	}
	,doRender: function(ctx) {
		if(this.index.length == 0) {
			return;
		}
		this.flush();
		var _g = 0;
		var _g1 = this.buffers;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			b.state.drawIndexed(ctx,b.vbuf,b.ibuf);
		}
		this.state.drawIndexed(ctx,this.buffer,this.indexes);
	}
	,flush: function() {
		if(this.buffer == null || this.buffer.vbuf == null) {
			this.alloc(h3d_Engine.CURRENT);
		} else {
			var allocator = hxd_impl_Allocator.get();
			if(this.bufferDirty) {
				allocator.disposeBuffer(this.buffer);
				this.buffer = allocator.ofFloats(this.tmp,hxd_BufferFormat.get_XY_UV_RGBA());
				this.bufferDirty = false;
			}
			if(this.indexDirty) {
				allocator.disposeIndexBuffer(this.indexes);
				this.indexes = allocator.ofIndexes(this.index);
				this.indexDirty = false;
			}
		}
	}
	,dispose: function() {
		var _g = 0;
		var _g1 = this.buffers;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			if(b.vbuf != null) {
				hxd_impl_Allocator.get().disposeBuffer(b.vbuf);
			}
			if(b.ibuf != null) {
				hxd_impl_Allocator.get().disposeIndexBuffer(b.ibuf);
			}
			b.vbuf = null;
			b.ibuf = null;
			b.state.clear();
		}
		if(this.buffer != null) {
			hxd_impl_Allocator.get().disposeBuffer(this.buffer);
			this.buffer = null;
		}
		if(this.indexes != null) {
			hxd_impl_Allocator.get().disposeIndexBuffer(this.indexes);
			this.indexes = null;
		}
		this.state.clear();
		h3d_prim_Primitive.prototype.dispose.call(this);
	}
	,clear: function() {
		this.dispose();
		this.tmp = hxd__$FloatBuffer_Float32Expand._new(0);
		this.index = new Array(0);
		this.buffers = [];
	}
	,__class__: h2d__$Graphics_GraphicsContent
});
var h2d_Graphics = function(parent) {
	this.bevel = 0.25;
	this.my = 0.;
	this.mx = 0.;
	this.md = 1.;
	this.mc = 0.;
	this.mb = 0.;
	this.ma = 1.;
	h2d_Drawable.call(this,parent);
	this.content = new h2d__$Graphics_GraphicsContent();
	this.tile = h2d_Tile.fromColor(16777215);
	this.clear();
};
$hxClasses["h2d.Graphics"] = h2d_Graphics;
h2d_Graphics.__name__ = "h2d.Graphics";
h2d_Graphics.__super__ = h2d_Drawable;
h2d_Graphics.prototype = $extend(h2d_Drawable.prototype,{
	onRemove: function() {
		h2d_Drawable.prototype.onRemove.call(this);
		this.clear();
	}
	,clear: function() {
		this.content.clear();
		this.tmpPoints = [];
		this.pindex = 0;
		this.lineSize = 0;
		this.xMin = Infinity;
		this.yMin = Infinity;
		this.yMax = -Infinity;
		this.xMax = -Infinity;
		this.xMinSize = Infinity;
		this.yMinSize = Infinity;
		this.yMaxSize = -Infinity;
		this.xMaxSize = -Infinity;
	}
	,getBoundsRec: function(relativeTo,out,forSize) {
		h2d_Drawable.prototype.getBoundsRec.call(this,relativeTo,out,forSize);
		if(this.tile != null) {
			if(forSize) {
				this.addBounds(relativeTo,out,this.xMinSize,this.yMinSize,this.xMaxSize - this.xMinSize,this.yMaxSize - this.yMinSize);
			} else {
				this.addBounds(relativeTo,out,this.xMin,this.yMin,this.xMax - this.xMin,this.yMax - this.yMin);
			}
		}
	}
	,isConvex: function(points) {
		var first = true;
		var sign = false;
		var _g = 0;
		var _g1 = points.length;
		while(_g < _g1) {
			var i = _g++;
			var p1 = points[i];
			var p2 = points[(i + 1) % points.length];
			var p3 = points[(i + 2) % points.length];
			var s = (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x) > 0;
			if(first) {
				first = false;
				sign = s;
			} else if(sign != s) {
				return false;
			}
		}
		return true;
	}
	,flushLine: function(start) {
		var pts = this.tmpPoints;
		var last = pts.length - 1;
		var prev = pts[last];
		var p = pts[0];
		this.content.setTile(h2d_Tile.fromColor(16777215));
		var closed = p.x == prev.x && p.y == prev.y;
		var count = pts.length;
		if(!closed) {
			var prevLast = pts[last - 1];
			if(prevLast == null) {
				prevLast = p;
			}
			var gp = new h2d_GPoint();
			gp.load(prev.x * 2 - prevLast.x,prev.y * 2 - prevLast.y,0,0,0,0);
			pts.push(gp);
			var pNext = pts[1];
			if(pNext == null) {
				pNext = p;
			}
			var gp = new h2d_GPoint();
			gp.load(p.x * 2 - pNext.x,p.y * 2 - pNext.y,0,0,0,0);
			prev = gp;
		} else if(p != prev) {
			--count;
			--last;
			prev = pts[last];
		}
		var _g = 0;
		var _g1 = count;
		while(_g < _g1) {
			var i = _g++;
			var next = pts[(i + 1) % pts.length];
			var nx1 = prev.y - p.y;
			var ny1 = p.x - prev.x;
			var ns1 = 1. / Math.sqrt(nx1 * nx1 + ny1 * ny1);
			var nx2 = p.y - next.y;
			var ny2 = next.x - p.x;
			var ns2 = 1. / Math.sqrt(nx2 * nx2 + ny2 * ny2);
			var nx = nx1 * ns1 + nx2 * ns2;
			var ny = ny1 * ns1 + ny2 * ns2;
			var ns = 1. / Math.sqrt(nx * nx + ny * ny);
			nx *= ns;
			ny *= ns;
			var size = nx * nx1 * ns1 + ny * ny1 * ns1;
			if(size < 0.1) {
				size = 0.1;
			}
			var d = this.lineSize * 0.5 / size;
			nx *= d;
			ny *= d;
			if(size > this.bevel) {
				var _this = this.content;
				var x = p.x + nx;
				var y = p.y + ny;
				var r = p.r;
				var g = p.g;
				var b = p.b;
				var a = p.a;
				var this1 = _this.tmp;
				if(this1.pos == this1.array.length) {
					var newSize = this1.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					var newArray = new Float32Array(newSize);
					newArray.set(this1.array);
					this1.array = newArray;
				}
				this1.array[this1.pos++] = x;
				var this2 = _this.tmp;
				if(this2.pos == this2.array.length) {
					var newSize1 = this2.array.length << 1;
					if(newSize1 < 128) {
						newSize1 = 128;
					}
					var newArray1 = new Float32Array(newSize1);
					newArray1.set(this2.array);
					this2.array = newArray1;
				}
				this2.array[this2.pos++] = y;
				var this3 = _this.tmp;
				if(this3.pos == this3.array.length) {
					var newSize2 = this3.array.length << 1;
					if(newSize2 < 128) {
						newSize2 = 128;
					}
					var newArray2 = new Float32Array(newSize2);
					newArray2.set(this3.array);
					this3.array = newArray2;
				}
				this3.array[this3.pos++] = 0;
				var this4 = _this.tmp;
				if(this4.pos == this4.array.length) {
					var newSize3 = this4.array.length << 1;
					if(newSize3 < 128) {
						newSize3 = 128;
					}
					var newArray3 = new Float32Array(newSize3);
					newArray3.set(this4.array);
					this4.array = newArray3;
				}
				this4.array[this4.pos++] = 0;
				var this5 = _this.tmp;
				if(this5.pos == this5.array.length) {
					var newSize4 = this5.array.length << 1;
					if(newSize4 < 128) {
						newSize4 = 128;
					}
					var newArray4 = new Float32Array(newSize4);
					newArray4.set(this5.array);
					this5.array = newArray4;
				}
				this5.array[this5.pos++] = r;
				var this6 = _this.tmp;
				if(this6.pos == this6.array.length) {
					var newSize5 = this6.array.length << 1;
					if(newSize5 < 128) {
						newSize5 = 128;
					}
					var newArray5 = new Float32Array(newSize5);
					newArray5.set(this6.array);
					this6.array = newArray5;
				}
				this6.array[this6.pos++] = g;
				var this7 = _this.tmp;
				if(this7.pos == this7.array.length) {
					var newSize6 = this7.array.length << 1;
					if(newSize6 < 128) {
						newSize6 = 128;
					}
					var newArray6 = new Float32Array(newSize6);
					newArray6.set(this7.array);
					this7.array = newArray6;
				}
				this7.array[this7.pos++] = b;
				var this8 = _this.tmp;
				if(this8.pos == this8.array.length) {
					var newSize7 = this8.array.length << 1;
					if(newSize7 < 128) {
						newSize7 = 128;
					}
					var newArray7 = new Float32Array(newSize7);
					newArray7.set(this8.array);
					this8.array = newArray7;
				}
				this8.array[this8.pos++] = a;
				_this.bufferDirty = true;
				var _this1 = this.content;
				var x1 = p.x - nx;
				var y1 = p.y - ny;
				var r1 = p.r;
				var g1 = p.g;
				var b1 = p.b;
				var a1 = p.a;
				var this9 = _this1.tmp;
				if(this9.pos == this9.array.length) {
					var newSize8 = this9.array.length << 1;
					if(newSize8 < 128) {
						newSize8 = 128;
					}
					var newArray8 = new Float32Array(newSize8);
					newArray8.set(this9.array);
					this9.array = newArray8;
				}
				this9.array[this9.pos++] = x1;
				var this10 = _this1.tmp;
				if(this10.pos == this10.array.length) {
					var newSize9 = this10.array.length << 1;
					if(newSize9 < 128) {
						newSize9 = 128;
					}
					var newArray9 = new Float32Array(newSize9);
					newArray9.set(this10.array);
					this10.array = newArray9;
				}
				this10.array[this10.pos++] = y1;
				var this11 = _this1.tmp;
				if(this11.pos == this11.array.length) {
					var newSize10 = this11.array.length << 1;
					if(newSize10 < 128) {
						newSize10 = 128;
					}
					var newArray10 = new Float32Array(newSize10);
					newArray10.set(this11.array);
					this11.array = newArray10;
				}
				this11.array[this11.pos++] = 0;
				var this12 = _this1.tmp;
				if(this12.pos == this12.array.length) {
					var newSize11 = this12.array.length << 1;
					if(newSize11 < 128) {
						newSize11 = 128;
					}
					var newArray11 = new Float32Array(newSize11);
					newArray11.set(this12.array);
					this12.array = newArray11;
				}
				this12.array[this12.pos++] = 0;
				var this13 = _this1.tmp;
				if(this13.pos == this13.array.length) {
					var newSize12 = this13.array.length << 1;
					if(newSize12 < 128) {
						newSize12 = 128;
					}
					var newArray12 = new Float32Array(newSize12);
					newArray12.set(this13.array);
					this13.array = newArray12;
				}
				this13.array[this13.pos++] = r1;
				var this14 = _this1.tmp;
				if(this14.pos == this14.array.length) {
					var newSize13 = this14.array.length << 1;
					if(newSize13 < 128) {
						newSize13 = 128;
					}
					var newArray13 = new Float32Array(newSize13);
					newArray13.set(this14.array);
					this14.array = newArray13;
				}
				this14.array[this14.pos++] = g1;
				var this15 = _this1.tmp;
				if(this15.pos == this15.array.length) {
					var newSize14 = this15.array.length << 1;
					if(newSize14 < 128) {
						newSize14 = 128;
					}
					var newArray14 = new Float32Array(newSize14);
					newArray14.set(this15.array);
					this15.array = newArray14;
				}
				this15.array[this15.pos++] = b1;
				var this16 = _this1.tmp;
				if(this16.pos == this16.array.length) {
					var newSize15 = this16.array.length << 1;
					if(newSize15 < 128) {
						newSize15 = 128;
					}
					var newArray15 = new Float32Array(newSize15);
					newArray15.set(this16.array);
					this16.array = newArray15;
				}
				this16.array[this16.pos++] = a1;
				_this1.bufferDirty = true;
				var pnext = i == last ? start : this.pindex + 2;
				if(i < count - 1 || closed) {
					var _this2 = this.content;
					_this2.index.push(this.pindex);
					var _this3 = _this2.state;
					_this3.tail.count += 1;
					_this3.totalCount += 1;
					_this2.indexDirty = true;
					var _this4 = this.content;
					_this4.index.push(this.pindex + 1);
					var _this5 = _this4.state;
					_this5.tail.count += 1;
					_this5.totalCount += 1;
					_this4.indexDirty = true;
					var _this6 = this.content;
					_this6.index.push(pnext);
					var _this7 = _this6.state;
					_this7.tail.count += 1;
					_this7.totalCount += 1;
					_this6.indexDirty = true;
					var _this8 = this.content;
					_this8.index.push(this.pindex + 1);
					var _this9 = _this8.state;
					_this9.tail.count += 1;
					_this9.totalCount += 1;
					_this8.indexDirty = true;
					var _this10 = this.content;
					_this10.index.push(pnext);
					var _this11 = _this10.state;
					_this11.tail.count += 1;
					_this11.totalCount += 1;
					_this10.indexDirty = true;
					var _this12 = this.content;
					_this12.index.push(pnext + 1);
					var _this13 = _this12.state;
					_this13.tail.count += 1;
					_this13.totalCount += 1;
					_this12.indexDirty = true;
				}
				this.pindex += 2;
			} else {
				var n0x = next.x - p.x;
				var n0y = next.y - p.y;
				var sign = n0x * nx + n0y * ny;
				var nnx = -ny;
				var nny = nx;
				var size1 = nnx * nx1 * ns1 + nny * ny1 * ns1;
				var d1 = this.lineSize * 0.5 / size1;
				nnx *= d1;
				nny *= d1;
				var pnext1 = i == last ? start : this.pindex + 3;
				if(sign > 0) {
					var _this14 = this.content;
					var x2 = p.x + nx;
					var y2 = p.y + ny;
					var r2 = p.r;
					var g2 = p.g;
					var b2 = p.b;
					var a2 = p.a;
					var this17 = _this14.tmp;
					if(this17.pos == this17.array.length) {
						var newSize16 = this17.array.length << 1;
						if(newSize16 < 128) {
							newSize16 = 128;
						}
						var newArray16 = new Float32Array(newSize16);
						newArray16.set(this17.array);
						this17.array = newArray16;
					}
					this17.array[this17.pos++] = x2;
					var this18 = _this14.tmp;
					if(this18.pos == this18.array.length) {
						var newSize17 = this18.array.length << 1;
						if(newSize17 < 128) {
							newSize17 = 128;
						}
						var newArray17 = new Float32Array(newSize17);
						newArray17.set(this18.array);
						this18.array = newArray17;
					}
					this18.array[this18.pos++] = y2;
					var this19 = _this14.tmp;
					if(this19.pos == this19.array.length) {
						var newSize18 = this19.array.length << 1;
						if(newSize18 < 128) {
							newSize18 = 128;
						}
						var newArray18 = new Float32Array(newSize18);
						newArray18.set(this19.array);
						this19.array = newArray18;
					}
					this19.array[this19.pos++] = 0;
					var this20 = _this14.tmp;
					if(this20.pos == this20.array.length) {
						var newSize19 = this20.array.length << 1;
						if(newSize19 < 128) {
							newSize19 = 128;
						}
						var newArray19 = new Float32Array(newSize19);
						newArray19.set(this20.array);
						this20.array = newArray19;
					}
					this20.array[this20.pos++] = 0;
					var this21 = _this14.tmp;
					if(this21.pos == this21.array.length) {
						var newSize20 = this21.array.length << 1;
						if(newSize20 < 128) {
							newSize20 = 128;
						}
						var newArray20 = new Float32Array(newSize20);
						newArray20.set(this21.array);
						this21.array = newArray20;
					}
					this21.array[this21.pos++] = r2;
					var this22 = _this14.tmp;
					if(this22.pos == this22.array.length) {
						var newSize21 = this22.array.length << 1;
						if(newSize21 < 128) {
							newSize21 = 128;
						}
						var newArray21 = new Float32Array(newSize21);
						newArray21.set(this22.array);
						this22.array = newArray21;
					}
					this22.array[this22.pos++] = g2;
					var this23 = _this14.tmp;
					if(this23.pos == this23.array.length) {
						var newSize22 = this23.array.length << 1;
						if(newSize22 < 128) {
							newSize22 = 128;
						}
						var newArray22 = new Float32Array(newSize22);
						newArray22.set(this23.array);
						this23.array = newArray22;
					}
					this23.array[this23.pos++] = b2;
					var this24 = _this14.tmp;
					if(this24.pos == this24.array.length) {
						var newSize23 = this24.array.length << 1;
						if(newSize23 < 128) {
							newSize23 = 128;
						}
						var newArray23 = new Float32Array(newSize23);
						newArray23.set(this24.array);
						this24.array = newArray23;
					}
					this24.array[this24.pos++] = a2;
					_this14.bufferDirty = true;
					var _this15 = this.content;
					var x3 = p.x - nnx;
					var y3 = p.y - nny;
					var r3 = p.r;
					var g3 = p.g;
					var b3 = p.b;
					var a3 = p.a;
					var this25 = _this15.tmp;
					if(this25.pos == this25.array.length) {
						var newSize24 = this25.array.length << 1;
						if(newSize24 < 128) {
							newSize24 = 128;
						}
						var newArray24 = new Float32Array(newSize24);
						newArray24.set(this25.array);
						this25.array = newArray24;
					}
					this25.array[this25.pos++] = x3;
					var this26 = _this15.tmp;
					if(this26.pos == this26.array.length) {
						var newSize25 = this26.array.length << 1;
						if(newSize25 < 128) {
							newSize25 = 128;
						}
						var newArray25 = new Float32Array(newSize25);
						newArray25.set(this26.array);
						this26.array = newArray25;
					}
					this26.array[this26.pos++] = y3;
					var this27 = _this15.tmp;
					if(this27.pos == this27.array.length) {
						var newSize26 = this27.array.length << 1;
						if(newSize26 < 128) {
							newSize26 = 128;
						}
						var newArray26 = new Float32Array(newSize26);
						newArray26.set(this27.array);
						this27.array = newArray26;
					}
					this27.array[this27.pos++] = 0;
					var this28 = _this15.tmp;
					if(this28.pos == this28.array.length) {
						var newSize27 = this28.array.length << 1;
						if(newSize27 < 128) {
							newSize27 = 128;
						}
						var newArray27 = new Float32Array(newSize27);
						newArray27.set(this28.array);
						this28.array = newArray27;
					}
					this28.array[this28.pos++] = 0;
					var this29 = _this15.tmp;
					if(this29.pos == this29.array.length) {
						var newSize28 = this29.array.length << 1;
						if(newSize28 < 128) {
							newSize28 = 128;
						}
						var newArray28 = new Float32Array(newSize28);
						newArray28.set(this29.array);
						this29.array = newArray28;
					}
					this29.array[this29.pos++] = r3;
					var this30 = _this15.tmp;
					if(this30.pos == this30.array.length) {
						var newSize29 = this30.array.length << 1;
						if(newSize29 < 128) {
							newSize29 = 128;
						}
						var newArray29 = new Float32Array(newSize29);
						newArray29.set(this30.array);
						this30.array = newArray29;
					}
					this30.array[this30.pos++] = g3;
					var this31 = _this15.tmp;
					if(this31.pos == this31.array.length) {
						var newSize30 = this31.array.length << 1;
						if(newSize30 < 128) {
							newSize30 = 128;
						}
						var newArray30 = new Float32Array(newSize30);
						newArray30.set(this31.array);
						this31.array = newArray30;
					}
					this31.array[this31.pos++] = b3;
					var this32 = _this15.tmp;
					if(this32.pos == this32.array.length) {
						var newSize31 = this32.array.length << 1;
						if(newSize31 < 128) {
							newSize31 = 128;
						}
						var newArray31 = new Float32Array(newSize31);
						newArray31.set(this32.array);
						this32.array = newArray31;
					}
					this32.array[this32.pos++] = a3;
					_this15.bufferDirty = true;
					var _this16 = this.content;
					var x4 = p.x + nnx;
					var y4 = p.y + nny;
					var r4 = p.r;
					var g4 = p.g;
					var b4 = p.b;
					var a4 = p.a;
					var this33 = _this16.tmp;
					if(this33.pos == this33.array.length) {
						var newSize32 = this33.array.length << 1;
						if(newSize32 < 128) {
							newSize32 = 128;
						}
						var newArray32 = new Float32Array(newSize32);
						newArray32.set(this33.array);
						this33.array = newArray32;
					}
					this33.array[this33.pos++] = x4;
					var this34 = _this16.tmp;
					if(this34.pos == this34.array.length) {
						var newSize33 = this34.array.length << 1;
						if(newSize33 < 128) {
							newSize33 = 128;
						}
						var newArray33 = new Float32Array(newSize33);
						newArray33.set(this34.array);
						this34.array = newArray33;
					}
					this34.array[this34.pos++] = y4;
					var this35 = _this16.tmp;
					if(this35.pos == this35.array.length) {
						var newSize34 = this35.array.length << 1;
						if(newSize34 < 128) {
							newSize34 = 128;
						}
						var newArray34 = new Float32Array(newSize34);
						newArray34.set(this35.array);
						this35.array = newArray34;
					}
					this35.array[this35.pos++] = 0;
					var this36 = _this16.tmp;
					if(this36.pos == this36.array.length) {
						var newSize35 = this36.array.length << 1;
						if(newSize35 < 128) {
							newSize35 = 128;
						}
						var newArray35 = new Float32Array(newSize35);
						newArray35.set(this36.array);
						this36.array = newArray35;
					}
					this36.array[this36.pos++] = 0;
					var this37 = _this16.tmp;
					if(this37.pos == this37.array.length) {
						var newSize36 = this37.array.length << 1;
						if(newSize36 < 128) {
							newSize36 = 128;
						}
						var newArray36 = new Float32Array(newSize36);
						newArray36.set(this37.array);
						this37.array = newArray36;
					}
					this37.array[this37.pos++] = r4;
					var this38 = _this16.tmp;
					if(this38.pos == this38.array.length) {
						var newSize37 = this38.array.length << 1;
						if(newSize37 < 128) {
							newSize37 = 128;
						}
						var newArray37 = new Float32Array(newSize37);
						newArray37.set(this38.array);
						this38.array = newArray37;
					}
					this38.array[this38.pos++] = g4;
					var this39 = _this16.tmp;
					if(this39.pos == this39.array.length) {
						var newSize38 = this39.array.length << 1;
						if(newSize38 < 128) {
							newSize38 = 128;
						}
						var newArray38 = new Float32Array(newSize38);
						newArray38.set(this39.array);
						this39.array = newArray38;
					}
					this39.array[this39.pos++] = b4;
					var this40 = _this16.tmp;
					if(this40.pos == this40.array.length) {
						var newSize39 = this40.array.length << 1;
						if(newSize39 < 128) {
							newSize39 = 128;
						}
						var newArray39 = new Float32Array(newSize39);
						newArray39.set(this40.array);
						this40.array = newArray39;
					}
					this40.array[this40.pos++] = a4;
					_this16.bufferDirty = true;
					var _this17 = this.content;
					_this17.index.push(this.pindex);
					var _this18 = _this17.state;
					_this18.tail.count += 1;
					_this18.totalCount += 1;
					_this17.indexDirty = true;
					var _this19 = this.content;
					_this19.index.push(pnext1);
					var _this20 = _this19.state;
					_this20.tail.count += 1;
					_this20.totalCount += 1;
					_this19.indexDirty = true;
					var _this21 = this.content;
					_this21.index.push(this.pindex + 2);
					var _this22 = _this21.state;
					_this22.tail.count += 1;
					_this22.totalCount += 1;
					_this21.indexDirty = true;
					var _this23 = this.content;
					_this23.index.push(this.pindex + 2);
					var _this24 = _this23.state;
					_this24.tail.count += 1;
					_this24.totalCount += 1;
					_this23.indexDirty = true;
					var _this25 = this.content;
					_this25.index.push(pnext1);
					var _this26 = _this25.state;
					_this26.tail.count += 1;
					_this26.totalCount += 1;
					_this25.indexDirty = true;
					var _this27 = this.content;
					_this27.index.push(pnext1 + 1);
					var _this28 = _this27.state;
					_this28.tail.count += 1;
					_this28.totalCount += 1;
					_this27.indexDirty = true;
				} else {
					var _this29 = this.content;
					var x5 = p.x + nnx;
					var y5 = p.y + nny;
					var r5 = p.r;
					var g5 = p.g;
					var b5 = p.b;
					var a5 = p.a;
					var this41 = _this29.tmp;
					if(this41.pos == this41.array.length) {
						var newSize40 = this41.array.length << 1;
						if(newSize40 < 128) {
							newSize40 = 128;
						}
						var newArray40 = new Float32Array(newSize40);
						newArray40.set(this41.array);
						this41.array = newArray40;
					}
					this41.array[this41.pos++] = x5;
					var this42 = _this29.tmp;
					if(this42.pos == this42.array.length) {
						var newSize41 = this42.array.length << 1;
						if(newSize41 < 128) {
							newSize41 = 128;
						}
						var newArray41 = new Float32Array(newSize41);
						newArray41.set(this42.array);
						this42.array = newArray41;
					}
					this42.array[this42.pos++] = y5;
					var this43 = _this29.tmp;
					if(this43.pos == this43.array.length) {
						var newSize42 = this43.array.length << 1;
						if(newSize42 < 128) {
							newSize42 = 128;
						}
						var newArray42 = new Float32Array(newSize42);
						newArray42.set(this43.array);
						this43.array = newArray42;
					}
					this43.array[this43.pos++] = 0;
					var this44 = _this29.tmp;
					if(this44.pos == this44.array.length) {
						var newSize43 = this44.array.length << 1;
						if(newSize43 < 128) {
							newSize43 = 128;
						}
						var newArray43 = new Float32Array(newSize43);
						newArray43.set(this44.array);
						this44.array = newArray43;
					}
					this44.array[this44.pos++] = 0;
					var this45 = _this29.tmp;
					if(this45.pos == this45.array.length) {
						var newSize44 = this45.array.length << 1;
						if(newSize44 < 128) {
							newSize44 = 128;
						}
						var newArray44 = new Float32Array(newSize44);
						newArray44.set(this45.array);
						this45.array = newArray44;
					}
					this45.array[this45.pos++] = r5;
					var this46 = _this29.tmp;
					if(this46.pos == this46.array.length) {
						var newSize45 = this46.array.length << 1;
						if(newSize45 < 128) {
							newSize45 = 128;
						}
						var newArray45 = new Float32Array(newSize45);
						newArray45.set(this46.array);
						this46.array = newArray45;
					}
					this46.array[this46.pos++] = g5;
					var this47 = _this29.tmp;
					if(this47.pos == this47.array.length) {
						var newSize46 = this47.array.length << 1;
						if(newSize46 < 128) {
							newSize46 = 128;
						}
						var newArray46 = new Float32Array(newSize46);
						newArray46.set(this47.array);
						this47.array = newArray46;
					}
					this47.array[this47.pos++] = b5;
					var this48 = _this29.tmp;
					if(this48.pos == this48.array.length) {
						var newSize47 = this48.array.length << 1;
						if(newSize47 < 128) {
							newSize47 = 128;
						}
						var newArray47 = new Float32Array(newSize47);
						newArray47.set(this48.array);
						this48.array = newArray47;
					}
					this48.array[this48.pos++] = a5;
					_this29.bufferDirty = true;
					var _this30 = this.content;
					var x6 = p.x - nx;
					var y6 = p.y - ny;
					var r6 = p.r;
					var g6 = p.g;
					var b6 = p.b;
					var a6 = p.a;
					var this49 = _this30.tmp;
					if(this49.pos == this49.array.length) {
						var newSize48 = this49.array.length << 1;
						if(newSize48 < 128) {
							newSize48 = 128;
						}
						var newArray48 = new Float32Array(newSize48);
						newArray48.set(this49.array);
						this49.array = newArray48;
					}
					this49.array[this49.pos++] = x6;
					var this50 = _this30.tmp;
					if(this50.pos == this50.array.length) {
						var newSize49 = this50.array.length << 1;
						if(newSize49 < 128) {
							newSize49 = 128;
						}
						var newArray49 = new Float32Array(newSize49);
						newArray49.set(this50.array);
						this50.array = newArray49;
					}
					this50.array[this50.pos++] = y6;
					var this51 = _this30.tmp;
					if(this51.pos == this51.array.length) {
						var newSize50 = this51.array.length << 1;
						if(newSize50 < 128) {
							newSize50 = 128;
						}
						var newArray50 = new Float32Array(newSize50);
						newArray50.set(this51.array);
						this51.array = newArray50;
					}
					this51.array[this51.pos++] = 0;
					var this52 = _this30.tmp;
					if(this52.pos == this52.array.length) {
						var newSize51 = this52.array.length << 1;
						if(newSize51 < 128) {
							newSize51 = 128;
						}
						var newArray51 = new Float32Array(newSize51);
						newArray51.set(this52.array);
						this52.array = newArray51;
					}
					this52.array[this52.pos++] = 0;
					var this53 = _this30.tmp;
					if(this53.pos == this53.array.length) {
						var newSize52 = this53.array.length << 1;
						if(newSize52 < 128) {
							newSize52 = 128;
						}
						var newArray52 = new Float32Array(newSize52);
						newArray52.set(this53.array);
						this53.array = newArray52;
					}
					this53.array[this53.pos++] = r6;
					var this54 = _this30.tmp;
					if(this54.pos == this54.array.length) {
						var newSize53 = this54.array.length << 1;
						if(newSize53 < 128) {
							newSize53 = 128;
						}
						var newArray53 = new Float32Array(newSize53);
						newArray53.set(this54.array);
						this54.array = newArray53;
					}
					this54.array[this54.pos++] = g6;
					var this55 = _this30.tmp;
					if(this55.pos == this55.array.length) {
						var newSize54 = this55.array.length << 1;
						if(newSize54 < 128) {
							newSize54 = 128;
						}
						var newArray54 = new Float32Array(newSize54);
						newArray54.set(this55.array);
						this55.array = newArray54;
					}
					this55.array[this55.pos++] = b6;
					var this56 = _this30.tmp;
					if(this56.pos == this56.array.length) {
						var newSize55 = this56.array.length << 1;
						if(newSize55 < 128) {
							newSize55 = 128;
						}
						var newArray55 = new Float32Array(newSize55);
						newArray55.set(this56.array);
						this56.array = newArray55;
					}
					this56.array[this56.pos++] = a6;
					_this30.bufferDirty = true;
					var _this31 = this.content;
					var x7 = p.x - nnx;
					var y7 = p.y - nny;
					var r7 = p.r;
					var g7 = p.g;
					var b7 = p.b;
					var a7 = p.a;
					var this57 = _this31.tmp;
					if(this57.pos == this57.array.length) {
						var newSize56 = this57.array.length << 1;
						if(newSize56 < 128) {
							newSize56 = 128;
						}
						var newArray56 = new Float32Array(newSize56);
						newArray56.set(this57.array);
						this57.array = newArray56;
					}
					this57.array[this57.pos++] = x7;
					var this58 = _this31.tmp;
					if(this58.pos == this58.array.length) {
						var newSize57 = this58.array.length << 1;
						if(newSize57 < 128) {
							newSize57 = 128;
						}
						var newArray57 = new Float32Array(newSize57);
						newArray57.set(this58.array);
						this58.array = newArray57;
					}
					this58.array[this58.pos++] = y7;
					var this59 = _this31.tmp;
					if(this59.pos == this59.array.length) {
						var newSize58 = this59.array.length << 1;
						if(newSize58 < 128) {
							newSize58 = 128;
						}
						var newArray58 = new Float32Array(newSize58);
						newArray58.set(this59.array);
						this59.array = newArray58;
					}
					this59.array[this59.pos++] = 0;
					var this60 = _this31.tmp;
					if(this60.pos == this60.array.length) {
						var newSize59 = this60.array.length << 1;
						if(newSize59 < 128) {
							newSize59 = 128;
						}
						var newArray59 = new Float32Array(newSize59);
						newArray59.set(this60.array);
						this60.array = newArray59;
					}
					this60.array[this60.pos++] = 0;
					var this61 = _this31.tmp;
					if(this61.pos == this61.array.length) {
						var newSize60 = this61.array.length << 1;
						if(newSize60 < 128) {
							newSize60 = 128;
						}
						var newArray60 = new Float32Array(newSize60);
						newArray60.set(this61.array);
						this61.array = newArray60;
					}
					this61.array[this61.pos++] = r7;
					var this62 = _this31.tmp;
					if(this62.pos == this62.array.length) {
						var newSize61 = this62.array.length << 1;
						if(newSize61 < 128) {
							newSize61 = 128;
						}
						var newArray61 = new Float32Array(newSize61);
						newArray61.set(this62.array);
						this62.array = newArray61;
					}
					this62.array[this62.pos++] = g7;
					var this63 = _this31.tmp;
					if(this63.pos == this63.array.length) {
						var newSize62 = this63.array.length << 1;
						if(newSize62 < 128) {
							newSize62 = 128;
						}
						var newArray62 = new Float32Array(newSize62);
						newArray62.set(this63.array);
						this63.array = newArray62;
					}
					this63.array[this63.pos++] = b7;
					var this64 = _this31.tmp;
					if(this64.pos == this64.array.length) {
						var newSize63 = this64.array.length << 1;
						if(newSize63 < 128) {
							newSize63 = 128;
						}
						var newArray63 = new Float32Array(newSize63);
						newArray63.set(this64.array);
						this64.array = newArray63;
					}
					this64.array[this64.pos++] = a7;
					_this31.bufferDirty = true;
					var _this32 = this.content;
					_this32.index.push(this.pindex + 1);
					var _this33 = _this32.state;
					_this33.tail.count += 1;
					_this33.totalCount += 1;
					_this32.indexDirty = true;
					var _this34 = this.content;
					_this34.index.push(pnext1);
					var _this35 = _this34.state;
					_this35.tail.count += 1;
					_this35.totalCount += 1;
					_this34.indexDirty = true;
					var _this36 = this.content;
					_this36.index.push(this.pindex + 2);
					var _this37 = _this36.state;
					_this37.tail.count += 1;
					_this37.totalCount += 1;
					_this36.indexDirty = true;
					var _this38 = this.content;
					_this38.index.push(this.pindex + 1);
					var _this39 = _this38.state;
					_this39.tail.count += 1;
					_this39.totalCount += 1;
					_this38.indexDirty = true;
					var _this40 = this.content;
					_this40.index.push(pnext1);
					var _this41 = _this40.state;
					_this41.tail.count += 1;
					_this41.totalCount += 1;
					_this40.indexDirty = true;
					var _this42 = this.content;
					_this42.index.push(pnext1 + 1);
					var _this43 = _this42.state;
					_this43.tail.count += 1;
					_this43.totalCount += 1;
					_this42.indexDirty = true;
				}
				var _this44 = this.content;
				_this44.index.push(this.pindex);
				var _this45 = _this44.state;
				_this45.tail.count += 1;
				_this45.totalCount += 1;
				_this44.indexDirty = true;
				var _this46 = this.content;
				_this46.index.push(this.pindex + 1);
				var _this47 = _this46.state;
				_this47.tail.count += 1;
				_this47.totalCount += 1;
				_this46.indexDirty = true;
				var _this48 = this.content;
				_this48.index.push(this.pindex + 2);
				var _this49 = _this48.state;
				_this49.tail.count += 1;
				_this49.totalCount += 1;
				_this48.indexDirty = true;
				this.pindex += 3;
			}
			prev = p;
			p = next;
		}
		this.content.setTile(this.tile);
	}
	,flushFill: function(i0) {
		if(this.tmpPoints.length < 3) {
			return;
		}
		var pts = this.tmpPoints;
		var p0 = pts[0];
		var p1 = pts[pts.length - 1];
		var last = null;
		var tmp;
		var f = p0.x - p1.x;
		if((f < 0 ? -f : f) < 1e-9) {
			var f = p0.y - p1.y;
			tmp = (f < 0 ? -f : f) < 1e-9;
		} else {
			tmp = false;
		}
		if(tmp) {
			last = pts.pop();
		}
		if(this.isConvex(pts)) {
			var _g = 1;
			var _g1 = pts.length - 1;
			while(_g < _g1) {
				var i = _g++;
				var _this = this.content;
				_this.index.push(i0);
				var _this1 = _this.state;
				_this1.tail.count += 1;
				_this1.totalCount += 1;
				_this.indexDirty = true;
				var _this2 = this.content;
				_this2.index.push(i0 + i);
				var _this3 = _this2.state;
				_this3.tail.count += 1;
				_this3.totalCount += 1;
				_this2.indexDirty = true;
				var _this4 = this.content;
				_this4.index.push(i0 + i + 1);
				var _this5 = _this4.state;
				_this5.tail.count += 1;
				_this5.totalCount += 1;
				_this4.indexDirty = true;
			}
		} else {
			var ear = h2d_Graphics.EARCUT;
			if(ear == null) {
				ear = new hxd_earcut_Earcut();
				h2d_Graphics.EARCUT = ear;
			}
			var _g = 0;
			var _g1 = ear.triangulate_h2d_GPoint(pts);
			while(_g < _g1.length) {
				var i = _g1[_g];
				++_g;
				var _this = this.content;
				_this.index.push(i + i0);
				var _this1 = _this.state;
				_this1.tail.count += 1;
				_this1.totalCount += 1;
				_this.indexDirty = true;
			}
		}
		if(last != null) {
			pts.push(last);
		}
	}
	,flush: function() {
		if(this.tmpPoints.length == 0) {
			return;
		}
		if(this.doFill) {
			this.flushFill(this.pindex);
			this.pindex += this.tmpPoints.length;
			if(this.content.next()) {
				this.pindex = 0;
			}
		}
		if(this.lineSize > 0) {
			this.flushLine(this.pindex);
			if(this.content.next()) {
				this.pindex = 0;
			}
		}
		this.tmpPoints = [];
	}
	,beginFill: function(color,alpha) {
		if(alpha == null) {
			alpha = 1.;
		}
		if(color == null) {
			color = 0;
		}
		this.flush();
		this.tile = h2d_Tile.fromColor(16777215);
		this.content.setTile(this.tile);
		var alpha1 = alpha;
		if(alpha1 == null) {
			alpha1 = 1.;
		}
		this.curA = alpha1;
		this.curR = (color >> 16 & 255) / 255.;
		this.curG = (color >> 8 & 255) / 255.;
		this.curB = (color & 255) / 255.;
		this.doFill = true;
	}
	,beginTileFill: function(dx,dy,scaleX,scaleY,tile) {
		if(tile == null) {
			tile = this.tile;
		}
		if(tile == null) {
			throw haxe_Exception.thrown("Tile not specified");
		}
		this.flush();
		this.tile = tile;
		this.content.setTile(tile);
		this.curA = 1.;
		this.curR = 1.;
		this.curG = 1.;
		this.curB = 1.;
		this.doFill = true;
		if(dx == null) {
			dx = 0;
		}
		if(dy == null) {
			dy = 0;
		}
		if(scaleX == null) {
			scaleX = 1;
		}
		if(scaleY == null) {
			scaleY = 1;
		}
		dx -= tile.x;
		dy -= tile.y;
		var tex = tile.innerTex;
		var pixWidth = 1 / tex.width;
		var pixHeight = 1 / tex.height;
		this.ma = pixWidth / scaleX;
		this.mb = 0;
		this.mc = 0;
		this.md = pixHeight / scaleY;
		this.mx = -dx * this.ma;
		this.my = -dy * this.md;
	}
	,drawTile: function(x,y,tile) {
		this.beginTileFill(x,y,null,null,tile);
		this.drawRect(x,y,tile.width,tile.height);
		this.endFill();
	}
	,lineStyle: function(size,color,alpha) {
		if(alpha == null) {
			alpha = 1.;
		}
		if(color == null) {
			color = 0;
		}
		if(size == null) {
			size = 0;
		}
		this.flush();
		this.lineSize = size;
		this.lineA = alpha;
		this.lineR = (color >> 16 & 255) / 255.;
		this.lineG = (color >> 8 & 255) / 255.;
		this.lineB = (color & 255) / 255.;
	}
	,moveTo: function(x,y) {
		this.flush();
		this.addVertex(x,y,this.curR,this.curG,this.curB,this.curA,x * this.ma + y * this.mc + this.mx,x * this.mb + y * this.md + this.my);
	}
	,endFill: function() {
		this.flush();
		this.doFill = false;
	}
	,setColor: function(color,alpha) {
		if(alpha == null) {
			alpha = 1.;
		}
		this.curA = alpha;
		this.curR = (color >> 16 & 255) / 255.;
		this.curG = (color >> 8 & 255) / 255.;
		this.curB = (color & 255) / 255.;
	}
	,drawRect: function(x,y,w,h) {
		this.flush();
		this.addVertex(x,y,this.curR,this.curG,this.curB,this.curA,x * this.ma + y * this.mc + this.mx,x * this.mb + y * this.md + this.my);
		var x1 = x + w;
		this.addVertex(x1,y,this.curR,this.curG,this.curB,this.curA,x1 * this.ma + y * this.mc + this.mx,x1 * this.mb + y * this.md + this.my);
		var x1 = x + w;
		var y1 = y + h;
		this.addVertex(x1,y1,this.curR,this.curG,this.curB,this.curA,x1 * this.ma + y1 * this.mc + this.mx,x1 * this.mb + y1 * this.md + this.my);
		var y1 = y + h;
		this.addVertex(x,y1,this.curR,this.curG,this.curB,this.curA,x * this.ma + y1 * this.mc + this.mx,x * this.mb + y1 * this.md + this.my);
		this.addVertex(x,y,this.curR,this.curG,this.curB,this.curA,x * this.ma + y * this.mc + this.mx,x * this.mb + y * this.md + this.my);
		var e = 0.01;
		this.tmpPoints[0].x += e;
		this.tmpPoints[0].y += e;
		this.tmpPoints[1].y += e;
		this.tmpPoints[3].x += e;
		this.tmpPoints[4].x += e;
		this.tmpPoints[4].y += e;
		this.flush();
	}
	,drawRoundedRect: function(x,y,w,h,radius,nsegments) {
		if(nsegments == null) {
			nsegments = 0;
		}
		var _gthis = this;
		if(radius <= 0) {
			this.drawRect(x,y,w,h);
			return;
		}
		x += radius;
		y += radius;
		w -= radius * 2;
		h -= radius * 2;
		this.flush();
		if(nsegments == 0) {
			var f = radius * 1.5707963267948966 / 4;
			nsegments = Math.ceil(f < 0 ? -f : f);
		}
		if(nsegments < 3) {
			nsegments = 3;
		}
		var angle = 1.5707963267948966 / (nsegments - 1);
		var y1 = y - radius;
		this.addVertex(x,y1,this.curR,this.curG,this.curB,this.curA,x * this.ma + y1 * this.mc + this.mx,x * this.mb + y1 * this.md + this.my);
		var x1 = x + w;
		var y1 = y - radius;
		this.addVertex(x1,y1,this.curR,this.curG,this.curB,this.curA,x1 * this.ma + y1 * this.mc + this.mx,x1 * this.mb + y1 * this.md + this.my);
		var x1 = x + w;
		var _g = 0;
		var _g1 = nsegments;
		while(_g < _g1) {
			var i = _g++;
			var a = i * angle + 4.71238898038469;
			var x2 = x1 + Math.cos(a) * radius;
			var y1 = y + Math.sin(a) * radius;
			_gthis.addVertex(x2,y1,_gthis.curR,_gthis.curG,_gthis.curB,_gthis.curA,x2 * _gthis.ma + y1 * _gthis.mc + _gthis.mx,x2 * _gthis.mb + y1 * _gthis.md + _gthis.my);
		}
		var x1 = x + w + radius;
		var y1 = y + h;
		this.addVertex(x1,y1,this.curR,this.curG,this.curB,this.curA,x1 * this.ma + y1 * this.mc + this.mx,x1 * this.mb + y1 * this.md + this.my);
		var x1 = x + w;
		var y1 = y + h;
		var _g = 0;
		var _g1 = nsegments;
		while(_g < _g1) {
			var i = _g++;
			var a = i * angle;
			var x2 = x1 + Math.cos(a) * radius;
			var y2 = y1 + Math.sin(a) * radius;
			_gthis.addVertex(x2,y2,_gthis.curR,_gthis.curG,_gthis.curB,_gthis.curA,x2 * _gthis.ma + y2 * _gthis.mc + _gthis.mx,x2 * _gthis.mb + y2 * _gthis.md + _gthis.my);
		}
		var y1 = y + h + radius;
		this.addVertex(x,y1,this.curR,this.curG,this.curB,this.curA,x * this.ma + y1 * this.mc + this.mx,x * this.mb + y1 * this.md + this.my);
		var y1 = y + h;
		var _g = 0;
		var _g1 = nsegments;
		while(_g < _g1) {
			var i = _g++;
			var a = i * angle + 1.5707963267948966;
			var x1 = x + Math.cos(a) * radius;
			var y2 = y1 + Math.sin(a) * radius;
			_gthis.addVertex(x1,y2,_gthis.curR,_gthis.curG,_gthis.curB,_gthis.curA,x1 * _gthis.ma + y2 * _gthis.mc + _gthis.mx,x1 * _gthis.mb + y2 * _gthis.md + _gthis.my);
		}
		var x1 = x - radius;
		this.addVertex(x1,y,this.curR,this.curG,this.curB,this.curA,x1 * this.ma + y * this.mc + this.mx,x1 * this.mb + y * this.md + this.my);
		var _g = 0;
		var _g1 = nsegments;
		while(_g < _g1) {
			var i = _g++;
			var a = i * angle + 3.1415926535897931;
			var x1 = x + Math.cos(a) * radius;
			var y1 = y + Math.sin(a) * radius;
			_gthis.addVertex(x1,y1,_gthis.curR,_gthis.curG,_gthis.curB,_gthis.curA,x1 * _gthis.ma + y1 * _gthis.mc + _gthis.mx,x1 * _gthis.mb + y1 * _gthis.md + _gthis.my);
		}
		this.flush();
	}
	,drawCircle: function(cx,cy,radius,nsegments) {
		if(nsegments == null) {
			nsegments = 0;
		}
		this.flush();
		if(nsegments == 0) {
			var f = radius * 3.14 * 2 / 4;
			nsegments = Math.ceil(f < 0 ? -f : f);
		}
		if(nsegments < 3) {
			nsegments = 3;
		}
		var angle = 6.2831853071795862 / nsegments;
		var _g = 0;
		var _g1 = nsegments + 1;
		while(_g < _g1) {
			var i = _g++;
			var a = i * angle;
			var x = cx + Math.cos(a) * radius;
			var y = cy + Math.sin(a) * radius;
			this.addVertex(x,y,this.curR,this.curG,this.curB,this.curA,x * this.ma + y * this.mc + this.mx,x * this.mb + y * this.md + this.my);
		}
		this.flush();
	}
	,drawEllipse: function(cx,cy,radiusX,radiusY,rotationAngle,nsegments) {
		if(nsegments == null) {
			nsegments = 0;
		}
		if(rotationAngle == null) {
			rotationAngle = 0;
		}
		this.flush();
		if(nsegments == 0) {
			var f = radiusY * 3.14 * 2 / 4;
			nsegments = Math.ceil(f < 0 ? -f : f);
		}
		if(nsegments < 3) {
			nsegments = 3;
		}
		var angle = 6.2831853071795862 / nsegments;
		var x1;
		var y1;
		var _g = 0;
		var _g1 = nsegments + 1;
		while(_g < _g1) {
			var i = _g++;
			var a = i * angle;
			x1 = Math.cos(a) * Math.cos(rotationAngle) * radiusX - Math.sin(a) * Math.sin(rotationAngle) * radiusY;
			y1 = Math.cos(rotationAngle) * Math.sin(a) * radiusY + Math.cos(a) * Math.sin(rotationAngle) * radiusX;
			var x = cx + x1;
			var y = cy + y1;
			this.addVertex(x,y,this.curR,this.curG,this.curB,this.curA,x * this.ma + y * this.mc + this.mx,x * this.mb + y * this.md + this.my);
		}
		this.flush();
	}
	,drawPie: function(cx,cy,radius,angleStart,angleLength,nsegments) {
		if(nsegments == null) {
			nsegments = 0;
		}
		if((angleLength < 0 ? -angleLength : angleLength) >= 6.2831853071795862) {
			this.drawCircle(cx,cy,radius,nsegments);
			return;
		}
		this.flush();
		this.addVertex(cx,cy,this.curR,this.curG,this.curB,this.curA,cx * this.ma + cy * this.mc + this.mx,cx * this.mb + cy * this.md + this.my);
		if(nsegments == 0) {
			var f = radius * angleLength / 4;
			nsegments = Math.ceil(f < 0 ? -f : f);
		}
		if(nsegments < 3) {
			nsegments = 3;
		}
		var angle = angleLength / (nsegments - 1);
		var _g = 0;
		var _g1 = nsegments;
		while(_g < _g1) {
			var i = _g++;
			var a = i * angle + angleStart;
			var x = cx + Math.cos(a) * radius;
			var y = cy + Math.sin(a) * radius;
			this.addVertex(x,y,this.curR,this.curG,this.curB,this.curA,x * this.ma + y * this.mc + this.mx,x * this.mb + y * this.md + this.my);
		}
		this.addVertex(cx,cy,this.curR,this.curG,this.curB,this.curA,cx * this.ma + cy * this.mc + this.mx,cx * this.mb + cy * this.md + this.my);
		this.flush();
	}
	,drawPieInner: function(cx,cy,radius,innerRadius,angleStart,angleLength,nsegments) {
		if(nsegments == null) {
			nsegments = 0;
		}
		this.flush();
		if((angleLength < 0 ? -angleLength : angleLength) >= 6.2841853071795866) {
			angleLength = 6.2841853071795866;
		}
		var cs = Math.cos(angleStart);
		var ss = Math.sin(angleStart);
		var ce = Math.cos(angleStart + angleLength);
		var se = Math.sin(angleStart + angleLength);
		var x = cx + cs * innerRadius;
		var y = cy + ss * innerRadius;
		this.addVertex(x,y,this.curR,this.curG,this.curB,this.curA,x * this.ma + y * this.mc + this.mx,x * this.mb + y * this.md + this.my);
		if(nsegments == 0) {
			var f = radius * angleLength / 4;
			nsegments = Math.ceil(f < 0 ? -f : f);
		}
		if(nsegments < 3) {
			nsegments = 3;
		}
		var angle = angleLength / (nsegments - 1);
		var _g = 0;
		var _g1 = nsegments;
		while(_g < _g1) {
			var i = _g++;
			var a = i * angle + angleStart;
			var x = cx + Math.cos(a) * radius;
			var y = cy + Math.sin(a) * radius;
			this.addVertex(x,y,this.curR,this.curG,this.curB,this.curA,x * this.ma + y * this.mc + this.mx,x * this.mb + y * this.md + this.my);
		}
		var x = cx + ce * innerRadius;
		var y = cy + se * innerRadius;
		this.addVertex(x,y,this.curR,this.curG,this.curB,this.curA,x * this.ma + y * this.mc + this.mx,x * this.mb + y * this.md + this.my);
		var _g = 0;
		var _g1 = nsegments;
		while(_g < _g1) {
			var i = _g++;
			var a = (nsegments - 1 - i) * angle + angleStart;
			var x = cx + Math.cos(a) * innerRadius;
			var y = cy + Math.sin(a) * innerRadius;
			this.addVertex(x,y,this.curR,this.curG,this.curB,this.curA,x * this.ma + y * this.mc + this.mx,x * this.mb + y * this.md + this.my);
		}
		this.flush();
	}
	,drawRectanglePie: function(cx,cy,width,height,angleStart,angleLength,nsegments) {
		if(nsegments == null) {
			nsegments = 0;
		}
		if((angleLength < 0 ? -angleLength : angleLength) >= 6.2831853071795862) {
			this.drawRect(cx - width / 2,cy - height / 2,width,height);
			return;
		}
		this.flush();
		this.addVertex(cx,cy,this.curR,this.curG,this.curB,this.curA,cx * this.ma + cy * this.mc + this.mx,cx * this.mb + cy * this.md + this.my);
		if(nsegments == 0) {
			var f = (width < height ? height : width) * angleLength / 4;
			nsegments = Math.ceil(f < 0 ? -f : f);
		}
		if(nsegments < 3) {
			nsegments = 3;
		}
		var angle = angleLength / (nsegments - 1);
		var square2 = Math.sqrt(2);
		var _g = 0;
		var _g1 = nsegments;
		while(_g < _g1) {
			var i = _g++;
			var a = i * angle + angleStart;
			var _width = Math.cos(a) * (width / 2 + 1) * square2;
			var _height = Math.sin(a) * (height / 2 + 1) * square2;
			if((_width < 0 ? -_width : _width) >= width / 2) {
				_width = Math.cos(a) < 0 ? width / 2 * -1 : width / 2;
			}
			if((_height < 0 ? -_height : _height) >= height / 2) {
				_height = Math.sin(a) < 0 ? height / 2 * -1 : height / 2;
			}
			var x = cx + _width;
			var y = cy + _height;
			this.addVertex(x,y,this.curR,this.curG,this.curB,this.curA,x * this.ma + y * this.mc + this.mx,x * this.mb + y * this.md + this.my);
		}
		this.addVertex(cx,cy,this.curR,this.curG,this.curB,this.curA,cx * this.ma + cy * this.mc + this.mx,cx * this.mb + cy * this.md + this.my);
		this.flush();
	}
	,curveTo: function(bx,by,cx,cy) {
		var ax = this.tmpPoints.length == 0 ? 0 : this.tmpPoints[this.tmpPoints.length - 1].x;
		var ay = this.tmpPoints.length == 0 ? 0 : this.tmpPoints[this.tmpPoints.length - 1].y;
		var t = 0.66666666666666663;
		this.cubicCurveTo(ax + t * (bx - ax),ay + t * (by - ay),cx + t * (bx - cx),cy + t * (by - cy),cx,cy);
	}
	,cubicCurveTo: function(bx,by,cx,cy,dx,dy,nsegments) {
		if(nsegments == null) {
			nsegments = 40;
		}
		var ax = this.tmpPoints.length == 0 ? 0 : this.tmpPoints[this.tmpPoints.length - 1].x;
		var ay = this.tmpPoints.length == 0 ? 0 : this.tmpPoints[this.tmpPoints.length - 1].y;
		var tobx = bx - ax;
		var toby = by - ay;
		var tocx = cx - bx;
		var tocy = cy - by;
		var todx = dx - cx;
		var tody = dy - cy;
		var step = 1 / nsegments;
		var _g = 1;
		var _g1 = nsegments;
		while(_g < _g1) {
			var i = _g++;
			var d = i * step;
			var px = ax + d * tobx;
			var py = ay + d * toby;
			var qx = bx + d * tocx;
			var qy = by + d * tocy;
			var rx = cx + d * todx;
			var ry = cy + d * tody;
			var toqx = qx - px;
			var toqy = qy - py;
			var torx = rx - qx;
			var tory = ry - qy;
			var sx = px + d * toqx;
			var sy = py + d * toqy;
			var tx = qx + d * torx;
			var ty = qy + d * tory;
			var totx = tx - sx;
			var toty = ty - sy;
			var x = sx + d * totx;
			var y = sy + d * toty;
			this.addVertex(x,y,this.curR,this.curG,this.curB,this.curA,x * this.ma + y * this.mc + this.mx,x * this.mb + y * this.md + this.my);
		}
		this.addVertex(dx,dy,this.curR,this.curG,this.curB,this.curA,dx * this.ma + dy * this.mc + this.mx,dx * this.mb + dy * this.md + this.my);
	}
	,lineTo: function(x,y) {
		this.addVertex(x,y,this.curR,this.curG,this.curB,this.curA,x * this.ma + y * this.mc + this.mx,x * this.mb + y * this.md + this.my);
	}
	,addVertex: function(x,y,r,g,b,a,u,v) {
		if(v == null) {
			v = 0.;
		}
		if(u == null) {
			u = 0.;
		}
		var half = this.lineSize / 2.0;
		if(x - half < this.xMin) {
			this.xMin = x - half;
		}
		if(y - half < this.yMin) {
			this.yMin = y - half;
		}
		if(x + half > this.xMax) {
			this.xMax = x + half;
		}
		if(y + half > this.yMax) {
			this.yMax = y + half;
		}
		if(x < this.xMinSize) {
			this.xMinSize = x;
		}
		if(y < this.yMinSize) {
			this.yMinSize = y;
		}
		if(x > this.xMaxSize) {
			this.xMaxSize = x;
		}
		if(y > this.yMaxSize) {
			this.yMaxSize = y;
		}
		if(this.doFill) {
			var _this = this.content;
			var this1 = _this.tmp;
			if(this1.pos == this1.array.length) {
				var newSize = this1.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(this1.array);
				this1.array = newArray;
			}
			this1.array[this1.pos++] = x;
			var this1 = _this.tmp;
			if(this1.pos == this1.array.length) {
				var newSize = this1.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(this1.array);
				this1.array = newArray;
			}
			this1.array[this1.pos++] = y;
			var this1 = _this.tmp;
			if(this1.pos == this1.array.length) {
				var newSize = this1.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(this1.array);
				this1.array = newArray;
			}
			this1.array[this1.pos++] = u;
			var this1 = _this.tmp;
			if(this1.pos == this1.array.length) {
				var newSize = this1.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(this1.array);
				this1.array = newArray;
			}
			this1.array[this1.pos++] = v;
			var this1 = _this.tmp;
			if(this1.pos == this1.array.length) {
				var newSize = this1.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(this1.array);
				this1.array = newArray;
			}
			this1.array[this1.pos++] = r;
			var this1 = _this.tmp;
			if(this1.pos == this1.array.length) {
				var newSize = this1.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(this1.array);
				this1.array = newArray;
			}
			this1.array[this1.pos++] = g;
			var this1 = _this.tmp;
			if(this1.pos == this1.array.length) {
				var newSize = this1.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(this1.array);
				this1.array = newArray;
			}
			this1.array[this1.pos++] = b;
			var this1 = _this.tmp;
			if(this1.pos == this1.array.length) {
				var newSize = this1.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(this1.array);
				this1.array = newArray;
			}
			this1.array[this1.pos++] = a;
			_this.bufferDirty = true;
		}
		var gp = new h2d_GPoint();
		gp.load(x,y,this.lineR,this.lineG,this.lineB,this.lineA);
		this.tmpPoints.push(gp);
	}
	,draw: function(ctx) {
		if(!ctx.beginDrawBatchState(this)) {
			return;
		}
		this.content.doRender(ctx);
	}
	,sync: function(ctx) {
		h2d_Drawable.prototype.sync.call(this,ctx);
		this.flush();
		this.content.flush();
	}
	,__class__: h2d_Graphics
});
var hxd_Interactive = function() { };
$hxClasses["hxd.Interactive"] = hxd_Interactive;
hxd_Interactive.__name__ = "hxd.Interactive";
hxd_Interactive.__isInterface__ = true;
hxd_Interactive.prototype = {
	__class__: hxd_Interactive
};
var h2d_Interactive = function(width,height,parent,shape) {
	this.shapeY = 0;
	this.shapeX = 0;
	this.lastClickFrame = -1;
	this.mouseDownButton = -1;
	this.allowMultiClick = false;
	this.enableRightButton = false;
	this.propagateEvents = false;
	this.cancelEvents = false;
	this.cursor = hxd_Cursor.Button;
	h2d_Object.call(this,parent);
	this.width = width;
	this.height = height;
	this.shape = shape;
};
$hxClasses["h2d.Interactive"] = h2d_Interactive;
h2d_Interactive.__name__ = "h2d.Interactive";
h2d_Interactive.__interfaces__ = [hxd_Interactive];
h2d_Interactive.__super__ = h2d_Object;
h2d_Interactive.prototype = $extend(h2d_Object.prototype,{
	onAdd: function() {
		this.scene = this.getScene();
		if(this.scene != null) {
			this.scene.addEventTarget(this);
		}
		h2d_Object.prototype.onAdd.call(this);
	}
	,draw: function(ctx) {
		this.maskedBounds = ctx.getCurrentRenderZone(this.maskedBounds);
		if(this.backgroundColor != null) {
			this.emitTile(ctx,h2d_Tile.fromColor(this.backgroundColor,this.width | 0,this.height | 0,(this.backgroundColor >>> 24) / 255));
		}
	}
	,getBoundsRec: function(relativeTo,out,forSize) {
		h2d_Object.prototype.getBoundsRec.call(this,relativeTo,out,forSize);
		if(this.backgroundColor != null || forSize) {
			this.addBounds(relativeTo,out,0,0,this.width | 0,this.height | 0);
		}
	}
	,onHierarchyMoved: function(parentChanged) {
		h2d_Object.prototype.onHierarchyMoved.call(this,parentChanged);
		if(this.scene != null) {
			this.scene.removeEventTarget(this);
			this.scene = this.getScene();
			if(this.scene != null) {
				this.scene.addEventTarget(this);
			}
		}
	}
	,onRemove: function() {
		if(this.scene != null) {
			this.scene.removeEventTarget(this,true);
			this.scene = null;
		}
		h2d_Object.prototype.onRemove.call(this);
	}
	,checkBounds: function(e) {
		switch(e.kind._hx_index) {
		case 4:case 6:case 7:case 10:
			return false;
		default:
			return true;
		}
	}
	,preventClick: function() {
		this.mouseDownButton = -1;
	}
	,getInteractiveScene: function() {
		return this.scene;
	}
	,handleEvent: function(e) {
		if(this.maskedBounds != null && this.checkBounds(e)) {
			var x = e.relX;
			var y = e.relY;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var pt = new h2d_col_PointImpl(x,y);
			this.localToGlobal(pt);
			if(pt.x < this.maskedBounds.xMin || pt.y < this.maskedBounds.yMin || pt.x > this.maskedBounds.xMax || pt.y > this.maskedBounds.yMax) {
				e.cancel = true;
				return;
			}
		}
		if(this.shape == null && this.isEllipse && this.checkBounds(e)) {
			var cx = this.width * 0.5;
			var cy = this.height * 0.5;
			var dx = (e.relX - cx) / cx;
			var dy = (e.relY - cy) / cy;
			if(dx * dx + dy * dy > 1) {
				e.cancel = true;
				return;
			}
		}
		if(this.propagateEvents) {
			e.propagate = true;
		}
		if(this.cancelEvents) {
			e.cancel = true;
		}
		switch(e.kind._hx_index) {
		case 0:
			if(this.enableRightButton || e.button == 0) {
				this.mouseDownButton = e.button;
				this.onPush(e);
				if(e.cancel) {
					this.mouseDownButton = -1;
				}
			}
			break;
		case 1:
			if(this.enableRightButton || e.button == 0) {
				this.onRelease(e);
				var frame = hxd_Timer.frameCount;
				if(this.mouseDownButton == e.button && (this.lastClickFrame != frame || this.allowMultiClick)) {
					this.onClick(e);
					this.lastClickFrame = frame;
				}
			}
			this.mouseDownButton = -1;
			break;
		case 2:
			this.onMove(e);
			break;
		case 3:
			this.onOver(e);
			break;
		case 4:
			this.onOut(e);
			break;
		case 5:
			e.propagate = true;
			this.onWheel(e);
			break;
		case 6:
			this.onFocus(e);
			break;
		case 7:
			this.onFocusLost(e);
			break;
		case 8:
			this.onKeyDown(e);
			break;
		case 9:
			this.onKeyUp(e);
			break;
		case 10:
			if(this.enableRightButton || e.button == 0) {
				this.onRelease(e);
				if(this.mouseDownButton == e.button) {
					this.onReleaseOutside(e);
				}
			}
			this.mouseDownButton = -1;
			break;
		case 11:
			this.onTextInput(e);
			break;
		case 12:
			this.onCheck(e);
			break;
		}
	}
	,calcAbsPos: function() {
		h2d_Object.prototype.calcAbsPos.call(this);
		this.invDet = 1 / (this.matA * this.matD - this.matB * this.matC);
	}
	,set_cursor: function(c) {
		this.cursor = c;
		if(this.scene != null && this.scene.events != null) {
			this.scene.events.updateCursor(this);
		}
		return c;
	}
	,eventToLocal: function(e) {
		var i = this;
		var dx = e.relX - i.absX;
		var dy = e.relY - i.absY;
		e.relX = (dx * i.matD - dy * i.matC) * i.invDet;
		e.relY = (-dx * i.matB + dy * i.matA) * i.invDet;
	}
	,startCapture: function(callb,onCancel,touchId) {
		var _gthis = this;
		this.scene.startCapture(function(event) {
			var x = event.relX;
			var y = event.relY;
			_gthis.eventToLocal(event);
			callb(event);
			event.relX = x;
			event.relY = y;
		},onCancel,touchId);
	}
	,stopCapture: function() {
		this.scene.stopCapture();
	}
	,startDrag: function(callb,onCancel) {
		this.startCapture(callb,onCancel);
	}
	,stopDrag: function() {
		this.stopCapture();
	}
	,focus: function() {
		if(this.scene == null || this.scene.events == null) {
			return;
		}
		this.scene.events.focus(this);
	}
	,blur: function() {
		if(this.hasFocus()) {
			this.scene.events.blur();
		}
	}
	,isOver: function() {
		if(this.scene != null && this.scene.events != null) {
			return this.scene.events.overList.indexOf(this) != -1;
		} else {
			return false;
		}
	}
	,hasFocus: function() {
		if(this.scene != null && this.scene.events != null) {
			return this.scene.events.currentFocus == this;
		} else {
			return false;
		}
	}
	,onOver: function(e) {
	}
	,onOut: function(e) {
	}
	,onPush: function(e) {
	}
	,onRelease: function(e) {
	}
	,onReleaseOutside: function(e) {
	}
	,onClick: function(e) {
	}
	,onMove: function(e) {
	}
	,onWheel: function(e) {
	}
	,onFocus: function(e) {
	}
	,onFocusLost: function(e) {
	}
	,onKeyUp: function(e) {
	}
	,onKeyDown: function(e) {
	}
	,onCheck: function(e) {
	}
	,onTextInput: function(e) {
	}
	,__class__: h2d_Interactive
});
var h3d_impl_RenderContext = function() {
	this.shaderBuffers = new h3d_shader_Buffers();
	this.engine = h3d_Engine.CURRENT;
	this.frame = 0;
	this.time = 0.;
	this.elapsedTime = 1. / hxd_System.getDefaultFrameRate();
	this.textures = new h3d_impl_TextureCache();
	this.globals = new hxsl_Globals();
};
$hxClasses["h3d.impl.RenderContext"] = h3d_impl_RenderContext;
h3d_impl_RenderContext.__name__ = "h3d.impl.RenderContext";
h3d_impl_RenderContext.get = function() {
	return h3d_impl_RenderContext.inst;
};
h3d_impl_RenderContext.getType = function(cl) {
	var value = h3d_impl_RenderContext.inst;
	if(js_Boot.__downcastCheck(value,cl)) {
		return value;
	} else {
		return null;
	}
};
h3d_impl_RenderContext.prototype = {
	setCurrent: function() {
		h3d_impl_RenderContext.inst = this;
	}
	,clearCurrent: function() {
		if(h3d_impl_RenderContext.inst == this) {
			h3d_impl_RenderContext.inst = null;
		} else {
			throw haxe_Exception.thrown("Context has changed");
		}
	}
	,dispose: function() {
		this.textures.dispose();
	}
	,fillRec: function(v,type,out,pos) {
		switch(type._hx_index) {
		case 1:
			out[pos] = v;
			return 1;
		case 3:
			out[pos] = v;
			return 1;
		case 5:
			var _g = type.size;
			var _g1 = type.t;
			if(_g == 4) {
				var v1 = v;
				out[pos++] = v1.x;
				out[pos++] = v1.y;
				out[pos++] = v1.z;
				out[pos++] = v1.w;
				return 4;
			} else {
				var n = _g;
				var v1 = v;
				out[pos++] = v1.x;
				out[pos++] = v1.y;
				if(n == 3) {
					out[pos++] = v1.z;
				}
				return n;
			}
			break;
		case 6:
			var m = v;
			out[pos++] = m._11;
			out[pos++] = m._21;
			out[pos++] = m._31;
			out[pos++] = 0;
			out[pos++] = m._12;
			out[pos++] = m._22;
			out[pos++] = m._32;
			out[pos++] = 0;
			out[pos++] = m._13;
			out[pos++] = m._23;
			out[pos++] = m._33;
			out[pos++] = 0;
			return 12;
		case 7:
			var m = v;
			out[pos++] = m._11;
			out[pos++] = m._21;
			out[pos++] = m._31;
			out[pos++] = m._41;
			out[pos++] = m._12;
			out[pos++] = m._22;
			out[pos++] = m._32;
			out[pos++] = m._42;
			out[pos++] = m._13;
			out[pos++] = m._23;
			out[pos++] = m._33;
			out[pos++] = m._43;
			out[pos++] = m._14;
			out[pos++] = m._24;
			out[pos++] = m._34;
			out[pos++] = m._44;
			return 16;
		case 8:
			var m = v;
			out[pos++] = m._11;
			out[pos++] = m._21;
			out[pos++] = m._31;
			out[pos++] = m._41;
			out[pos++] = m._12;
			out[pos++] = m._22;
			out[pos++] = m._32;
			out[pos++] = m._42;
			out[pos++] = m._13;
			out[pos++] = m._23;
			out[pos++] = m._33;
			out[pos++] = m._43;
			return 12;
		case 13:
			var vl = type.vl;
			var tot = 0;
			var _g = 0;
			while(_g < vl.length) {
				var vv = vl[_g];
				++_g;
				tot += this.fillRec(Reflect.field(v,vv.name),vv.type,out,pos + tot);
			}
			return tot;
		case 15:
			var _g = type.t;
			var _g1 = type.size;
			switch(_g._hx_index) {
			case 3:
				if(_g1._hx_index == 0) {
					var len = _g1.v;
					var v1 = v;
					var size = 0;
					var count = v1.length < len ? v1.length : len;
					var _g2 = 0;
					var _g3 = count;
					while(_g2 < _g3) {
						var i = _g2++;
						out[pos++] = v1[i];
					}
					return len;
				} else {
					throw haxe_Exception.thrown("assert " + Std.string(type));
				}
				break;
			case 5:
				if(_g.size == 4) {
					if(_g.t._hx_index == 1) {
						if(_g1._hx_index == 0) {
							var len = _g1.v;
							var v1 = v;
							var _g2 = 0;
							var _g3 = len;
							while(_g2 < _g3) {
								var i = _g2++;
								var n = v1[i];
								if(n == null) {
									break;
								}
								out[pos++] = n.x;
								out[pos++] = n.y;
								out[pos++] = n.z;
								out[pos++] = n.w;
							}
							return len * 4;
						} else {
							throw haxe_Exception.thrown("assert " + Std.string(type));
						}
					} else if(_g1._hx_index == 0) {
						var t = _g;
						var len = _g1.v;
						var v1 = v;
						var size = 0;
						var _g2 = 0;
						var _g3 = len;
						while(_g2 < _g3) {
							var i = _g2++;
							var n = v1[i];
							if(n == null) {
								break;
							}
							size = this.fillRec(n,t,out,pos);
							pos += size;
						}
						return len * size;
					} else {
						throw haxe_Exception.thrown("assert " + Std.string(type));
					}
				} else if(_g1._hx_index == 0) {
					var t = _g;
					var len = _g1.v;
					var v1 = v;
					var size = 0;
					var _g2 = 0;
					var _g3 = len;
					while(_g2 < _g3) {
						var i = _g2++;
						var n = v1[i];
						if(n == null) {
							break;
						}
						size = this.fillRec(n,t,out,pos);
						pos += size;
					}
					return len * size;
				} else {
					throw haxe_Exception.thrown("assert " + Std.string(type));
				}
				break;
			case 8:
				if(_g1._hx_index == 0) {
					var len = _g1.v;
					var v1 = v;
					var _g2 = 0;
					var _g3 = len;
					while(_g2 < _g3) {
						var i = _g2++;
						var m = v1[i];
						if(m == null) {
							break;
						}
						out[pos++] = m._11;
						out[pos++] = m._21;
						out[pos++] = m._31;
						out[pos++] = m._41;
						out[pos++] = m._12;
						out[pos++] = m._22;
						out[pos++] = m._32;
						out[pos++] = m._42;
						out[pos++] = m._13;
						out[pos++] = m._23;
						out[pos++] = m._33;
						out[pos++] = m._43;
					}
					return len * 12;
				} else {
					throw haxe_Exception.thrown("assert " + Std.string(type));
				}
				break;
			default:
				if(_g1._hx_index == 0) {
					var t = _g;
					var len = _g1.v;
					var v1 = v;
					var size = 0;
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						var n = v1[i];
						if(n == null) {
							break;
						}
						size = this.fillRec(n,t,out,pos);
						pos += size;
					}
					return len * size;
				} else {
					throw haxe_Exception.thrown("assert " + Std.string(type));
				}
			}
			break;
		default:
			throw haxe_Exception.thrown("assert " + Std.string(type));
		}
	}
	,shaderInfo: function(shaders,path) {
		var name = path.split(".").pop();
		while(shaders != null) {
			var inst = shaders.s.instance;
			var _g = 0;
			var _g1 = inst.shader.vars;
			while(_g < _g1.length) {
				var v = _g1[_g];
				++_g;
				if(v.name == name) {
					return shaders.s.toString();
				}
			}
			shaders = shaders.next;
		}
		return "(not found)";
	}
	,getPtr: function(data) {
		return data;
	}
	,getParamValue: function(p,shaders,opt) {
		if(opt == null) {
			opt = false;
		}
		if(p.perObjectGlobal != null) {
			var v = this.globals.map.h[p.perObjectGlobal.gid];
			if(v == null) {
				throw haxe_Exception.thrown("Missing global value " + p.perObjectGlobal.path + " for shader " + this.shaderInfo(shaders,p.perObjectGlobal.path));
			}
			var _g = p.type;
			var tmp;
			if(_g._hx_index == 17) {
				var _g1 = _g.size;
				tmp = true;
			} else {
				tmp = false;
			}
			if(tmp) {
				return v.texture;
			}
			return v;
		}
		var si = shaders;
		var n = p.instance;
		while(--n > 0) si = si.next;
		var v = si.s.getParamValue(p.index);
		if(v == null && !opt) {
			throw haxe_Exception.thrown("Missing param value " + Std.string(si.s) + "." + p.name);
		}
		return v;
	}
	,fillGlobals: function(buf,s) {
		var _gthis = this;
		var g = s.vertex.globals;
		var ptr = buf.vertex.globals;
		while(g != null) {
			var v = _gthis.globals.map.h[g.gid];
			if(v == null) {
				throw haxe_Exception.thrown("Missing global value " + g.path);
			}
			_gthis.fillRec(v,g.type,ptr,g.pos);
			g = g.next;
		}
		if(s.fragment != null) {
			var g = s.fragment.globals;
			var ptr = buf.fragment.globals;
			while(g != null) {
				var v = _gthis.globals.map.h[g.gid];
				if(v == null) {
					throw haxe_Exception.thrown("Missing global value " + g.path);
				}
				_gthis.fillRec(v,g.type,ptr,g.pos);
				g = g.next;
			}
		}
	}
	,fillParams: function(buf,s,shaders,compute) {
		if(compute == null) {
			compute = false;
		}
		var _gthis = this;
		var curInstance = -1;
		var curInstanceValue = null;
		var buf1 = buf.vertex;
		var s1 = s.vertex;
		var p = s1.params;
		var ptr = buf1.params;
		while(p != null) {
			var v;
			if(p.perObjectGlobal == null) {
				switch(p.type._hx_index) {
				case 1:case 3:
					var index = p.instance;
					var i;
					if(curInstance == index) {
						i = curInstanceValue;
					} else {
						var si = shaders;
						curInstance = index;
						if(compute) {
							++index;
						}
						while(--index > 0) si = si.next;
						curInstanceValue = si.s;
						i = curInstanceValue;
					}
					ptr[p.pos] = i.getParamFloatValue(p.index);
					p = p.next;
					continue;
				default:
				}
				var index1 = p.instance;
				var v1;
				if(curInstance == index1) {
					v1 = curInstanceValue;
				} else {
					var si1 = shaders;
					curInstance = index1;
					if(compute) {
						++index1;
					}
					while(--index1 > 0) si1 = si1.next;
					curInstanceValue = si1.s;
					v1 = curInstanceValue;
				}
				v = v1.getParamValue(p.index);
				if(v == null) {
					throw haxe_Exception.thrown("Missing param value " + Std.string(curInstanceValue) + "." + p.name);
				}
			} else if(p.perObjectGlobal != null) {
				var v2 = _gthis.globals.map.h[p.perObjectGlobal.gid];
				if(v2 == null) {
					throw haxe_Exception.thrown("Missing global value " + p.perObjectGlobal.path + " for shader " + _gthis.shaderInfo(shaders,p.perObjectGlobal.path));
				}
				var _g = p.type;
				var v3;
				if(_g._hx_index == 17) {
					var _g1 = _g.size;
					v3 = true;
				} else {
					v3 = false;
				}
				v = v3 ? v2.texture : v2;
			} else {
				var index2 = p.instance;
				var v4;
				if(curInstance == index2) {
					v4 = curInstanceValue;
				} else {
					var si2 = shaders;
					curInstance = index2;
					if(compute) {
						++index2;
					}
					while(--index2 > 0) si2 = si2.next;
					curInstanceValue = si2.s;
					v4 = curInstanceValue;
				}
				var v5 = v4.getParamValue(p.index);
				if(v5 == null) {
					throw haxe_Exception.thrown("Missing param value " + Std.string(shaders.s) + "." + p.name);
				}
				v = v5;
			}
			_gthis.fillRec(v,p.type,ptr,p.pos);
			p = p.next;
		}
		var tid = 0;
		var p = s1.textures;
		while(p != null) {
			var opt = !h3d_impl_RenderContext.STRICT;
			if(opt == null) {
				opt = false;
			}
			var t;
			if(p.perObjectGlobal != null) {
				var v = _gthis.globals.map.h[p.perObjectGlobal.gid];
				if(v == null) {
					throw haxe_Exception.thrown("Missing global value " + p.perObjectGlobal.path + " for shader " + _gthis.shaderInfo(shaders,p.perObjectGlobal.path));
				}
				var _g = p.type;
				var t1;
				if(_g._hx_index == 17) {
					var _g1 = _g.size;
					t1 = true;
				} else {
					t1 = false;
				}
				t = t1 ? v.texture : v;
			} else {
				var index = p.instance;
				var v1;
				if(curInstance == index) {
					v1 = curInstanceValue;
				} else {
					var si = shaders;
					curInstance = index;
					if(compute) {
						++index;
					}
					while(--index > 0) si = si.next;
					curInstanceValue = si.s;
					v1 = curInstanceValue;
				}
				var v2 = v1.getParamValue(p.index);
				if(v2 == null && !opt) {
					throw haxe_Exception.thrown("Missing param value " + Std.string(shaders.s) + "." + p.name);
				}
				t = v2;
			}
			if(p.pos < 0) {
				var arr = t;
				var _g2 = 0;
				var _g3 = -p.pos;
				while(_g2 < _g3) {
					var i = _g2++;
					buf1.tex[tid++] = arr[i];
				}
			} else {
				buf1.tex[tid++] = t;
			}
			p = p.next;
		}
		var p = s1.buffers;
		var bid = 0;
		while(p != null) {
			var opt = !h3d_impl_RenderContext.STRICT;
			if(opt == null) {
				opt = false;
			}
			var b;
			if(p.perObjectGlobal != null) {
				var v = _gthis.globals.map.h[p.perObjectGlobal.gid];
				if(v == null) {
					throw haxe_Exception.thrown("Missing global value " + p.perObjectGlobal.path + " for shader " + _gthis.shaderInfo(shaders,p.perObjectGlobal.path));
				}
				var _g = p.type;
				var b1;
				if(_g._hx_index == 17) {
					var _g1 = _g.size;
					b1 = true;
				} else {
					b1 = false;
				}
				b = b1 ? v.texture : v;
			} else {
				var index = p.instance;
				var v1;
				if(curInstance == index) {
					v1 = curInstanceValue;
				} else {
					var si = shaders;
					curInstance = index;
					if(compute) {
						++index;
					}
					while(--index > 0) si = si.next;
					curInstanceValue = si.s;
					v1 = curInstanceValue;
				}
				var v2 = v1.getParamValue(p.index);
				if(v2 == null && !opt) {
					throw haxe_Exception.thrown("Missing param value " + Std.string(shaders.s) + "." + p.name);
				}
				b = v2;
			}
			buf1.buffers[bid++] = b;
			p = p.next;
		}
		if(s.fragment != null) {
			var buf1 = buf.fragment;
			var s1 = s.fragment;
			var p = s1.params;
			var ptr = buf1.params;
			while(p != null) {
				var v;
				if(p.perObjectGlobal == null) {
					switch(p.type._hx_index) {
					case 1:case 3:
						var index = p.instance;
						var i;
						if(curInstance == index) {
							i = curInstanceValue;
						} else {
							var si = shaders;
							curInstance = index;
							if(compute) {
								++index;
							}
							while(--index > 0) si = si.next;
							curInstanceValue = si.s;
							i = curInstanceValue;
						}
						ptr[p.pos] = i.getParamFloatValue(p.index);
						p = p.next;
						continue;
					default:
					}
					var index1 = p.instance;
					var v1;
					if(curInstance == index1) {
						v1 = curInstanceValue;
					} else {
						var si1 = shaders;
						curInstance = index1;
						if(compute) {
							++index1;
						}
						while(--index1 > 0) si1 = si1.next;
						curInstanceValue = si1.s;
						v1 = curInstanceValue;
					}
					v = v1.getParamValue(p.index);
					if(v == null) {
						throw haxe_Exception.thrown("Missing param value " + Std.string(curInstanceValue) + "." + p.name);
					}
				} else if(p.perObjectGlobal != null) {
					var v2 = _gthis.globals.map.h[p.perObjectGlobal.gid];
					if(v2 == null) {
						throw haxe_Exception.thrown("Missing global value " + p.perObjectGlobal.path + " for shader " + _gthis.shaderInfo(shaders,p.perObjectGlobal.path));
					}
					var _g = p.type;
					var v3;
					if(_g._hx_index == 17) {
						var _g1 = _g.size;
						v3 = true;
					} else {
						v3 = false;
					}
					v = v3 ? v2.texture : v2;
				} else {
					var index2 = p.instance;
					var v4;
					if(curInstance == index2) {
						v4 = curInstanceValue;
					} else {
						var si2 = shaders;
						curInstance = index2;
						if(compute) {
							++index2;
						}
						while(--index2 > 0) si2 = si2.next;
						curInstanceValue = si2.s;
						v4 = curInstanceValue;
					}
					var v5 = v4.getParamValue(p.index);
					if(v5 == null) {
						throw haxe_Exception.thrown("Missing param value " + Std.string(shaders.s) + "." + p.name);
					}
					v = v5;
				}
				_gthis.fillRec(v,p.type,ptr,p.pos);
				p = p.next;
			}
			var tid = 0;
			var p = s1.textures;
			while(p != null) {
				var opt = !h3d_impl_RenderContext.STRICT;
				if(opt == null) {
					opt = false;
				}
				var t;
				if(p.perObjectGlobal != null) {
					var v = _gthis.globals.map.h[p.perObjectGlobal.gid];
					if(v == null) {
						throw haxe_Exception.thrown("Missing global value " + p.perObjectGlobal.path + " for shader " + _gthis.shaderInfo(shaders,p.perObjectGlobal.path));
					}
					var _g = p.type;
					var t1;
					if(_g._hx_index == 17) {
						var _g1 = _g.size;
						t1 = true;
					} else {
						t1 = false;
					}
					t = t1 ? v.texture : v;
				} else {
					var index = p.instance;
					var v1;
					if(curInstance == index) {
						v1 = curInstanceValue;
					} else {
						var si = shaders;
						curInstance = index;
						if(compute) {
							++index;
						}
						while(--index > 0) si = si.next;
						curInstanceValue = si.s;
						v1 = curInstanceValue;
					}
					var v2 = v1.getParamValue(p.index);
					if(v2 == null && !opt) {
						throw haxe_Exception.thrown("Missing param value " + Std.string(shaders.s) + "." + p.name);
					}
					t = v2;
				}
				if(p.pos < 0) {
					var arr = t;
					var _g2 = 0;
					var _g3 = -p.pos;
					while(_g2 < _g3) {
						var i = _g2++;
						buf1.tex[tid++] = arr[i];
					}
				} else {
					buf1.tex[tid++] = t;
				}
				p = p.next;
			}
			var p = s1.buffers;
			var bid = 0;
			while(p != null) {
				var opt = !h3d_impl_RenderContext.STRICT;
				if(opt == null) {
					opt = false;
				}
				var b;
				if(p.perObjectGlobal != null) {
					var v = _gthis.globals.map.h[p.perObjectGlobal.gid];
					if(v == null) {
						throw haxe_Exception.thrown("Missing global value " + p.perObjectGlobal.path + " for shader " + _gthis.shaderInfo(shaders,p.perObjectGlobal.path));
					}
					var _g = p.type;
					var b1;
					if(_g._hx_index == 17) {
						var _g1 = _g.size;
						b1 = true;
					} else {
						b1 = false;
					}
					b = b1 ? v.texture : v;
				} else {
					var index = p.instance;
					var v1;
					if(curInstance == index) {
						v1 = curInstanceValue;
					} else {
						var si = shaders;
						curInstance = index;
						if(compute) {
							++index;
						}
						while(--index > 0) si = si.next;
						curInstanceValue = si.s;
						v1 = curInstanceValue;
					}
					var v2 = v1.getParamValue(p.index);
					if(v2 == null && !opt) {
						throw haxe_Exception.thrown("Missing param value " + Std.string(shaders.s) + "." + p.name);
					}
					b = v2;
				}
				buf1.buffers[bid++] = b;
				p = p.next;
			}
		}
	}
	,__class__: h3d_impl_RenderContext
};
var h2d_RenderContext = function(scene) {
	this.renderZoneIndex = 0;
	this.renderZoneStack = [];
	this.currentCamera = null;
	this.tmpBounds = new h2d_col_Bounds();
	this.defaultSmooth = false;
	this.globalAlpha = 1.;
	h3d_impl_RenderContext.call(this);
	this.scene = scene;
	this.bufPos = 0;
	this.output = new h3d_pass_OutputShader();
	this.pass = new h3d_mat_Pass("",null);
	this.pass.depth(true,h3d_mat_Compare.Always);
	this.pass.set_culling(h3d_mat_Face.None);
	this.baseShader = new h3d_shader_Base2d();
	this.baseShader.setPriority(100);
	this.baseShader.zValue__ = 0.;
	this.baseShaderList = new hxsl_ShaderList(this.baseShader);
	this.targetsStack = [];
	this.targetsStackIndex = 0;
	this.cameraStack = [];
	this.cameraStackIndex = 0;
	this.filterStack = [];
	this.filterStackIndex = 0;
};
$hxClasses["h2d.RenderContext"] = h2d_RenderContext;
h2d_RenderContext.__name__ = "h2d.RenderContext";
h2d_RenderContext.__super__ = h3d_impl_RenderContext;
h2d_RenderContext.prototype = $extend(h3d_impl_RenderContext.prototype,{
	dispose: function() {
		h3d_impl_RenderContext.prototype.dispose.call(this);
		if(this.fixedBuffer != null) {
			this.fixedBuffer.dispose();
		}
	}
	,hasBuffering: function() {
		return false;
	}
	,begin: function() {
		this.texture = null;
		this.currentObj = null;
		this.bufPos = 0;
		this.stride = 0;
		this.viewA = this.scene.viewportA;
		this.viewB = 0;
		this.viewC = 0;
		this.viewD = this.scene.viewportD;
		this.viewX = this.scene.viewportX;
		this.viewY = this.scene.viewportY;
		this.setCurrent();
		this.targetFlipY = this.engine.driver.hasFeature(h3d_impl_Feature.BottomLeftCoords) ? -1 : 1;
		this.baseFlipY = this.engine.getCurrentTarget() != null ? this.targetFlipY : 1;
		this.inFilter = null;
		this.globals.set("time",this.time);
		this.globals.set("global.time",this.time);
		var _this = this.baseShader;
		_this.constModified = true;
		_this.pixelAlign__ = false;
		var _this = this.baseShader.halfPixelInverse__;
		var x = 0.5 / this.engine.width;
		var y = 0.5 / this.engine.height;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = 0.;
		var _this = this.baseShader.viewportA__;
		var x = this.scene.viewportA;
		var y = 0;
		var z = this.scene.viewportX;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		var _this = this.baseShader.viewportB__;
		var x = 0;
		var y = this.scene.viewportD * -this.baseFlipY;
		var z = this.scene.viewportY * -this.baseFlipY;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		var _this = this.baseShader.filterMatrixA__;
		var x = 1;
		var y = 0;
		var z = 0;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		var _this = this.baseShader.filterMatrixB__;
		var x = 0;
		var y = 1;
		var z = 0;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		this.baseShaderList.next = null;
		this.initShaders(this.baseShaderList);
		this.engine.selectMaterial(this.pass);
		this.textures.begin();
	}
	,allocTarget: function(name,filter) {
		if(filter == null) {
			filter = false;
		}
		var t = this.textures.allocTarget(name,this.scene.width,this.scene.height,false);
		t.set_filter(filter ? h3d_mat_Filter.Linear : h3d_mat_Filter.Nearest);
		return t;
	}
	,clear: function(color) {
		this.engine.clear(color);
	}
	,initShaders: function(shaders) {
		this.needInitShaders = false;
		this.currentShaders = shaders;
		this.compiledShader = this.output.compileShaders(this.globals,shaders);
		var buffers = this.shaderBuffers;
		var s = this.compiledShader;
		buffers.vertex.grow(s.vertex);
		if(s.fragment != null) {
			buffers.fragment.grow(s.fragment);
		}
		this.fillGlobals(buffers,this.compiledShader);
		this.engine.selectShader(this.compiledShader);
		this.engine.uploadShaderBuffers(buffers,0);
	}
	,end: function() {
		this.texture = null;
		this.currentObj = null;
		this.baseShaderList.next = null;
		this.clearCurrent();
		if(this.targetsStackIndex != 0) {
			throw haxe_Exception.thrown("Missing popTarget()");
		}
		if(this.cameraStackIndex != 0) {
			throw haxe_Exception.thrown("Missing popCamera()");
		}
	}
	,pushCamera: function(cam) {
		var entry = this.cameraStack[this.cameraStackIndex++];
		if(entry == null) {
			entry = { va : 0, vb : 0, vc : 0, vd : 0, vx : 0, vy : 0, camera : null};
			this.cameraStack.push(entry);
		}
		var tmpA = this.viewA;
		var tmpB = this.viewB;
		var tmpC = this.viewC;
		var tmpD = this.viewD;
		entry.va = tmpA;
		entry.vb = tmpB;
		entry.vc = tmpC;
		entry.vd = tmpD;
		entry.vx = this.viewX;
		entry.vy = this.viewY;
		entry.camera = this.currentCamera;
		this.currentCamera = cam;
		this.viewA = cam.matA * tmpA + cam.matB * tmpC;
		this.viewB = cam.matA * tmpB + cam.matB * tmpD;
		this.viewC = cam.matC * tmpA + cam.matD * tmpC;
		this.viewD = cam.matC * tmpB + cam.matD * tmpD;
		this.viewX = cam.absX * tmpA + cam.absY * tmpC + this.viewX;
		this.viewY = cam.absX * tmpB + cam.absY * tmpD + this.viewY;
		var flipY = this.curTarget != null ? -this.targetFlipY : -this.baseFlipY;
		var _this = this.baseShader.viewportA__;
		var x = this.viewA;
		var y = this.viewC;
		var z = this.viewX;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		var _this = this.baseShader.viewportB__;
		var x = this.viewB * flipY;
		var y = this.viewD * flipY;
		var z = this.viewY * flipY;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
	}
	,popCamera: function() {
		if(this.cameraStackIndex == 0) {
			throw haxe_Exception.thrown("Too many popCamera()");
		}
		var inf = this.cameraStack[--this.cameraStackIndex];
		this.viewA = inf.va;
		this.viewB = inf.vb;
		this.viewC = inf.vc;
		this.viewD = inf.vd;
		this.viewX = inf.vx;
		this.viewY = inf.vy;
		this.currentCamera = inf.camera;
		inf.camera = null;
		var flipY = this.curTarget != null ? -this.targetFlipY : -this.baseFlipY;
		var _this = this.baseShader.viewportA__;
		var x = this.viewA;
		var y = this.viewC;
		var z = this.viewX;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		var _this = this.baseShader.viewportB__;
		var x = this.viewB * flipY;
		var y = this.viewD * flipY;
		var z = this.viewY * flipY;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
	}
	,pushFilter: function(spr) {
		if(this.filterStack.length == 0 && this.onEnterFilter != null) {
			if(!this.onEnterFilter(spr)) {
				return false;
			}
		}
		this.inFilter = this.filterStack[this.filterStackIndex++];
		if(this.inFilter == null) {
			this.inFilter = { spr : null, scaleX : 1, scaleY : 1};
			this.filterStack.push(this.inFilter);
		}
		this.inFilter.spr = spr;
		this.inFilter.scaleX = 1;
		this.inFilter.scaleY = 1;
		return true;
	}
	,setFilterScale: function(scaleX,scaleY) {
		if(this.inFilter != null) {
			this.inFilter.scaleX = scaleX;
			this.inFilter.scaleY = scaleY;
		}
	}
	,getFilterScale: function(into) {
		if(into == null) {
			into = new h2d_col_PointImpl(0.,0.);
		}
		if(this.inFilter != null) {
			var _this = into;
			var x = this.inFilter.scaleX;
			var y = this.inFilter.scaleY;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
		} else {
			var _this = into;
			var x = 1;
			var y = 1;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
		}
		return into;
	}
	,popFilter: function() {
		this.inFilter.spr = null;
		this.filterStackIndex--;
		if(this.filterStackIndex > 0) {
			this.inFilter = this.filterStack[this.filterStackIndex - 1];
		} else {
			this.inFilter = null;
			if(this.onLeaveFilter != null) {
				this.onLeaveFilter(this.filterStack[this.filterStackIndex].spr);
			}
		}
	}
	,pushTarget: function(t,startX,startY,width,height) {
		if(height == null) {
			height = -1;
		}
		if(width == null) {
			width = -1;
		}
		if(startY == null) {
			startY = 0;
		}
		if(startX == null) {
			startX = 0;
		}
		this.engine.pushTarget(t);
		this.initShaders(this.baseShaderList);
		var entry = this.targetsStack[this.targetsStackIndex++];
		if(entry == null) {
			entry = { t : null, va : 0, vb : 0, vc : 0, vd : 0, vx : 0, vy : 0, hasRZ : false, rzX : 0, rzY : 0, rzW : 0, rzH : 0};
			this.targetsStack.push(entry);
		}
		entry.t = this.curTarget;
		entry.va = this.viewA;
		entry.vb = this.viewB;
		entry.vc = this.viewC;
		entry.vd = this.viewD;
		entry.vx = this.viewX;
		entry.vy = this.viewY;
		entry.hasRZ = this.hasRenderZone;
		entry.rzX = this.renderX;
		entry.rzY = this.renderY;
		entry.rzW = this.renderW;
		entry.rzH = this.renderH;
		if(width < 0) {
			width = t == null ? this.scene.width : t.width;
		}
		if(height < 0) {
			height = t == null ? this.scene.height : t.height;
		}
		this.viewA = 2 / width;
		this.viewB = 0;
		this.viewC = 0;
		this.viewD = 2 / height;
		this.viewX = -1 - startX * this.viewA;
		this.viewY = -1 - startY * this.viewD;
		var _this = this.baseShader.halfPixelInverse__;
		var x = 0.5 / (t == null ? this.engine.width : t.width);
		var y = 0.5 / (t == null ? this.engine.height : t.height);
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = 0.;
		var _this = this.baseShader.viewportA__;
		var x = this.viewA;
		var y = this.viewC;
		var z = this.viewX;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		var _this = this.baseShader.viewportB__;
		var x = this.viewB * -this.targetFlipY;
		var y = this.viewD * -this.targetFlipY;
		var z = this.viewY * -this.targetFlipY;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		this.curTarget = t;
		this.currentBlend = null;
		if(this.hasRenderZone) {
			this.hasRenderZone = false;
			this.engine.setRenderZone();
		}
	}
	,pushTargets: function(texs) {
		this.pushTarget(texs[0]);
		if(texs.length > 1) {
			this.engine.popTarget();
			this.engine.pushTargets(texs);
		}
	}
	,popTarget: function() {
		if(this.targetsStackIndex <= 0) {
			throw haxe_Exception.thrown("Too many popTarget()");
		}
		this.engine.popTarget();
		var tinf = this.targetsStack[--this.targetsStackIndex];
		var t = this.curTarget = tinf.t;
		this.viewA = tinf.va;
		this.viewB = tinf.vb;
		this.viewC = tinf.vc;
		this.viewD = tinf.vd;
		this.viewX = tinf.vx;
		this.viewY = tinf.vy;
		var flipY = t == null ? -this.baseFlipY : -this.targetFlipY;
		this.initShaders(this.baseShaderList);
		var _this = this.baseShader.halfPixelInverse__;
		var x = 0.5 / (t == null ? this.engine.width : t.width);
		var y = 0.5 / (t == null ? this.engine.height : t.height);
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = 0.;
		var _this = this.baseShader.viewportA__;
		var x = this.viewA;
		var y = this.viewC;
		var z = this.viewX;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		var _this = this.baseShader.viewportB__;
		var x = this.viewB * flipY;
		var y = this.viewD * flipY;
		var z = this.viewY * flipY;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		if(tinf.hasRZ) {
			this.setRZ(tinf.rzX,tinf.rzY,tinf.rzW,tinf.rzH);
		}
	}
	,pushRenderZone: function(x,y,w,h) {
		var inf = this.renderZoneStack[this.renderZoneIndex++];
		if(inf == null) {
			inf = { hasRZ : this.hasRenderZone, x : this.renderX, y : this.renderY, w : this.renderW, h : this.renderH};
			this.renderZoneStack[this.renderZoneIndex - 1] = inf;
		} else if(this.hasRenderZone) {
			inf.hasRZ = true;
			inf.x = this.renderX;
			inf.y = this.renderY;
			inf.w = this.renderW;
			inf.h = this.renderH;
		} else {
			inf.hasRZ = false;
		}
		this.setRZ(x,y,w,h);
	}
	,popRenderZone: function() {
		if(this.renderZoneIndex == 0) {
			throw haxe_Exception.thrown("Too many popRenderZone()");
		}
		var inf = this.renderZoneStack[--this.renderZoneIndex];
		if(inf.hasRZ) {
			this.setRZ(inf.x,inf.y,inf.w,inf.h);
		} else {
			this.hasRenderZone = false;
			this.engine.setRenderZone();
		}
	}
	,getCurrentRenderZone: function(bounds) {
		if(!this.hasRenderZone) {
			return null;
		}
		if(bounds == null) {
			bounds = new h2d_col_Bounds();
		}
		var x = this.renderX;
		var y = this.renderY;
		bounds.xMin = x;
		bounds.yMin = y;
		bounds.xMax = x + this.renderW;
		bounds.yMax = y + this.renderH;
		return bounds;
	}
	,clipRenderZone: function(x,y,w,h) {
		if(!this.hasRenderZone) {
			this.pushRenderZone(x,y,w,h);
			return;
		}
		var x2 = Math.min(x + w,this.renderX + this.renderW);
		var y2 = Math.min(y + h,this.renderY + this.renderH);
		x = Math.max(x,this.renderX);
		y = Math.max(y,this.renderY);
		if(x2 < x) {
			x2 = x;
		}
		if(y2 < y) {
			y2 = y;
		}
		this.pushRenderZone(x,y,x2 - x,y2 - y);
	}
	,setRZ: function(x,y,w,h) {
		this.hasRenderZone = true;
		this.renderX = x;
		this.renderY = y;
		this.renderW = w;
		this.renderH = h;
		var scaleX = this.scene.viewportA * this.engine.width / 2;
		var scaleY = this.scene.viewportD * this.engine.height / 2;
		if(this.inFilter != null) {
			var fa = this.baseShader.filterMatrixA__;
			var fb = this.baseShader.filterMatrixB__;
			var x2 = x + w;
			var y2 = y + h;
			var rx1 = x * fa.x + y * fa.y + fa.z;
			var ry1 = x * fb.x + y * fb.y + fb.z;
			var rx2 = x2 * fa.x + y2 * fa.y + fa.z;
			var ry2 = x2 * fb.x + y2 * fb.y + fb.z;
			x = rx1;
			y = ry1;
			w = rx2 - rx1;
			h = ry2 - ry1;
		}
		this.engine.setRenderZone(x * scaleX + (this.scene.viewportX + 1) * (this.engine.width / 2) + 1e-10 | 0,y * scaleY + (this.scene.viewportY + 1) * (this.engine.height / 2) + 1e-10 | 0,w * scaleX + 1e-10 | 0,h * scaleY + 1e-10 | 0);
	}
	,clearRZ: function() {
		this.hasRenderZone = false;
		this.engine.setRenderZone();
	}
	,setRenderZone: function(x,y,w,h) {
		this.pushRenderZone(x,y,w,h);
	}
	,clearRenderZone: function() {
		this.popRenderZone();
	}
	,drawLayer: function(layer) {
		this.scene.drawLayer(this,layer);
	}
	,drawScene: function() {
		this.scene.drawRec(this);
	}
	,flush: function() {
	}
	,_flush: function() {
		if(this.bufPos == 0) {
			return;
		}
		this.beforeDraw();
		var nverts = this.bufPos / this.stride | 0;
		var tmp = new h3d_Buffer(nverts,hxd_BufferFormat.get_XY_UV_RGBA(),[h3d_BufferFlag.Dynamic]);
		tmp.uploadFloats(this.buffer,0,nverts);
		var _this = this.engine;
		_this.renderBuffer(tmp,_this.mem.getQuadIndexes(tmp.vertices),2,0,-1);
		tmp.dispose();
		this.bufPos = 0;
		this.texture = null;
	}
	,beforeDraw: function() {
		if(this.texture == null) {
			this.texture = h3d_mat_Texture.fromColor(16711935);
		}
		this.baseShader.texture__ = this.texture;
		this.texture.set_filter((this.currentObj.smooth == null ? this.defaultSmooth : this.currentObj.smooth) ? h3d_mat_Filter.Linear : h3d_mat_Filter.Nearest);
		this.texture.set_wrap(this.currentObj.tileWrap && (this.currentObj.filter == null || this.inFilter != null) ? h3d_mat_Wrap.Repeat : h3d_mat_Wrap.Clamp);
		var blend = this.currentObj.blendMode;
		if(this.inFilter != null && this.inFilter.spr == this.currentObj && blend == h2d_BlendMode.Erase) {
			blend = h2d_BlendMode.Add;
		}
		if(this.inFilterBlend != null) {
			blend = this.inFilterBlend;
		}
		if(blend != this.currentBlend) {
			this.currentBlend = blend;
			this.pass.setBlendMode(blend);
			if(blend == h2d_BlendMode.Alpha || blend == h2d_BlendMode.Add) {
				this.pass.set_blendAlphaSrc(h3d_mat_Blend.One);
				if(this.inFilterBlend != null) {
					this.pass.set_blendSrc(h3d_mat_Blend.One);
				}
			}
		}
		var buffers = this.shaderBuffers;
		this.fillParams(buffers,this.compiledShader,this.currentShaders);
		this.engine.selectMaterial(this.pass);
		this.engine.uploadShaderBuffers(buffers,1);
		this.engine.uploadShaderBuffers(buffers,2);
		this.engine.uploadShaderBuffers(buffers,3);
	}
	,setupColor: function(obj) {
		if(this.inFilter != null && this.inFilter.spr == obj) {
			var _this = this.baseShader.color__;
			var x = obj.color.x;
			var y = obj.color.y;
			var z = obj.color.z;
			var w = obj.color.w;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = w;
		} else if(this.inFilterBlend != null) {
			var _this = this.baseShader.color__;
			var x = this.globalAlpha;
			var y = this.globalAlpha;
			var z = this.globalAlpha;
			var w = this.globalAlpha;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = w;
		} else {
			var _this = this.baseShader.color__;
			var x = obj.color.x;
			var y = obj.color.y;
			var z = obj.color.z;
			var w = obj.color.w * this.globalAlpha;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = w;
		}
	}
	,beginDrawBatchState: function(obj) {
		if(!this.beginDraw(obj,null,true)) {
			return false;
		}
		if(this.inFilter != null && this.inFilter.spr == obj) {
			var _this = this.baseShader.color__;
			var x = obj.color.x;
			var y = obj.color.y;
			var z = obj.color.z;
			var w = obj.color.w;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = w;
		} else if(this.inFilterBlend != null) {
			var _this = this.baseShader.color__;
			var x = this.globalAlpha;
			var y = this.globalAlpha;
			var z = this.globalAlpha;
			var w = this.globalAlpha;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = w;
		} else {
			var _this = this.baseShader.color__;
			var x = obj.color.x;
			var y = obj.color.y;
			var z = obj.color.z;
			var w = obj.color.w * this.globalAlpha;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = w;
		}
		var _this = this.baseShader.absoluteMatrixA__;
		var x = obj.matA;
		var y = obj.matC;
		var z = obj.absX;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		var _this = this.baseShader.absoluteMatrixB__;
		var x = obj.matB;
		var y = obj.matD;
		var z = obj.absY;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		return true;
	}
	,swapTexture: function(texture) {
		this.texture = texture;
		this.beforeDraw();
	}
	,beginDrawObject: function(obj,texture) {
		if(!this.beginDraw(obj,texture,true)) {
			return false;
		}
		if(this.inFilter != null && this.inFilter.spr == obj) {
			var _this = this.baseShader.color__;
			var x = obj.color.x;
			var y = obj.color.y;
			var z = obj.color.z;
			var w = obj.color.w;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = w;
		} else if(this.inFilterBlend != null) {
			var _this = this.baseShader.color__;
			var x = this.globalAlpha;
			var y = this.globalAlpha;
			var z = this.globalAlpha;
			var w = this.globalAlpha;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = w;
		} else {
			var _this = this.baseShader.color__;
			var x = obj.color.x;
			var y = obj.color.y;
			var z = obj.color.z;
			var w = obj.color.w * this.globalAlpha;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = w;
		}
		var _this = this.baseShader.absoluteMatrixA__;
		var x = obj.matA;
		var y = obj.matC;
		var z = obj.absX;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		var _this = this.baseShader.absoluteMatrixB__;
		var x = obj.matB;
		var y = obj.matD;
		var z = obj.absY;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		this.beforeDraw();
		return true;
	}
	,beginDrawBatch: function(obj,texture) {
		return this.beginDraw(obj,texture,false);
	}
	,drawTile: function(obj,tile) {
		var matA;
		var matB;
		var matC;
		var matD;
		var absX;
		var absY;
		if(this.inFilter != null) {
			var f1 = this.baseShader.filterMatrixA__;
			var f2 = this.baseShader.filterMatrixB__;
			var tmpA = obj.matA * f1.x + obj.matB * f1.y;
			var tmpB = obj.matA * f2.x + obj.matB * f2.y;
			var tmpC = obj.matC * f1.x + obj.matD * f1.y;
			var tmpD = obj.matC * f2.x + obj.matD * f2.y;
			var tmpX = obj.absX * f1.x + obj.absY * f1.y + f1.z;
			var tmpY = obj.absX * f2.x + obj.absY * f2.y + f2.z;
			matA = tmpA * this.viewA + tmpB * this.viewC;
			matB = tmpA * this.viewB + tmpB * this.viewD;
			matC = tmpC * this.viewA + tmpD * this.viewC;
			matD = tmpC * this.viewB + tmpD * this.viewD;
			absX = tmpX * this.viewA + tmpY * this.viewC + this.viewX;
			absY = tmpX * this.viewB + tmpY * this.viewD + this.viewY;
		} else {
			matA = obj.matA * this.viewA + obj.matB * this.viewC;
			matB = obj.matA * this.viewB + obj.matB * this.viewD;
			matC = obj.matC * this.viewA + obj.matD * this.viewC;
			matD = obj.matC * this.viewB + obj.matD * this.viewD;
			absX = obj.absX * this.viewA + obj.absY * this.viewC + this.viewX;
			absY = obj.absX * this.viewB + obj.absY * this.viewD + this.viewY;
		}
		if(matB == 0 && matC == 0) {
			var tx = tile.dx + tile.width * 0.5;
			var ty = tile.dy + tile.height * 0.5;
			var a = matA < 0 ? -matA : matA;
			var b = matD < 0 ? -matD : matD;
			var tr = (tile.width > tile.height ? tile.width : tile.height) * 1.5 * (a < b ? b : a);
			var cx = absX + tx * matA;
			var cy = absY + ty * matD;
			if(cx + tr < -1 || cx - tr > 1 || cy + tr < -1 || cy - tr > 1) {
				return false;
			}
		} else {
			var xMin = 1e20;
			var yMin = 1e20;
			var xMax = -1e20;
			var yMax = -1e20;
			var hw = tile.width * 0.5;
			var hh = tile.height * 0.5;
			var px = tile.dx * matA + tile.dy * matC;
			var py = tile.dx * matB + tile.dy * matD;
			if(px < xMin) {
				xMin = px;
			}
			if(px > xMax) {
				xMax = px;
			}
			if(py < yMin) {
				yMin = py;
			}
			if(py > yMax) {
				yMax = py;
			}
			var x = tile.width;
			var px = (x + tile.dx) * matA + tile.dy * matC;
			var py = (x + tile.dx) * matB + tile.dy * matD;
			if(px < xMin) {
				xMin = px;
			}
			if(px > xMax) {
				xMax = px;
			}
			if(py < yMin) {
				yMin = py;
			}
			if(py > yMax) {
				yMax = py;
			}
			var y = tile.height;
			var px = tile.dx * matA + (y + tile.dy) * matC;
			var py = tile.dx * matB + (y + tile.dy) * matD;
			if(px < xMin) {
				xMin = px;
			}
			if(px > xMax) {
				xMax = px;
			}
			if(py < yMin) {
				yMin = py;
			}
			if(py > yMax) {
				yMax = py;
			}
			var x = tile.width;
			var y = tile.height;
			var px = (x + tile.dx) * matA + (y + tile.dy) * matC;
			var py = (x + tile.dx) * matB + (y + tile.dy) * matD;
			if(px < xMin) {
				xMin = px;
			}
			if(px > xMax) {
				xMax = px;
			}
			if(py < yMin) {
				yMin = py;
			}
			if(py > yMax) {
				yMax = py;
			}
			if(absX + xMax < -1 || absY + yMax < -1 || absX + xMin > 1 || absY + yMin > 1) {
				return false;
			}
		}
		if(!this.beginDraw(obj,tile.innerTex,true,true)) {
			return false;
		}
		if(this.inFilter != null && this.inFilter.spr == obj) {
			var _this = this.baseShader.color__;
			var x = obj.color.x;
			var y = obj.color.y;
			var z = obj.color.z;
			var w = obj.color.w;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = w;
		} else if(this.inFilterBlend != null) {
			var _this = this.baseShader.color__;
			var x = this.globalAlpha;
			var y = this.globalAlpha;
			var z = this.globalAlpha;
			var w = this.globalAlpha;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = w;
		} else {
			var _this = this.baseShader.color__;
			var x = obj.color.x;
			var y = obj.color.y;
			var z = obj.color.z;
			var w = obj.color.w * this.globalAlpha;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = w;
		}
		var _this = this.baseShader.absoluteMatrixA__;
		var x = tile.width * obj.matA;
		var y = tile.height * obj.matC;
		var z = obj.absX + tile.dx * obj.matA + tile.dy * obj.matC;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		var _this = this.baseShader.absoluteMatrixB__;
		var x = tile.width * obj.matB;
		var y = tile.height * obj.matD;
		var z = obj.absY + tile.dx * obj.matB + tile.dy * obj.matD;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		var _this = this.baseShader.uvPos__;
		var x = tile.u;
		var y = tile.v;
		var z = tile.u2 - tile.u;
		var w = tile.v2 - tile.v;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		_this.w = w;
		this.beforeDraw();
		if(this.fixedBuffer == null || this.fixedBuffer.vbuf == null) {
			this.fixedBuffer = new h3d_Buffer(4,hxd_BufferFormat.get_XY_UV_RGBA());
			var k = hxd__$FloatBuffer_Float32Expand._new(0);
			var v = 0;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 0;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 0;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 0;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 0;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 0;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 0;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 0;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			this.fixedBuffer.uploadFloats(k,0,4);
		}
		var _this = this.engine;
		var b = this.fixedBuffer;
		_this.renderBuffer(b,_this.mem.getQuadIndexes(b.vertices),2,0,-1);
		return true;
	}
	,beginDraw: function(obj,texture,isRelative,hasUVPos) {
		if(hasUVPos == null) {
			hasUVPos = false;
		}
		if(this.onBeginDraw != null && !this.onBeginDraw(obj)) {
			return false;
		}
		var stride = 8;
		var shaderChanged = this.needInitShaders;
		var paramsChanged = false;
		var objShaders = obj.shaders;
		var curShaders = this.currentShaders.next;
		while(objShaders != null && curShaders != null) {
			var s = objShaders.s;
			var t = curShaders.s;
			objShaders = objShaders.next;
			curShaders = curShaders.next;
			var prevInst = t.instance;
			if(s != t) {
				paramsChanged = true;
			}
			s.updateConstants(this.globals);
			if(s.instance != prevInst) {
				shaderChanged = true;
			}
		}
		if(objShaders != null || curShaders != null || this.baseShader.isRelative__ != isRelative || this.baseShader.hasUVPos__ != hasUVPos || this.baseShader.killAlpha__ != this.killAlpha) {
			shaderChanged = true;
		}
		if(shaderChanged) {
			var _this = this.baseShader;
			_this.constModified = true;
			_this.hasUVPos__ = hasUVPos;
			var _this = this.baseShader;
			_this.constModified = true;
			_this.isRelative__ = isRelative;
			var _this = this.baseShader;
			_this.constModified = true;
			_this.killAlpha__ = this.killAlpha;
			this.baseShader.updateConstants(this.globals);
			this.baseShaderList.next = obj.shaders;
			this.initShaders(this.baseShaderList);
		} else if(paramsChanged) {
			if(this.currentShaders != this.baseShaderList) {
				throw haxe_Exception.thrown("!");
			}
			this.currentShaders.next = obj.shaders;
		}
		this.texture = texture;
		this.stride = stride;
		this.currentObj = obj;
		return true;
	}
	,setCurrent: function() {
		h3d_impl_RenderContext.prototype.setCurrent.call(this);
		this.needInitShaders = true;
	}
	,__class__: h2d_RenderContext
});
var h2d_ScaleModeAlign = $hxEnums["h2d.ScaleModeAlign"] = { __ename__:true,__constructs__:null
	,Left: {_hx_name:"Left",_hx_index:0,__enum__:"h2d.ScaleModeAlign",toString:$estr}
	,Right: {_hx_name:"Right",_hx_index:1,__enum__:"h2d.ScaleModeAlign",toString:$estr}
	,Center: {_hx_name:"Center",_hx_index:2,__enum__:"h2d.ScaleModeAlign",toString:$estr}
	,Top: {_hx_name:"Top",_hx_index:3,__enum__:"h2d.ScaleModeAlign",toString:$estr}
	,Bottom: {_hx_name:"Bottom",_hx_index:4,__enum__:"h2d.ScaleModeAlign",toString:$estr}
};
h2d_ScaleModeAlign.__constructs__ = [h2d_ScaleModeAlign.Left,h2d_ScaleModeAlign.Right,h2d_ScaleModeAlign.Center,h2d_ScaleModeAlign.Top,h2d_ScaleModeAlign.Bottom];
h2d_ScaleModeAlign.__empty_constructs__ = [h2d_ScaleModeAlign.Left,h2d_ScaleModeAlign.Right,h2d_ScaleModeAlign.Center,h2d_ScaleModeAlign.Top,h2d_ScaleModeAlign.Bottom];
var h2d_ScaleMode = $hxEnums["h2d.ScaleMode"] = { __ename__:true,__constructs__:null
	,Resize: {_hx_name:"Resize",_hx_index:0,__enum__:"h2d.ScaleMode",toString:$estr}
	,Stretch: ($_=function(width,height) { return {_hx_index:1,width:width,height:height,__enum__:"h2d.ScaleMode",toString:$estr}; },$_._hx_name="Stretch",$_.__params__ = ["width","height"],$_)
	,LetterBox: ($_=function(width,height,integerScale,horizontalAlign,verticalAlign) { return {_hx_index:2,width:width,height:height,integerScale:integerScale,horizontalAlign:horizontalAlign,verticalAlign:verticalAlign,__enum__:"h2d.ScaleMode",toString:$estr}; },$_._hx_name="LetterBox",$_.__params__ = ["width","height","integerScale","horizontalAlign","verticalAlign"],$_)
	,Fixed: ($_=function(width,height,zoom,horizontalAlign,verticalAlign) { return {_hx_index:3,width:width,height:height,zoom:zoom,horizontalAlign:horizontalAlign,verticalAlign:verticalAlign,__enum__:"h2d.ScaleMode",toString:$estr}; },$_._hx_name="Fixed",$_.__params__ = ["width","height","zoom","horizontalAlign","verticalAlign"],$_)
	,Zoom: ($_=function(level) { return {_hx_index:4,level:level,__enum__:"h2d.ScaleMode",toString:$estr}; },$_._hx_name="Zoom",$_.__params__ = ["level"],$_)
	,AutoZoom: ($_=function(minWidth,minHeight,integerScaling) { return {_hx_index:5,minWidth:minWidth,minHeight:minHeight,integerScaling:integerScaling,__enum__:"h2d.ScaleMode",toString:$estr}; },$_._hx_name="AutoZoom",$_.__params__ = ["minWidth","minHeight","integerScaling"],$_)
};
h2d_ScaleMode.__constructs__ = [h2d_ScaleMode.Resize,h2d_ScaleMode.Stretch,h2d_ScaleMode.LetterBox,h2d_ScaleMode.Fixed,h2d_ScaleMode.Zoom,h2d_ScaleMode.AutoZoom];
h2d_ScaleMode.__empty_constructs__ = [h2d_ScaleMode.Resize];
var h2d_Align = $hxEnums["h2d.Align"] = { __ename__:true,__constructs__:null
	,Left: {_hx_name:"Left",_hx_index:0,__enum__:"h2d.Align",toString:$estr}
	,Right: {_hx_name:"Right",_hx_index:1,__enum__:"h2d.Align",toString:$estr}
	,Center: {_hx_name:"Center",_hx_index:2,__enum__:"h2d.Align",toString:$estr}
	,MultilineRight: {_hx_name:"MultilineRight",_hx_index:3,__enum__:"h2d.Align",toString:$estr}
	,MultilineCenter: {_hx_name:"MultilineCenter",_hx_index:4,__enum__:"h2d.Align",toString:$estr}
};
h2d_Align.__constructs__ = [h2d_Align.Left,h2d_Align.Right,h2d_Align.Center,h2d_Align.MultilineRight,h2d_Align.MultilineCenter];
h2d_Align.__empty_constructs__ = [h2d_Align.Left,h2d_Align.Right,h2d_Align.Center,h2d_Align.MultilineRight,h2d_Align.MultilineCenter];
var h2d_Text = function(font,parent) {
	this.realMaxWidth = -1;
	this.constraintWidth = -1;
	this.lineBreak = true;
	this.lineSpacing = 0;
	this.letterSpacing = 0;
	h2d_Drawable.call(this,parent);
	this.set_font(font);
	this.set_textAlign(h2d_Align.Left);
	this.set_text("");
	this.currentText = "";
	this.set_textColor(16777215);
};
$hxClasses["h2d.Text"] = h2d_Text;
h2d_Text.__name__ = "h2d.Text";
h2d_Text.__super__ = h2d_Drawable;
h2d_Text.prototype = $extend(h2d_Drawable.prototype,{
	set_font: function(font) {
		if(this.font == font) {
			return font;
		}
		this.font = font;
		if(font != null) {
			var _g = font.type;
			switch(_g._hx_index) {
			case 0:
				if(this.sdfShader != null) {
					this.removeShader(this.sdfShader);
					this.sdfShader = null;
				}
				break;
			case 1:
				var channel = _g.channel;
				var alphaCutoff = _g.alphaCutoff;
				var smoothing = _g.smoothing;
				if(this.sdfShader == null) {
					this.sdfShader = new h3d_shader_SignedDistanceField();
					this.addShader(this.sdfShader);
				}
				if(this.smooth == null) {
					this.smooth = true;
				}
				this.sdfShader.alphaCutoff__ = alphaCutoff;
				this.sdfShader.smoothing__ = smoothing;
				var _this = this.sdfShader;
				_this.constModified = true;
				_this.channel__ = channel;
				var _this = this.sdfShader;
				_this.constModified = true;
				_this.autoSmoothing__ = smoothing == -1;
				break;
			}
		}
		if(this.glyphs != null) {
			var _this = this.glyphs;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
		}
		this.glyphs = new h2d_TileGroup(font == null ? null : font.tile,this);
		this.glyphs.set_visible(false);
		this.rebuild();
		return font;
	}
	,set_textAlign: function(a) {
		if(this.textAlign == a) {
			return a;
		}
		this.textAlign = a;
		this.rebuild();
		return a;
	}
	,set_letterSpacing: function(s) {
		if(this.letterSpacing == s) {
			return s;
		}
		this.letterSpacing = s;
		this.rebuild();
		return s;
	}
	,set_lineSpacing: function(s) {
		if(this.lineSpacing == s) {
			return s;
		}
		this.lineSpacing = s;
		this.rebuild();
		return s;
	}
	,set_lineBreak: function(b) {
		if(this.lineBreak == b) {
			return b;
		}
		this.lineBreak = b;
		this.rebuild();
		return b;
	}
	,constraintSize: function(width,height) {
		this.constraintWidth = width;
		this.updateConstraint();
	}
	,onAdd: function() {
		h2d_Drawable.prototype.onAdd.call(this);
		this.rebuild();
	}
	,checkText: function() {
		if(this.textChanged && this.text != this.currentText) {
			this.textChanged = false;
			this.currentText = this.text;
			this.calcDone = false;
			this.needsRebuild = true;
		}
	}
	,sync: function(ctx) {
		h2d_Drawable.prototype.sync.call(this,ctx);
		if(this.textChanged && this.text != this.currentText) {
			this.textChanged = false;
			this.currentText = this.text;
			this.calcDone = false;
			this.needsRebuild = true;
		}
		if(this.needsRebuild) {
			this.initGlyphs(this.currentText);
		}
	}
	,draw: function(ctx) {
		if(this.glyphs == null) {
			this.emitTile(ctx,h2d_Tile.fromColor(16711935,16,16));
			return;
		}
		if(this.textChanged && this.text != this.currentText) {
			this.textChanged = false;
			this.currentText = this.text;
			this.calcDone = false;
			this.needsRebuild = true;
		}
		if(this.needsRebuild) {
			this.initGlyphs(this.currentText);
		}
		if(this.dropShadow != null) {
			var oldX = this.absX;
			var oldY = this.absY;
			this.absX += this.dropShadow.dx * this.matA + this.dropShadow.dy * this.matC;
			this.absY += this.dropShadow.dx * this.matB + this.dropShadow.dy * this.matD;
			var oldR = this.color.x;
			var oldG = this.color.y;
			var oldB = this.color.z;
			var oldA = this.color.w;
			var _this = this.color;
			var c = this.dropShadow.color;
			_this.x = (c >> 16 & 255) / 255;
			_this.y = (c >> 8 & 255) / 255;
			_this.z = (c & 255) / 255;
			_this.w = (c >>> 24) / 255;
			this.color.w = this.dropShadow.alpha * oldA;
			this.glyphs.drawWith(ctx,this);
			this.absX = oldX;
			this.absY = oldY;
			var _this = this.color;
			var x = oldR;
			var y = oldG;
			var z = oldB;
			var w = oldA;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = w;
		}
		this.glyphs.drawWith(ctx,this);
	}
	,set_text: function(t) {
		var t1 = t == null ? "null" : t;
		if(t1 == this.text) {
			return t1;
		}
		this.text = t1;
		this.textChanged = true;
		this.validateText();
		if(this.parentContainer != null) {
			this.parentContainer.contentChanged(this);
		}
		return t1;
	}
	,validateText: function() {
	}
	,rebuild: function() {
		this.calcDone = false;
		this.needsRebuild = true;
		if(this.parentContainer != null) {
			this.parentContainer.contentChanged(this);
		}
	}
	,calcTextWidth: function(text) {
		if(this.calcDone) {
			var ow = this.calcWidth;
			var oh = this.calcHeight;
			var osh = this.calcSizeHeight;
			var ox = this.calcXMin;
			var oy = this.calcYMin;
			this.initGlyphs(text,false);
			var w = this.calcWidth;
			this.calcWidth = ow;
			this.calcHeight = oh;
			this.calcSizeHeight = osh;
			this.calcXMin = ox;
			this.calcYMin = oy;
			return w;
		} else {
			this.initGlyphs(text,false);
			this.calcDone = false;
			return this.calcWidth;
		}
	}
	,splitText: function(text) {
		return this.splitRawText(text,0,0);
	}
	,splitRawText: function(text,leftMargin,afterData,font,sizes,prevChar) {
		if(prevChar == null) {
			prevChar = -1;
		}
		if(afterData == null) {
			afterData = 0.;
		}
		if(leftMargin == null) {
			leftMargin = 0.;
		}
		var maxWidth = this.realMaxWidth;
		if(maxWidth < 0) {
			if(sizes == null) {
				return text;
			} else {
				maxWidth = Infinity;
			}
		}
		if(font == null) {
			font = this.font;
		}
		var lines = [];
		var restPos = 0;
		var x = leftMargin;
		var wLastSep = 0.;
		var _g = 0;
		var _g1 = text.length;
		while(_g < _g1) {
			var i = _g++;
			var cc = text.charCodeAt(i);
			var c = font.glyphs.h[cc];
			if(c == null) {
				c = font.charset.resolveChar(cc,font.glyphs);
				if(c == null) {
					c = cc == 13 || cc == 10 ? font.nullChar : font.defaultChar;
				}
			}
			var e = c;
			var newline = cc == 10;
			var esize = e.width + e.getKerningOffset(prevChar);
			var isComplement = i < text.length - 1 && font.charset.isComplementChar(text.charCodeAt(i + 1));
			if(font.charset.isBreakChar(cc) && !isComplement) {
				if(lines.length == 0 && leftMargin > 0 && x > maxWidth) {
					lines.push("");
					if(sizes != null) {
						sizes.push(leftMargin);
					}
					x -= leftMargin;
				}
				var size = x + esize + this.letterSpacing;
				var k = i + 1;
				var max = text.length;
				var prevChar1 = cc;
				var breakFound = false;
				while(size <= maxWidth && k < max) {
					var cc1 = text.charCodeAt(k++);
					if(this.lineBreak && (font.charset.isSpace(cc1) || cc1 == 10)) {
						breakFound = true;
						break;
					}
					var c1 = font.glyphs.h[cc1];
					if(c1 == null) {
						c1 = font.charset.resolveChar(cc1,font.glyphs);
						if(c1 == null) {
							c1 = cc1 == 13 || cc1 == 10 ? font.nullChar : font.defaultChar;
						}
					}
					var e1 = c1;
					size += e1.width + this.letterSpacing + e1.getKerningOffset(prevChar1);
					prevChar1 = cc1;
					if(font.charset.isBreakChar(cc1)) {
						if(k >= text.length) {
							break;
						}
						var nc = text.charCodeAt(k);
						if(!font.charset.isComplementChar(nc)) {
							break;
						}
					}
				}
				if(this.lineBreak && (size > maxWidth || !breakFound && size + afterData > maxWidth)) {
					newline = true;
					if(font.charset.isSpace(cc)) {
						lines.push(HxOverrides.substr(text,restPos,i - restPos));
						e = null;
					} else {
						lines.push(HxOverrides.substr(text,restPos,i + 1 - restPos));
					}
					restPos = i + 1;
				} else {
					wLastSep = size;
				}
			} else if(x + esize + this.letterSpacing - wLastSep > maxWidth) {
				newline = true;
				lines.push(HxOverrides.substr(text,restPos,i - restPos));
				restPos = i + 1;
			}
			if(e != null && cc != 10) {
				x += esize + this.letterSpacing;
			}
			if(newline) {
				if(sizes != null) {
					sizes.push(x);
				}
				x = 0;
				wLastSep = 0.;
				prevChar = -1;
			} else {
				prevChar = cc;
			}
		}
		if(restPos < text.length) {
			if(lines.length == 0 && leftMargin > 0 && x + afterData - this.letterSpacing > maxWidth) {
				lines.push("");
				if(sizes != null) {
					sizes.push(leftMargin);
				}
				x -= leftMargin;
			}
			lines.push(HxOverrides.substr(text,restPos,text.length - restPos));
			if(sizes != null) {
				sizes.push(x);
			}
		}
		return lines.join("\n");
	}
	,getTextProgress: function(text,progress) {
		if(progress >= text.length) {
			return text;
		}
		return HxOverrides.substr(text,0,progress | 0);
	}
	,initGlyphs: function(text,rebuild) {
		if(rebuild == null) {
			rebuild = true;
		}
		if(rebuild) {
			this.glyphs.clear();
		}
		var x = 0.;
		var y = 0.;
		var xMax = 0.;
		var xMin = 0.;
		var yMin = 0.;
		var yMax = 0.;
		var prevChar = -1;
		var linei = 0;
		var align = this.textAlign;
		var lines = [];
		var dl = this.font.lineHeight + this.lineSpacing;
		var t = this.splitRawText(text,0,0,null,lines);
		var _g = 0;
		while(_g < lines.length) {
			var lw = lines[_g];
			++_g;
			if(lw > x) {
				x = lw;
			}
		}
		this.calcWidth = x;
		switch(align._hx_index) {
		case 0:
			x = 0;
			break;
		case 1:case 2:case 3:case 4:
			var max = align == h2d_Align.MultilineCenter || align == h2d_Align.MultilineRight ? Math.ceil(this.calcWidth) : this.realMaxWidth < 0 ? 0 : Math.ceil(this.realMaxWidth);
			var k = align == h2d_Align.Center || align == h2d_Align.MultilineCenter ? 0.5 : 1;
			var _g = 0;
			var _g1 = lines.length;
			while(_g < _g1) {
				var i = _g++;
				lines[i] = Math.floor((max - lines[i]) * k);
			}
			x = lines[0];
			xMin = x;
			break;
		}
		var _g = 0;
		var _g1 = t.length;
		while(_g < _g1) {
			var i = _g++;
			var cc = t.charCodeAt(i);
			var _this = this.font;
			var c = _this.glyphs.h[cc];
			if(c == null) {
				c = _this.charset.resolveChar(cc,_this.glyphs);
				if(c == null) {
					c = cc == 13 || cc == 10 ? _this.nullChar : _this.defaultChar;
				}
			}
			var e = c;
			var offs = e.getKerningOffset(prevChar);
			var esize = e.width + offs;
			if(cc == 10) {
				if(x > xMax) {
					xMax = x;
				}
				switch(align._hx_index) {
				case 0:
					x = 0;
					break;
				case 1:case 2:case 3:case 4:
					x = lines[++linei];
					if(x < xMin) {
						xMin = x;
					}
					break;
				}
				y += dl;
				prevChar = -1;
			} else {
				if(e != null) {
					if(rebuild) {
						var _this1 = this.glyphs;
						_this1.content.add(x + offs,y,_this1.curColor.x,_this1.curColor.y,_this1.curColor.z,_this1.curColor.w,e.t);
					}
					if(y == 0 && e.t.dy < yMin) {
						yMin = e.t.dy;
					}
					var ty = y + e.t.dy + e.t.height;
					if(ty > yMax) {
						yMax = ty;
					}
					x += esize + this.letterSpacing;
				}
				prevChar = cc;
			}
		}
		if(x > xMax) {
			xMax = x;
		}
		this.calcXMin = xMin;
		this.calcYMin = yMin;
		this.calcWidth = xMax - xMin;
		this.calcHeight = yMax - yMin;
		this.calcSizeHeight = y + (this.font.baseLine > 0 ? this.font.baseLine : this.font.lineHeight);
		this.calcDone = true;
		if(rebuild) {
			this.needsRebuild = false;
		}
	}
	,updateSize: function() {
		if(this.textChanged && this.text != this.currentText) {
			this.textChanged = false;
			this.currentText = this.text;
			this.calcDone = false;
			this.needsRebuild = true;
		}
		if(!this.calcDone) {
			this.initGlyphs(this.text,this.needsRebuild);
		}
	}
	,get_textHeight: function() {
		if(this.textChanged && this.text != this.currentText) {
			this.textChanged = false;
			this.currentText = this.text;
			this.calcDone = false;
			this.needsRebuild = true;
		}
		if(!this.calcDone) {
			this.initGlyphs(this.text,this.needsRebuild);
		}
		if(this.font.baseLine == 0) {
			return this.calcSizeHeight;
		} else {
			return this.calcSizeHeight - this.font.baseLine + this.font.lineHeight;
		}
	}
	,get_textWidth: function() {
		if(this.textChanged && this.text != this.currentText) {
			this.textChanged = false;
			this.currentText = this.text;
			this.calcDone = false;
			this.needsRebuild = true;
		}
		if(!this.calcDone) {
			this.initGlyphs(this.text,this.needsRebuild);
		}
		return this.calcWidth;
	}
	,set_maxWidth: function(w) {
		if(this.maxWidth == w) {
			return w;
		}
		this.maxWidth = w;
		this.updateConstraint();
		return w;
	}
	,updateConstraint: function() {
		var old = this.realMaxWidth;
		if(this.maxWidth == null) {
			this.realMaxWidth = this.constraintWidth;
		} else if(this.constraintWidth < 0) {
			this.realMaxWidth = this.maxWidth;
		} else {
			var a = this.maxWidth;
			var b = this.constraintWidth;
			this.realMaxWidth = a > b ? b : a;
		}
		if(this.realMaxWidth != old) {
			this.rebuild();
		}
	}
	,set_textColor: function(c) {
		if(this.textColor == c) {
			return c;
		}
		this.textColor = c;
		var a = this.color.w;
		var _this = this.color;
		_this.x = (c >> 16 & 255) / 255;
		_this.y = (c >> 8 & 255) / 255;
		_this.z = (c & 255) / 255;
		_this.w = (c >>> 24) / 255;
		this.color.w = a;
		return c;
	}
	,getBoundsRec: function(relativeTo,out,forSize) {
		h2d_Drawable.prototype.getBoundsRec.call(this,relativeTo,out,forSize);
		if(this.textChanged && this.text != this.currentText) {
			this.textChanged = false;
			this.currentText = this.text;
			this.calcDone = false;
			this.needsRebuild = true;
		}
		if(!this.calcDone) {
			this.initGlyphs(this.text,this.needsRebuild);
		}
		var x;
		var y;
		var w;
		var h;
		if(forSize) {
			x = this.calcXMin;
			y = 0.;
			w = this.calcWidth;
			h = this.calcSizeHeight;
		} else {
			x = this.calcXMin;
			y = this.calcYMin;
			w = this.calcWidth;
			h = this.calcHeight;
		}
		this.addBounds(relativeTo,out,x,y,w,h);
	}
	,__class__: h2d_Text
});
var h2d_Tile = function(tex,x,y,w,h,dx,dy) {
	if(dy == null) {
		dy = 0;
	}
	if(dx == null) {
		dx = 0;
	}
	this.innerTex = tex;
	this.x = x;
	this.y = y;
	this.width = w;
	this.height = h;
	this.dx = dx;
	this.dy = dy;
	if(tex != null) {
		this.setTexture(tex);
	}
};
$hxClasses["h2d.Tile"] = h2d_Tile;
h2d_Tile.__name__ = "h2d.Tile";
h2d_Tile.fromColor = function(color,width,height,alpha) {
	if(alpha == null) {
		alpha = 1.;
	}
	if(height == null) {
		height = 1;
	}
	if(width == null) {
		width = 1;
	}
	var t = new h2d_Tile(h3d_mat_Texture.fromColor(color,alpha),0,0,1,1);
	t.width = width;
	t.height = height;
	return t;
};
h2d_Tile.fromBitmap = function(bmp) {
	var tex = h3d_mat_Texture.fromBitmap(bmp);
	return new h2d_Tile(tex,0,0,bmp.ctx.canvas.width,bmp.ctx.canvas.height);
};
h2d_Tile.autoCut = function(bmp,width,height) {
	bmp.lock();
	if(height == null) {
		height = width;
	}
	var colorBG = bmp.getPixel(bmp.ctx.canvas.width - 1,bmp.ctx.canvas.height - 1);
	var tl = [];
	var w = 1;
	var h = 1;
	while(w < bmp.ctx.canvas.width) w <<= 1;
	while(h < bmp.ctx.canvas.height) h <<= 1;
	var tex = new h3d_mat_Texture(w,h);
	var _g = 0;
	var _g1 = bmp.ctx.canvas.height / height | 0;
	while(_g < _g1) {
		var y = _g++;
		var a = [];
		tl[y] = a;
		var _g2 = 0;
		var _g3 = bmp.ctx.canvas.width / width | 0;
		while(_g2 < _g3) {
			var x = _g2++;
			var sz = h2d_Tile.isEmpty(bmp,x * width,y * height,width,height,colorBG);
			if(sz == null) {
				break;
			}
			a.push(new h2d_Tile(tex,x * width + sz.dx,y * height + sz.dy,sz.w,sz.h,sz.dx,sz.dy));
		}
	}
	bmp.unlock();
	var main = new h2d_Tile(tex,0,0,bmp.ctx.canvas.width,bmp.ctx.canvas.height);
	main.upload(bmp);
	return { main : main, tiles : tl};
};
h2d_Tile.fromTexture = function(t) {
	return new h2d_Tile(t,0,0,t.width,t.height);
};
h2d_Tile.fromPixels = function(pixels) {
	var pix2 = pixels.makeSquare(true);
	var t = h3d_mat_Texture.fromPixels(pix2,h3d_mat_Texture.nativeFormat);
	if(pix2 != pixels) {
		pix2.dispose();
	}
	return new h2d_Tile(t,0,0,pixels.width,pixels.height);
};
h2d_Tile.isEmpty = function(b,px,py,width,height,bg) {
	var empty = true;
	var xmin = width;
	var ymin = height;
	var xmax = 0;
	var ymax = 0;
	var _g = 0;
	var _g1 = width;
	while(_g < _g1) {
		var x = _g++;
		var _g2 = 0;
		var _g3 = height;
		while(_g2 < _g3) {
			var y = _g2++;
			var color = b.getPixel(x + px,y + py);
			if((color & -16777216) == 0) {
				if(color != 0) {
					b.setPixel(x + px,y + py,0);
				}
				continue;
			}
			if(color != bg) {
				empty = false;
				if(x < xmin) {
					xmin = x;
				}
				if(y < ymin) {
					ymin = y;
				}
				if(x > xmax) {
					xmax = x;
				}
				if(y > ymax) {
					ymax = y;
				}
			}
			if(color == bg && color != 0) {
				b.setPixel(x + px,y + py,0);
			}
		}
	}
	if(empty) {
		return null;
	} else {
		return { dx : xmin, dy : ymin, w : xmax - xmin + 1, h : ymax - ymin + 1};
	}
};
h2d_Tile.prototype = {
	get_ix: function() {
		return Math.floor(this.x);
	}
	,get_iy: function() {
		return Math.floor(this.y);
	}
	,get_iwidth: function() {
		return Math.ceil(this.width + this.x) - Math.floor(this.x);
	}
	,get_iheight: function() {
		return Math.ceil(this.height + this.y) - Math.floor(this.y);
	}
	,getTexture: function() {
		return this.innerTex;
	}
	,isDisposed: function() {
		if(this.innerTex != null) {
			var _this = this.innerTex;
			if(_this.t == null) {
				if(!_this.isDepth()) {
					return _this.realloc == null;
				} else {
					return true;
				}
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	,setTexture: function(tex) {
		this.innerTex = tex;
		if(tex != null) {
			this.u = this.x / tex.width;
			this.v = this.y / tex.height;
			this.u2 = (this.x + this.width) / tex.width;
			this.v2 = (this.y + this.height) / tex.height;
		}
	}
	,switchTexture: function(t) {
		this.setTexture(t.innerTex);
	}
	,sub: function(x,y,w,h,dx,dy) {
		if(dy == null) {
			dy = 0.;
		}
		if(dx == null) {
			dx = 0.;
		}
		return new h2d_Tile(this.innerTex,this.x + x,this.y + y,w,h,dx,dy);
	}
	,center: function() {
		return this.sub(0,0,this.width,this.height,-(this.width * .5),-(this.height * .5));
	}
	,setCenterRatio: function(px,py) {
		if(py == null) {
			py = 0.5;
		}
		if(px == null) {
			px = 0.5;
		}
		this.dx = -(px * this.width);
		this.dy = -(py * this.height);
	}
	,flipX: function() {
		var tmp = this.u;
		this.u = this.u2;
		this.u2 = tmp;
		this.dx = -this.dx - this.width;
	}
	,flipY: function() {
		var tmp = this.v;
		this.v = this.v2;
		this.v2 = tmp;
		this.dy = -this.dy - this.height;
	}
	,setPosition: function(x,y) {
		this.x = x;
		this.y = y;
		var tex = this.innerTex;
		if(tex != null) {
			this.u = x / tex.width;
			this.v = y / tex.height;
			this.u2 = (x + this.width) / tex.width;
			this.v2 = (y + this.height) / tex.height;
		}
	}
	,setSize: function(w,h) {
		this.width = w;
		this.height = h;
		var tex = this.innerTex;
		if(tex != null) {
			this.u2 = (this.x + w) / tex.width;
			this.v2 = (this.y + h) / tex.height;
		}
	}
	,scaleToSize: function(w,h) {
		this.width = w;
		this.height = h;
	}
	,scrollDiscrete: function(dx,dy) {
		var tex = this.innerTex;
		this.u += dx / tex.width;
		this.v -= dy / tex.height;
		this.u2 += dx / tex.width;
		this.v2 -= dy / tex.height;
		this.x = this.u * tex.width;
		this.y = this.v * tex.height;
	}
	,dispose: function() {
		if(this.innerTex != null) {
			this.innerTex.dispose();
		}
		this.innerTex = null;
	}
	,clone: function() {
		var t = new h2d_Tile(null,this.x,this.y,this.width,this.height,this.dx,this.dy);
		t.innerTex = this.innerTex;
		t.u = this.u;
		t.u2 = this.u2;
		t.v = this.v;
		t.v2 = this.v2;
		return t;
	}
	,get_xFlip: function() {
		return this.u2 < this.u;
	}
	,get_yFlip: function() {
		return this.v2 < this.v;
	}
	,set_xFlip: function(v) {
		if(v != this.get_xFlip()) {
			this.flipX();
		}
		return v;
	}
	,set_yFlip: function(v) {
		if(v != this.get_yFlip()) {
			this.flipY();
		}
		return v;
	}
	,split: function(frames,vertical,subpixel) {
		if(subpixel == null) {
			subpixel = false;
		}
		if(vertical == null) {
			vertical = false;
		}
		if(frames == null) {
			frames = 0;
		}
		var tl = [];
		if(vertical) {
			if(frames == 0) {
				frames = this.height / this.width | 0;
			}
			var stride = subpixel ? this.height / frames : this.height / frames | 0;
			var _g = 0;
			var _g1 = frames;
			while(_g < _g1) {
				var i = _g++;
				tl.push(this.sub(0,i * stride,this.width,stride));
			}
		} else {
			if(frames == 0) {
				frames = this.width / this.height | 0;
			}
			var stride = subpixel ? this.width / frames : this.width / frames | 0;
			var _g = 0;
			var _g1 = frames;
			while(_g < _g1) {
				var i = _g++;
				tl.push(this.sub(i * stride,0,stride,this.height));
			}
		}
		return tl;
	}
	,gridFlatten: function(size,dx,dy) {
		if(dy == null) {
			dy = 0.;
		}
		if(dx == null) {
			dx = 0.;
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = this.height / size | 0;
		while(_g1 < _g2) {
			var y = _g1++;
			var _g3 = 0;
			var _g4 = this.width / size | 0;
			while(_g3 < _g4) {
				var x = _g3++;
				_g.push(this.sub(x * size,y * size,size,size,dx,dy));
			}
		}
		return _g;
	}
	,grid: function(size,dx,dy) {
		if(dy == null) {
			dy = 0.;
		}
		if(dx == null) {
			dx = 0.;
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = this.width / size | 0;
		while(_g1 < _g2) {
			var x = _g1++;
			var _g3 = [];
			var _g4 = 0;
			var _g5 = this.height / size | 0;
			while(_g4 < _g5) {
				var y = _g4++;
				_g3.push(this.sub(x * size,y * size,size,size,dx,dy));
			}
			_g.push(_g3);
		}
		return _g;
	}
	,toString: function() {
		return "Tile(" + this.x + "," + this.y + "," + this.width + "x" + this.height + (this.dx != 0 || this.dy != 0 ? "," + this.dx + ":" + this.dy : "") + ")";
	}
	,upload: function(bmp) {
		var w = this.innerTex.width;
		var h = this.innerTex.height;
		this.innerTex.uploadBitmap(bmp);
	}
	,__class__: h2d_Tile
};
var h2d_TileLayerContent = function() {
	this.useAllocatorLimit = 1024;
	h3d_prim_Primitive.call(this);
	this.state = new h2d_impl_BatchDrawState();
	this.clear();
};
$hxClasses["h2d.TileLayerContent"] = h2d_TileLayerContent;
h2d_TileLayerContent.__name__ = "h2d.TileLayerContent";
h2d_TileLayerContent.__super__ = h3d_prim_Primitive;
h2d_TileLayerContent.prototype = $extend(h3d_prim_Primitive.prototype,{
	clear: function() {
		this.tmp = hxd__$FloatBuffer_Float32Expand._new(0);
		if(this.buffer != null) {
			if(this.buffer.vertices * 8 < this.useAllocatorLimit) {
				hxd_impl_Allocator.get().disposeBuffer(this.buffer);
			} else {
				this.buffer.dispose();
			}
		}
		this.buffer = null;
		this.xMin = Infinity;
		this.yMin = Infinity;
		this.xMax = -Infinity;
		this.yMax = -Infinity;
		this.state.clear();
	}
	,isEmpty: function() {
		return this.triCount() == 0;
	}
	,triCount: function() {
		if(this.buffer == null) {
			return this.tmp.pos >> 4;
		} else {
			return this.buffer.vertices >> 1;
		}
	}
	,addColor: function(x,y,color,t) {
		this.add(x,y,color.x,color.y,color.z,color.w,t);
	}
	,add: function(x,y,r,g,b,a,t) {
		var sx = x + t.dx;
		var sy = y + t.dy;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = sx;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = sy;
		var this1 = this.tmp;
		var v = t.u;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = t.v;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = r;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = g;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = b;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = a;
		var this1 = this.tmp;
		var v = sx + t.width;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = sy;
		var this1 = this.tmp;
		var v = t.u2;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = t.v;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = r;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = g;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = b;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = a;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = sx;
		var this1 = this.tmp;
		var v = sy + t.height;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = t.u;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = t.v2;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = r;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = g;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = b;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = a;
		var this1 = this.tmp;
		var v = sx + t.width;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = sy + t.height;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = t.u2;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = t.v2;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = r;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = g;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = b;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = a;
		var x1 = x + t.dx;
		var y1 = y + t.dy;
		if(x1 < this.xMin) {
			this.xMin = x1;
		}
		if(y1 < this.yMin) {
			this.yMin = y1;
		}
		x1 += t.width;
		y1 += t.height;
		if(x1 > this.xMax) {
			this.xMax = x1;
		}
		if(y1 > this.yMax) {
			this.yMax = y1;
		}
		if(t != null) {
			this.state.setTexture(t.innerTex);
		}
		var _this = this.state;
		_this.tail.count += 4;
		_this.totalCount += 4;
	}
	,addTransform: function(x,y,sx,sy,r,c,t) {
		var _gthis = this;
		var ca = Math.cos(r);
		var sa = Math.sin(r);
		var hx = t.width;
		var hy = t.height;
		var dx = t.dx * sx;
		var dy = t.dy * sy;
		var px = dx * ca - dy * sa + x;
		var py = dy * ca + dx * sa + y;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = px;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = py;
		var this1 = this.tmp;
		var v = t.u;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = t.v;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = c.x;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = c.y;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = c.z;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = c.w;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		if(px < _gthis.xMin) {
			_gthis.xMin = px;
		}
		if(py < _gthis.yMin) {
			_gthis.yMin = py;
		}
		if(px > _gthis.xMax) {
			_gthis.xMax = px;
		}
		if(py > _gthis.yMax) {
			_gthis.yMax = py;
		}
		var dx = (t.dx + hx) * sx;
		var dy = t.dy * sy;
		var px = dx * ca - dy * sa + x;
		var py = dy * ca + dx * sa + y;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = px;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = py;
		var this1 = this.tmp;
		var v = t.u2;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = t.v;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = c.x;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = c.y;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = c.z;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = c.w;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		if(px < _gthis.xMin) {
			_gthis.xMin = px;
		}
		if(py < _gthis.yMin) {
			_gthis.yMin = py;
		}
		if(px > _gthis.xMax) {
			_gthis.xMax = px;
		}
		if(py > _gthis.yMax) {
			_gthis.yMax = py;
		}
		var dx = t.dx * sx;
		var dy = (t.dy + hy) * sy;
		var px = dx * ca - dy * sa + x;
		var py = dy * ca + dx * sa + y;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = px;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = py;
		var this1 = this.tmp;
		var v = t.u;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = t.v2;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = c.x;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = c.y;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = c.z;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = c.w;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		if(px < _gthis.xMin) {
			_gthis.xMin = px;
		}
		if(py < _gthis.yMin) {
			_gthis.yMin = py;
		}
		if(px > _gthis.xMax) {
			_gthis.xMax = px;
		}
		if(py > _gthis.yMax) {
			_gthis.yMax = py;
		}
		var dx = (t.dx + hx) * sx;
		var dy = (t.dy + hy) * sy;
		var px = dx * ca - dy * sa + x;
		var py = dy * ca + dx * sa + y;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = px;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = py;
		var this1 = this.tmp;
		var v = t.u2;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = t.v2;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = c.x;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = c.y;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = c.z;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = c.w;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		if(px < _gthis.xMin) {
			_gthis.xMin = px;
		}
		if(py < _gthis.yMin) {
			_gthis.yMin = py;
		}
		if(px > _gthis.xMax) {
			_gthis.xMax = px;
		}
		if(py > _gthis.yMax) {
			_gthis.yMax = py;
		}
		if(t != null) {
			this.state.setTexture(t.innerTex);
		}
		var _this = this.state;
		_this.tail.count += 4;
		_this.totalCount += 4;
	}
	,addPoint: function(x,y,color) {
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = x;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = y;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = 0;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = 0;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color >> 16 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color >> 8 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color >>> 24) / 255.;
		if(x < this.xMin) {
			this.xMin = x;
		}
		if(y < this.yMin) {
			this.yMin = y;
		}
		if(x > this.xMax) {
			this.xMax = x;
		}
		if(y > this.yMax) {
			this.yMax = y;
		}
	}
	,insertColor: function(c) {
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (c >> 16 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (c >> 8 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (c & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (c >>> 24) / 255.;
	}
	,rectColor: function(x,y,w,h,color) {
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = x;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = y;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = 0;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = 0;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color >> 16 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color >> 8 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color >>> 24) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = x + w;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = y;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = 1;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = 0;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color >> 16 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color >> 8 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color >>> 24) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = x;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = y + h;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = 0;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = 1;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color >> 16 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color >> 8 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color >>> 24) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = x + w;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = y + h;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = 1;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = 1;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color >> 16 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color >> 8 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color >>> 24) / 255.;
		if(x < this.xMin) {
			this.xMin = x;
		}
		if(y < this.yMin) {
			this.yMin = y;
		}
		x += w;
		y += h;
		if(x > this.xMax) {
			this.xMax = x;
		}
		if(y > this.yMax) {
			this.yMax = y;
		}
		var _this = this.state;
		_this.tail.count += 4;
		_this.totalCount += 4;
	}
	,rectGradient: function(x,y,w,h,ctl,ctr,cbl,cbr) {
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = x;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = y;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = 0;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = 0;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (ctl >> 16 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (ctl >> 8 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (ctl & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (ctl >>> 24) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = x + w;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = y;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = 1;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = 0;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (ctr >> 16 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (ctr >> 8 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (ctr & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (ctr >>> 24) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = x;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = y + h;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = 0;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = 1;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (cbl >> 16 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (cbl >> 8 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (cbl & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (cbl >>> 24) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = x + w;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = y + h;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = 1;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = 1;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (cbr >> 16 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (cbr >> 8 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (cbr & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (cbr >>> 24) / 255.;
		if(x < this.xMin) {
			this.xMin = x;
		}
		if(y < this.yMin) {
			this.yMin = y;
		}
		x += w;
		y += h;
		if(x > this.xMax) {
			this.xMax = x;
		}
		if(y > this.yMax) {
			this.yMax = y;
		}
		var _this = this.state;
		_this.tail.count += 4;
		_this.totalCount += 4;
	}
	,fillArc: function(x,y,ray,c,start,end) {
		if(end <= start) {
			return;
		}
		var arcLength = end - start;
		var nsegments = Math.ceil(ray * 3.14 * 2 / 4);
		if(nsegments < 4) {
			nsegments = 4;
		}
		var angle = arcLength / nsegments;
		var prevX = -Infinity;
		var prevY = -Infinity;
		var _x = 0.;
		var _y = 0.;
		var i = 0;
		var count = 0;
		while(i < nsegments) {
			var a = start + i * angle;
			_x = x + Math.cos(a) * ray;
			_y = y + Math.sin(a) * ray;
			if(prevX != -Infinity) {
				this.addPoint(x,y,c);
				this.addPoint(_x,_y,c);
				this.addPoint(prevX,prevY,c);
				this.addPoint(prevX,prevY,c);
				count += 4;
			}
			prevX = _x;
			prevY = _y;
			++i;
		}
		var a = end;
		_x = x + Math.cos(a) * ray;
		_y = y + Math.sin(a) * ray;
		this.addPoint(x,y,c);
		this.addPoint(_x,_y,c);
		this.addPoint(prevX,prevY,c);
		this.addPoint(prevX,prevY,c);
		var _this = this.state;
		var count1 = count + 4;
		_this.tail.count += count1;
		_this.totalCount += count1;
	}
	,fillCircle: function(x,y,radius,c) {
		var nsegments = Math.ceil(radius * 3.14 * 2 / 2);
		if(nsegments < 3) {
			nsegments = 3;
		}
		var angle = Math.PI * 2 / nsegments;
		var prevX = -Infinity;
		var prevY = -Infinity;
		var firstX = -Infinity;
		var firstY = -Infinity;
		var curX = 0.;
		var curY = 0.;
		var count = 0;
		var _g = 0;
		var _g1 = nsegments;
		while(_g < _g1) {
			var i = _g++;
			var a = i * angle;
			curX = x + Math.cos(a) * radius;
			curY = y + Math.sin(a) * radius;
			if(prevX != -Infinity) {
				this.addPoint(x,y,c);
				this.addPoint(curX,curY,c);
				this.addPoint(prevX,prevY,c);
				this.addPoint(x,y,c);
				count += 4;
			}
			if(firstX == -Infinity) {
				firstX = curX;
				firstY = curY;
			}
			prevX = curX;
			prevY = curY;
		}
		this.addPoint(x,y,c);
		this.addPoint(curX,curY,c);
		this.addPoint(firstX,firstY,c);
		this.addPoint(x,y,c);
		var _this = this.state;
		var count1 = count + 4;
		_this.tail.count += count1;
		_this.totalCount += count1;
	}
	,circle: function(x,y,ray,size,c) {
		if(size > ray) {
			return;
		}
		var nsegments = Math.ceil(ray * 3.14 * 2 / 2);
		if(nsegments < 3) {
			nsegments = 3;
		}
		var ray1 = ray - size;
		var angle = Math.PI * 2 / nsegments;
		var prevX = -Infinity;
		var prevY = -Infinity;
		var prevX1 = -Infinity;
		var prevY1 = -Infinity;
		var count = 0;
		var _g = 0;
		var _g1 = nsegments;
		while(_g < _g1) {
			var i = _g++;
			var a = i * angle;
			var _x = x + Math.cos(a) * ray;
			var _y = y + Math.sin(a) * ray;
			var _x1 = x + Math.cos(a) * ray1;
			var _y1 = y + Math.sin(a) * ray1;
			if(prevX != -Infinity) {
				this.addPoint(_x,_y,c);
				this.addPoint(prevX,prevY,c);
				this.addPoint(_x1,_y1,c);
				this.addPoint(prevX1,prevY1,c);
				count += 4;
			}
			prevX = _x;
			prevY = _y;
			prevX1 = _x1;
			prevY1 = _y1;
		}
		var _this = this.state;
		_this.tail.count += count;
		_this.totalCount += count;
	}
	,arc: function(x,y,ray,size,start,end,c) {
		if(size > ray) {
			return;
		}
		if(end <= start) {
			return;
		}
		var arcLength = end - start;
		var nsegments = Math.ceil(ray * 3.14 * 2 / 4);
		if(nsegments < 3) {
			nsegments = 3;
		}
		var ray1 = ray - size;
		var angle = arcLength / nsegments;
		var prevX = -Infinity;
		var prevY = -Infinity;
		var prevX1 = -Infinity;
		var prevY1 = -Infinity;
		var _x = 0.;
		var _y = 0.;
		var _x1 = 0.;
		var _y1 = 0.;
		var count = 0;
		var _g = 0;
		var _g1 = nsegments;
		while(_g < _g1) {
			var i = _g++;
			var a = start + i * angle;
			_x = x + Math.cos(a) * ray;
			_y = y + Math.sin(a) * ray;
			_x1 = x + Math.cos(a) * ray1;
			_y1 = y + Math.sin(a) * ray1;
			if(prevX != -Infinity) {
				this.addPoint(_x,_y,c);
				this.addPoint(prevX,prevY,c);
				this.addPoint(_x1,_y1,c);
				this.addPoint(prevX1,prevY1,c);
				count += 4;
			}
			prevX = _x;
			prevY = _y;
			prevX1 = _x1;
			prevY1 = _y1;
		}
		var a = end;
		_x = x + Math.cos(a) * ray;
		_y = y + Math.sin(a) * ray;
		_x1 = x + Math.cos(a) * ray1;
		_y1 = y + Math.sin(a) * ray1;
		this.addPoint(_x,_y,c);
		this.addPoint(prevX,prevY,c);
		this.addPoint(_x1,_y1,c);
		this.addPoint(prevX1,prevY1,c);
		var _this = this.state;
		var count1 = count + 4;
		_this.tail.count += count1;
		_this.totalCount += count1;
	}
	,alloc: function(engine) {
		if(this.tmp == null) {
			this.clear();
		}
		if(this.tmp.pos > 0) {
			this.buffer = this.tmp.pos < this.useAllocatorLimit ? hxd_impl_Allocator.get().ofFloats(this.tmp,hxd_BufferFormat.get_XY_UV_RGBA()) : h3d_Buffer.ofFloats(this.tmp,hxd_BufferFormat.get_XY_UV_RGBA());
		}
	}
	,dispose: function() {
		if(this.buffer != null) {
			if(this.buffer.vertices * 8 < this.useAllocatorLimit) {
				hxd_impl_Allocator.get().disposeBuffer(this.buffer);
			} else {
				this.buffer.dispose();
			}
			this.buffer = null;
		}
		h3d_prim_Primitive.prototype.dispose.call(this);
	}
	,flush: function() {
		if(this.buffer == null || this.buffer.vbuf == null) {
			this.alloc(h3d_Engine.CURRENT);
		}
	}
	,doRender: function(ctx,min,len) {
		if(this.buffer == null || this.buffer.vbuf == null) {
			this.alloc(h3d_Engine.CURRENT);
		}
		this.state.drawQuads(ctx,this.buffer,min,len);
	}
	,__class__: h2d_TileLayerContent
});
var h2d_TileGroup = function(t,parent) {
	h2d_Drawable.call(this,parent);
	this.tile = t;
	this.rangeMin = this.rangeMax = -1;
	var x = 1;
	var y = 1;
	var z = 1;
	var w = 1;
	if(w == null) {
		w = 1.;
	}
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.curColor = new h3d_Vector4Impl(x,y,z,w);
	this.content = new h2d_TileLayerContent();
};
$hxClasses["h2d.TileGroup"] = h2d_TileGroup;
h2d_TileGroup.__name__ = "h2d.TileGroup";
h2d_TileGroup.__super__ = h2d_Drawable;
h2d_TileGroup.prototype = $extend(h2d_Drawable.prototype,{
	getBoundsRec: function(relativeTo,out,forSize) {
		h2d_Drawable.prototype.getBoundsRec.call(this,relativeTo,out,forSize);
		this.addBounds(relativeTo,out,this.content.xMin,this.content.yMin,this.content.xMax - this.content.xMin,this.content.yMax - this.content.yMin);
	}
	,clear: function() {
		this.content.clear();
	}
	,invalidate: function() {
		this.content.dispose();
	}
	,count: function() {
		return this.content.triCount() >> 1;
	}
	,onRemove: function() {
		this.content.dispose();
		h2d_Drawable.prototype.onRemove.call(this);
	}
	,setDefaultColor: function(rgb,alpha) {
		if(alpha == null) {
			alpha = 1.0;
		}
		this.curColor.x = (rgb >> 16 & 255) / 255;
		this.curColor.y = (rgb >> 8 & 255) / 255;
		this.curColor.z = (rgb & 255) / 255;
		this.curColor.w = alpha;
	}
	,add: function(x,y,t) {
		this.content.add(x,y,this.curColor.x,this.curColor.y,this.curColor.z,this.curColor.w,t);
	}
	,addColor: function(x,y,r,g,b,a,t) {
		this.content.add(x,y,r,g,b,a,t);
	}
	,addAlpha: function(x,y,a,t) {
		this.content.add(x,y,this.curColor.x,this.curColor.y,this.curColor.z,a,t);
	}
	,addTransform: function(x,y,sx,sy,r,t) {
		this.content.addTransform(x,y,sx,sy,r,this.curColor,t);
	}
	,draw: function(ctx) {
		this.drawWith(ctx,this);
	}
	,sync: function(ctx) {
		h2d_Drawable.prototype.sync.call(this,ctx);
		if(this.visible) {
			var _this = this.content;
			if(_this.buffer == null || _this.buffer.vbuf == null) {
				_this.alloc(h3d_Engine.CURRENT);
			}
		}
	}
	,drawWith: function(ctx,obj) {
		var max = this.content.triCount();
		if(max == 0) {
			return;
		}
		if(!ctx.beginDrawBatchState(obj)) {
			return;
		}
		var min = this.rangeMin < 0 ? 0 : this.rangeMin * 2;
		if(this.rangeMax > 0 && this.rangeMax < max * 2) {
			max = this.rangeMax * 2;
		}
		var _this = this.content;
		if(_this.buffer == null || _this.buffer.vbuf == null) {
			_this.alloc(h3d_Engine.CURRENT);
		}
		_this.state.drawQuads(ctx,_this.buffer,min,max - min);
	}
	,__class__: h2d_TileGroup
});
var h2d_col_Collider = function() { };
$hxClasses["h2d.col.Collider"] = h2d_col_Collider;
h2d_col_Collider.__name__ = "h2d.col.Collider";
h2d_col_Collider.prototype = {
	__class__: h2d_col_Collider
};
var h2d_col_Bounds = function() {
	this.xMin = 1e20;
	this.yMin = 1e20;
	this.xMax = -1e20;
	this.yMax = -1e20;
};
$hxClasses["h2d.col.Bounds"] = h2d_col_Bounds;
h2d_col_Bounds.__name__ = "h2d.col.Bounds";
h2d_col_Bounds.fromValues = function(x0,y0,width,height) {
	var b = new h2d_col_Bounds();
	b.xMin = x0;
	b.yMin = y0;
	b.xMax = x0 + width;
	b.yMax = y0 + height;
	return b;
};
h2d_col_Bounds.fromPoints = function(min,max) {
	var b = new h2d_col_Bounds();
	b.xMin = min.x;
	b.yMin = min.y;
	b.xMax = max.x;
	b.yMax = max.y;
	return b;
};
h2d_col_Bounds.__super__ = h2d_col_Collider;
h2d_col_Bounds.prototype = $extend(h2d_col_Collider.prototype,{
	toIBounds: function(scale) {
		if(scale == null) {
			scale = 1.;
		}
		var ix = Math.floor(this.xMin * scale);
		var iy = Math.floor(this.yMin * scale);
		var width = Math.ceil(this.xMax * scale) - ix;
		var height = Math.ceil(this.yMax * scale) - iy;
		var b = new h2d_col_IBounds();
		b.xMin = ix;
		b.yMin = iy;
		b.xMax = ix + width;
		b.yMax = iy + height;
		return b;
	}
	,intersects: function(b) {
		return !(this.xMin > b.xMax || this.yMin > b.yMax || this.xMax < b.xMin || this.yMax < b.yMin);
	}
	,collideBounds: function(b) {
		return !(this.xMin > b.xMax || this.yMin > b.yMax || this.xMax < b.xMin || this.yMax < b.yMin);
	}
	,collideCircle: function(c) {
		if(c.x < this.xMin - c.ray) {
			return false;
		} else if(c.x > this.xMax + c.ray) {
			return false;
		} else if(c.y < this.yMin - c.ray) {
			return false;
		} else if(c.y > this.yMax + c.ray) {
			return false;
		} else {
			var tmp;
			if(c.x < this.xMin && c.y < this.yMin) {
				var dx = c.x - this.xMin;
				var dy = c.y - this.yMin;
				tmp = dx * dx + dy * dy > c.ray * c.ray;
			} else {
				tmp = false;
			}
			if(tmp) {
				return false;
			} else {
				var tmp;
				if(c.x > this.xMax && c.y < this.yMin) {
					var dx = c.x - this.xMax;
					var dy = c.y - this.yMin;
					tmp = dx * dx + dy * dy > c.ray * c.ray;
				} else {
					tmp = false;
				}
				if(tmp) {
					return false;
				} else {
					var tmp;
					if(c.x < this.xMin && c.y > this.yMax) {
						var dx = c.x - this.xMin;
						var dy = c.y - this.yMax;
						tmp = dx * dx + dy * dy > c.ray * c.ray;
					} else {
						tmp = false;
					}
					if(tmp) {
						return false;
					} else {
						var tmp;
						if(c.x > this.xMax && c.y > this.yMax) {
							var dx = c.x - this.xMax;
							var dy = c.y - this.yMax;
							tmp = dx * dx + dy * dy > c.ray * c.ray;
						} else {
							tmp = false;
						}
						if(tmp) {
							return false;
						} else {
							return true;
						}
					}
				}
			}
		}
	}
	,contains: function(p) {
		if(p.x >= this.xMin && p.x < this.xMax && p.y >= this.yMin) {
			return p.y < this.yMax;
		} else {
			return false;
		}
	}
	,rayIntersection: function(r) {
		var minTx = (this.xMin - r.px) / r.lx;
		var minTy = (this.yMin - r.py) / r.ly;
		var maxTx = (this.xMax - r.px) / r.lx;
		var maxTy = (this.yMax - r.py) / r.ly;
		var realMinTx = minTx > maxTx ? maxTx : minTx;
		var realMinTy = minTy > maxTy ? maxTy : minTy;
		var realMaxTx = minTx < maxTx ? maxTx : minTx;
		var realMaxTy = minTy < maxTy ? maxTy : minTy;
		var minmax = realMaxTx > realMaxTy ? realMaxTy : realMaxTx;
		var maxmin = realMinTx < realMinTy ? realMinTy : realMinTx;
		if(minmax < maxmin) {
			return -1;
		}
		return maxmin;
	}
	,distanceSq: function(p) {
		var dx = p.x < this.xMin ? this.xMin - p.x : p.x > this.xMax ? p.x - this.xMax : 0.;
		var dy = p.y < this.yMin ? this.yMin - p.y : p.y > this.yMax ? p.y - this.yMax : 0.;
		return dx * dx + dy * dy;
	}
	,distance: function(p) {
		var dx = p.x < this.xMin ? this.xMin - p.x : p.x > this.xMax ? p.x - this.xMax : 0.;
		var dy = p.y < this.yMin ? this.yMin - p.y : p.y > this.yMax ? p.y - this.yMax : 0.;
		return Math.sqrt(dx * dx + dy * dy);
	}
	,addBounds: function(b) {
		if(b.xMin < this.xMin) {
			this.xMin = b.xMin;
		}
		if(b.xMax > this.xMax) {
			this.xMax = b.xMax;
		}
		if(b.yMin < this.yMin) {
			this.yMin = b.yMin;
		}
		if(b.yMax > this.yMax) {
			this.yMax = b.yMax;
		}
	}
	,addPoint: function(p) {
		if(p.x < this.xMin) {
			this.xMin = p.x;
		}
		if(p.x > this.xMax) {
			this.xMax = p.x;
		}
		if(p.y < this.yMin) {
			this.yMin = p.y;
		}
		if(p.y > this.yMax) {
			this.yMax = p.y;
		}
	}
	,addPos: function(x,y) {
		if(x < this.xMin) {
			this.xMin = x;
		}
		if(x > this.xMax) {
			this.xMax = x;
		}
		if(y < this.yMin) {
			this.yMin = y;
		}
		if(y > this.yMax) {
			this.yMax = y;
		}
	}
	,set: function(x,y,width,height) {
		this.xMin = x;
		this.yMin = y;
		this.xMax = x + width;
		this.yMax = y + height;
	}
	,setMin: function(p) {
		this.xMin = p.x;
		this.yMin = p.y;
	}
	,setMax: function(p) {
		this.xMax = p.x;
		this.yMax = p.y;
	}
	,doIntersect: function(b) {
		var a = this.xMin;
		var b1 = b.xMin;
		this.xMin = a < b1 ? b1 : a;
		var a = this.yMin;
		var b1 = b.yMin;
		this.yMin = a < b1 ? b1 : a;
		var a = this.xMax;
		var b1 = b.xMax;
		this.xMax = a > b1 ? b1 : a;
		var a = this.yMax;
		var b1 = b.yMax;
		this.yMax = a > b1 ? b1 : a;
	}
	,doUnion: function(b) {
		var a = this.xMin;
		var b1 = b.xMin;
		this.xMin = a > b1 ? b1 : a;
		var a = this.yMin;
		var b1 = b.yMin;
		this.yMin = a > b1 ? b1 : a;
		var a = this.xMax;
		var b1 = b.xMax;
		this.xMax = a < b1 ? b1 : a;
		var a = this.yMax;
		var b1 = b.yMax;
		this.yMax = a < b1 ? b1 : a;
	}
	,intersection: function(b) {
		var i = new h2d_col_Bounds();
		var a = this.xMin;
		var b1 = b.xMin;
		i.xMin = a < b1 ? b1 : a;
		var a = this.yMin;
		var b1 = b.yMin;
		i.yMin = a < b1 ? b1 : a;
		var a = this.xMax;
		var b1 = b.xMax;
		i.xMax = a > b1 ? b1 : a;
		var a = this.yMax;
		var b1 = b.yMax;
		i.yMax = a > b1 ? b1 : a;
		if(i.xMax < i.xMin) {
			i.xMax = i.xMin;
		}
		if(i.yMax < i.yMin) {
			i.yMax = i.yMin;
		}
		return i;
	}
	,union: function(b) {
		var i = new h2d_col_Bounds();
		var a = this.xMin;
		var b1 = b.xMin;
		i.xMin = a > b1 ? b1 : a;
		var a = this.yMin;
		var b1 = b.yMin;
		i.yMin = a > b1 ? b1 : a;
		var a = this.xMax;
		var b1 = b.xMax;
		i.xMax = a < b1 ? b1 : a;
		var a = this.yMax;
		var b1 = b.yMax;
		i.yMax = a < b1 ? b1 : a;
		return i;
	}
	,load: function(b) {
		this.xMin = b.xMin;
		this.yMin = b.yMin;
		this.xMax = b.xMax;
		this.yMax = b.yMax;
	}
	,scalePivot: function(v) {
		this.xMin *= v;
		this.yMin *= v;
		this.xMax *= v;
		this.yMax *= v;
	}
	,scaleCenter: function(v) {
		var dx = (this.xMax - this.xMin) * 0.5 * v;
		var dy = (this.yMax - this.yMin) * 0.5 * v;
		var mx = (this.xMax + this.xMin) * 0.5;
		var my = (this.yMax + this.yMin) * 0.5;
		this.xMin = mx - dx;
		this.yMin = my - dy;
		this.xMax = mx + dx;
		this.yMax = my + dy;
	}
	,rotate: function(angle) {
		var cos = Math.cos(angle);
		var sin = Math.sin(angle);
		var x0 = this.xMin;
		var y0 = this.yMin;
		var x1 = this.xMax;
		var y1 = this.yMax;
		this.xMin = 1e20;
		this.yMin = 1e20;
		this.xMax = -1e20;
		this.yMax = -1e20;
		var x = x0 * cos - y0 * sin;
		var y = x0 * sin + y0 * cos;
		if(x < this.xMin) {
			this.xMin = x;
		}
		if(x > this.xMax) {
			this.xMax = x;
		}
		if(y < this.yMin) {
			this.yMin = y;
		}
		if(y > this.yMax) {
			this.yMax = y;
		}
		var x = x1 * cos - y0 * sin;
		var y = x1 * sin + y0 * cos;
		if(x < this.xMin) {
			this.xMin = x;
		}
		if(x > this.xMax) {
			this.xMax = x;
		}
		if(y < this.yMin) {
			this.yMin = y;
		}
		if(y > this.yMax) {
			this.yMax = y;
		}
		var x = x0 * cos - y1 * sin;
		var y = x0 * sin + y1 * cos;
		if(x < this.xMin) {
			this.xMin = x;
		}
		if(x > this.xMax) {
			this.xMax = x;
		}
		if(y < this.yMin) {
			this.yMin = y;
		}
		if(y > this.yMax) {
			this.yMax = y;
		}
		var x = x1 * cos - y1 * sin;
		var y = x1 * sin + y1 * cos;
		if(x < this.xMin) {
			this.xMin = x;
		}
		if(x > this.xMax) {
			this.xMax = x;
		}
		if(y < this.yMin) {
			this.yMin = y;
		}
		if(y > this.yMax) {
			this.yMax = y;
		}
	}
	,offset: function(dx,dy) {
		this.xMin += dx;
		this.xMax += dx;
		this.yMin += dy;
		this.yMax += dy;
	}
	,getMin: function() {
		var x = this.xMin;
		var y = this.yMin;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h2d_col_PointImpl(x,y);
	}
	,getCenter: function() {
		var x = (this.xMin + this.xMax) * 0.5;
		var y = (this.yMin + this.yMax) * 0.5;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h2d_col_PointImpl(x,y);
	}
	,getSize: function() {
		var x = this.xMax - this.xMin;
		var y = this.yMax - this.yMin;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h2d_col_PointImpl(x,y);
	}
	,getMax: function() {
		var x = this.xMax;
		var y = this.yMax;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h2d_col_PointImpl(x,y);
	}
	,isEmpty: function() {
		if(!(this.xMax <= this.xMin)) {
			return this.yMax <= this.yMin;
		} else {
			return true;
		}
	}
	,empty: function() {
		this.xMin = 1e20;
		this.yMin = 1e20;
		this.xMax = -1e20;
		this.yMax = -1e20;
	}
	,all: function() {
		this.xMin = -1e20;
		this.yMin = -1e20;
		this.xMax = 1e20;
		this.yMax = 1e20;
	}
	,clone: function() {
		var b = new h2d_col_Bounds();
		b.xMin = this.xMin;
		b.yMin = this.yMin;
		b.xMax = this.xMax;
		b.yMax = this.yMax;
		return b;
	}
	,get_x: function() {
		return this.xMin;
	}
	,get_y: function() {
		return this.yMin;
	}
	,set_x: function(x) {
		this.xMax += x - this.xMin;
		return this.xMin = x;
	}
	,set_y: function(y) {
		this.yMax += y - this.yMin;
		return this.yMin = y;
	}
	,get_width: function() {
		return this.xMax - this.xMin;
	}
	,get_height: function() {
		return this.yMax - this.yMin;
	}
	,set_width: function(w) {
		this.xMax = this.xMin + w;
		return w;
	}
	,set_height: function(h) {
		this.yMax = this.yMin + h;
		return h;
	}
	,toString: function() {
		var x = this.xMin;
		var y = this.yMin;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var tmp = "{" + Std.string(new h2d_col_PointImpl(x,y)) + ",";
		var x = this.xMax - this.xMin;
		var y = this.yMax - this.yMin;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return tmp + Std.string(new h2d_col_PointImpl(x,y)) + "}";
	}
	,toCircle: function() {
		var dx = this.xMax - this.xMin;
		var dy = this.yMax - this.yMin;
		return new h2d_col_Circle((this.xMin + this.xMax) * 0.5,(this.yMin + this.yMax) * 0.5,Math.sqrt(dx * dx + dy * dy) * 0.5);
	}
	,__class__: h2d_col_Bounds
});
var h2d_col_Circle = function(x,y,ray) {
	this.x = x;
	this.y = y;
	this.ray = ray;
};
$hxClasses["h2d.col.Circle"] = h2d_col_Circle;
h2d_col_Circle.__name__ = "h2d.col.Circle";
h2d_col_Circle.__super__ = h2d_col_Collider;
h2d_col_Circle.prototype = $extend(h2d_col_Collider.prototype,{
	distanceSq: function(p) {
		var dx = p.x - this.x;
		var dy = p.y - this.y;
		var d = dx * dx + dy * dy - this.ray * this.ray;
		if(d < 0) {
			return 0;
		} else {
			return d;
		}
	}
	,side: function(p) {
		var dx = p.x - this.x;
		var dy = p.y - this.y;
		return this.ray * this.ray - (dx * dx + dy * dy);
	}
	,collideCircle: function(c) {
		var dx = this.x - c.x;
		var dy = this.y - c.y;
		return dx * dx + dy * dy < (this.ray + c.ray) * (this.ray + c.ray);
	}
	,collideBounds: function(b) {
		if(this.x < b.xMin - this.ray) {
			return false;
		}
		if(this.x > b.xMax + this.ray) {
			return false;
		}
		if(this.y < b.yMin - this.ray) {
			return false;
		}
		if(this.y > b.yMax + this.ray) {
			return false;
		}
		var tmp;
		if(this.x < b.xMin && this.y < b.yMin) {
			var dx = this.x - b.xMin;
			var dy = this.y - b.yMin;
			tmp = dx * dx + dy * dy > this.ray * this.ray;
		} else {
			tmp = false;
		}
		if(tmp) {
			return false;
		}
		var tmp;
		if(this.x > b.xMax && this.y < b.yMin) {
			var dx = this.x - b.xMax;
			var dy = this.y - b.yMin;
			tmp = dx * dx + dy * dy > this.ray * this.ray;
		} else {
			tmp = false;
		}
		if(tmp) {
			return false;
		}
		var tmp;
		if(this.x < b.xMin && this.y > b.yMax) {
			var dx = this.x - b.xMin;
			var dy = this.y - b.yMax;
			tmp = dx * dx + dy * dy > this.ray * this.ray;
		} else {
			tmp = false;
		}
		if(tmp) {
			return false;
		}
		var tmp;
		if(this.x > b.xMax && this.y > b.yMax) {
			var dx = this.x - b.xMax;
			var dy = this.y - b.yMax;
			tmp = dx * dx + dy * dy > this.ray * this.ray;
		} else {
			tmp = false;
		}
		if(tmp) {
			return false;
		}
		return true;
	}
	,lineIntersect: function(p1,p2) {
		var dx = p2.x - p1.x;
		var dy = p2.y - p1.y;
		var a = dx * dx + dy * dy;
		if(a < 1e-8) {
			return null;
		}
		var b = 2 * (dx * (p1.x - this.x) + dy * (p1.y - this.y));
		var dx1 = p1.x - this.x;
		var dy1 = p1.y - this.y;
		var c = dx1 * dx1 + dy1 * dy1 - this.ray * this.ray;
		var d = b * b - 4 * a * c;
		if(d < 0) {
			return null;
		}
		if(d == 0) {
			var t = -b / (2 * a);
			var x = p1.x + t * dx;
			var y = p1.y + t * dy;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			return [new h2d_col_PointImpl(x,y)];
		}
		var t1 = (-b - Math.sqrt(d)) / (2 * a);
		var t2 = (-b + Math.sqrt(d)) / (2 * a);
		var x = p1.x + t1 * dx;
		var y = p1.y + t1 * dy;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var this1 = new h2d_col_PointImpl(x,y);
		var x = p1.x + t2 * dx;
		var y = p1.y + t2 * dy;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return [this1,new h2d_col_PointImpl(x,y)];
	}
	,toString: function() {
		return "{" + hxd_Math.fmt(this.x) + "," + hxd_Math.fmt(this.y) + "," + hxd_Math.fmt(this.ray) + "}";
	}
	,contains: function(p) {
		var dx = p.x - this.x;
		var dy = p.y - this.y;
		var d = dx * dx + dy * dy - this.ray * this.ray;
		return (d < 0 ? 0 : d) == 0;
	}
	,__class__: h2d_col_Circle
});
var h2d_col_IBounds = function() {
	this.xMin = 2147483647;
	this.yMin = 2147483647;
	this.xMax = -2147483648;
	this.yMax = -2147483648;
};
$hxClasses["h2d.col.IBounds"] = h2d_col_IBounds;
h2d_col_IBounds.__name__ = "h2d.col.IBounds";
h2d_col_IBounds.fromValues = function(x0,y0,width,height) {
	var b = new h2d_col_IBounds();
	b.xMin = x0;
	b.yMin = y0;
	b.xMax = x0 + width;
	b.yMax = y0 + height;
	return b;
};
h2d_col_IBounds.fromPoints = function(min,max) {
	var b = new h2d_col_IBounds();
	b.xMin = min.x;
	b.yMin = min.y;
	b.xMax = max.x;
	b.yMax = max.y;
	return b;
};
h2d_col_IBounds.prototype = {
	toBounds: function(scale) {
		if(scale == null) {
			scale = 1.;
		}
		var x0 = this.xMin * scale;
		var y0 = this.yMin * scale;
		var width = (this.xMax - this.xMin) * scale;
		var height = (this.yMax - this.yMin) * scale;
		var b = new h2d_col_Bounds();
		b.xMin = x0;
		b.yMin = y0;
		b.xMax = x0 + width;
		b.yMax = y0 + height;
		return b;
	}
	,intersects: function(b) {
		return !(this.xMin > b.xMax || this.yMin > b.yMax || this.xMax < b.xMin || this.yMax < b.yMin);
	}
	,contains: function(p) {
		if(p.x >= this.xMin && p.x < this.xMax && p.y >= this.yMin) {
			return p.y < this.yMax;
		} else {
			return false;
		}
	}
	,addBounds: function(b) {
		if(b.xMin < this.xMin) {
			this.xMin = b.xMin;
		}
		if(b.xMax > this.xMax) {
			this.xMax = b.xMax;
		}
		if(b.yMin < this.yMin) {
			this.yMin = b.yMin;
		}
		if(b.yMax > this.yMax) {
			this.yMax = b.yMax;
		}
	}
	,addPoint: function(p) {
		if(p.x < this.xMin) {
			this.xMin = p.x;
		}
		if(p.x > this.xMax) {
			this.xMax = p.x;
		}
		if(p.y < this.yMin) {
			this.yMin = p.y;
		}
		if(p.y > this.yMax) {
			this.yMax = p.y;
		}
	}
	,addPos: function(x,y) {
		if(x < this.xMin) {
			this.xMin = x;
		}
		if(x > this.xMax) {
			this.xMax = x;
		}
		if(y < this.yMin) {
			this.yMin = y;
		}
		if(y > this.yMax) {
			this.yMax = y;
		}
	}
	,set: function(x,y,width,height) {
		this.xMin = x;
		this.yMin = y;
		this.xMax = x + width;
		this.yMax = y + height;
	}
	,setMin: function(p) {
		this.xMin = p.x;
		this.yMin = p.y;
	}
	,setMax: function(p) {
		this.xMax = p.x;
		this.yMax = p.y;
	}
	,doIntersect: function(b) {
		var a = this.xMin;
		var b1 = b.xMin;
		this.xMin = a < b1 ? b1 : a;
		var a = this.yMin;
		var b1 = b.yMin;
		this.yMin = a < b1 ? b1 : a;
		var a = this.xMax;
		var b1 = b.xMax;
		this.xMax = a > b1 ? b1 : a;
		var a = this.yMax;
		var b1 = b.yMax;
		this.yMax = a > b1 ? b1 : a;
	}
	,doUnion: function(b) {
		var a = this.xMin;
		var b1 = b.xMin;
		this.xMin = a > b1 ? b1 : a;
		var a = this.yMin;
		var b1 = b.yMin;
		this.yMin = a > b1 ? b1 : a;
		var a = this.xMax;
		var b1 = b.xMax;
		this.xMax = a < b1 ? b1 : a;
		var a = this.yMax;
		var b1 = b.yMax;
		this.yMax = a < b1 ? b1 : a;
	}
	,intersection: function(b) {
		var i = new h2d_col_IBounds();
		var a = this.xMin;
		var b1 = b.xMin;
		i.xMin = a < b1 ? b1 : a;
		var a = this.yMin;
		var b1 = b.yMin;
		i.yMin = a < b1 ? b1 : a;
		var a = this.xMax;
		var b1 = b.xMax;
		i.xMax = a > b1 ? b1 : a;
		var a = this.yMax;
		var b1 = b.yMax;
		i.yMax = a > b1 ? b1 : a;
		if(i.xMax < i.xMin) {
			i.xMax = i.xMin;
		}
		if(i.yMax < i.yMin) {
			i.yMax = i.yMin;
		}
		return i;
	}
	,union: function(b) {
		var i = new h2d_col_IBounds();
		var a = this.xMin;
		var b1 = b.xMin;
		i.xMin = a > b1 ? b1 : a;
		var a = this.yMin;
		var b1 = b.yMin;
		i.yMin = a > b1 ? b1 : a;
		var a = this.xMax;
		var b1 = b.xMax;
		i.xMax = a < b1 ? b1 : a;
		var a = this.yMax;
		var b1 = b.yMax;
		i.yMax = a < b1 ? b1 : a;
		return i;
	}
	,load: function(b) {
		this.xMin = b.xMin;
		this.yMin = b.yMin;
		this.xMax = b.xMax;
		this.yMax = b.yMax;
	}
	,offset: function(dx,dy) {
		this.xMin += dx;
		this.xMax += dx;
		this.yMin += dy;
		this.yMax += dy;
	}
	,getMin: function() {
		return new h2d_col_IPoint(this.xMin,this.yMin);
	}
	,getCenter: function() {
		return new h2d_col_IPoint(this.xMin + this.xMax >> 1,this.yMin + this.yMax >> 1);
	}
	,getSize: function() {
		return new h2d_col_IPoint(this.xMax - this.xMin,this.yMax - this.yMin);
	}
	,getMax: function() {
		return new h2d_col_IPoint(this.xMax,this.yMax);
	}
	,isEmpty: function() {
		if(this.xMax > this.xMin) {
			return this.yMax <= this.yMin;
		} else {
			return true;
		}
	}
	,empty: function() {
		this.xMin = 2147483647;
		this.yMin = 2147483647;
		this.xMax = -2147483648;
		this.yMax = -2147483648;
	}
	,all: function() {
		this.xMin = -2147483648;
		this.yMin = -2147483648;
		this.xMax = 2147483647;
		this.yMax = 2147483647;
	}
	,clone: function() {
		var b = new h2d_col_IBounds();
		b.xMin = this.xMin;
		b.yMin = this.yMin;
		b.xMax = this.xMax;
		b.yMax = this.yMax;
		return b;
	}
	,get_x: function() {
		return this.xMin;
	}
	,get_y: function() {
		return this.yMin;
	}
	,set_x: function(x) {
		this.xMax += x - this.xMin;
		return this.xMin = x;
	}
	,set_y: function(y) {
		this.yMax += y - this.yMin;
		return this.yMin = y;
	}
	,get_width: function() {
		return this.xMax - this.xMin;
	}
	,get_height: function() {
		return this.yMax - this.yMin;
	}
	,set_width: function(w) {
		this.xMax = this.xMin + w;
		return w;
	}
	,set_height: function(h) {
		this.yMax = this.yMin + h;
		return h;
	}
	,toString: function() {
		return "{" + Std.string(new h2d_col_IPoint(this.xMin,this.yMin)) + "," + Std.string(new h2d_col_IPoint(this.xMax - this.xMin,this.yMax - this.yMin)) + "}";
	}
	,__class__: h2d_col_IBounds
};
var h2d_col_IPoint = function(x,y) {
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.x = x;
	this.y = y;
};
$hxClasses["h2d.col.IPoint"] = h2d_col_IPoint;
h2d_col_IPoint.__name__ = "h2d.col.IPoint";
h2d_col_IPoint.prototype = {
	load: function(p) {
		this.x = p.x;
		this.y = p.y;
	}
	,scale: function(v) {
		this.x *= v;
		this.y *= v;
	}
	,scaled: function(v) {
		return new h2d_col_IPoint(this.x * v,this.y * v);
	}
	,distanceSq: function(p) {
		var dx = this.x - p.x;
		var dy = this.y - p.y;
		return dx * dx + dy * dy;
	}
	,distance: function(p) {
		var dx = this.x - p.x;
		var dy = this.y - p.y;
		return Math.sqrt(dx * dx + dy * dy);
	}
	,toString: function() {
		return "{" + this.x + "," + this.y + "}";
	}
	,sub: function(p) {
		return new h2d_col_IPoint(this.x - p.x,this.y - p.y);
	}
	,add: function(p) {
		return new h2d_col_IPoint(this.x + p.x,this.y + p.y);
	}
	,equals: function(other) {
		if(this.x == other.x) {
			return this.y == other.y;
		} else {
			return false;
		}
	}
	,dot: function(p) {
		return this.x * p.x + this.y * p.y;
	}
	,lengthSq: function() {
		return this.x * this.x + this.y * this.y;
	}
	,length: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	}
	,set: function(x,y) {
		if(y == null) {
			y = 0;
		}
		if(x == null) {
			x = 0;
		}
		this.x = x;
		this.y = y;
	}
	,clone: function() {
		return new h2d_col_IPoint(this.x,this.y);
	}
	,cross: function(p) {
		return this.x * p.y - this.y * p.x;
	}
	,toPoint: function(scale) {
		if(scale == null) {
			scale = 1.;
		}
		var x = this.x * scale;
		var y = this.y * scale;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h2d_col_PointImpl(x,y);
	}
	,__class__: h2d_col_IPoint
};
var h2d_col_OffsetKind = $hxEnums["h2d.col.OffsetKind"] = { __ename__:true,__constructs__:null
	,Square: {_hx_name:"Square",_hx_index:0,__enum__:"h2d.col.OffsetKind",toString:$estr}
	,Miter: {_hx_name:"Miter",_hx_index:1,__enum__:"h2d.col.OffsetKind",toString:$estr}
	,Round: ($_=function(arc) { return {_hx_index:2,arc:arc,__enum__:"h2d.col.OffsetKind",toString:$estr}; },$_._hx_name="Round",$_.__params__ = ["arc"],$_)
};
h2d_col_OffsetKind.__constructs__ = [h2d_col_OffsetKind.Square,h2d_col_OffsetKind.Miter,h2d_col_OffsetKind.Round];
h2d_col_OffsetKind.__empty_constructs__ = [h2d_col_OffsetKind.Square,h2d_col_OffsetKind.Miter];
var h2d_col_IPolygon = {};
h2d_col_IPolygon.get_length = function(this1) {
	return this1.length;
};
h2d_col_IPolygon.get_points = function(this1) {
	return this1;
};
h2d_col_IPolygon._new = function(points) {
	return points == null ? [] : points;
};
h2d_col_IPolygon.iterator = function(this1) {
	return new hxd_impl_ArrayIterator_$h2d_$col_$IPoint(this1);
};
h2d_col_IPolygon.toPolygon = function(this1,scale) {
	if(scale == null) {
		scale = 1.;
	}
	var _g = [];
	var _g1 = 0;
	var _g2 = this1;
	while(_g1 < _g2.length) {
		var p = _g2[_g1];
		++_g1;
		var scale1 = scale;
		if(scale1 == null) {
			scale1 = 1.;
		}
		var x = p.x * scale1;
		var y = p.y * scale1;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_g.push(new h2d_col_PointImpl(x,y));
	}
	return _g;
};
h2d_col_IPolygon.getBounds = function(this1,b) {
	if(b == null) {
		b = new h2d_col_IBounds();
	}
	var _g = 0;
	var _g1 = this1;
	while(_g < _g1.length) {
		var p = _g1[_g];
		++_g;
		if(p.x < b.xMin) {
			b.xMin = p.x;
		}
		if(p.x > b.xMax) {
			b.xMax = p.x;
		}
		if(p.y < b.yMin) {
			b.yMin = p.y;
		}
		if(p.y > b.yMax) {
			b.yMax = p.y;
		}
	}
	return b;
};
h2d_col_IPolygon.union = function(this1,p,withHoles) {
	if(withHoles == null) {
		withHoles = true;
	}
	var c = new hxd_clipper_Clipper();
	if(!withHoles) {
		c.resultKind = hxd_clipper_ResultKind.NoHoles;
	}
	c.addPolygon(this1,hxd_clipper_PolyType.Clip);
	c.addPolygon(p,hxd_clipper_PolyType.Clip);
	return c.execute(hxd_clipper_ClipType.Union,hxd_clipper_PolyFillType.NonZero,hxd_clipper_PolyFillType.NonZero);
};
h2d_col_IPolygon.intersection = function(this1,p,withHoles) {
	if(withHoles == null) {
		withHoles = true;
	}
	return h2d_col_IPolygon.clipperOp(this1,p,hxd_clipper_ClipType.Intersection,withHoles);
};
h2d_col_IPolygon.subtraction = function(this1,p,withHoles) {
	if(withHoles == null) {
		withHoles = true;
	}
	return h2d_col_IPolygon.clipperOp(this1,p,hxd_clipper_ClipType.Difference,withHoles);
};
h2d_col_IPolygon.offset = function(this1,delta,kind,withHoles) {
	if(withHoles == null) {
		withHoles = true;
	}
	var c = new hxd_clipper_ClipperOffset();
	switch(kind._hx_index) {
	case 0:
		c.addPolygon(this1,hxd_clipper_JoinType.Square,hxd_clipper_EndType.ClosedPol);
		break;
	case 1:
		c.addPolygon(this1,hxd_clipper_JoinType.Miter,hxd_clipper_EndType.ClosedPol);
		break;
	case 2:
		var arc = kind.arc;
		c.ArcTolerance = arc;
		c.addPolygon(this1,hxd_clipper_JoinType.Round,hxd_clipper_EndType.ClosedPol);
		break;
	}
	if(!withHoles) {
		c.resultKind = hxd_clipper_ResultKind.NoHoles;
	}
	return c.execute(delta);
};
h2d_col_IPolygon.clipperOp = function(this1,p,op,withHoles) {
	var c = new hxd_clipper_Clipper();
	if(!withHoles) {
		c.resultKind = hxd_clipper_ResultKind.NoHoles;
	}
	c.addPolygon(this1,hxd_clipper_PolyType.Subject);
	c.addPolygon(p,hxd_clipper_PolyType.Clip);
	return c.execute(op,hxd_clipper_PolyFillType.NonZero,hxd_clipper_PolyFillType.NonZero);
};
h2d_col_IPolygon.convexHull = function(this1) {
	var len = this1.length;
	if(len < 3) {
		throw haxe_Exception.thrown("convexHull() needs at least 3 points");
	}
	var first = 0;
	var firstX = this1[first].x;
	var _g = 1;
	var _g1 = this1.length;
	while(_g < _g1) {
		var i = _g++;
		var px = this1[i].x;
		if(px < firstX) {
			first = i;
			firstX = px;
		}
	}
	var hull = [];
	var curr = first;
	var next = 0;
	do {
		hull.push(this1[curr]);
		next = (curr + 1) % len;
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			var p1 = this1[i];
			var p2 = this1[curr];
			var t = this1[next];
			if((p2.x - p1.x) * (t.y - p1.y) - (p2.y - p1.y) * (t.x - p1.x) < 0) {
				next = i;
			}
		}
		curr = next;
	} while(curr != first);
	return hull;
};
h2d_col_IPolygon.isClockwise = function(this1) {
	var sum = 0.;
	var p1 = this1[this1.length - 1];
	var _g = 0;
	var _g1 = this1;
	while(_g < _g1.length) {
		var p2 = _g1[_g];
		++_g;
		sum += (p2.x - p1.x) * (p2.y + p1.y);
		p1 = p2;
	}
	return sum < 0;
};
h2d_col_IPolygon.area = function(this1) {
	var sum = 0.;
	var p1 = this1[this1.length - 1];
	var _g = 0;
	var _g1 = this1;
	while(_g < _g1.length) {
		var p2 = _g1[_g];
		++_g;
		sum += p1.x * p2.y - p2.x * p1.y;
		p1 = p2;
	}
	return (sum < 0 ? -sum : sum) * 0.5;
};
h2d_col_IPolygon.side = function(this1,p1,p2,t) {
	return (p2.x - p1.x) * (t.y - p1.y) - (p2.y - p1.y) * (t.x - p1.x);
};
h2d_col_IPolygon.isConvex = function(this1) {
	var p1 = this1[this1.length - 2];
	var p2 = this1[this1.length - 1];
	var p3 = this1[0];
	var s = (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x) > 0;
	var _g = 1;
	var _g1 = this1.length;
	while(_g < _g1) {
		var i = _g++;
		p1 = p2;
		p2 = p3;
		p3 = this1[i];
		if((p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x) > 0 != s) {
			return false;
		}
	}
	return true;
};
h2d_col_IPolygon.reverse = function(this1) {
	this1.reverse();
};
h2d_col_IPolygon.contains = function(this1,p,isConvex) {
	if(isConvex == null) {
		isConvex = false;
	}
	if(isConvex) {
		var p1 = this1[this1.length - 1];
		var _g = 0;
		var _g1 = this1;
		while(_g < _g1.length) {
			var p2 = _g1[_g];
			++_g;
			if((p2.x - p1.x) * (p.y - p1.y) - (p2.y - p1.y) * (p.x - p1.x) < 0) {
				return false;
			}
			p1 = p2;
		}
		return true;
	} else {
		var w = 0;
		var p1 = this1[this1.length - 1];
		var _g = 0;
		var _g1 = this1;
		while(_g < _g1.length) {
			var p2 = _g1[_g];
			++_g;
			if(p2.y <= p.y) {
				if(p1.y > p.y && (p1.x - p2.x) * (p.y - p2.y) - (p1.y - p2.y) * (p.x - p2.x) > 0) {
					++w;
				}
			} else if(p1.y <= p.y && (p1.x - p2.x) * (p.y - p2.y) - (p1.y - p2.y) * (p.x - p2.x) < 0) {
				--w;
			}
			p1 = p2;
		}
		return w != 0;
	}
};
h2d_col_IPolygon.optimize = function(this1,epsilon) {
	var out = [];
	h2d_col_IPolygon.optimizeRec(this1,0,this1.length,out,epsilon);
	return out;
};
h2d_col_IPolygon.optimizeRec = function(points,index,len,out,epsilon) {
	var dmax = 0.;
	var pfirst = points[index];
	var plast = points[len - 1];
	var _g = index + 1;
	var _g1 = len - 1;
	while(_g < _g1) {
		var i = _g++;
		var p0 = points[i];
		var A = p0.x - pfirst.x;
		var B = p0.y - pfirst.y;
		var C = plast.x - pfirst.x;
		var D = plast.y - pfirst.y;
		var dot = A * C + B * D;
		var dist = C * C + D * D;
		var param = -1.;
		if(dist != 0) {
			param = dot / dist;
		}
		var xx;
		var yy;
		if(param < 0) {
			xx = pfirst.x;
			yy = pfirst.y;
		} else if(param > 1) {
			xx = plast.x;
			yy = plast.y;
		} else {
			xx = pfirst.x + param * C;
			yy = pfirst.y + param * D;
		}
		var dx = p0.x - xx;
		var dy = p0.y - yy;
		var d = dx * dx + dy * dy;
		if(d > dmax) {
			index = i;
			dmax = d;
		}
	}
	if(dmax >= epsilon) {
		h2d_col_IPolygon.optimizeRec(points,0,index,out,epsilon);
		out.pop();
		h2d_col_IPolygon.optimizeRec(points,index,len,out,epsilon);
	} else {
		out.push(points[index]);
		out.push(points[len - 1]);
	}
};
var h2d_col_IPolygons = {};
h2d_col_IPolygons.get_length = function(this1) {
	return this1.length;
};
h2d_col_IPolygons.get_polygons = function(this1) {
	return this1;
};
h2d_col_IPolygons._new = function(polygons) {
	return polygons == null ? [] : polygons;
};
h2d_col_IPolygons.iterator = function(this1) {
	return new hxd_impl_ArrayIterator_$h2d_$col_$IPolygon(this1);
};
h2d_col_IPolygons.toPolygons = function(this1,scale) {
	if(scale == null) {
		scale = 1.;
	}
	var _g = [];
	var _g1 = 0;
	var _g2 = this1;
	while(_g1 < _g2.length) {
		var p = _g2[_g1];
		++_g1;
		_g.push(h2d_col_IPolygon.toPolygon(p,scale));
	}
	return _g;
};
h2d_col_IPolygons.getBounds = function(this1,b) {
	if(b == null) {
		b = new h2d_col_IBounds();
	}
	var _g = 0;
	var _g1 = this1;
	while(_g < _g1.length) {
		var p = _g1[_g];
		++_g;
		h2d_col_IPolygon.getBounds(p,b);
	}
	return b;
};
h2d_col_IPolygons.union = function(this1,p,withHoles) {
	if(withHoles == null) {
		withHoles = true;
	}
	var c = new hxd_clipper_Clipper();
	if(!withHoles) {
		c.resultKind = hxd_clipper_ResultKind.NoHoles;
	}
	c.addPolygons(this1,hxd_clipper_PolyType.Clip);
	if(p != null) {
		c.addPolygons(p,hxd_clipper_PolyType.Clip);
	}
	return c.execute(hxd_clipper_ClipType.Union,hxd_clipper_PolyFillType.NonZero,hxd_clipper_PolyFillType.NonZero);
};
h2d_col_IPolygons.intersection = function(this1,p,withHoles) {
	if(withHoles == null) {
		withHoles = true;
	}
	return h2d_col_IPolygons.clipperOp(this1,p,hxd_clipper_ClipType.Intersection,withHoles);
};
h2d_col_IPolygons.subtraction = function(this1,p,withHoles) {
	if(withHoles == null) {
		withHoles = true;
	}
	return h2d_col_IPolygons.clipperOp(this1,p,hxd_clipper_ClipType.Difference,withHoles);
};
h2d_col_IPolygons.offset = function(this1,delta,kind,withHoles) {
	if(withHoles == null) {
		withHoles = true;
	}
	if(this1.length == 0) {
		var polygons = null;
		return polygons == null ? [] : polygons;
	}
	var c = new hxd_clipper_ClipperOffset();
	switch(kind._hx_index) {
	case 0:
		c.addPolygons(this1,hxd_clipper_JoinType.Square,hxd_clipper_EndType.ClosedPol);
		break;
	case 1:
		c.addPolygons(this1,hxd_clipper_JoinType.Miter,hxd_clipper_EndType.ClosedPol);
		break;
	case 2:
		var arc = kind.arc;
		c.ArcTolerance = arc;
		c.addPolygons(this1,hxd_clipper_JoinType.Round,hxd_clipper_EndType.ClosedPol);
		break;
	}
	if(!withHoles) {
		c.resultKind = hxd_clipper_ResultKind.NoHoles;
	}
	return c.execute(delta);
};
h2d_col_IPolygons.clipperOp = function(this1,p,op,withHoles) {
	var c = new hxd_clipper_Clipper();
	if(!withHoles) {
		c.resultKind = hxd_clipper_ResultKind.NoHoles;
	}
	c.addPolygons(this1,hxd_clipper_PolyType.Subject);
	c.addPolygons(p,hxd_clipper_PolyType.Clip);
	return c.execute(op,hxd_clipper_PolyFillType.NonZero,hxd_clipper_PolyFillType.NonZero);
};
h2d_col_IPolygons.contains = function(this1,p,isConvex) {
	if(isConvex == null) {
		isConvex = false;
	}
	var _g = 0;
	var _g1 = this1;
	while(_g < _g1.length) {
		var pl = _g1[_g];
		++_g;
		if(h2d_col_IPolygon.contains(pl,p,isConvex)) {
			return true;
		}
	}
	return false;
};
h2d_col_IPolygons.optimize = function(this1,epsilon) {
	var _g = [];
	var _g1 = 0;
	var _g2 = this1;
	while(_g1 < _g2.length) {
		var p = _g2[_g1];
		++_g1;
		_g.push(h2d_col_IPolygon.optimize(p,epsilon));
	}
	return _g;
};
var h2d_col_Matrix = function() {
	this.a = 1;
	this.b = 0;
	this.c = 0;
	this.d = 1;
	this.x = 0;
	this.y = 0;
};
$hxClasses["h2d.col.Matrix"] = h2d_col_Matrix;
h2d_col_Matrix.__name__ = "h2d.col.Matrix";
h2d_col_Matrix.prototype = {
	identity: function() {
		this.a = 1;
		this.b = 0;
		this.c = 0;
		this.d = 1;
		this.x = 0;
		this.y = 0;
	}
	,initTranslate: function(x,y) {
		this.a = 1;
		this.b = 0;
		this.c = 0;
		this.d = 1;
		this.x = x;
		this.y = y;
	}
	,initScale: function(sx,sy) {
		this.a = sx;
		this.b = 0;
		this.c = 0;
		this.d = sy;
		this.x = 0;
		this.y = 0;
	}
	,initRotate: function(angle) {
		var cos = Math.cos(angle);
		var sin = Math.sin(angle);
		this.a = cos;
		this.b = sin;
		this.c = -sin;
		this.d = cos;
		this.x = 0;
		this.y = 0;
	}
	,initSkew: function(sx,sy) {
		var tanX = Math.tan(sx);
		var tanY = Math.tan(sy);
		this.a = 1;
		this.b = tanY;
		this.c = tanX;
		this.d = 1;
		this.x = 0;
		this.y = 0;
	}
	,invert: function() {
		this.inverse(this);
	}
	,getDeterminant: function() {
		return this.a * this.d - this.b * this.c;
	}
	,inverse: function(m) {
		var a = m.a;
		var b = m.b;
		var c = m.c;
		var d = m.d;
		var x = m.x;
		var y = m.y;
		var invDet = 1 / (m.a * m.d - m.b * m.c);
		this.a = d * invDet;
		this.b = -b * invDet;
		this.c = -c * invDet;
		this.d = a * invDet;
		this.x = (-x * d + c * y) * invDet;
		this.y = (x * b - a * y) * invDet;
	}
	,transform: function(pt) {
		var x = pt.x * this.a + pt.y * this.c + this.x;
		var y = pt.x * this.b + pt.y * this.d + this.y;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h2d_col_PointImpl(x,y);
	}
	,translate: function(x,y) {
		this.x += x;
		this.y += y;
	}
	,translateX: function(x) {
		this.x += x;
	}
	,translateY: function(y) {
		this.y += y;
	}
	,prependTranslate: function(x,y) {
		this.x += this.a * x + this.c * y;
		this.y += this.b * x + this.d * y;
	}
	,prependTranslateX: function(x) {
		this.x += this.a * x;
	}
	,prependTranslateY: function(y) {
		this.y += this.d * y;
	}
	,multiply: function(a,b) {
		var aa = a.a;
		var ab = a.b;
		var ac = a.c;
		var ad = a.d;
		var ax = a.x;
		var ay = a.y;
		var ba = b.a;
		var bb = b.b;
		var bc = b.c;
		var bd = b.d;
		var bx = b.x;
		var by = b.y;
		this.a = aa * ba + ab * bc;
		this.b = aa * bb + ab * bd;
		this.c = ac * ba + ad * bc;
		this.d = ac * bb + ad * bd;
		this.x = ax * ba + ay * bc + bx;
		this.y = ax * bb + ay * bd + by;
	}
	,getScale: function() {
		var p = new h2d_col_PointImpl(0.,0.);
		p.x = Math.sqrt(this.a * this.a + this.b * this.b);
		p.y = Math.sqrt(this.c * this.c + this.d * this.d);
		if(this.a * this.d - this.b * this.c < 0) {
			p.x *= -1;
			p.y *= -1;
		}
		return p;
	}
	,scale: function(sx,sy) {
		this.a *= sx;
		this.c *= sx;
		this.x *= sx;
		this.b *= sy;
		this.d *= sy;
		this.y *= sy;
	}
	,scaleX: function(sx) {
		this.a *= sx;
		this.c *= sx;
		this.x *= sx;
	}
	,scaleY: function(sy) {
		this.b *= sy;
		this.d *= sy;
		this.y *= sy;
	}
	,rotate: function(angle) {
		var _this = h2d_col_Matrix.tmp;
		var cos = Math.cos(angle);
		var sin = Math.sin(angle);
		_this.a = cos;
		_this.b = sin;
		_this.c = -sin;
		_this.d = cos;
		_this.x = 0;
		_this.y = 0;
		this.multiply(this,h2d_col_Matrix.tmp);
	}
	,skew: function(sx,sy) {
		var aa = this.a;
		var ab = this.b;
		var ac = this.c;
		var ad = this.d;
		var ax = this.x;
		var ay = this.y;
		var bb = Math.tan(sy);
		var bc = Math.tan(sx);
		this.a = aa + ab * bc;
		this.b = aa * bb + ab;
		this.c = ac + ad * bc;
		this.d = ac * bb + ad;
		this.x = ax + ay * bc;
		this.y = ax * bb + ay;
	}
	,skewX: function(sx) {
		var bc = Math.tan(sx);
		this.a += this.b * bc;
		this.c += this.d * bc;
		this.x += this.y * bc;
	}
	,skewY: function(sy) {
		var bb = Math.tan(sy);
		this.b = this.a * bb + this.b;
		this.d = this.c * bb + this.d;
		this.y = this.x * bb + this.y;
	}
	,clone: function() {
		var m = new h2d_col_Matrix();
		m.a = this.a;
		m.b = this.b;
		m.c = this.c;
		m.d = this.d;
		m.x = this.x;
		m.y = this.y;
		return m;
	}
	,getPosition: function(p) {
		if(p == null) {
			p = new h2d_col_PointImpl(0.,0.);
		}
		var _this = p;
		var x = this.x;
		var y = this.y;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		return p;
	}
	,toString: function() {
		return "MAT=[\n" + "  [ " + hxd_Math.fmt(this.a) + ", " + hxd_Math.fmt(this.b) + " ]\n" + "  [ " + hxd_Math.fmt(this.c) + ", " + hxd_Math.fmt(this.d) + " ]\n" + "  [ " + hxd_Math.fmt(this.x) + ", " + hxd_Math.fmt(this.y) + " ]\n" + "]";
	}
	,__class__: h2d_col_Matrix
};
var h2d_col_Point = {};
h2d_col_Point._new = function(x,y) {
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h2d_col_PointImpl(x,y);
};
h2d_col_Point.sub = function(this1,p) {
	var x = this1.x - p.x;
	var y = this1.y - p.y;
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h2d_col_PointImpl(x,y);
};
h2d_col_Point.add = function(this1,p) {
	var x = this1.x + p.x;
	var y = this1.y + p.y;
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h2d_col_PointImpl(x,y);
};
h2d_col_Point.transform = function(this1,m) {
	var mx = m.a * this1.x + m.c * this1.y + m.x;
	var my = m.b * this1.x + m.d * this1.y + m.y;
	this1.x = mx;
	this1.y = my;
};
h2d_col_Point.transformed = function(this1,m) {
	var mx = m.a * this1.x + m.c * this1.y + m.x;
	var my = m.b * this1.x + m.d * this1.y + m.y;
	var x = mx;
	var y = my;
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h2d_col_PointImpl(x,y);
};
h2d_col_Point.scale = function(this1,v) {
	this1.x *= v;
	this1.y *= v;
};
h2d_col_Point.scaled = function(this1,v) {
	var x = this1.x * v;
	var y = this1.y * v;
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h2d_col_PointImpl(x,y);
};
h2d_col_Point.scaledInv = function(f,p) {
	var x = p.x * f;
	var y = p.y * f;
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h2d_col_PointImpl(x,y);
};
var h2d_col_Polygon = {};
h2d_col_Polygon.get_length = function(this1) {
	return this1.length;
};
h2d_col_Polygon.get_points = function(this1) {
	return this1;
};
h2d_col_Polygon._new = function(points) {
	return points == null ? [] : points;
};
h2d_col_Polygon.iterator = function(this1) {
	return new hxd_impl_ArrayIterator_$h2d_$col_$Point(this1);
};
h2d_col_Polygon.fastTriangulate = function(this1) {
	return new hxd_earcut_Earcut().triangulate_anon_y_Float_x_Float(this1);
};
h2d_col_Polygon.toSegments = function(this1) {
	var segments = [];
	var p1 = this1[this1.length - 1];
	var _g = 0;
	var _g1 = this1;
	while(_g < _g1.length) {
		var p2 = _g1[_g];
		++_g;
		var s = new h2d_col_Segment(p1,p2);
		segments.push(s);
		p1 = p2;
	}
	return segments;
};
h2d_col_Polygon.toIPolygon = function(this1,scale) {
	if(scale == null) {
		scale = 1.;
	}
	var _g = [];
	var _g1 = 0;
	var _g2 = this1;
	while(_g1 < _g2.length) {
		var p = _g2[_g1];
		++_g1;
		var _this = p;
		var scale1 = scale;
		if(scale1 == null) {
			scale1 = 1.;
		}
		_g.push(new h2d_col_IPoint(Math.round(_this.x * scale1),Math.round(_this.y * scale1)));
	}
	return _g;
};
h2d_col_Polygon.getBounds = function(this1,b) {
	if(b == null) {
		b = new h2d_col_Bounds();
	}
	var _g = 0;
	var _g1 = this1;
	while(_g < _g1.length) {
		var p = _g1[_g];
		++_g;
		if(p.x < b.xMin) {
			b.xMin = p.x;
		}
		if(p.x > b.xMax) {
			b.xMax = p.x;
		}
		if(p.y < b.yMin) {
			b.yMin = p.y;
		}
		if(p.y > b.yMax) {
			b.yMax = p.y;
		}
	}
	return b;
};
h2d_col_Polygon.getCollider = function(this1,isConvex) {
	if(isConvex == null) {
		isConvex = false;
	}
	return new h2d_col_PolygonCollider([this1],isConvex);
};
h2d_col_Polygon.xSort = function(this1,a,b) {
	if(a.x == b.x) {
		if(a.y < b.y) {
			return -1;
		} else {
			return 1;
		}
	}
	if(a.x < b.x) {
		return -1;
	} else {
		return 1;
	}
};
h2d_col_Polygon.convexHull = function(this1) {
	var len = this1.length;
	if(this1.length < 3) {
		return this1;
	}
	this1.sort(function(a,b) {
		if(a.x == b.x) {
			if(a.y < b.y) {
				return -1;
			} else {
				return 1;
			}
		} else if(a.x < b.x) {
			return -1;
		} else {
			return 1;
		}
	});
	var hull = [];
	var k = 0;
	var _g = 0;
	var _g1 = this1;
	while(_g < _g1.length) {
		var p = _g1[_g];
		++_g;
		while(true) {
			var tmp;
			if(k >= 2) {
				var p1 = hull[k - 2];
				var p2 = hull[k - 1];
				tmp = (p2.x - p1.x) * (p.y - p1.y) - (p2.y - p1.y) * (p.x - p1.x) <= 0;
			} else {
				tmp = false;
			}
			if(!tmp) {
				break;
			}
			--k;
		}
		hull[k++] = p;
	}
	var i = this1.length - 2;
	var len = k + 1;
	while(i >= 0) {
		var p = this1[i];
		while(true) {
			var tmp;
			if(k >= len) {
				var p1 = hull[k - 2];
				var p2 = hull[k - 1];
				tmp = (p2.x - p1.x) * (p.y - p1.y) - (p2.y - p1.y) * (p.x - p1.x) <= 0;
			} else {
				tmp = false;
			}
			if(!tmp) {
				break;
			}
			--k;
		}
		hull[k++] = p;
		--i;
	}
	while(hull.length >= k) hull.pop();
	return hull;
};
h2d_col_Polygon.isClockwise = function(this1) {
	var sum = 0.;
	var p1 = this1[this1.length - 1];
	var _g = 0;
	var _g1 = this1;
	while(_g < _g1.length) {
		var p2 = _g1[_g];
		++_g;
		sum += (p2.x - p1.x) * (p2.y + p1.y);
		p1 = p2;
	}
	return sum < 0;
};
h2d_col_Polygon.area = function(this1) {
	var sum = 0.;
	var p1 = this1[this1.length - 1];
	var _g = 0;
	var _g1 = this1;
	while(_g < _g1.length) {
		var p2 = _g1[_g];
		++_g;
		sum += p2.x * p1.y - p1.x * p2.y;
		p1 = p2;
	}
	return (sum < 0 ? -sum : sum) * 0.5;
};
h2d_col_Polygon.centroid = function(this1) {
	var A = 0.;
	var cx = 0.;
	var cy = 0.;
	var p0 = this1[this1.length - 1];
	var _g = 0;
	var _g1 = this1;
	while(_g < _g1.length) {
		var p = _g1[_g];
		++_g;
		var a = p0.x * p.y - p.x * p0.y;
		cx += (p0.x + p.x) * a;
		cy += (p0.y + p.y) * a;
		A += a;
		p0 = p;
	}
	A *= 0.5;
	cx *= 1 / (6 * A);
	cy *= 1 / (6 * A);
	var x = cx;
	var y = cy;
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h2d_col_PointImpl(x,y);
};
h2d_col_Polygon.side = function(this1,p1,p2,t) {
	return (p2.x - p1.x) * (t.y - p1.y) - (p2.y - p1.y) * (t.x - p1.x);
};
h2d_col_Polygon.isConvex = function(this1) {
	if(this1.length < 4) {
		return true;
	}
	var p1 = this1[this1.length - 2];
	var p2 = this1[this1.length - 1];
	var p3 = this1[0];
	var s = (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x) > 0;
	var _g = 1;
	var _g1 = this1.length;
	while(_g < _g1) {
		var i = _g++;
		p1 = p2;
		p2 = p3;
		p3 = this1[i];
		if((p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x) > 0 != s) {
			return false;
		}
	}
	return true;
};
h2d_col_Polygon.reverse = function(this1) {
	this1.reverse();
};
h2d_col_Polygon.transform = function(this1,mat) {
	var _g = 0;
	var _g1 = this1.length;
	while(_g < _g1) {
		var i = _g++;
		var this2 = this1[i];
		var mx = mat.a * this2.x + mat.c * this2.y + mat.x;
		var my = mat.b * this2.x + mat.d * this2.y + mat.y;
		this2.x = mx;
		this2.y = my;
	}
};
h2d_col_Polygon.transformed = function(this1,mat) {
	var ret = this1.slice();
	var _g = 0;
	var _g1 = ret.length;
	while(_g < _g1) {
		var i = _g++;
		var this1 = ret[i];
		var mx = mat.a * this1.x + mat.c * this1.y + mat.x;
		var my = mat.b * this1.x + mat.d * this1.y + mat.y;
		var x = mx;
		var y = my;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		ret[i] = new h2d_col_PointImpl(x,y);
	}
	return ret == null ? [] : ret;
};
h2d_col_Polygon.contains = function(this1,p,isConvex) {
	if(isConvex == null) {
		isConvex = false;
	}
	if(isConvex) {
		var p1 = this1[this1.length - 1];
		var _g = 0;
		var _g1 = this1;
		while(_g < _g1.length) {
			var p2 = _g1[_g];
			++_g;
			if((p2.x - p1.x) * (p.y - p1.y) - (p2.y - p1.y) * (p.x - p1.x) < 0) {
				return false;
			}
			p1 = p2;
		}
		return true;
	} else {
		var w = 0;
		var p1 = this1[this1.length - 1];
		var _g = 0;
		var _g1 = this1;
		while(_g < _g1.length) {
			var p2 = _g1[_g];
			++_g;
			if(p2.y <= p.y) {
				if(p1.y > p.y && (p1.x - p2.x) * (p.y - p2.y) - (p1.y - p2.y) * (p.x - p2.x) > 0) {
					++w;
				}
			} else if(p1.y <= p.y && (p1.x - p2.x) * (p.y - p2.y) - (p1.y - p2.y) * (p.x - p2.x) < 0) {
				--w;
			}
			p1 = p2;
		}
		return w != 0;
	}
};
h2d_col_Polygon.findClosestPoint = function(this1,pt,maxDist) {
	var closest = null;
	var minDist = maxDist * maxDist;
	var _g = 0;
	var _g1 = this1;
	while(_g < _g1.length) {
		var cp = _g1[_g];
		++_g;
		var _this = cp;
		var dx = _this.x - pt.x;
		var dy = _this.y - pt.y;
		var sqDist = dx * dx + dy * dy;
		if(sqDist < minDist) {
			closest = cp;
			minDist = sqDist;
		}
	}
	return closest;
};
h2d_col_Polygon.projectPoint = function(this1,pt,out) {
	var p1 = this1[this1.length - 1];
	var x = 0.;
	var y = 0.;
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	var _this_x = x;
	var _this_y = y;
	if(out == null) {
		out = new h2d_col_PointImpl(0.,0.);
	}
	var minDistSq = 1e10;
	var _g = 0;
	var _g1 = this1;
	while(_g < _g1.length) {
		var p2 = _g1[_g];
		++_g;
		var p11 = p1;
		var p21 = p2;
		var _this_x1 = p11.x;
		var _this_y1 = p11.y;
		var _this_dx = p21.x - _this_x1;
		var _this_dy = p21.y - _this_y1;
		var _this_lenSq = _this_dx * _this_dx + _this_dy * _this_dy;
		var _this_invLenSq = 1 / _this_lenSq;
		var out1 = out;
		var px = pt.x - _this_x1;
		var py = pt.y - _this_y1;
		var t = px * _this_dx + py * _this_dy;
		if(out1 == null) {
			out1 = new h2d_col_PointImpl(0.,0.);
		}
		if(t < 0) {
			var _this = out1;
			var x = _this_x1;
			var y = _this_y1;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
		} else if(t > _this_lenSq) {
			var _this1 = out1;
			var x1 = _this_x1 + _this_dx;
			var y1 = _this_y1 + _this_dy;
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			_this1.x = x1;
			_this1.y = y1;
		} else {
			var tl2 = t * _this_invLenSq;
			var _this2 = out1;
			var x2 = _this_x1 + tl2 * _this_dx;
			var y2 = _this_y1 + tl2 * _this_dy;
			if(y2 == null) {
				y2 = 0.;
			}
			if(x2 == null) {
				x2 = 0.;
			}
			_this2.x = x2;
			_this2.y = y2;
		}
		var _this3 = out;
		var dx = _this3.x - pt.x;
		var dy = _this3.y - pt.y;
		var distSq = dx * dx + dy * dy;
		if(distSq < minDistSq) {
			_this_x = out.x;
			_this_y = out.y;
			minDistSq = distSq;
		}
		p1 = p2;
	}
	var _this = out;
	_this.x = _this_x;
	_this.y = _this_y;
	return out;
};
h2d_col_Polygon.distance = function(this1,pt,outside) {
	return Math.sqrt(h2d_col_Polygon.distanceSq(this1,pt,outside));
};
h2d_col_Polygon.distanceSq = function(this1,pt,outside) {
	var p1 = this1[this1.length - 1];
	var minDistSq = 1e10;
	var _g = 0;
	var _g1 = this1;
	while(_g < _g1.length) {
		var p2 = _g1[_g];
		++_g;
		var p11 = p1;
		var p21 = p2;
		var s_x = p11.x;
		var s_y = p11.y;
		var s_dx = p21.x - s_x;
		var s_dy = p21.y - s_y;
		var s_lenSq = s_dx * s_dx + s_dy * s_dy;
		var s_invLenSq = 1 / s_lenSq;
		if(outside == null || s_dx * (pt.y - s_y) - s_dy * (pt.x - s_x) < 0 == outside) {
			var px = pt.x - s_x;
			var py = pt.y - s_y;
			var t = px * s_dx + py * s_dy;
			var dist;
			if(t < 0) {
				dist = px * px + py * py;
			} else if(t > s_lenSq) {
				var kx = pt.x - (s_x + s_dx);
				var ky = pt.y - (s_y + s_dy);
				dist = kx * kx + ky * ky;
			} else {
				var tl2 = t * s_invLenSq;
				var pdx = s_x + tl2 * s_dx - pt.x;
				var pdy = s_y + tl2 * s_dy - pt.y;
				dist = pdx * pdx + pdy * pdy;
			}
			if(dist < minDistSq) {
				minDistSq = dist;
			}
		}
		p1 = p2;
	}
	if(minDistSq == 1e10) {
		return 0.;
	} else {
		return minDistSq;
	}
};
h2d_col_Polygon.rayIntersection = function(this1,r,bestMatch,oriented) {
	if(oriented == null) {
		oriented = false;
	}
	var dmin = -1.;
	var p0 = this1[this1.length - 1];
	var _g = 0;
	var _g1 = this1;
	while(_g < _g1.length) {
		var p = _g1[_g];
		++_g;
		if((r.lx * (p0.y - r.py) - r.ly * (p0.x - r.px)) * (r.lx * (p.y - r.py) - r.ly * (p.x - r.px)) > 0) {
			p0 = p;
			continue;
		}
		var u = (r.lx * (p0.y - r.py) - r.ly * (p0.x - r.px)) / (r.ly * (p.x - p0.x) - r.lx * (p.y - p0.y));
		var x = p0.x + u * (p.x - p0.x);
		var y = p0.y + u * (p.y - p0.y);
		var x1 = x - r.px;
		var y1 = y - r.py;
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var x2 = x1;
		var y2 = y1;
		if(y2 == null) {
			y2 = 0.;
		}
		if(x2 == null) {
			x2 = 0.;
		}
		var v_x = x2;
		var v_y = y2;
		var tmp;
		if(!(!oriented)) {
			var x3 = r.lx;
			var y3 = r.ly;
			if(y3 == null) {
				y3 = 0.;
			}
			if(x3 == null) {
				x3 = 0.;
			}
			var x4 = x3;
			var y4 = y3;
			if(y4 == null) {
				y4 = 0.;
			}
			if(x4 == null) {
				x4 = 0.;
			}
			var _this_x = x4;
			var _this_y = y4;
			tmp = _this_x * v_x + _this_y * v_y > 0;
		} else {
			tmp = true;
		}
		if(tmp) {
			var dx = v_x;
			var dy = v_y;
			var d = dx * dx + dy * dy;
			if(d < dmin || dmin < 0) {
				if(!bestMatch) {
					return Math.sqrt(d);
				}
				dmin = d;
			}
		}
		p0 = p;
	}
	if(dmin < 0) {
		return dmin;
	} else {
		return Math.sqrt(dmin);
	}
};
h2d_col_Polygon.orientation = function(this1,p,q,r) {
	var v = (q.x - p.x) * (r.y - p.y) - (q.y - p.y) * (r.x - p.x);
	if(v == 0) {
		return 0;
	}
	if(v > 0) {
		return 1;
	} else {
		return -1;
	}
};
h2d_col_Polygon.onSegment = function(this1,p,q,r) {
	var a = p.x;
	var b = q.x;
	if(r.x > (a < b ? b : a)) {
		return false;
	}
	var a = p.x;
	var b = q.x;
	if(r.x < (a > b ? b : a)) {
		return false;
	}
	var a = p.y;
	var b = q.y;
	if(r.y > (a < b ? b : a)) {
		return false;
	}
	var a = p.y;
	var b = q.y;
	if(r.y < (a > b ? b : a)) {
		return false;
	}
	return true;
};
h2d_col_Polygon.intersect = function(this1,p1,q1,p2,q2) {
	var v = (q1.x - p1.x) * (p2.y - p1.y) - (q1.y - p1.y) * (p2.x - p1.x);
	var s1 = v == 0 ? 0 : v > 0 ? 1 : -1;
	var v = (q1.x - p1.x) * (q2.y - p1.y) - (q1.y - p1.y) * (q2.x - p1.x);
	var s2 = v == 0 ? 0 : v > 0 ? 1 : -1;
	var v = (q2.x - p2.x) * (p1.y - p2.y) - (q2.y - p2.y) * (p1.x - p2.x);
	var s3 = v == 0 ? 0 : v > 0 ? 1 : -1;
	var v = (q2.x - p2.x) * (q1.y - p2.y) - (q2.y - p2.y) * (q1.x - p2.x);
	var s4 = v == 0 ? 0 : v > 0 ? 1 : -1;
	if(s1 != s2 && s3 != s4) {
		return true;
	}
	var tmp;
	var tmp1;
	var tmp2;
	var tmp3;
	if(s1 == 0) {
		var a = p1.x;
		var b = q1.x;
		if(p2.x > (a < b ? b : a)) {
			tmp3 = false;
		} else {
			var a = p1.x;
			var b = q1.x;
			if(p2.x < (a > b ? b : a)) {
				tmp3 = false;
			} else {
				var a = p1.y;
				var b = q1.y;
				if(p2.y > (a < b ? b : a)) {
					tmp3 = false;
				} else {
					var a = p1.y;
					var b = q1.y;
					tmp3 = p2.y < (a > b ? b : a) ? false : true;
				}
			}
		}
	} else {
		tmp3 = false;
	}
	if(!tmp3) {
		if(s2 == 0) {
			var a = p1.x;
			var b = q1.x;
			if(q2.x > (a < b ? b : a)) {
				tmp2 = false;
			} else {
				var a = p1.x;
				var b = q1.x;
				if(q2.x < (a > b ? b : a)) {
					tmp2 = false;
				} else {
					var a = p1.y;
					var b = q1.y;
					if(q2.y > (a < b ? b : a)) {
						tmp2 = false;
					} else {
						var a = p1.y;
						var b = q1.y;
						tmp2 = q2.y < (a > b ? b : a) ? false : true;
					}
				}
			}
		} else {
			tmp2 = false;
		}
	} else {
		tmp2 = true;
	}
	if(!tmp2) {
		if(s3 == 0) {
			var a = p2.x;
			var b = q2.x;
			if(p1.x > (a < b ? b : a)) {
				tmp1 = false;
			} else {
				var a = p2.x;
				var b = q2.x;
				if(p1.x < (a > b ? b : a)) {
					tmp1 = false;
				} else {
					var a = p2.y;
					var b = q2.y;
					if(p1.y > (a < b ? b : a)) {
						tmp1 = false;
					} else {
						var a = p2.y;
						var b = q2.y;
						tmp1 = p1.y < (a > b ? b : a) ? false : true;
					}
				}
			}
		} else {
			tmp1 = false;
		}
	} else {
		tmp1 = true;
	}
	if(!tmp1) {
		if(s4 == 0) {
			var a = p2.x;
			var b = q2.x;
			if(q1.x > (a < b ? b : a)) {
				tmp = false;
			} else {
				var a = p2.x;
				var b = q2.x;
				if(q1.x < (a > b ? b : a)) {
					tmp = false;
				} else {
					var a = p2.y;
					var b = q2.y;
					if(q1.y > (a < b ? b : a)) {
						tmp = false;
					} else {
						var a = p2.y;
						var b = q2.y;
						tmp = q1.y < (a > b ? b : a) ? false : true;
					}
				}
			}
		} else {
			tmp = false;
		}
	} else {
		tmp = true;
	}
	if(tmp) {
		return true;
	}
	return false;
};
h2d_col_Polygon.getIntersectionPoint = function(this1,a,b,c,d) {
	if(!h2d_col_Polygon.intersect(this1,a,b,c,d)) {
		return null;
	}
	var a1 = b.y - a.y;
	var b1 = a.x - b.x;
	var c1 = a1 * a.x + b1 * a.y;
	var a2 = d.y - c.y;
	var b2 = c.x - d.x;
	var c2 = a2 * c.x + b2 * c.y;
	var determinant = a1 * b2 - a2 * b1;
	if(determinant == 0) {
		return null;
	}
	var x = (b2 * c1 - b1 * c2) / determinant;
	var y = (a1 * c2 - a2 * c1) / determinant;
	var x1 = x;
	var y1 = y;
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	return new h2d_col_PointImpl(x1,y1);
};
h2d_col_Polygon.selfIntersecting = function(this1) {
	if(this1.length < 4) {
		return false;
	}
	var _g = 0;
	var _g1 = this1.length - 2;
	while(_g < _g1) {
		var i = _g++;
		var p1 = this1[i];
		var q1 = this1[i + 1];
		var _g2 = i + 2;
		var _g3 = this1.length;
		while(_g2 < _g3) {
			var j = _g2++;
			var p2 = this1[j];
			var q2 = this1[(j + 1) % this1.length];
			if(q2 != p1 && h2d_col_Polygon.intersect(this1,p1,q1,p2,q2)) {
				return true;
			}
		}
	}
	return false;
};
h2d_col_Polygon.optimize = function(this1,epsilon) {
	var out = [];
	h2d_col_Polygon.optimizeRec(this1,0,this1.length - 1,out,epsilon);
	return out;
};
h2d_col_Polygon.optimizeRec = function(points,start,end,out,epsilon) {
	var dmax = 0.;
	var pfirst = points[start];
	var plast = points[end];
	var index = 0;
	var _g = start + 1;
	var _g1 = end;
	while(_g < _g1) {
		var i = _g++;
		var p0 = points[i];
		var A = p0.x - pfirst.x;
		var B = p0.y - pfirst.y;
		var C = plast.x - pfirst.x;
		var D = plast.y - pfirst.y;
		var dot = A * C + B * D;
		var dist = C * C + D * D;
		var param = -1.;
		if(dist != 0) {
			param = dot / dist;
		}
		var xx;
		var yy;
		if(param < 0) {
			xx = pfirst.x;
			yy = pfirst.y;
		} else if(param > 1) {
			xx = plast.x;
			yy = plast.y;
		} else {
			xx = pfirst.x + param * C;
			yy = pfirst.y + param * D;
		}
		var dx = p0.x - xx;
		var dy = p0.y - yy;
		var d = dx * dx + dy * dy;
		if(d > dmax) {
			index = i;
			dmax = d;
		}
	}
	if(dmax >= epsilon * epsilon) {
		h2d_col_Polygon.optimizeRec(points,start,index,out,epsilon);
		out.pop();
		h2d_col_Polygon.optimizeRec(points,index,end,out,epsilon);
	} else {
		out.push(points[start]);
		out.push(points[end]);
	}
};
h2d_col_Polygon.makeCircle = function(x,y,radius,npoints) {
	if(npoints == null) {
		npoints = 0;
	}
	if(npoints == 0) {
		var f = radius * 3.14 * 2 / 4;
		npoints = Math.ceil(f < 0 ? -f : f);
	}
	if(npoints < 3) {
		npoints = 3;
	}
	var angle = 6.2831853071795862 / npoints;
	var points = [];
	var _g = 0;
	var _g1 = npoints;
	while(_g < _g1) {
		var i = _g++;
		var a = i * angle;
		var x1 = Math.cos(a) * radius + x;
		var y1 = Math.sin(a) * radius + y;
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		points.push(new h2d_col_PointImpl(x1,y1));
	}
	return points == null ? [] : points;
};
var h2d_col_PolygonCollider = function(polygons,isConvex) {
	if(isConvex == null) {
		isConvex = false;
	}
	this.polygons = polygons;
	this.isConvex = isConvex;
};
$hxClasses["h2d.col.PolygonCollider"] = h2d_col_PolygonCollider;
h2d_col_PolygonCollider.__name__ = "h2d.col.PolygonCollider";
h2d_col_PolygonCollider.__super__ = h2d_col_Collider;
h2d_col_PolygonCollider.prototype = $extend(h2d_col_Collider.prototype,{
	contains: function(p) {
		if(this.polygons == null) {
			return false;
		}
		return h2d_col_Polygons.contains(this.polygons,p,this.isConvex);
	}
	,collideCircle: function(c) {
		throw haxe_Exception.thrown("Not implemented");
	}
	,collideBounds: function(b) {
		throw haxe_Exception.thrown("Not implemented");
	}
	,__class__: h2d_col_PolygonCollider
});
var h2d_col_Polygons = {};
h2d_col_Polygons.get_length = function(this1) {
	return this1.length;
};
h2d_col_Polygons.get_polygons = function(this1) {
	return this1;
};
h2d_col_Polygons._new = function(polygons) {
	return polygons == null ? [] : polygons;
};
h2d_col_Polygons.iterator = function(this1) {
	return new hxd_impl_ArrayIterator_$h2d_$col_$Polygon(this1);
};
h2d_col_Polygons.toIPolygons = function(this1,scale) {
	if(scale == null) {
		scale = 1.;
	}
	var _g = [];
	var _g1 = 0;
	var _g2 = this1;
	while(_g1 < _g2.length) {
		var p = _g2[_g1];
		++_g1;
		_g.push(h2d_col_Polygon.toIPolygon(p,scale));
	}
	return _g;
};
h2d_col_Polygons.getBounds = function(this1,b) {
	if(b == null) {
		b = new h2d_col_Bounds();
	}
	var _g = 0;
	var _g1 = this1;
	while(_g < _g1.length) {
		var p = _g1[_g];
		++_g;
		h2d_col_Polygon.getBounds(p,b);
	}
	return b;
};
h2d_col_Polygons.getCollider = function(this1,isConvex) {
	if(isConvex == null) {
		isConvex = false;
	}
	return new h2d_col_PolygonCollider(this1,isConvex);
};
h2d_col_Polygons.contains = function(this1,p,isConvex) {
	if(isConvex == null) {
		isConvex = false;
	}
	var _g = 0;
	var _g1 = this1;
	while(_g < _g1.length) {
		var pl = _g1[_g];
		++_g;
		if(h2d_col_Polygon.contains(pl,p,isConvex)) {
			return true;
		}
	}
	return false;
};
h2d_col_Polygons.optimize = function(this1,epsilon) {
	var _g = [];
	var _g1 = 0;
	var _g2 = this1;
	while(_g1 < _g2.length) {
		var p = _g2[_g1];
		++_g1;
		_g.push(h2d_col_Polygon.optimize(p,epsilon));
	}
	return _g;
};
var h2d_col_Ray = function() {
};
$hxClasses["h2d.col.Ray"] = h2d_col_Ray;
h2d_col_Ray.__name__ = "h2d.col.Ray";
h2d_col_Ray.fromPoints = function(p1,p2) {
	var r = new h2d_col_Ray();
	r.px = p1.x;
	r.py = p1.y;
	r.lx = p2.x - p1.x;
	r.ly = p2.y - p1.y;
	r.normalize();
	return r;
};
h2d_col_Ray.fromValues = function(x,y,dx,dy) {
	var r = new h2d_col_Ray();
	r.px = x;
	r.py = y;
	r.lx = dx;
	r.ly = dy;
	r.normalize();
	return r;
};
h2d_col_Ray.prototype = {
	side: function(p) {
		return this.lx * (p.y - this.py) - this.ly * (p.x - this.px);
	}
	,getPoint: function(distance) {
		var x = this.px + distance * this.lx;
		var y = this.py + distance * this.ly;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h2d_col_PointImpl(x,y);
	}
	,getPos: function() {
		var x = this.px;
		var y = this.py;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h2d_col_PointImpl(x,y);
	}
	,getDir: function() {
		var x = this.lx;
		var y = this.ly;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h2d_col_PointImpl(x,y);
	}
	,normalize: function() {
		var l = this.lx * this.lx + this.ly * this.ly;
		if(l == 1.) {
			return;
		}
		if(l < 1e-20) {
			l = 0;
		} else {
			l = 1. / Math.sqrt(l);
		}
		this.lx *= l;
		this.ly *= l;
	}
	,__class__: h2d_col_Ray
};
var h2d_col_Segment = function(p1,p2) {
	this.x = p1.x;
	this.y = p1.y;
	this.dx = p2.x - this.x;
	this.dy = p2.y - this.y;
	this.lenSq = this.dx * this.dx + this.dy * this.dy;
	this.invLenSq = 1 / this.lenSq;
};
$hxClasses["h2d.col.Segment"] = h2d_col_Segment;
h2d_col_Segment.__name__ = "h2d.col.Segment";
h2d_col_Segment.prototype = {
	setPoints: function(p1,p2) {
		this.x = p1.x;
		this.y = p1.y;
		this.dx = p2.x - this.x;
		this.dy = p2.y - this.y;
		this.lenSq = this.dx * this.dx + this.dy * this.dy;
		this.invLenSq = 1 / this.lenSq;
	}
	,side: function(p) {
		return this.dx * (p.y - this.y) - this.dy * (p.x - this.x);
	}
	,distanceSq: function(p) {
		var px = p.x - this.x;
		var py = p.y - this.y;
		var t = px * this.dx + py * this.dy;
		if(t < 0) {
			return px * px + py * py;
		} else if(t > this.lenSq) {
			var kx = p.x - (this.x + this.dx);
			var ky = p.y - (this.y + this.dy);
			return kx * kx + ky * ky;
		} else {
			var tl2 = t * this.invLenSq;
			var pdx = this.x + tl2 * this.dx - p.x;
			var pdy = this.y + tl2 * this.dy - p.y;
			return pdx * pdx + pdy * pdy;
		}
	}
	,distance: function(p) {
		var px = p.x - this.x;
		var py = p.y - this.y;
		var t = px * this.dx + py * this.dy;
		var f;
		if(t < 0) {
			f = px * px + py * py;
		} else if(t > this.lenSq) {
			var kx = p.x - (this.x + this.dx);
			var ky = p.y - (this.y + this.dy);
			f = kx * kx + ky * ky;
		} else {
			var tl2 = t * this.invLenSq;
			var pdx = this.x + tl2 * this.dx - p.x;
			var pdy = this.y + tl2 * this.dy - p.y;
			f = pdx * pdx + pdy * pdy;
		}
		return Math.sqrt(f);
	}
	,project: function(p,out) {
		var px = p.x - this.x;
		var py = p.y - this.y;
		var t = px * this.dx + py * this.dy;
		if(out == null) {
			out = new h2d_col_PointImpl(0.,0.);
		}
		if(t < 0) {
			var _this = out;
			var x = this.x;
			var y = this.y;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
		} else if(t > this.lenSq) {
			var _this = out;
			var x = this.x + this.dx;
			var y = this.y + this.dy;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
		} else {
			var tl2 = t * this.invLenSq;
			var _this = out;
			var x = this.x + tl2 * this.dx;
			var y = this.y + tl2 * this.dy;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
		}
		return out;
	}
	,lineIntersection: function(r,pt) {
		var x = this.x;
		var y = this.y;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var p_x = x1;
		var p_y = y1;
		var x = this.x + this.dx;
		var y = this.y + this.dy;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var p_x1 = x1;
		var p_y1 = y1;
		if((r.lx * (p_y - r.py) - r.ly * (p_x - r.px)) * (r.lx * (p_y1 - r.py) - r.ly * (p_x1 - r.px)) > 0) {
			return null;
		}
		var u = (r.lx * (this.y - r.py) - r.ly * (this.x - r.px)) / (r.ly * this.dx - r.lx * this.dy);
		if(u < 0 || u > 1) {
			return null;
		}
		if(pt == null) {
			pt = new h2d_col_PointImpl(0.,0.);
		}
		pt.x = this.x + u * this.dx;
		pt.y = this.y + u * this.dy;
		return pt;
	}
	,__class__: h2d_col_Segment
};
var h2d_col_Segments = {};
h2d_col_Segments.get_segments = function(this1) {
	return this1;
};
h2d_col_Segments.get_length = function(this1) {
	return this1.length;
};
h2d_col_Segments.iterator = function(this1) {
	return new hxd_impl_ArrayIterator_$h2d_$col_$Segment(this1);
};
h2d_col_Segments.containsPoint = function(this1,p,isConvex) {
	if(isConvex) {
		var _g = 0;
		var _g1 = this1;
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			if(s.dx * (p.y - s.y) - s.dy * (p.x - s.x) < 0) {
				return false;
			}
		}
	} else {
		throw haxe_Exception.thrown("TODO");
	}
	return true;
};
h2d_col_Segments.toPolygon = function(this1) {
	var _g = [];
	var _g1 = 0;
	var _g2 = this1;
	while(_g1 < _g2.length) {
		var s = _g2[_g1];
		++_g1;
		var x = s.x;
		var y = s.y;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_g.push(new h2d_col_PointImpl(x,y));
	}
	return _g;
};
h2d_col_Segments.project = function(this1,p) {
	var dmin = 1e20;
	var smin = null;
	var _g = 0;
	var _g1 = this1;
	while(_g < _g1.length) {
		var s = _g1[_g];
		++_g;
		var px = p.x - s.x;
		var py = p.y - s.y;
		var t = px * s.dx + py * s.dy;
		var d;
		if(t < 0) {
			d = px * px + py * py;
		} else if(t > s.lenSq) {
			var kx = p.x - (s.x + s.dx);
			var ky = p.y - (s.y + s.dy);
			d = kx * kx + ky * ky;
		} else {
			var tl2 = t * s.invLenSq;
			var pdx = s.x + tl2 * s.dx - p.x;
			var pdy = s.y + tl2 * s.dy - p.y;
			d = pdx * pdx + pdy * pdy;
		}
		if(d < dmin) {
			dmin = d;
			smin = s;
		}
	}
	var out = null;
	var px = p.x - smin.x;
	var py = p.y - smin.y;
	var t = px * smin.dx + py * smin.dy;
	if(out == null) {
		out = new h2d_col_PointImpl(0.,0.);
	}
	if(t < 0) {
		var _this = out;
		var x = smin.x;
		var y = smin.y;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
	} else if(t > smin.lenSq) {
		var _this = out;
		var x = smin.x + smin.dx;
		var y = smin.y + smin.dy;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
	} else {
		var tl2 = t * smin.invLenSq;
		var _this = out;
		var x = smin.x + tl2 * smin.dx;
		var y = smin.y + tl2 * smin.dy;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
	}
	return out;
};
h2d_col_Segments.distanceSq = function(this1,p) {
	var dmin = 1e20;
	var _g = 0;
	var _g1 = this1;
	while(_g < _g1.length) {
		var s = _g1[_g];
		++_g;
		var px = p.x - s.x;
		var py = p.y - s.y;
		var t = px * s.dx + py * s.dy;
		var d;
		if(t < 0) {
			d = px * px + py * py;
		} else if(t > s.lenSq) {
			var kx = p.x - (s.x + s.dx);
			var ky = p.y - (s.y + s.dy);
			d = kx * kx + ky * ky;
		} else {
			var tl2 = t * s.invLenSq;
			var pdx = s.x + tl2 * s.dx - p.x;
			var pdy = s.y + tl2 * s.dy - p.y;
			d = pdx * pdx + pdy * pdy;
		}
		if(d < dmin) {
			dmin = d;
		}
	}
	return dmin;
};
h2d_col_Segments.distance = function(this1,p) {
	return Math.sqrt(h2d_col_Segments.distanceSq(this1,p));
};
var h2d_filter_Filter = function() {
	this.useScreenResolution = h2d_filter_Filter.defaultUseScreenResolution;
	this.resolutionScale = 1;
	this.enable = true;
	this.smooth = false;
	this.boundsExtend = 0.;
	this.autoBounds = true;
};
$hxClasses["h2d.filter.Filter"] = h2d_filter_Filter;
h2d_filter_Filter.__name__ = "h2d.filter.Filter";
h2d_filter_Filter.prototype = {
	get_enable: function() {
		return this.enable;
	}
	,set_enable: function(v) {
		return this.enable = v;
	}
	,set_resolutionScale: function(v) {
		return this.resolutionScale = v;
	}
	,set_useScreenResolution: function(v) {
		return this.useScreenResolution = v;
	}
	,sync: function(ctx,s) {
	}
	,bind: function(s) {
	}
	,unbind: function(s) {
	}
	,getBounds: function(s,bounds,scale) {
		s.getBounds(s,bounds);
		bounds.xMin = bounds.xMin * scale.x - this.boundsExtend;
		bounds.xMax = bounds.xMax * scale.x + this.boundsExtend;
		bounds.yMin = bounds.yMin * scale.y - this.boundsExtend;
		bounds.yMax = bounds.yMax * scale.y + this.boundsExtend;
	}
	,draw: function(ctx,input) {
		return input;
	}
	,__class__: h2d_filter_Filter
};
var h2d_impl_BatchDrawState = function() {
	this.head = this.tail = new h2d_impl__$BatchDrawState_StateEntry(null);
	this.totalCount = 0;
};
$hxClasses["h2d.impl.BatchDrawState"] = h2d_impl_BatchDrawState;
h2d_impl_BatchDrawState.__name__ = "h2d.impl.BatchDrawState";
h2d_impl_BatchDrawState.prototype = {
	setTile: function(tile) {
		if(tile != null) {
			this.setTexture(tile.innerTex);
		}
	}
	,setTexture: function(texture) {
		if(texture != null) {
			if(this.tail.texture == null) {
				this.tail.texture = texture;
			} else if(this.tail.texture != texture) {
				var cur = this.tail;
				if(cur.count == 0) {
					cur.set(texture);
				} else if(cur.next == null) {
					cur.next = this.tail = new h2d_impl__$BatchDrawState_StateEntry(texture);
				} else {
					this.tail = cur.next.set(texture);
				}
			}
		}
	}
	,add: function(count) {
		this.tail.count += count;
		this.totalCount += count;
	}
	,clear: function() {
		var state = this.head;
		do {
			state.texture = null;
			state = state.next;
		} while(state != null);
		this.tail = this.head;
		this.tail.count = 0;
		this.totalCount = 0;
	}
	,drawQuads: function(ctx,buffer,offset,length) {
		if(length == null) {
			length = -1;
		}
		if(offset == null) {
			offset = 0;
		}
		var state = this.head;
		var last = this.tail.next;
		var engine = ctx.engine;
		var stateLen;
		if(offset == 0 && length == -1) {
			do {
				ctx.texture = state.texture;
				ctx.beforeDraw();
				stateLen = state.count >> 1;
				var start = offset;
				var max = stateLen;
				if(max == null) {
					max = -1;
				}
				if(start == null) {
					start = 0;
				}
				engine.renderBuffer(buffer,engine.mem.getQuadIndexes(buffer.vertices),2,start,max);
				offset += stateLen;
				state = state.next;
			} while(state != last);
		} else {
			if(length == -1) {
				length = (this.totalCount >> 1) - offset;
			}
			var caret = 0;
			do {
				stateLen = state.count >> 1;
				if(caret + stateLen >= offset) {
					var stateMin = offset >= caret ? offset : caret;
					var stateLen1 = length > stateLen ? stateLen : length;
					ctx.texture = state.texture;
					ctx.beforeDraw();
					var start = stateMin;
					var max = stateLen1;
					if(max == null) {
						max = -1;
					}
					if(start == null) {
						start = 0;
					}
					engine.renderBuffer(buffer,engine.mem.getQuadIndexes(buffer.vertices),2,start,max);
					length -= stateLen1;
					if(length == 0) {
						break;
					}
				}
				caret += stateLen;
				state = state.next;
			} while(state != last);
		}
	}
	,drawIndexed: function(ctx,buffer,indices,offset,length) {
		if(length == null) {
			length = -1;
		}
		if(offset == null) {
			offset = 0;
		}
		var state = this.head;
		var last = this.tail.next;
		var engine = ctx.engine;
		var stateLen;
		if(offset == 0 && length == -1) {
			do {
				ctx.texture = state.texture;
				ctx.beforeDraw();
				stateLen = state.count / 3 | 0;
				engine.renderIndexed(buffer,indices,offset,stateLen);
				offset += stateLen;
				state = state.next;
			} while(state != last);
		} else {
			if(length == -1) {
				length = this.totalCount / 3 | 0;
			}
			var caret = 0;
			do {
				stateLen = state.count / 3 | 0;
				if(caret + stateLen >= offset) {
					var stateMin = offset >= caret ? offset : caret;
					var stateLen1 = length > stateLen ? stateLen : length;
					ctx.texture = state.texture;
					ctx.beforeDraw();
					engine.renderIndexed(buffer,indices,stateMin,stateLen1);
					length -= stateLen1;
					if(length == 0) {
						break;
					}
				}
				caret += stateLen;
				state = state.next;
			} while(state != last);
		}
	}
	,get_currentTexture: function() {
		return this.tail.texture;
	}
	,__class__: h2d_impl_BatchDrawState
};
var h2d_impl__$BatchDrawState_StateEntry = function(texture) {
	this.texture = texture;
	this.count = 0;
};
$hxClasses["h2d.impl._BatchDrawState.StateEntry"] = h2d_impl__$BatchDrawState_StateEntry;
h2d_impl__$BatchDrawState_StateEntry.__name__ = "h2d.impl._BatchDrawState.StateEntry";
h2d_impl__$BatchDrawState_StateEntry.prototype = {
	set: function(texture) {
		this.texture = texture;
		this.count = 0;
		return this;
	}
	,__class__: h2d_impl__$BatchDrawState_StateEntry
};
var h3d_BufferFlag = $hxEnums["h3d.BufferFlag"] = { __ename__:true,__constructs__:null
	,Dynamic: {_hx_name:"Dynamic",_hx_index:0,__enum__:"h3d.BufferFlag",toString:$estr}
	,NoAlloc: {_hx_name:"NoAlloc",_hx_index:1,__enum__:"h3d.BufferFlag",toString:$estr}
	,UniformBuffer: {_hx_name:"UniformBuffer",_hx_index:2,__enum__:"h3d.BufferFlag",toString:$estr}
	,ReadWriteBuffer: {_hx_name:"ReadWriteBuffer",_hx_index:3,__enum__:"h3d.BufferFlag",toString:$estr}
	,IndexBuffer: {_hx_name:"IndexBuffer",_hx_index:4,__enum__:"h3d.BufferFlag",toString:$estr}
};
h3d_BufferFlag.__constructs__ = [h3d_BufferFlag.Dynamic,h3d_BufferFlag.NoAlloc,h3d_BufferFlag.UniformBuffer,h3d_BufferFlag.ReadWriteBuffer,h3d_BufferFlag.IndexBuffer];
h3d_BufferFlag.__empty_constructs__ = [h3d_BufferFlag.Dynamic,h3d_BufferFlag.NoAlloc,h3d_BufferFlag.UniformBuffer,h3d_BufferFlag.ReadWriteBuffer,h3d_BufferFlag.IndexBuffer];
var h3d_Buffer = function(vertices,format,flags) {
	this.id = h3d_Buffer.GUID++;
	this.vertices = vertices;
	this.format = format;
	this.flags = 0;
	this.allocPos = hxd_impl_AllocPos.make();
	if(flags != null) {
		var _g = 0;
		while(_g < flags.length) {
			var f = flags[_g];
			++_g;
			this.flags |= 1 << f._hx_index;
		}
	}
	this.engine = h3d_Engine.CURRENT;
	if((this.flags & 1 << h3d_BufferFlag.NoAlloc._hx_index) == 0) {
		this.engine.mem.allocBuffer(this);
	}
};
$hxClasses["h3d.Buffer"] = h3d_Buffer;
h3d_Buffer.__name__ = "h3d.Buffer";
h3d_Buffer.ofFloats = function(v,format,flags) {
	var nvert = Math.ceil(v.pos / format.stride);
	var b = new h3d_Buffer(nvert,format,flags);
	b.uploadFloats(v,0,nvert);
	return b;
};
h3d_Buffer.ofSubFloats = function(v,vertices,format,flags) {
	var b = new h3d_Buffer(vertices,format,flags);
	b.uploadFloats(v,0,vertices);
	return b;
};
h3d_Buffer.prototype = {
	getMemSize: function() {
		return this.vertices * this.format.strideBytes;
	}
	,isDisposed: function() {
		return this.vbuf == null;
	}
	,dispose: function() {
		if(this.vbuf != null) {
			this.engine.mem.freeBuffer(this);
			this.vbuf = null;
		}
	}
	,uploadFloats: function(buf,bufPos,vertices,startVertice) {
		if(startVertice == null) {
			startVertice = 0;
		}
		if(startVertice < 0 || vertices < 0 || startVertice + vertices > this.vertices) {
			throw haxe_Exception.thrown("Invalid vertices count");
		}
		if(vertices == 0) {
			return;
		}
		if(this.format.hasLowPrecision) {
			var bytes = new haxe_io_Bytes(new ArrayBuffer(vertices * this.format.strideBytes));
			var bytesPos = 0;
			var index = bufPos;
			var inputs_current = 0;
			var inputs_array = this.format.inputs;
			var _g = 0;
			var _g1 = vertices;
			while(_g < _g1) {
				var _ = _g++;
				inputs_current = 0;
				while(inputs_current < inputs_array.length) {
					var input = inputs_array[inputs_current++];
					var elementCount = input.type & 7;
					var step = 0;
					switch(input.precision) {
					case 0:
						var _g2 = 0;
						var _g3 = elementCount;
						while(_g2 < _g3) {
							var i = _g2++;
							bytes.setFloat(bytesPos + step,buf.array[index++]);
							step += 4;
						}
						break;
					case 1:
						var _g4 = 0;
						var _g5 = elementCount;
						while(_g4 < _g5) {
							var i1 = _g4++;
							var f = hxd_BufferFormat.float32to16(buf.array[index++]);
							bytes.setUInt16(bytesPos + step,f);
							step += 2;
						}
						break;
					case 2:
						var _g6 = 0;
						var _g7 = elementCount;
						while(_g6 < _g7) {
							var i2 = _g6++;
							var f1 = hxd_BufferFormat.float32toU8(buf.array[index++]);
							bytes.b[bytesPos + step] = f1;
							++step;
						}
						break;
					case 3:
						var _g8 = 0;
						var _g9 = elementCount;
						while(_g8 < _g9) {
							var i3 = _g8++;
							var f2 = hxd_BufferFormat.float32toS8(buf.array[index++]);
							bytes.b[bytesPos + step] = f2;
							++step;
						}
						break;
					}
					bytesPos += (input.type & 7) * hxd_Precision.SIZES[input.precision];
					if((bytesPos & 3) != 0) {
						bytesPos += 4 - (bytesPos & 3);
					}
				}
			}
			this.uploadBytes(bytes,0,vertices);
			return;
		}
		this.engine.driver.uploadBufferData(this,startVertice,vertices,buf,bufPos);
	}
	,uploadBytes: function(data,dataPos,vertices) {
		if(vertices < 0 || vertices > this.vertices) {
			throw haxe_Exception.thrown("Invalid vertices count");
		}
		if(vertices == 0) {
			return;
		}
		this.engine.driver.uploadBufferBytes(this,0,vertices,data,dataPos);
	}
	,readBytes: function(bytes,bytesPosition,vertices,startVertice) {
		if(startVertice == null) {
			startVertice = 0;
		}
		if(startVertice < 0 || vertices < 0 || startVertice + vertices > this.vertices) {
			throw haxe_Exception.thrown("Invalid vertices count");
		}
		this.engine.driver.readBufferBytes(this,startVertice,vertices,bytes,bytesPosition);
	}
	,__class__: h3d_Buffer
};
var h3d_Camera = function(fovY,zoom,screenRatio,zNear,zFar,rightHanded) {
	if(rightHanded == null) {
		rightHanded = false;
	}
	if(zFar == null) {
		zFar = 4000.;
	}
	if(zNear == null) {
		zNear = 0.02;
	}
	if(screenRatio == null) {
		screenRatio = 1.333333;
	}
	if(zoom == null) {
		zoom = 1.;
	}
	if(fovY == null) {
		fovY = 25.;
	}
	this.jitterOffsetY = 0.;
	this.jitterOffsetX = 0.;
	this.viewY = 0.;
	this.viewX = 0.;
	this.fovY = fovY;
	this.zoom = zoom;
	this.screenRatio = screenRatio;
	this.zNear = zNear;
	this.zFar = zFar;
	this.rightHanded = rightHanded;
	var x = 2;
	var y = 3;
	var z = 4;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.pos = new h3d_VectorImpl(x,y,z);
	var x = 0;
	var y = 0;
	var z = 1;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.up = new h3d_VectorImpl(x,y,z);
	var x = 0;
	var y = 0;
	var z = 0;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.target = new h3d_VectorImpl(x,y,z);
	this.m = new h3d_MatrixImpl();
	this.mcam = new h3d_MatrixImpl();
	this.mproj = new h3d_MatrixImpl();
	this.frustum = new h3d_col_Frustum();
	this.update();
};
$hxClasses["h3d.Camera"] = h3d_Camera;
h3d_Camera.__name__ = "h3d.Camera";
h3d_Camera.prototype = {
	setFovX: function(fovX,withRatio) {
		var degToRad = Math.PI / 180;
		this.fovY = 2 * Math.atan(Math.tan(fovX * 0.5 * degToRad) / withRatio) / degToRad;
	}
	,getFovX: function() {
		var degToRad = Math.PI / 180;
		var halfFovX = Math.atan(Math.tan(this.fovY * 0.5 * degToRad) * this.screenRatio);
		var fovX = halfFovX * 2 / degToRad;
		return fovX;
	}
	,clone: function() {
		var c = new h3d_Camera(this.fovY,this.zoom,this.screenRatio,this.zNear,this.zFar,this.rightHanded);
		var _this = this.pos;
		var x = _this.x;
		var y = _this.y;
		var z = _this.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		c.pos = new h3d_VectorImpl(x,y,z);
		var _this = this.up;
		var x = _this.x;
		var y = _this.y;
		var z = _this.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		c.up = new h3d_VectorImpl(x,y,z);
		var _this = this.target;
		var x = _this.x;
		var y = _this.y;
		var z = _this.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		c.target = new h3d_VectorImpl(x,y,z);
		c.update();
		return c;
	}
	,getInverseViewProj: function() {
		if(this.minv == null) {
			this.minv = new h3d_MatrixImpl();
		}
		if(this.needInv) {
			this.minv.initInverse(this.m);
			this.needInv = false;
		}
		return this.minv;
	}
	,getInverseProj: function() {
		if(this.mprojInv == null) {
			this.mprojInv = new h3d_MatrixImpl();
			this.mprojInv._44 = 0;
		}
		if(this.mprojInv._44 == 0) {
			this.mprojInv.initInverse(this.mproj);
		}
		return this.mprojInv;
	}
	,getInverseView: function() {
		if(this.mcamInv == null) {
			this.mcamInv = new h3d_MatrixImpl();
			this.mcamInv._44 = 0;
		}
		if(this.mcamInv._44 == 0) {
			this.mcamInv.initInverse(this.mcam);
		}
		return this.mcamInv;
	}
	,calcDirections: function() {
		var this1 = this.target;
		var v = this.pos;
		var x = this1.x - v.x;
		var y = this1.y - v.y;
		var z = this1.z - v.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var k = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		var x = _this_x * k;
		var y = _this_y * k;
		var z = _this_z * k;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var _this = this.up;
		var x = _this.y * _this_z - _this.z * _this_y;
		var y = _this.z * _this_x - _this.x * _this_z;
		var z = _this.x * _this_y - _this.y * _this_x;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x1 = x1;
		var _this_y1 = y1;
		var _this_z1 = z1;
		var k = _this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		var x = _this_x1 * k;
		var y = _this_y1 * k;
		var z = _this_z1 * k;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var cameraRight_x = x1;
		var cameraRight_y = y1;
		var cameraRight_z = z1;
		var x = _this_y * cameraRight_z - _this_z * cameraRight_y;
		var y = _this_z * cameraRight_x - _this_x * cameraRight_z;
		var z = _this_x * cameraRight_y - _this_y * cameraRight_x;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var cameraUp_x = x1;
		var cameraUp_y = y1;
		var cameraUp_z = z1;
		this.directions._11 = _this_x;
		this.directions._12 = _this_y;
		this.directions._13 = _this_z;
		this.directions._21 = cameraRight_x;
		this.directions._22 = cameraRight_y;
		this.directions._23 = cameraRight_z;
		this.directions._31 = cameraUp_x;
		this.directions._32 = cameraUp_y;
		this.directions._33 = cameraUp_z;
		this.directions._44 = 1;
	}
	,getForward: function() {
		var forward = new h3d_VectorImpl(0.,0.,0.);
		if(this.directions == null) {
			this.directions = new h3d_MatrixImpl();
			this.directions._44 = 0;
		}
		if(this.directions._44 == 0) {
			this.calcDirections();
		}
		forward.x = this.directions._11;
		forward.y = this.directions._12;
		forward.z = this.directions._13;
		return forward;
	}
	,getRight: function() {
		var right = new h3d_VectorImpl(0.,0.,0.);
		if(this.directions == null) {
			this.directions = new h3d_MatrixImpl();
			this.directions._44 = 0;
		}
		if(this.directions._44 == 0) {
			this.calcDirections();
		}
		right.x = this.directions._21;
		right.y = this.directions._22;
		right.z = this.directions._23;
		return right;
	}
	,getUp: function() {
		var up = new h3d_VectorImpl(0.,0.,0.);
		if(this.directions == null) {
			this.directions = new h3d_MatrixImpl();
			this.directions._44 = 0;
		}
		if(this.directions._44 == 0) {
			this.calcDirections();
		}
		up.x = this.directions._31;
		up.y = this.directions._32;
		up.z = this.directions._33;
		return up;
	}
	,setCubeMap: function(face,position) {
		var dx = 0;
		var dy = 0;
		var dz = 0;
		switch(face) {
		case 0:
			dx = 1;
			var _this = this.up;
			var x = 0;
			var y = 1;
			var z = 0;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			break;
		case 1:
			dx = -1;
			var _this = this.up;
			var x = 0;
			var y = 1;
			var z = 0;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			break;
		case 2:
			dy = 1;
			var _this = this.up;
			var x = 0;
			var y = 0;
			var z = -1;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			break;
		case 3:
			dy = -1;
			var _this = this.up;
			var x = 0;
			var y = 0;
			var z = 1;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			break;
		case 4:
			dz = 1;
			var _this = this.up;
			var x = 0;
			var y = 1;
			var z = 0;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			break;
		case 5:
			dz = -1;
			var _this = this.up;
			var x = 0;
			var y = 1;
			var z = 0;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			break;
		}
		if(position != null) {
			var _this = this.pos;
			_this.x = position.x;
			_this.y = position.y;
			_this.z = position.z;
		}
		var _this = this.target;
		var x = this.pos.x + dx;
		var y = this.pos.y + dy;
		var z = this.pos.z + dz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
	}
	,unproject: function(screenX,screenY,camZ) {
		var x = screenX;
		var y = screenY;
		var z = camZ;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var p = new h3d_VectorImpl(x,y,z);
		var _this = p;
		var m = this.getInverseViewProj();
		var px = _this.x * m._11 + _this.y * m._21 + _this.z * m._31 + m._41;
		var py = _this.x * m._12 + _this.y * m._22 + _this.z * m._32 + m._42;
		var pz = _this.x * m._13 + _this.y * m._23 + _this.z * m._33 + m._43;
		var iw = 1 / (_this.x * m._14 + _this.y * m._24 + _this.z * m._34 + m._44);
		_this.x = px * iw;
		_this.y = py * iw;
		_this.z = pz * iw;
		return p;
	}
	,rayFromScreen: function(pixelX,pixelY,sceneWidth,sceneHeight) {
		if(sceneHeight == null) {
			sceneHeight = -1;
		}
		if(sceneWidth == null) {
			sceneWidth = -1;
		}
		var engine = h3d_Engine.CURRENT;
		if(sceneWidth < 0) {
			sceneWidth = engine.width;
		}
		if(sceneHeight < 0) {
			sceneHeight = engine.height;
		}
		var rx = (pixelX / sceneWidth - 0.5) * 2;
		var ry = (0.5 - pixelY / sceneHeight) * 2;
		var p1 = this.unproject(rx,ry,0);
		var p2 = this.unproject(rx,ry,1);
		var r = new h3d_col_Ray();
		r.px = p1.x;
		r.py = p1.y;
		r.pz = p1.z;
		r.lx = p2.x - p1.x;
		r.ly = p2.y - p1.y;
		r.lz = p2.z - p1.z;
		r.normalize();
		return r;
	}
	,update: function() {
		if(this.follow != null) {
			var fpos = this.follow.pos.localToGlobal();
			var ftarget = this.follow.target.localToGlobal();
			var _this = this.pos;
			var x = fpos.x;
			var y = fpos.y;
			var z = fpos.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			var _this = this.target;
			var x = ftarget.x;
			var y = ftarget.y;
			var z = ftarget.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			if(this.follow.pos.name != null) {
				var p = this.follow.pos;
				while(p != null) {
					if(p.currentAnimation != null) {
						var v = p.currentAnimation.getPropValue(this.follow.pos.name,"FOVY");
						if(v != null) {
							this.fovY = v;
							break;
						}
					}
					p = p.parent;
				}
			}
		}
		this.makeCameraMatrix(this.mcam);
		this.makeFrustumMatrix(this.mproj);
		this.m.multiply(this.mcam,this.mproj);
		this.needInv = true;
		if(this.mcamInv != null) {
			this.mcamInv._44 = 0;
		}
		if(this.mprojInv != null) {
			this.mprojInv._44 = 0;
		}
		if(this.directions != null) {
			this.directions._44 = 0;
		}
		this.frustum.loadMatrix(this.m);
	}
	,getFrustumCorners: function(zMax,zMin) {
		if(zMin == null) {
			zMin = 0.;
		}
		if(zMax == null) {
			zMax = 1.;
		}
		return [this.unproject(-1,1,zMin),this.unproject(1,1,zMin),this.unproject(1,-1,zMin),this.unproject(-1,-1,zMin),this.unproject(-1,1,zMax),this.unproject(1,1,zMax),this.unproject(1,-1,zMax),this.unproject(-1,-1,zMax)];
	}
	,lostUp: function() {
		var _this = this.pos;
		var x = _this.x;
		var y = _this.y;
		var z = _this.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var k = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		_this_x *= k;
		_this_y *= k;
		_this_z *= k;
		var v = this.up;
		return Math.abs(_this_x * v.x + _this_y * v.y + _this_z * v.z) > 0.999;
	}
	,getViewDirection: function(dx,dy,dz) {
		if(dz == null) {
			dz = 0.;
		}
		var x = dx;
		var y = dy;
		var z = dz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var a = new h3d_VectorImpl(x,y,z);
		var _this = a;
		var m = this.mcam;
		var px = _this.x * m._11 + _this.y * m._21 + _this.z * m._31;
		var py = _this.x * m._12 + _this.y * m._22 + _this.z * m._32;
		var pz = _this.x * m._13 + _this.y * m._23 + _this.z * m._33;
		_this.x = px;
		_this.y = py;
		_this.z = pz;
		var _this = a;
		var k = _this.x * _this.x + _this.y * _this.y + _this.z * _this.z;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		_this.x *= k;
		_this.y *= k;
		_this.z *= k;
		return a;
	}
	,movePosAxis: function(dx,dy,dz) {
		if(dz == null) {
			dz = 0.;
		}
		var x = dx;
		var y = dy;
		var z = dz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var m = this.mcam;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		this.pos.x += _this_x;
		this.pos.y += _this_y;
		this.pos.z += _this_z;
	}
	,moveTargetAxis: function(dx,dy,dz) {
		if(dz == null) {
			dz = 0.;
		}
		var x = dx;
		var y = dy;
		var z = dz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var m = this.mcam;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		this.target.x += _this_x;
		this.target.y += _this_y;
		this.target.z += _this_z;
	}
	,forward: function(speed) {
		if(speed == null) {
			speed = 1.;
		}
		var c = 1 - 0.025 * speed;
		var _this = this.pos;
		var x = this.target.x + (this.pos.x - this.target.x) * c;
		var y = this.target.y + (this.pos.y - this.target.y) * c;
		var z = this.target.z + (this.pos.z - this.target.z) * c;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
	}
	,backward: function(speed) {
		if(speed == null) {
			speed = 1.;
		}
		var c = 1 + 0.025 * speed;
		var _this = this.pos;
		var x = this.target.x + (this.pos.x - this.target.x) * c;
		var y = this.target.y + (this.pos.y - this.target.y) * c;
		var z = this.target.z + (this.pos.z - this.target.z) * c;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
	}
	,makeCameraMatrix: function(m) {
		var this1 = this.target;
		var v = this.pos;
		var x = this1.x - v.x;
		var y = this1.y - v.y;
		var z = this1.z - v.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		if(this.rightHanded) {
			_this_x *= -1;
			_this_y *= -1;
			_this_z *= -1;
		}
		var k = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		_this_x *= k;
		_this_y *= k;
		_this_z *= k;
		var _this = this.up;
		var x = _this.y * _this_z - _this.z * _this_y;
		var y = _this.z * _this_x - _this.x * _this_z;
		var z = _this.x * _this_y - _this.y * _this_x;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x1 = x1;
		var _this_y1 = y1;
		var _this_z1 = z1;
		var k = _this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		_this_x1 *= k;
		_this_y1 *= k;
		_this_z1 *= k;
		if(Math.sqrt(_this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1) == 0) {
			_this_x1 = _this_y;
			_this_y1 = _this_z;
			_this_z1 = _this_x;
		}
		var x = _this_y * _this_z1 - _this_z * _this_y1;
		var y = _this_z * _this_x1 - _this_x * _this_z1;
		var z = _this_x * _this_y1 - _this_y * _this_x1;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x2 = x1;
		var _this_y2 = y1;
		var _this_z2 = z1;
		m._11 = _this_x1;
		m._12 = _this_x2;
		m._13 = _this_x;
		m._14 = 0;
		m._21 = _this_y1;
		m._22 = _this_y2;
		m._23 = _this_y;
		m._24 = 0;
		m._31 = _this_z1;
		m._32 = _this_z2;
		m._33 = _this_z;
		m._34 = 0;
		var v = this.pos;
		m._41 = -(_this_x1 * v.x + _this_y1 * v.y + _this_z1 * v.z);
		var v = this.pos;
		m._42 = -(_this_x2 * v.x + _this_y2 * v.y + _this_z2 * v.z);
		var v = this.pos;
		m._43 = -(_this_x * v.x + _this_y * v.y + _this_z * v.z);
		m._44 = 1;
	}
	,setTransform: function(m) {
		var _this = this.pos;
		var x = m._41;
		var y = m._42;
		var z = m._43;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		var _this = this.target;
		var this1 = this.pos;
		var v = m.getDirection();
		var x = this1.x + v.x;
		var y = this1.y + v.y;
		var z = this1.z + v.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		_this.x = v_x;
		_this.y = v_y;
		_this.z = v_z;
	}
	,makeFrustumMatrix: function(m) {
		m.zero();
		var bounds = this.orthoBounds;
		if(bounds != null) {
			var w = 1 / (bounds.xMax - bounds.xMin);
			var h = 1 / (bounds.yMax - bounds.yMin);
			var d = 1 / (bounds.zMax - bounds.zMin);
			m._11 = 2 * w;
			m._22 = 2 * h;
			m._33 = d;
			m._41 = -(bounds.xMin + bounds.xMax) * w;
			m._42 = -(bounds.yMin + bounds.yMax) * h;
			m._43 = -bounds.zMin * d;
			m._44 = 1;
		} else {
			var degToRad = Math.PI / 180;
			var halfFovX = Math.atan(Math.tan(this.fovY * 0.5 * degToRad) * this.screenRatio);
			var scale = this.zoom / Math.tan(halfFovX);
			m._11 = scale;
			m._22 = scale * this.screenRatio;
			m._33 = this.zFar / (this.zFar - this.zNear);
			m._34 = 1;
			m._43 = -(this.zNear * this.zFar) / (this.zFar - this.zNear);
			m._31 = this.jitterOffsetX;
			m._32 = this.jitterOffsetY;
		}
		m._11 += this.viewX * m._14;
		m._21 += this.viewX * m._24;
		m._31 += this.viewX * m._34;
		m._41 += this.viewX * m._44;
		m._12 += this.viewY * m._14;
		m._22 += this.viewY * m._24;
		m._32 += this.viewY * m._34;
		m._42 += this.viewY * m._44;
		if(this.rightHanded) {
			m._33 *= -1;
			m._34 *= -1;
		}
	}
	,projectInline: function(x,y,z,screenWidth,screenHeight,snapToPixel) {
		if(snapToPixel == null) {
			snapToPixel = true;
		}
		var p = new h3d_VectorImpl(0.,0.,0.);
		var _this = p;
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		_this.x = x1;
		_this.y = y1;
		_this.z = z1;
		var _this = p;
		var m = this.m;
		var px = _this.x * m._11 + _this.y * m._21 + _this.z * m._31 + m._41;
		var py = _this.x * m._12 + _this.y * m._22 + _this.z * m._32 + m._42;
		var pz = _this.x * m._13 + _this.y * m._23 + _this.z * m._33 + m._43;
		var iw = 1 / (_this.x * m._14 + _this.y * m._24 + _this.z * m._34 + m._44);
		_this.x = px * iw;
		_this.y = py * iw;
		_this.z = pz * iw;
		p.x = (p.x + 1) * 0.5 * screenWidth;
		p.y = (-p.y + 1) * 0.5 * screenHeight;
		if(snapToPixel) {
			p.x = Math.round(p.x);
			p.y = Math.round(p.y);
		}
		return p;
	}
	,project: function(x,y,z,screenWidth,screenHeight,snapToPixel,p) {
		if(snapToPixel == null) {
			snapToPixel = true;
		}
		if(p == null) {
			p = new h3d_VectorImpl(0.,0.,0.);
		}
		var _this = p;
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		_this.x = x1;
		_this.y = y1;
		_this.z = z1;
		var _this = p;
		var m = this.m;
		var px = _this.x * m._11 + _this.y * m._21 + _this.z * m._31 + m._41;
		var py = _this.x * m._12 + _this.y * m._22 + _this.z * m._32 + m._42;
		var pz = _this.x * m._13 + _this.y * m._23 + _this.z * m._33 + m._43;
		var iw = 1 / (_this.x * m._14 + _this.y * m._24 + _this.z * m._34 + m._44);
		_this.x = px * iw;
		_this.y = py * iw;
		_this.z = pz * iw;
		p.x = (p.x + 1) * 0.5 * screenWidth;
		p.y = (-p.y + 1) * 0.5 * screenHeight;
		if(snapToPixel) {
			p.x = Math.round(p.x);
			p.y = Math.round(p.y);
		}
		return p;
	}
	,distanceToDepth: function(dist) {
		var min = this.zNear;
		var max = this.zFar;
		if(max == null) {
			max = 1.;
		}
		if(min == null) {
			min = 0.;
		}
		return ((this.zFar + this.zNear - 2.0 * this.zNear * this.zFar / (dist < min ? min : dist > max ? max : dist)) / (this.zFar - this.zNear) + 1.0) / 2.0;
	}
	,depthToDistance: function(depth) {
		var min = 0;
		var max = 1;
		if(max == null) {
			max = 1.;
		}
		if(min == null) {
			min = 0.;
		}
		return ((depth < min ? min : depth > max ? max : depth) * this.zFar - this.zNear * this.zFar) / (this.zFar - this.zNear);
	}
	,load: function(cam) {
		var _this = this.pos;
		var v = cam.pos;
		_this.x = v.x;
		_this.y = v.y;
		_this.z = v.z;
		var _this = this.target;
		var v = cam.target;
		_this.x = v.x;
		_this.y = v.y;
		_this.z = v.z;
		var _this = this.up;
		var v = cam.up;
		_this.x = v.x;
		_this.y = v.y;
		_this.z = v.z;
		if(cam.orthoBounds != null) {
			this.orthoBounds = new h3d_col_Bounds();
			this.orthoBounds.load(cam.orthoBounds);
		} else {
			this.orthoBounds = null;
		}
		this.fovY = cam.fovY;
		this.screenRatio = cam.screenRatio;
		this.zoom = cam.zoom;
		this.zNear = cam.zNear;
		this.zFar = cam.zFar;
		if(cam.follow != null) {
			this.follow = { pos : cam.follow.pos, target : cam.follow.target};
		} else {
			this.follow = null;
		}
		this.viewX = cam.viewX;
		this.viewY = cam.viewY;
		this.update();
	}
	,__class__: h3d_Camera
};
var h3d__$Engine_TargetTmp = function(t,n,l,m,db) {
	this.t = t;
	this.next = n;
	this.layer = l;
	this.mipLevel = m;
	this.depthBinding = db;
};
$hxClasses["h3d._Engine.TargetTmp"] = h3d__$Engine_TargetTmp;
h3d__$Engine_TargetTmp.__name__ = "h3d._Engine.TargetTmp";
h3d__$Engine_TargetTmp.prototype = {
	__class__: h3d__$Engine_TargetTmp
};
var h3d_DepthBinding = $hxEnums["h3d.DepthBinding"] = { __ename__:true,__constructs__:null
	,ReadWrite: {_hx_name:"ReadWrite",_hx_index:0,__enum__:"h3d.DepthBinding",toString:$estr}
	,ReadOnly: {_hx_name:"ReadOnly",_hx_index:1,__enum__:"h3d.DepthBinding",toString:$estr}
	,DepthOnly: {_hx_name:"DepthOnly",_hx_index:2,__enum__:"h3d.DepthBinding",toString:$estr}
	,NotBound: {_hx_name:"NotBound",_hx_index:3,__enum__:"h3d.DepthBinding",toString:$estr}
};
h3d_DepthBinding.__constructs__ = [h3d_DepthBinding.ReadWrite,h3d_DepthBinding.ReadOnly,h3d_DepthBinding.DepthOnly,h3d_DepthBinding.NotBound];
h3d_DepthBinding.__empty_constructs__ = [h3d_DepthBinding.ReadWrite,h3d_DepthBinding.ReadOnly,h3d_DepthBinding.DepthOnly,h3d_DepthBinding.NotBound];
var h3d_Engine = function() {
	this.resCache = new haxe_ds_ObjectMap();
	this.ready = false;
	this.inRender = false;
	this.textureColorCache = new haxe_ds_IntMap();
	this.tmpVector = new h3d_Vector4Impl(0.,0.,0.,1.);
	this.backgroundColor = -16777216;
	this.hardware = !h3d_Engine.SOFTWARE_DRIVER;
	this.antiAlias = h3d_Engine.ANTIALIASING;
	this.autoResize = true;
	this.set_fullScreen(!hxd_System.getValue(hxd_SystemValue.IsWindowed));
	this.window = hxd_Window.getInstance();
	this.realFps = hxd_System.getDefaultFrameRate();
	this.lastTime = HxOverrides.now() / 1000;
	this.window.addResizeEvent($bind(this,this.onWindowResize));
	h3d_Engine.CURRENT = this;
	this.window.setCurrent();
	this.driver = js_Browser.get_supported() ? new h3d_impl_GlDriver(this.antiAlias) : new h3d_impl_NullDriver();
};
$hxClasses["h3d.Engine"] = h3d_Engine;
h3d_Engine.__name__ = "h3d.Engine";
h3d_Engine.getCurrent = function() {
	return h3d_Engine.CURRENT;
};
h3d_Engine.prototype = {
	setDriver: function(d) {
		this.driver = d;
		if(this.mem != null) {
			this.mem.driver = d;
		}
	}
	,setCurrent: function() {
		h3d_Engine.CURRENT = this;
		this.window.setCurrent();
	}
	,init: function() {
		this.driver.init($bind(this,this.onCreate),!this.hardware);
	}
	,driverName: function(details) {
		if(details == null) {
			details = false;
		}
		return this.driver.getDriverName(details);
	}
	,selectShader: function(shader) {
		if(this.needFlushTarget) {
			this.doFlushTarget();
		}
		if(this.driver.selectShader(shader)) {
			this.shaderSwitches++;
		}
	}
	,selectMaterial: function(pass) {
		this.driver.selectMaterial(pass);
	}
	,uploadShaderBuffers: function(buffers,which) {
		this.driver.uploadShaderBuffers(buffers,which);
	}
	,selectBuffer: function(buf) {
		if(buf.vbuf == null) {
			return false;
		}
		if(this.needFlushTarget) {
			this.doFlushTarget();
		}
		this.driver.selectBuffer(buf);
		return true;
	}
	,renderTriBuffer: function(b,start,max) {
		if(max == null) {
			max = -1;
		}
		if(start == null) {
			start = 0;
		}
		this.renderBuffer(b,this.mem.getTriIndexes(b.vertices),3,start,max);
	}
	,renderQuadBuffer: function(b,start,max) {
		if(max == null) {
			max = -1;
		}
		if(start == null) {
			start = 0;
		}
		this.renderBuffer(b,this.mem.getQuadIndexes(b.vertices),2,start,max);
	}
	,renderBuffer: function(b,indexes,vertPerTri,startTri,drawTri) {
		if(drawTri == null) {
			drawTri = -1;
		}
		if(startTri == null) {
			startTri = 0;
		}
		if(indexes.vbuf == null) {
			return;
		}
		var ntri = b.vertices / vertPerTri | 0;
		if(drawTri < 0) {
			drawTri = ntri - startTri;
		}
		if(startTri < 0 || drawTri < 0 || startTri + drawTri > ntri) {
			throw haxe_Exception.thrown("Invalid vertices count");
		}
		if(drawTri > 0 && this.selectBuffer(b)) {
			this.driver.draw(indexes,startTri * 3,drawTri);
			this.drawTriangles += drawTri;
			this.drawCalls++;
		}
	}
	,renderIndexed: function(b,indexes,startTri,drawTri) {
		if(drawTri == null) {
			drawTri = -1;
		}
		if(startTri == null) {
			startTri = 0;
		}
		if(indexes.vbuf == null) {
			return;
		}
		var maxTri = indexes.vertices / 3 | 0;
		if(drawTri < 0) {
			drawTri = maxTri - startTri;
		}
		if(drawTri > 0 && this.selectBuffer(b)) {
			this.driver.draw(indexes,startTri * 3,drawTri);
			this.drawTriangles += drawTri;
			this.drawCalls++;
		}
	}
	,renderMultiBuffers: function(format,buffers,indexes,startTri,drawTri) {
		if(drawTri == null) {
			drawTri = -1;
		}
		if(startTri == null) {
			startTri = 0;
		}
		var maxTri = indexes.vertices / 3 | 0;
		if(maxTri <= 0) {
			return;
		}
		if(this.needFlushTarget) {
			this.doFlushTarget();
		}
		this.driver.selectMultiBuffers(format,buffers);
		if(indexes.vbuf == null) {
			return;
		}
		if(drawTri < 0) {
			drawTri = maxTri - startTri;
		}
		if(drawTri > 0) {
			this.driver.draw(indexes,startTri * 3,drawTri);
			this.drawTriangles += drawTri;
			this.drawCalls++;
		}
	}
	,renderInstanced: function(indexes,commands) {
		if(indexes.vbuf == null) {
			return;
		}
		if(commands.commandCount > 0) {
			this.driver.drawInstanced(indexes,commands);
			this.drawTriangles += commands.triCount;
			this.drawCalls++;
		}
	}
	,set_debug: function(d) {
		this.debug = d;
		this.driver.setDebug(this.debug);
		return d;
	}
	,onCreate: function(disposed) {
		h3d_Engine.CURRENT = this;
		this.window.setCurrent();
		if(this.autoResize) {
			this.width = this.window.get_width();
			this.height = this.window.get_height();
		}
		if(disposed) {
			hxd_impl_Allocator.get().onContextLost();
			this.mem.onContextLost();
		} else {
			this.mem = new h3d_impl_MemoryManager(this.driver);
			this.mem.init();
			this.nullTexture = new h3d_mat_Texture(0,0,[h3d_mat_TextureFlags.NoAlloc]);
		}
		this.hardware = this.driver.hasFeature(h3d_impl_Feature.HardwareAccelerated);
		this.set_debug(this.debug);
		this.set_fullScreen(this.fullScreen);
		this.resize(this.width,this.height);
		if(disposed) {
			this.onContextLost();
		} else {
			this.onReady();
		}
		this.ready = true;
	}
	,onContextLost: function() {
	}
	,onReady: function() {
	}
	,onWindowResize: function() {
		if(this.autoResize && !this.driver.isDisposed()) {
			var w = this.window.get_width();
			var h = this.window.get_height();
			if(w != this.width || h != this.height) {
				this.resize(w,h);
			}
			this.onResized();
		}
	}
	,set_fullScreen: function(v) {
		this.fullScreen = v;
		if(this.mem != null && hxd_System.getValue(hxd_SystemValue.IsWindowed)) {
			this.window.set_displayMode(v ? hxd_DisplayMode.Borderless : hxd_DisplayMode.Windowed);
		}
		return v;
	}
	,onResized: function() {
	}
	,resize: function(width,height) {
		if(width < 32) {
			width = 32;
		}
		if(height < 32) {
			height = 32;
		}
		this.width = width;
		this.height = height;
		if(!this.driver.isDisposed()) {
			this.driver.resize(width,height);
		}
	}
	,begin: function() {
		if(this.driver.isDisposed()) {
			return false;
		}
		this.inRender = true;
		this.drawTriangles = 0;
		this.shaderSwitches = 0;
		this.drawCalls = 0;
		this.dispatches = 0;
		this.targetStack = null;
		this.needFlushTarget = this.currentTargetTex != null;
		this.driver.begin(hxd_Timer.frameCount);
		if(this.backgroundColor != null) {
			this.clear(this.backgroundColor,1,0);
		}
		return true;
	}
	,hasFeature: function(f) {
		return this.driver.hasFeature(f);
	}
	,end: function() {
		this.inRender = false;
		this.driver.end();
	}
	,getCurrentTarget: function() {
		if(this.targetStack == null) {
			return null;
		} else if(this.targetStack.t == this.nullTexture) {
			return this.targetStack.textures[0];
		} else {
			return this.targetStack.t;
		}
	}
	,pushTarget: function(tex,layer,mipLevel,depthBinding) {
		if(depthBinding == null) {
			depthBinding = h3d_DepthBinding.ReadWrite;
		}
		if(mipLevel == null) {
			mipLevel = 0;
		}
		if(layer == null) {
			layer = 0;
		}
		var c = this.targetTmp;
		if(c == null) {
			c = new h3d__$Engine_TargetTmp(tex,this.targetStack,layer,mipLevel,depthBinding);
		} else {
			this.targetTmp = c.next;
			c.t = tex;
			c.next = this.targetStack;
			c.mipLevel = mipLevel;
			c.layer = layer;
			c.depthBinding = depthBinding;
		}
		this.targetStack = c;
		this.updateNeedFlush();
	}
	,updateNeedFlush: function() {
		var t = this.targetStack;
		if(t == null) {
			this.needFlushTarget = this.currentTargetTex != null;
		} else {
			this.needFlushTarget = this.currentTargetTex != t.t || this.currentTargetLayer != t.layer || this.currentTargetMip != t.mipLevel || t.textures != null || this.currentDepthBinding != t.depthBinding;
		}
	}
	,pushTargets: function(textures,depthBinding) {
		if(depthBinding == null) {
			depthBinding = h3d_DepthBinding.ReadWrite;
		}
		this.pushTarget(this.nullTexture,null,null,depthBinding);
		this.targetStack.textures = textures;
		this.needFlushTarget = true;
	}
	,pushDepth: function(depthBuffer) {
		this.pushTarget(depthBuffer,null,null,h3d_DepthBinding.DepthOnly);
	}
	,popTarget: function() {
		var c = this.targetStack;
		if(c == null) {
			throw haxe_Exception.thrown("popTarget() with no matching pushTarget()");
		}
		this.targetStack = c.next;
		this.updateNeedFlush();
		c.t = null;
		c.textures = null;
		c.next = this.targetTmp;
		this.targetTmp = c;
	}
	,flushTarget: function() {
		if(this.needFlushTarget) {
			this.doFlushTarget();
		}
	}
	,doFlushTarget: function() {
		var t = this.targetStack;
		if(t == null) {
			this.driver.setRenderTarget(null);
			this.currentTargetTex = null;
		} else {
			if(t.depthBinding == h3d_DepthBinding.DepthOnly) {
				this.driver.setDepth(t.t);
			} else if(t.textures != null) {
				this.driver.setRenderTargets(t.textures,t.depthBinding);
			} else {
				this.driver.setRenderTarget(t.t,t.layer,t.mipLevel,t.depthBinding);
			}
			this.currentTargetTex = t.t;
			this.currentTargetLayer = t.layer;
			this.currentTargetMip = t.mipLevel;
			this.currentDepthBinding = t.depthBinding;
		}
		this.needFlushTarget = false;
	}
	,clearF: function(color,depth,stencil) {
		if(this.needFlushTarget) {
			this.doFlushTarget();
		}
		this.driver.clear(color,depth,stencil);
	}
	,clear: function(color,depth,stencil) {
		if(color != null) {
			var _this = this.tmpVector;
			_this.x = (color >> 16 & 255) / 255;
			_this.y = (color >> 8 & 255) / 255;
			_this.z = (color & 255) / 255;
			_this.w = (color >>> 24) / 255;
		}
		if(this.needFlushTarget) {
			this.doFlushTarget();
		}
		this.driver.clear(color == null ? null : this.tmpVector,depth,stencil);
	}
	,setRenderZone: function(x,y,width,height) {
		if(height == null) {
			height = -1;
		}
		if(width == null) {
			width = -1;
		}
		if(y == null) {
			y = 0;
		}
		if(x == null) {
			x = 0;
		}
		if(this.needFlushTarget) {
			this.doFlushTarget();
		}
		this.driver.setRenderZone(x,y,width,height);
	}
	,render: function(obj) {
		if(!this.begin()) {
			return false;
		}
		obj.render(this);
		this.end();
		var delta = HxOverrides.now() / 1000 - this.lastTime;
		this.lastTime += delta;
		if(delta > 0) {
			var curFps = 1. / delta;
			if(curFps > this.realFps * 2) {
				curFps = this.realFps * 2;
			} else if(curFps < this.realFps * 0.5) {
				curFps = this.realFps * 0.5;
			}
			var f = delta / .5;
			if(f > 0.3) {
				f = 0.3;
			}
			this.realFps = this.realFps * (1 - f) + curFps * f;
		}
		return true;
	}
	,onTextureBiasChanged: function(t) {
		if(!t.isDepth()) {
			throw haxe_Exception.thrown("Can change texture bias on depth buffer only");
		}
		this.driver.onTextureBiasChanged(t);
	}
	,dispose: function() {
		this.driver.dispose();
		this.window.removeResizeEvent($bind(this,this.onWindowResize));
		if(this.mem != null) {
			this.mem.dispose();
		}
	}
	,get_fps: function() {
		return Math.ceil(this.realFps * 100) / 100;
	}
	,__class__: h3d_Engine
};
var h3d_Indexes = {};
h3d_Indexes._new = function(count,is32) {
	if(is32 == null) {
		is32 = false;
	}
	return new h3d_Buffer(count,is32 ? hxd_BufferFormat.get_INDEX32() : hxd_BufferFormat.get_INDEX16(),[h3d_BufferFlag.IndexBuffer]);
};
h3d_Indexes.uploadIndexes = function(this1,ibuf,bufPos,indices,startIndice) {
	if(startIndice == null) {
		startIndice = 0;
	}
	if(startIndice < 0 || indices < 0 || startIndice + indices > this1.vertices) {
		throw haxe_Exception.thrown("Invalid indices count");
	}
	if(this1.format.inputs[0].precision != 1) {
		throw haxe_Exception.thrown("Can't upload indexes on a 32-bit buffer");
	}
	if(indices == 0) {
		return;
	}
	h3d_Engine.CURRENT.driver.uploadIndexData(this1,startIndice,indices,ibuf,bufPos);
};
h3d_Indexes.get_count = function(this1) {
	return this1.vertices;
};
h3d_Indexes.alloc = function(i,startPos,length) {
	if(length == null) {
		length = -1;
	}
	if(startPos == null) {
		startPos = 0;
	}
	if(length < 0) {
		length = i.length;
	}
	var idx = h3d_Indexes._new(length);
	h3d_Indexes.uploadIndexes(idx,i,0,length);
	return idx;
};
var h3d_MatrixImpl = function() {
};
$hxClasses["h3d.MatrixImpl"] = h3d_MatrixImpl;
h3d_MatrixImpl.__name__ = "h3d.MatrixImpl";
h3d_MatrixImpl.prototype = {
	get_tx: function() {
		return this._41;
	}
	,get_ty: function() {
		return this._42;
	}
	,get_tz: function() {
		return this._43;
	}
	,set_tx: function(v) {
		return this._41 = v;
	}
	,set_ty: function(v) {
		return this._42 = v;
	}
	,set_tz: function(v) {
		return this._43 = v;
	}
	,equal: function(other) {
		if(this._11 == other._11 && this._12 == other._12 && this._13 == other._13 && this._14 == other._14 && this._21 == other._21 && this._22 == other._22 && this._23 == other._23 && this._24 == other._24 && this._31 == other._31 && this._32 == other._32 && this._33 == other._33 && this._34 == other._34 && this._41 == other._41 && this._42 == other._42 && this._43 == other._43) {
			return this._44 == other._44;
		} else {
			return false;
		}
	}
	,zero: function() {
		this._11 = 0.0;
		this._12 = 0.0;
		this._13 = 0.0;
		this._14 = 0.0;
		this._21 = 0.0;
		this._22 = 0.0;
		this._23 = 0.0;
		this._24 = 0.0;
		this._31 = 0.0;
		this._32 = 0.0;
		this._33 = 0.0;
		this._34 = 0.0;
		this._41 = 0.0;
		this._42 = 0.0;
		this._43 = 0.0;
		this._44 = 0.0;
	}
	,identity: function() {
		this._11 = 1.0;
		this._12 = 0.0;
		this._13 = 0.0;
		this._14 = 0.0;
		this._21 = 0.0;
		this._22 = 1.0;
		this._23 = 0.0;
		this._24 = 0.0;
		this._31 = 0.0;
		this._32 = 0.0;
		this._33 = 1.0;
		this._34 = 0.0;
		this._41 = 0.0;
		this._42 = 0.0;
		this._43 = 0.0;
		this._44 = 1.0;
	}
	,isIdentity: function() {
		if(this._41 != 0 || this._42 != 0 || this._43 != 0) {
			return false;
		}
		if(this._11 != 1 || this._22 != 1 || this._33 != 1) {
			return false;
		}
		if(this._12 != 0 || this._13 != 0 || this._14 != 0) {
			return false;
		}
		if(this._21 != 0 || this._23 != 0 || this._24 != 0) {
			return false;
		}
		if(this._31 != 0 || this._32 != 0 || this._34 != 0) {
			return false;
		}
		return this._44 == 1;
	}
	,isIdentityEpsilon: function(e) {
		var tmp;
		var tmp1;
		var f = this._41;
		if(!((f < 0 ? -f : f) > e)) {
			var f = this._42;
			tmp1 = (f < 0 ? -f : f) > e;
		} else {
			tmp1 = true;
		}
		if(!tmp1) {
			var f = this._43;
			tmp = (f < 0 ? -f : f) > e;
		} else {
			tmp = true;
		}
		if(tmp) {
			return false;
		}
		var tmp;
		var tmp1;
		var f = this._11 - 1;
		if(!((f < 0 ? -f : f) > e)) {
			var f = this._22 - 1;
			tmp1 = (f < 0 ? -f : f) > e;
		} else {
			tmp1 = true;
		}
		if(!tmp1) {
			var f = this._33 - 1;
			tmp = (f < 0 ? -f : f) > e;
		} else {
			tmp = true;
		}
		if(tmp) {
			return false;
		}
		var tmp;
		var tmp1;
		var f = this._12;
		if(!((f < 0 ? -f : f) > e)) {
			var f = this._13;
			tmp1 = (f < 0 ? -f : f) > e;
		} else {
			tmp1 = true;
		}
		if(!tmp1) {
			var f = this._14;
			tmp = (f < 0 ? -f : f) > e;
		} else {
			tmp = true;
		}
		if(tmp) {
			return false;
		}
		var tmp;
		var tmp1;
		var f = this._21;
		if(!((f < 0 ? -f : f) > e)) {
			var f = this._23;
			tmp1 = (f < 0 ? -f : f) > e;
		} else {
			tmp1 = true;
		}
		if(!tmp1) {
			var f = this._24;
			tmp = (f < 0 ? -f : f) > e;
		} else {
			tmp = true;
		}
		if(tmp) {
			return false;
		}
		var tmp;
		var tmp1;
		var f = this._31;
		if(!((f < 0 ? -f : f) > e)) {
			var f = this._32;
			tmp1 = (f < 0 ? -f : f) > e;
		} else {
			tmp1 = true;
		}
		if(!tmp1) {
			var f = this._34;
			tmp = (f < 0 ? -f : f) > e;
		} else {
			tmp = true;
		}
		if(tmp) {
			return false;
		}
		var f = this._44 - 1;
		return (f < 0 ? -f : f) <= e;
	}
	,initRotationX: function(a) {
		var cos = Math.cos(a);
		var sin = Math.sin(a);
		this._11 = 1.0;
		this._12 = 0.0;
		this._13 = 0.0;
		this._14 = 0.0;
		this._21 = 0.0;
		this._22 = cos;
		this._23 = sin;
		this._24 = 0.0;
		this._31 = 0.0;
		this._32 = -sin;
		this._33 = cos;
		this._34 = 0.0;
		this._41 = 0.0;
		this._42 = 0.0;
		this._43 = 0.0;
		this._44 = 1.0;
	}
	,initRotationY: function(a) {
		var cos = Math.cos(a);
		var sin = Math.sin(a);
		this._11 = cos;
		this._12 = 0.0;
		this._13 = -sin;
		this._14 = 0.0;
		this._21 = 0.0;
		this._22 = 1.0;
		this._23 = 0.0;
		this._24 = 0.0;
		this._31 = sin;
		this._32 = 0.0;
		this._33 = cos;
		this._34 = 0.0;
		this._41 = 0.0;
		this._42 = 0.0;
		this._43 = 0.0;
		this._44 = 1.0;
	}
	,initRotationZ: function(a) {
		var cos = Math.cos(a);
		var sin = Math.sin(a);
		this._11 = cos;
		this._12 = sin;
		this._13 = 0.0;
		this._14 = 0.0;
		this._21 = -sin;
		this._22 = cos;
		this._23 = 0.0;
		this._24 = 0.0;
		this._31 = 0.0;
		this._32 = 0.0;
		this._33 = 1.0;
		this._34 = 0.0;
		this._41 = 0.0;
		this._42 = 0.0;
		this._43 = 0.0;
		this._44 = 1.0;
	}
	,initTranslation: function(x,y,z) {
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		this._11 = 1.0;
		this._12 = 0.0;
		this._13 = 0.0;
		this._14 = 0.0;
		this._21 = 0.0;
		this._22 = 1.0;
		this._23 = 0.0;
		this._24 = 0.0;
		this._31 = 0.0;
		this._32 = 0.0;
		this._33 = 1.0;
		this._34 = 0.0;
		this._41 = x;
		this._42 = y;
		this._43 = z;
		this._44 = 1.0;
	}
	,initScale: function(x,y,z) {
		if(z == null) {
			z = 1.;
		}
		if(y == null) {
			y = 1.;
		}
		if(x == null) {
			x = 1.;
		}
		this._11 = x;
		this._12 = 0.0;
		this._13 = 0.0;
		this._14 = 0.0;
		this._21 = 0.0;
		this._22 = y;
		this._23 = 0.0;
		this._24 = 0.0;
		this._31 = 0.0;
		this._32 = 0.0;
		this._33 = z;
		this._34 = 0.0;
		this._41 = 0.0;
		this._42 = 0.0;
		this._43 = 0.0;
		this._44 = 1.0;
	}
	,initRotationAxis: function(axis,angle) {
		var cos = Math.cos(angle);
		var sin = Math.sin(angle);
		var cos1 = 1 - cos;
		var x = -axis.x;
		var y = -axis.y;
		var z = -axis.z;
		var xx = x * x;
		var yy = y * y;
		var zz = z * z;
		var len = 1. / Math.sqrt(xx + yy + zz);
		x *= len;
		y *= len;
		z *= len;
		var xcos1 = x * cos1;
		var zcos1 = z * cos1;
		this._11 = cos + x * xcos1;
		this._12 = y * xcos1 - z * sin;
		this._13 = x * zcos1 + y * sin;
		this._14 = 0.;
		this._21 = y * xcos1 + z * sin;
		this._22 = cos + y * y * cos1;
		this._23 = y * zcos1 - x * sin;
		this._24 = 0.;
		this._31 = x * zcos1 - y * sin;
		this._32 = y * zcos1 + x * sin;
		this._33 = cos + z * zcos1;
		this._34 = 0.;
		this._41 = 0.;
		this._42 = 0.;
		this._43 = 0.;
		this._44 = 1.;
	}
	,initRotation: function(x,y,z) {
		var cx = Math.cos(x);
		var sx = Math.sin(x);
		var cy = Math.cos(y);
		var sy = Math.sin(y);
		var cz = Math.cos(z);
		var sz = Math.sin(z);
		var cxsy = cx * sy;
		var sxsy = sx * sy;
		this._11 = cy * cz;
		this._12 = cy * sz;
		this._13 = -sy;
		this._14 = 0;
		this._21 = sxsy * cz - cx * sz;
		this._22 = sxsy * sz + cx * cz;
		this._23 = sx * cy;
		this._24 = 0;
		this._31 = cxsy * cz + sx * sz;
		this._32 = cxsy * sz - sx * cz;
		this._33 = cx * cy;
		this._34 = 0;
		this._41 = 0;
		this._42 = 0;
		this._43 = 0;
		this._44 = 1;
	}
	,translate: function(x,y,z) {
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		this._11 += x * this._14;
		this._12 += y * this._14;
		this._13 += z * this._14;
		this._21 += x * this._24;
		this._22 += y * this._24;
		this._23 += z * this._24;
		this._31 += x * this._34;
		this._32 += y * this._34;
		this._33 += z * this._34;
		this._41 += x * this._44;
		this._42 += y * this._44;
		this._43 += z * this._44;
	}
	,scale: function(x,y,z) {
		if(z == null) {
			z = 1.;
		}
		if(y == null) {
			y = 1.;
		}
		if(x == null) {
			x = 1.;
		}
		this._11 *= x;
		this._21 *= x;
		this._31 *= x;
		this._41 *= x;
		this._12 *= y;
		this._22 *= y;
		this._32 *= y;
		this._42 *= y;
		this._13 *= z;
		this._23 *= z;
		this._33 *= z;
		this._43 *= z;
	}
	,rotate: function(x,y,z) {
		var tmp = h3d_MatrixImpl.tmp;
		tmp.initRotation(x,y,z);
		this.multiply(this,tmp);
	}
	,rotateAxis: function(axis,angle) {
		var tmp = h3d_MatrixImpl.tmp;
		tmp.initRotationAxis(axis,angle);
		this.multiply(this,tmp);
	}
	,getPosition: function() {
		var v = new h3d_VectorImpl(0.,0.,0.);
		var _this = v;
		var x = this._41;
		var y = this._42;
		var z = this._43;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		return v;
	}
	,setPosition: function(v) {
		this._41 = v.x;
		this._42 = v.y;
		this._43 = v.z;
	}
	,prependTranslation: function(x,y,z) {
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var vx = this._11 * x + this._21 * y + this._31 * z + this._41;
		var vy = this._12 * x + this._22 * y + this._32 * z + this._42;
		var vz = this._13 * x + this._23 * y + this._33 * z + this._43;
		var vw = this._14 * x + this._24 * y + this._34 * z + this._44;
		this._41 = vx;
		this._42 = vy;
		this._43 = vz;
		this._44 = vw;
	}
	,getScale: function() {
		var v = new h3d_VectorImpl(0.,0.,0.);
		v.x = Math.sqrt(this._11 * this._11 + this._12 * this._12 + this._13 * this._13);
		v.y = Math.sqrt(this._21 * this._21 + this._22 * this._22 + this._23 * this._23);
		v.z = Math.sqrt(this._31 * this._31 + this._32 * this._32 + this._33 * this._33);
		if(this._11 * (this._22 * this._33 - this._23 * this._32) + this._12 * (this._23 * this._31 - this._21 * this._33) + this._13 * (this._21 * this._32 - this._22 * this._31) < 0) {
			v.x *= -1;
			v.y *= -1;
			v.z *= -1;
		}
		return v;
	}
	,prependRotation: function(x,y,z) {
		var tmp = h3d_MatrixImpl.tmp;
		tmp.initRotation(x,y,z);
		this.multiply(tmp,this);
	}
	,prependRotationAxis: function(axis,angle) {
		var tmp = h3d_MatrixImpl.tmp;
		tmp.initRotationAxis(axis,angle);
		this.multiply(tmp,this);
	}
	,prependScale: function(sx,sy,sz) {
		if(sz == null) {
			sz = 1.;
		}
		if(sy == null) {
			sy = 1.;
		}
		if(sx == null) {
			sx = 1.;
		}
		var tmp = h3d_MatrixImpl.tmp;
		tmp.initScale(sx,sy,sz);
		this.multiply(tmp,this);
	}
	,multiply3x4: function(a,b) {
		var m11 = a._11;
		var m12 = a._12;
		var m13 = a._13;
		var m21 = a._21;
		var m22 = a._22;
		var m23 = a._23;
		var a31 = a._31;
		var a32 = a._32;
		var a33 = a._33;
		var a41 = a._41;
		var a42 = a._42;
		var a43 = a._43;
		var b11 = b._11;
		var b12 = b._12;
		var b13 = b._13;
		var b21 = b._21;
		var b22 = b._22;
		var b23 = b._23;
		var b31 = b._31;
		var b32 = b._32;
		var b33 = b._33;
		var b41 = b._41;
		var b42 = b._42;
		var b43 = b._43;
		this._11 = m11 * b11 + m12 * b21 + m13 * b31;
		this._12 = m11 * b12 + m12 * b22 + m13 * b32;
		this._13 = m11 * b13 + m12 * b23 + m13 * b33;
		this._14 = 0;
		this._21 = m21 * b11 + m22 * b21 + m23 * b31;
		this._22 = m21 * b12 + m22 * b22 + m23 * b32;
		this._23 = m21 * b13 + m22 * b23 + m23 * b33;
		this._24 = 0;
		this._31 = a31 * b11 + a32 * b21 + a33 * b31;
		this._32 = a31 * b12 + a32 * b22 + a33 * b32;
		this._33 = a31 * b13 + a32 * b23 + a33 * b33;
		this._34 = 0;
		this._41 = a41 * b11 + a42 * b21 + a43 * b31 + b41;
		this._42 = a41 * b12 + a42 * b22 + a43 * b32 + b42;
		this._43 = a41 * b13 + a42 * b23 + a43 * b33 + b43;
		this._44 = 1;
	}
	,multiply3x4inline: function(a,b) {
		var m11 = a._11;
		var m12 = a._12;
		var m13 = a._13;
		var m21 = a._21;
		var m22 = a._22;
		var m23 = a._23;
		var a31 = a._31;
		var a32 = a._32;
		var a33 = a._33;
		var a41 = a._41;
		var a42 = a._42;
		var a43 = a._43;
		var b11 = b._11;
		var b12 = b._12;
		var b13 = b._13;
		var b21 = b._21;
		var b22 = b._22;
		var b23 = b._23;
		var b31 = b._31;
		var b32 = b._32;
		var b33 = b._33;
		var b41 = b._41;
		var b42 = b._42;
		var b43 = b._43;
		this._11 = m11 * b11 + m12 * b21 + m13 * b31;
		this._12 = m11 * b12 + m12 * b22 + m13 * b32;
		this._13 = m11 * b13 + m12 * b23 + m13 * b33;
		this._14 = 0;
		this._21 = m21 * b11 + m22 * b21 + m23 * b31;
		this._22 = m21 * b12 + m22 * b22 + m23 * b32;
		this._23 = m21 * b13 + m22 * b23 + m23 * b33;
		this._24 = 0;
		this._31 = a31 * b11 + a32 * b21 + a33 * b31;
		this._32 = a31 * b12 + a32 * b22 + a33 * b32;
		this._33 = a31 * b13 + a32 * b23 + a33 * b33;
		this._34 = 0;
		this._41 = a41 * b11 + a42 * b21 + a43 * b31 + b41;
		this._42 = a41 * b12 + a42 * b22 + a43 * b32 + b42;
		this._43 = a41 * b13 + a42 * b23 + a43 * b33 + b43;
		this._44 = 1;
	}
	,multiply: function(a,b) {
		var a11 = a._11;
		var a12 = a._12;
		var a13 = a._13;
		var a14 = a._14;
		var a21 = a._21;
		var a22 = a._22;
		var a23 = a._23;
		var a24 = a._24;
		var a31 = a._31;
		var a32 = a._32;
		var a33 = a._33;
		var a34 = a._34;
		var a41 = a._41;
		var a42 = a._42;
		var a43 = a._43;
		var a44 = a._44;
		var b11 = b._11;
		var b12 = b._12;
		var b13 = b._13;
		var b14 = b._14;
		var b21 = b._21;
		var b22 = b._22;
		var b23 = b._23;
		var b24 = b._24;
		var b31 = b._31;
		var b32 = b._32;
		var b33 = b._33;
		var b34 = b._34;
		var b41 = b._41;
		var b42 = b._42;
		var b43 = b._43;
		var b44 = b._44;
		this._11 = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		this._12 = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		this._13 = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		this._14 = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
		this._21 = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		this._22 = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		this._23 = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		this._24 = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
		this._31 = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		this._32 = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		this._33 = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		this._34 = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
		this._41 = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		this._42 = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		this._43 = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		this._44 = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
	}
	,multiplyValue: function(v) {
		this._11 *= v;
		this._12 *= v;
		this._13 *= v;
		this._14 *= v;
		this._21 *= v;
		this._22 *= v;
		this._23 *= v;
		this._24 *= v;
		this._31 *= v;
		this._32 *= v;
		this._33 *= v;
		this._34 *= v;
		this._41 *= v;
		this._42 *= v;
		this._43 *= v;
		this._44 *= v;
	}
	,invert: function() {
		this.initInverse(this);
	}
	,getInverse: function(m) {
		if(m == null) {
			m = new h3d_MatrixImpl();
		}
		m.initInverse(this);
		return m;
	}
	,getDeterminant: function() {
		return this._11 * (this._22 * this._33 - this._23 * this._32) + this._12 * (this._23 * this._31 - this._21 * this._33) + this._13 * (this._21 * this._32 - this._22 * this._31);
	}
	,inverse3x4: function(m) {
		var m11 = m._11;
		var m12 = m._12;
		var m13 = m._13;
		var m21 = m._21;
		var m22 = m._22;
		var m23 = m._23;
		var m31 = m._31;
		var m32 = m._32;
		var m33 = m._33;
		var m41 = m._41;
		var m42 = m._42;
		var m43 = m._43;
		this._11 = m22 * m33 - m23 * m32;
		this._12 = m13 * m32 - m12 * m33;
		this._13 = m12 * m23 - m13 * m22;
		this._14 = 0;
		this._21 = m23 * m31 - m21 * m33;
		this._22 = m11 * m33 - m13 * m31;
		this._23 = m13 * m21 - m11 * m23;
		this._24 = 0;
		this._31 = m21 * m32 - m22 * m31;
		this._32 = m12 * m31 - m11 * m32;
		this._33 = m11 * m22 - m12 * m21;
		this._34 = 0;
		this._41 = -m21 * m32 * m43 + m21 * m33 * m42 + m31 * m22 * m43 - m31 * m23 * m42 - m41 * m22 * m33 + m41 * m23 * m32;
		this._42 = m11 * m32 * m43 - m11 * m33 * m42 - m31 * m12 * m43 + m31 * m13 * m42 + m41 * m12 * m33 - m41 * m13 * m32;
		this._43 = -m11 * m22 * m43 + m11 * m23 * m42 + m21 * m12 * m43 - m21 * m13 * m42 - m41 * m12 * m23 + m41 * m13 * m22;
		this._44 = m11 * m22 * m33 - m11 * m23 * m32 - m21 * m12 * m33 + m21 * m13 * m32 + m31 * m12 * m23 - m31 * m13 * m22;
		this._44 = 1;
		var det = m11 * this._11 + m12 * this._21 + m13 * this._31;
		if((det < 0 ? -det : det) < 1e-10) {
			this.zero();
			return;
		}
		var invDet = 1.0 / det;
		this._11 *= invDet;
		this._12 *= invDet;
		this._13 *= invDet;
		this._21 *= invDet;
		this._22 *= invDet;
		this._23 *= invDet;
		this._31 *= invDet;
		this._32 *= invDet;
		this._33 *= invDet;
		this._41 *= invDet;
		this._42 *= invDet;
		this._43 *= invDet;
	}
	,initInverse: function(m) {
		var m11 = m._11;
		var m12 = m._12;
		var m13 = m._13;
		var m14 = m._14;
		var m21 = m._21;
		var m22 = m._22;
		var m23 = m._23;
		var m24 = m._24;
		var m31 = m._31;
		var m32 = m._32;
		var m33 = m._33;
		var m34 = m._34;
		var m41 = m._41;
		var m42 = m._42;
		var m43 = m._43;
		var m44 = m._44;
		this._11 = m22 * m33 * m44 - m22 * m34 * m43 - m32 * m23 * m44 + m32 * m24 * m43 + m42 * m23 * m34 - m42 * m24 * m33;
		this._12 = -m12 * m33 * m44 + m12 * m34 * m43 + m32 * m13 * m44 - m32 * m14 * m43 - m42 * m13 * m34 + m42 * m14 * m33;
		this._13 = m12 * m23 * m44 - m12 * m24 * m43 - m22 * m13 * m44 + m22 * m14 * m43 + m42 * m13 * m24 - m42 * m14 * m23;
		this._14 = -m12 * m23 * m34 + m12 * m24 * m33 + m22 * m13 * m34 - m22 * m14 * m33 - m32 * m13 * m24 + m32 * m14 * m23;
		this._21 = -m21 * m33 * m44 + m21 * m34 * m43 + m31 * m23 * m44 - m31 * m24 * m43 - m41 * m23 * m34 + m41 * m24 * m33;
		this._22 = m11 * m33 * m44 - m11 * m34 * m43 - m31 * m13 * m44 + m31 * m14 * m43 + m41 * m13 * m34 - m41 * m14 * m33;
		this._23 = -m11 * m23 * m44 + m11 * m24 * m43 + m21 * m13 * m44 - m21 * m14 * m43 - m41 * m13 * m24 + m41 * m14 * m23;
		this._24 = m11 * m23 * m34 - m11 * m24 * m33 - m21 * m13 * m34 + m21 * m14 * m33 + m31 * m13 * m24 - m31 * m14 * m23;
		this._31 = m21 * m32 * m44 - m21 * m34 * m42 - m31 * m22 * m44 + m31 * m24 * m42 + m41 * m22 * m34 - m41 * m24 * m32;
		this._32 = -m11 * m32 * m44 + m11 * m34 * m42 + m31 * m12 * m44 - m31 * m14 * m42 - m41 * m12 * m34 + m41 * m14 * m32;
		this._33 = m11 * m22 * m44 - m11 * m24 * m42 - m21 * m12 * m44 + m21 * m14 * m42 + m41 * m12 * m24 - m41 * m14 * m22;
		this._34 = -m11 * m22 * m34 + m11 * m24 * m32 + m21 * m12 * m34 - m21 * m14 * m32 - m31 * m12 * m24 + m31 * m14 * m22;
		this._41 = -m21 * m32 * m43 + m21 * m33 * m42 + m31 * m22 * m43 - m31 * m23 * m42 - m41 * m22 * m33 + m41 * m23 * m32;
		this._42 = m11 * m32 * m43 - m11 * m33 * m42 - m31 * m12 * m43 + m31 * m13 * m42 + m41 * m12 * m33 - m41 * m13 * m32;
		this._43 = -m11 * m22 * m43 + m11 * m23 * m42 + m21 * m12 * m43 - m21 * m13 * m42 - m41 * m12 * m23 + m41 * m13 * m22;
		this._44 = m11 * m22 * m33 - m11 * m23 * m32 - m21 * m12 * m33 + m21 * m13 * m32 + m31 * m12 * m23 - m31 * m13 * m22;
		var det = m11 * this._11 + m12 * this._21 + m13 * this._31 + m14 * this._41;
		if((det < 0 ? -det : det) < 1e-10) {
			this.zero();
			return;
		}
		det = 1.0 / det;
		this._11 *= det;
		this._12 *= det;
		this._13 *= det;
		this._14 *= det;
		this._21 *= det;
		this._22 *= det;
		this._23 *= det;
		this._24 *= det;
		this._31 *= det;
		this._32 *= det;
		this._33 *= det;
		this._34 *= det;
		this._41 *= det;
		this._42 *= det;
		this._43 *= det;
		this._44 *= det;
	}
	,initInverse3x3: function(m) {
		var m11 = m._11;
		var m12 = m._12;
		var m13 = m._13;
		var m21 = m._21;
		var m22 = m._22;
		var m23 = m._23;
		var m31 = m._31;
		var m32 = m._32;
		var m33 = m._33;
		this._11 = m22 * m33 - m32 * m23;
		this._12 = -m12 * m33 + m32 * m13;
		this._13 = m12 * m23 - m22 * m13;
		this._21 = -m21 * m33 + m31 * m23;
		this._22 = m11 * m33 - m31 * m13;
		this._23 = -m11 * m23 + m21 * m13;
		this._31 = m21 * m32 - m31 * m22;
		this._32 = -m11 * m32 + m31 * m12;
		this._33 = m11 * m22 - m21 * m12;
		var det = m11 * this._11 + m12 * this._21 + m13 * this._31;
		if((det < 0 ? -det : det) < 1e-10) {
			this.zero();
			return;
		}
		det = 1.0 / det;
		this._11 *= det;
		this._12 *= det;
		this._13 *= det;
		this._14 = 0;
		this._21 *= det;
		this._22 *= det;
		this._23 *= det;
		this._24 = 0;
		this._31 *= det;
		this._32 *= det;
		this._33 *= det;
		this._34 = 0;
		this._41 = 0;
		this._42 = 0;
		this._43 = 0;
		this._44 = 1;
	}
	,front: function() {
		var x = this._11;
		var y = this._12;
		var z = this._13;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var v = new h3d_VectorImpl(x,y,z);
		var _this = v;
		var k = _this.x * _this.x + _this.y * _this.y + _this.z * _this.z;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		_this.x *= k;
		_this.y *= k;
		_this.z *= k;
		return v;
	}
	,right: function() {
		var x = this._21;
		var y = this._22;
		var z = this._23;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var v = new h3d_VectorImpl(x,y,z);
		var _this = v;
		var k = _this.x * _this.x + _this.y * _this.y + _this.z * _this.z;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		_this.x *= k;
		_this.y *= k;
		_this.z *= k;
		return v;
	}
	,up: function() {
		var x = this._31;
		var y = this._32;
		var z = this._33;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var v = new h3d_VectorImpl(x,y,z);
		var _this = v;
		var k = _this.x * _this.x + _this.y * _this.y + _this.z * _this.z;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		_this.x *= k;
		_this.y *= k;
		_this.z *= k;
		return v;
	}
	,transpose: function() {
		var tmp = this._12;
		this._12 = this._21;
		this._21 = tmp;
		tmp = this._13;
		this._13 = this._31;
		this._31 = tmp;
		tmp = this._14;
		this._14 = this._41;
		this._41 = tmp;
		tmp = this._23;
		this._23 = this._32;
		this._32 = tmp;
		tmp = this._24;
		this._24 = this._42;
		this._42 = tmp;
		tmp = this._34;
		this._34 = this._43;
		this._43 = tmp;
	}
	,clone: function() {
		var m = new h3d_MatrixImpl();
		m._11 = this._11;
		m._12 = this._12;
		m._13 = this._13;
		m._14 = this._14;
		m._21 = this._21;
		m._22 = this._22;
		m._23 = this._23;
		m._24 = this._24;
		m._31 = this._31;
		m._32 = this._32;
		m._33 = this._33;
		m._34 = this._34;
		m._41 = this._41;
		m._42 = this._42;
		m._43 = this._43;
		m._44 = this._44;
		return m;
	}
	,load: function(m) {
		this._11 = m._11;
		this._12 = m._12;
		this._13 = m._13;
		this._14 = m._14;
		this._21 = m._21;
		this._22 = m._22;
		this._23 = m._23;
		this._24 = m._24;
		this._31 = m._31;
		this._32 = m._32;
		this._33 = m._33;
		this._34 = m._34;
		this._41 = m._41;
		this._42 = m._42;
		this._43 = m._43;
		this._44 = m._44;
	}
	,loadValues: function(a) {
		this._11 = a[0];
		this._12 = a[1];
		this._13 = a[2];
		this._14 = a[3];
		this._21 = a[4];
		this._22 = a[5];
		this._23 = a[6];
		this._24 = a[7];
		this._31 = a[8];
		this._32 = a[9];
		this._33 = a[10];
		this._34 = a[11];
		this._41 = a[12];
		this._42 = a[13];
		this._43 = a[14];
		this._44 = a[15];
	}
	,getFloats: function() {
		return [this._11,this._12,this._13,this._14,this._21,this._22,this._23,this._24,this._31,this._32,this._33,this._34,this._41,this._42,this._43,this._44];
	}
	,getDirection: function() {
		var q = new h3d_Quat();
		q.initRotateMatrix(this);
		q.normalize();
		var x = 1 - 2 * (q.y * q.y + q.z * q.z);
		var y = 2 * (q.x * q.y + q.z * q.w);
		var z = 2 * (q.x * q.z - q.y * q.w);
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,getEulerAngles: function() {
		var m = this.clone();
		var x = 0.;
		var y = 0.;
		var z = 0.;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var s_x = x;
		var s_y = y;
		var s_z = z;
		s_x = Math.sqrt(this._11 * this._11 + this._12 * this._12 + this._13 * this._13);
		s_y = Math.sqrt(this._21 * this._21 + this._22 * this._22 + this._23 * this._23);
		s_z = Math.sqrt(this._31 * this._31 + this._32 * this._32 + this._33 * this._33);
		if(this._11 * (this._22 * this._33 - this._23 * this._32) + this._12 * (this._23 * this._31 - this._21 * this._33) + this._13 * (this._21 * this._32 - this._22 * this._31) < 0) {
			s_x *= -1;
			s_y *= -1;
			s_z *= -1;
		}
		m.prependScale(1.0 / s_x,1.0 / s_y,1.0 / s_z);
		var cy = Math.sqrt(m._11 * m._11 + m._12 * m._12);
		if(cy > 0.01) {
			var x = Math.atan2(m._23,m._33);
			var y = Math.atan2(-m._13,cy);
			var z = Math.atan2(m._12,m._11);
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var v1 = new h3d_VectorImpl(x,y,z);
			var x = Math.atan2(-m._23,-m._33);
			var y = Math.atan2(-m._13,-cy);
			var z = Math.atan2(-m._12,-m._11);
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var v2 = new h3d_VectorImpl(x,y,z);
			var _this = v1;
			var _this1 = v2;
			if(_this.x * _this.x + _this.y * _this.y + _this.z * _this.z < _this1.x * _this1.x + _this1.y * _this1.y + _this1.z * _this1.z) {
				return v1;
			} else {
				return v2;
			}
		} else {
			var x = Math.atan2(-m._32,m._22);
			var y = Math.atan2(-m._13,cy);
			var z = 0.0;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			return new h3d_VectorImpl(x,y,z);
		}
	}
	,toString: function() {
		return "MAT=[\n" + "  [ " + hxd_Math.fmt(this._11) + ", " + hxd_Math.fmt(this._12) + ", " + hxd_Math.fmt(this._13) + ", " + hxd_Math.fmt(this._14) + " ]\n" + "  [ " + hxd_Math.fmt(this._21) + ", " + hxd_Math.fmt(this._22) + ", " + hxd_Math.fmt(this._23) + ", " + hxd_Math.fmt(this._24) + " ]\n" + "  [ " + hxd_Math.fmt(this._31) + ", " + hxd_Math.fmt(this._32) + ", " + hxd_Math.fmt(this._33) + ", " + hxd_Math.fmt(this._34) + " ]\n" + "  [ " + hxd_Math.fmt(this._41) + ", " + hxd_Math.fmt(this._42) + ", " + hxd_Math.fmt(this._43) + ", " + hxd_Math.fmt(this._44) + " ]\n" + "]";
	}
	,colorHue: function(hue) {
		if(hue == 0.) {
			return;
		}
		var cosA = Math.cos(-hue);
		var sinA = Math.sin(-hue);
		var ch = (1 - cosA) / 3;
		var tmp = h3d_MatrixImpl.tmp;
		tmp._11 = cosA + ch;
		tmp._12 = ch - 0.57735026918962576450914878050196 * sinA;
		tmp._13 = ch + 0.57735026918962576450914878050196 * sinA;
		tmp._21 = ch + 0.57735026918962576450914878050196 * sinA;
		tmp._22 = cosA + ch;
		tmp._23 = ch - 0.57735026918962576450914878050196 * sinA;
		tmp._31 = ch - 0.57735026918962576450914878050196 * sinA;
		tmp._32 = ch + 0.57735026918962576450914878050196 * sinA;
		tmp._33 = cosA + ch;
		tmp._34 = 0;
		tmp._41 = 0;
		tmp._42 = 0;
		tmp._43 = 0;
		this.multiply3x4(this,tmp);
	}
	,colorSaturate: function(sat) {
		++sat;
		var ins = 1 - sat;
		var r = ins * 0.212671;
		var g = ins * 0.71516;
		var b = ins * 0.072169;
		var tmp = h3d_MatrixImpl.tmp;
		tmp._11 = r + sat;
		tmp._12 = r;
		tmp._13 = r;
		tmp._21 = g;
		tmp._22 = g + sat;
		tmp._23 = g;
		tmp._31 = b;
		tmp._32 = b;
		tmp._33 = b + sat;
		tmp._41 = 0;
		tmp._42 = 0;
		tmp._43 = 0;
		this.multiply3x4(this,tmp);
	}
	,colorContrast: function(contrast) {
		var tmp = h3d_MatrixImpl.tmp;
		var v = contrast + 1;
		tmp._11 = v;
		tmp._12 = 0;
		tmp._13 = 0;
		tmp._21 = 0;
		tmp._22 = v;
		tmp._23 = 0;
		tmp._31 = 0;
		tmp._32 = 0;
		tmp._33 = v;
		tmp._41 = -contrast * 0.5;
		tmp._42 = -contrast * 0.5;
		tmp._43 = -contrast * 0.5;
		this.multiply3x4(this,tmp);
	}
	,colorLightness: function(lightness) {
		this._41 += lightness;
		this._42 += lightness;
		this._43 += lightness;
	}
	,colorGain: function(color,alpha) {
		var tmp = h3d_MatrixImpl.tmp;
		tmp._11 = 1 - alpha;
		tmp._12 = 0;
		tmp._13 = 0;
		tmp._21 = 0;
		tmp._22 = 1 - alpha;
		tmp._23 = 0;
		tmp._31 = 0;
		tmp._32 = 0;
		tmp._33 = 1 - alpha;
		tmp._41 = (color >> 16 & 255) / 255 * alpha;
		tmp._42 = (color >> 8 & 255) / 255 * alpha;
		tmp._43 = (color & 255) / 255 * alpha;
		this.multiply3x4(this,tmp);
	}
	,colorBits: function(bits,blend) {
		var t11 = 0.;
		var t12 = 0.;
		var t13 = 0.;
		var t21 = 0.;
		var t22 = 0.;
		var t23 = 0.;
		var t31 = 0.;
		var t32 = 0.;
		var t33 = 0.;
		var c = bits;
		if((c & 1) == 1) {
			t11 = 1;
		}
		c >>= 1;
		if((c & 1) == 1) {
			t12 = 1;
		}
		c >>= 1;
		if((c & 1) == 1) {
			t13 = 1;
		}
		c >>= 1;
		if((c & 1) == 1) {
			t21 = 1;
		}
		c >>= 1;
		if((c & 1) == 1) {
			t22 = 1;
		}
		c >>= 1;
		if((c & 1) == 1) {
			t23 = 1;
		}
		c >>= 1;
		if((c & 1) == 1) {
			t31 = 1;
		}
		c >>= 1;
		if((c & 1) == 1) {
			t32 = 1;
		}
		c >>= 1;
		if((c & 1) == 1) {
			t33 = 1;
		}
		c >>= 1;
		var r = t11 + t21 + t31;
		var g = t12 + t22 + t32;
		var b = t13 + t23 + t33;
		if(r > 1) {
			t11 /= r;
			t21 /= r;
			t31 /= r;
		}
		if(g > 1) {
			t12 /= g;
			t22 /= g;
			t32 /= g;
		}
		if(b > 1) {
			t13 /= b;
			t23 /= b;
			t33 /= b;
		}
		var b11 = this._11 * t11 + this._12 * t21 + this._13 * t31;
		var b12 = this._11 * t12 + this._12 * t22 + this._13 * t32;
		var b13 = this._11 * t13 + this._12 * t23 + this._13 * t33;
		var b21 = this._21 * t11 + this._22 * t21 + this._23 * t31;
		var b22 = this._21 * t12 + this._22 * t22 + this._23 * t32;
		var b23 = this._21 * t13 + this._22 * t23 + this._23 * t33;
		var b31 = this._31 * t11 + this._32 * t21 + this._33 * t31;
		var b32 = this._31 * t12 + this._32 * t22 + this._33 * t32;
		var b33 = this._31 * t13 + this._32 * t23 + this._33 * t33;
		var ik = blend;
		var k = 1 - ik;
		this._11 = this._11 * k + b11 * ik;
		this._12 = this._12 * k + b12 * ik;
		this._13 = this._13 * k + b13 * ik;
		this._21 = this._21 * k + b21 * ik;
		this._22 = this._22 * k + b22 * ik;
		this._23 = this._23 * k + b23 * ik;
		this._31 = this._31 * k + b31 * ik;
		this._32 = this._32 * k + b32 * ik;
		this._33 = this._33 * k + b33 * ik;
	}
	,colorAdd: function(c) {
		this._41 += (c >> 16 & 255) / 255;
		this._42 += (c >> 8 & 255) / 255;
		this._43 += (c & 255) / 255;
	}
	,colorSet: function(c,alpha) {
		if(alpha == null) {
			alpha = 1.;
		}
		this.zero();
		this._44 = alpha;
		this._41 += (c >> 16 & 255) / 255;
		this._42 += (c >> 8 & 255) / 255;
		this._43 += (c & 255) / 255;
	}
	,adjustColor: function(col) {
		if(col.hue != null) {
			this.colorHue(col.hue);
		}
		if(col.saturation != null) {
			this.colorSaturate(col.saturation);
		}
		if(col.contrast != null) {
			this.colorContrast(col.contrast);
		}
		if(col.lightness != null) {
			this.colorLightness(col.lightness);
		}
		if(col.gain != null) {
			this.colorGain(col.gain.color,col.gain.alpha);
		}
	}
	,toMatrix2D: function(m) {
		if(m == null) {
			m = new h2d_col_Matrix();
		}
		m.a = this._11;
		m.b = this._12;
		m.c = this._21;
		m.d = this._22;
		m.x = this._41;
		m.y = this._42;
		return m;
	}
	,decomposeMatrix: function(inMatrix) {
		this.load(inMatrix);
		var x = 0.;
		var y = 0.;
		var z = 0.;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var scale_x = x;
		var scale_y = y;
		var scale_z = z;
		scale_x = Math.sqrt(this._11 * this._11 + this._12 * this._12 + this._13 * this._13);
		scale_y = Math.sqrt(this._21 * this._21 + this._22 * this._22 + this._23 * this._23);
		scale_z = Math.sqrt(this._31 * this._31 + this._32 * this._32 + this._33 * this._33);
		if(this._11 * (this._22 * this._33 - this._23 * this._32) + this._12 * (this._23 * this._31 - this._21 * this._33) + this._13 * (this._21 * this._32 - this._22 * this._31) < 0) {
			scale_x *= -1;
			scale_y *= -1;
			scale_z *= -1;
		}
		this.prependScale(1.0 / scale_x,1.0 / scale_y,1.0 / scale_z);
		var quat_x = 0.;
		var quat_y = 0.;
		var quat_z = 0.;
		var quat_w = 1.;
		var tr = this._11 + this._22 + this._33;
		if(tr > 0) {
			var s = Math.sqrt(tr + 1.0) * 2;
			var ins = 1 / s;
			quat_x = (this._23 - this._32) * ins;
			quat_y = (this._31 - this._13) * ins;
			quat_z = (this._12 - this._21) * ins;
			quat_w = 0.25 * s;
		} else if(this._11 > this._22 && this._11 > this._33) {
			var s = Math.sqrt(1.0 + this._11 - this._22 - this._33) * 2;
			var ins = 1 / s;
			quat_x = 0.25 * s;
			quat_y = (this._21 + this._12) * ins;
			quat_z = (this._31 + this._13) * ins;
			quat_w = (this._23 - this._32) * ins;
		} else if(this._22 > this._33) {
			var s = Math.sqrt(1.0 + this._22 - this._11 - this._33) * 2;
			var ins = 1 / s;
			quat_x = (this._21 + this._12) * ins;
			quat_y = 0.25 * s;
			quat_z = (this._32 + this._23) * ins;
			quat_w = (this._31 - this._13) * ins;
		} else {
			var s = Math.sqrt(1.0 + this._33 - this._11 - this._22) * 2;
			var ins = 1 / s;
			quat_x = (this._31 + this._13) * ins;
			quat_y = (this._32 + this._23) * ins;
			quat_z = 0.25 * s;
			quat_w = (this._12 - this._21) * ins;
		}
		this._11 = scale_x;
		this._12 = quat_x;
		this._13 = quat_y;
		this._14 = 0.0;
		this._21 = quat_z;
		this._22 = scale_y;
		this._23 = quat_w;
		this._24 = 0.0;
		this._31 = 0.0;
		this._32 = 0.0;
		this._33 = scale_z;
		this._34 = 0.0;
		this._41 = inMatrix._41;
		this._42 = inMatrix._42;
		this._43 = inMatrix._43;
		this._44 = 1.0;
	}
	,recomposeMatrix: function(inMatrix) {
		var _this__44;
		var _this__43;
		var _this__42;
		var _this__41;
		var _this__34;
		var _this__33;
		var _this__32;
		var _this__31;
		var _this__24;
		var _this__23;
		var _this__22;
		var _this__21;
		var _this__14;
		var _this__13;
		var _this__12;
		var _this__11;
		_this__11 = inMatrix._11;
		_this__12 = inMatrix._12;
		_this__13 = inMatrix._13;
		_this__14 = inMatrix._14;
		_this__21 = inMatrix._21;
		_this__22 = inMatrix._22;
		_this__23 = inMatrix._23;
		_this__24 = inMatrix._24;
		_this__31 = inMatrix._31;
		_this__32 = inMatrix._32;
		_this__33 = inMatrix._33;
		_this__34 = inMatrix._34;
		_this__41 = inMatrix._41;
		_this__42 = inMatrix._42;
		_this__43 = inMatrix._43;
		_this__44 = inMatrix._44;
		var x = inMatrix._12;
		var y = inMatrix._13;
		var z = inMatrix._21;
		var w = inMatrix._23;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var quat_x = x;
		var quat_y = y;
		var quat_z = z;
		var quat_w = w;
		var m = this;
		if(m == null) {
			m = new h3d_MatrixImpl();
		}
		var xx = quat_x * quat_x;
		var xy = quat_x * quat_y;
		var xz = quat_x * quat_z;
		var xw = quat_x * quat_w;
		var yy = quat_y * quat_y;
		var yz = quat_y * quat_z;
		var yw = quat_y * quat_w;
		var zz = quat_z * quat_z;
		var zw = quat_z * quat_w;
		m._11 = 1 - 2 * (yy + zz);
		m._12 = 2 * (xy + zw);
		m._13 = 2 * (xz - yw);
		m._14 = 0;
		m._21 = 2 * (xy - zw);
		m._22 = 1 - 2 * (xx + zz);
		m._23 = 2 * (yz + xw);
		m._24 = 0;
		m._31 = 2 * (xz + yw);
		m._32 = 2 * (yz - xw);
		m._33 = 1 - 2 * (xx + yy);
		m._34 = 0;
		m._41 = 0;
		m._42 = 0;
		m._43 = 0;
		m._44 = 1;
		this._11 *= _this__11;
		this._12 *= _this__11;
		this._13 *= _this__11;
		this._21 *= _this__22;
		this._22 *= _this__22;
		this._23 *= _this__22;
		this._31 *= _this__33;
		this._32 *= _this__33;
		this._33 *= _this__33;
		this._41 = _this__41;
		this._42 = _this__42;
		this._43 = _this__43;
	}
	,__class__: h3d_MatrixImpl
};
var h3d_Matrix = {};
h3d_Matrix._new = function() {
	return new h3d_MatrixImpl();
};
h3d_Matrix.multiplied = function(this1,m) {
	var mout = new h3d_MatrixImpl();
	mout.multiply(this1,m);
	return mout;
};
h3d_Matrix.I = function() {
	var m = new h3d_MatrixImpl();
	m.identity();
	return m;
};
h3d_Matrix.L = function(a) {
	var m = new h3d_MatrixImpl();
	m.loadValues(a);
	return m;
};
h3d_Matrix.T = function(x,y,z) {
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	var m = new h3d_MatrixImpl();
	m.initTranslation(x,y,z);
	return m;
};
h3d_Matrix.R = function(x,y,z) {
	var m = new h3d_MatrixImpl();
	m.initRotation(x,y,z);
	return m;
};
h3d_Matrix.S = function(x,y,z) {
	if(z == null) {
		z = 1.0;
	}
	if(y == null) {
		y = 1.;
	}
	if(x == null) {
		x = 1.;
	}
	var m = new h3d_MatrixImpl();
	m.initScale(x,y,z);
	return m;
};
h3d_Matrix.lookAtXInline = function(dir,up,m) {
	var _this = dir;
	var k = _this.x * _this.x + _this.y * _this.y + _this.z * _this.z;
	if(k < 1e-20) {
		k = 0;
	} else {
		k = 1. / Math.sqrt(k);
	}
	var x = _this.x * k;
	var y = _this.y * k;
	var z = _this.z * k;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	var x1 = x;
	var y1 = y;
	var z1 = z;
	if(z1 == null) {
		z1 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	var _this_x = x1;
	var _this_y = y1;
	var _this_z = z1;
	var _this = up;
	var x = _this.y * _this_z - _this.z * _this_y;
	var y = _this.z * _this_x - _this.x * _this_z;
	var z = _this.x * _this_y - _this.y * _this_x;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	var x1 = x;
	var y1 = y;
	var z1 = z;
	if(z1 == null) {
		z1 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	var _this_x1 = x1;
	var _this_y1 = y1;
	var _this_z1 = z1;
	var k = _this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1;
	if(k < 1e-20) {
		k = 0;
	} else {
		k = 1. / Math.sqrt(k);
	}
	var x = _this_x1 * k;
	var y = _this_y1 * k;
	var z = _this_z1 * k;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	var x1 = x;
	var y1 = y;
	var z1 = z;
	if(z1 == null) {
		z1 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	var _this_x1 = x1;
	var _this_y1 = y1;
	var _this_z1 = z1;
	if(_this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1 < 1e-20) {
		_this_x1 = _this_y;
		_this_y1 = _this_z;
		_this_z1 = _this_x;
	}
	var x = _this_y * _this_z1 - _this_z * _this_y1;
	var y = _this_z * _this_x1 - _this_x * _this_z1;
	var z = _this_x * _this_y1 - _this_y * _this_x1;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	var x1 = x;
	var y1 = y;
	var z1 = z;
	if(z1 == null) {
		z1 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	var az_x = x1;
	var az_y = y1;
	var az_z = z1;
	m._11 = _this_x;
	m._12 = _this_y;
	m._13 = _this_z;
	m._14 = 0;
	m._21 = _this_x1;
	m._22 = _this_y1;
	m._23 = _this_z1;
	m._24 = 0;
	m._31 = az_x;
	m._32 = az_y;
	m._33 = az_z;
	m._34 = 0;
	m._41 = 0;
	m._42 = 0;
	m._43 = 0;
	m._44 = 1;
	return m;
};
h3d_Matrix.lookAtX = function(dir,up,m) {
	if(up == null) {
		var x = 0;
		var y = 0;
		var z = 1;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		up = new h3d_VectorImpl(x,y,z);
	}
	if(m == null) {
		m = new h3d_MatrixImpl();
	}
	var _this = dir;
	var k = _this.x * _this.x + _this.y * _this.y + _this.z * _this.z;
	if(k < 1e-20) {
		k = 0;
	} else {
		k = 1. / Math.sqrt(k);
	}
	var x = _this.x * k;
	var y = _this.y * k;
	var z = _this.z * k;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	var x1 = x;
	var y1 = y;
	var z1 = z;
	if(z1 == null) {
		z1 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	var _this_x = x1;
	var _this_y = y1;
	var _this_z = z1;
	var _this = up;
	var x = _this.y * _this_z - _this.z * _this_y;
	var y = _this.z * _this_x - _this.x * _this_z;
	var z = _this.x * _this_y - _this.y * _this_x;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	var x1 = x;
	var y1 = y;
	var z1 = z;
	if(z1 == null) {
		z1 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	var _this_x1 = x1;
	var _this_y1 = y1;
	var _this_z1 = z1;
	var k = _this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1;
	if(k < 1e-20) {
		k = 0;
	} else {
		k = 1. / Math.sqrt(k);
	}
	var x = _this_x1 * k;
	var y = _this_y1 * k;
	var z = _this_z1 * k;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	var x1 = x;
	var y1 = y;
	var z1 = z;
	if(z1 == null) {
		z1 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	var _this_x1 = x1;
	var _this_y1 = y1;
	var _this_z1 = z1;
	if(_this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1 < 1e-20) {
		_this_x1 = _this_y;
		_this_y1 = _this_z;
		_this_z1 = _this_x;
	}
	var x = _this_y * _this_z1 - _this_z * _this_y1;
	var y = _this_z * _this_x1 - _this_x * _this_z1;
	var z = _this_x * _this_y1 - _this_y * _this_x1;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	var x1 = x;
	var y1 = y;
	var z1 = z;
	if(z1 == null) {
		z1 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	var az_x = x1;
	var az_y = y1;
	var az_z = z1;
	m._11 = _this_x;
	m._12 = _this_y;
	m._13 = _this_z;
	m._14 = 0;
	m._21 = _this_x1;
	m._22 = _this_y1;
	m._23 = _this_z1;
	m._24 = 0;
	m._31 = az_x;
	m._32 = az_y;
	m._33 = az_z;
	m._34 = 0;
	m._41 = 0;
	m._42 = 0;
	m._43 = 0;
	m._44 = 1;
	return m;
};
var h3d_Quat = function(x,y,z,w) {
	if(w == null) {
		w = 1.;
	}
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.x = x;
	this.y = y;
	this.z = z;
	this.w = w;
};
$hxClasses["h3d.Quat"] = h3d_Quat;
h3d_Quat.__name__ = "h3d.Quat";
h3d_Quat.prototype = {
	set: function(x,y,z,w) {
		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;
	}
	,identity: function() {
		this.x = this.y = this.z = 0;
		this.w = 1;
	}
	,lengthSq: function() {
		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
	}
	,length: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
	}
	,load: function(q) {
		this.x = q.x;
		this.y = q.y;
		this.z = q.z;
		this.w = q.w;
	}
	,clone: function() {
		return new h3d_Quat(this.x,this.y,this.z,this.w);
	}
	,initMoveTo: function(from,to) {
		var hx = from.x + to.x;
		var hy = from.y + to.y;
		var hz = from.z + to.z;
		var h = 1. / Math.sqrt(hx * hx + hy * hy + hz * hz);
		this.x = from.y * hz - from.z * hy;
		this.y = from.z * hx - from.x * hz;
		this.z = from.x * hy - from.y * hx;
		this.w = from.x * hx + from.y * hy + from.z * hz;
		this.normalize();
	}
	,initNormal: function(dir,rotate) {
		if(rotate == null) {
			rotate = 0.0;
		}
		var _this = dir;
		var k = _this.x * _this.x + _this.y * _this.y + _this.z * _this.z;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		var x = _this.x * k;
		var y = _this.y * k;
		var z = _this.z * k;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		if(_this_x * _this_x + _this_y * _this_y < 1e-20) {
			var x = 1;
			var y = 0;
			var z = 0;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			this.initDirection(new h3d_VectorImpl(x,y,z));
		} else {
			var x = _this_x;
			var y = _this_y;
			var z = 0;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var _this_x1 = x1;
			var _this_y1 = y1;
			var _this_z1 = z1;
			var k = _this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1;
			if(k < 1e-20) {
				k = 0;
			} else {
				k = 1. / Math.sqrt(k);
			}
			var x = _this_x1 * k;
			var y = _this_y1 * k;
			var z = _this_z1 * k;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var ay_x = x1;
			var ay_y = y1;
			var ay_z = z1;
			var x = _this_y * ay_z - _this_z * ay_y;
			var y = _this_z * ay_x - _this_x * ay_z;
			var z = _this_x * ay_y - _this_y * ay_x;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var az_x = x1;
			var az_y = y1;
			var az_z = z1;
			var x = _this_y * az_z - _this_z * az_y;
			var y = _this_z * az_x - _this_x * az_z;
			var z = _this_x * az_y - _this_y * az_x;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var this_x = x1;
			var this_y = y1;
			var this_z = z1;
			var x = this_x;
			var y = this_y;
			var z = this_z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var ax = new h3d_VectorImpl(x,y,z);
			if(_this_z < 0.0) {
				var x = 0.0;
				var y = 0.0;
				var z = -1.0;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				this.initDirection(ax,new h3d_VectorImpl(x,y,z));
			} else {
				this.initDirection(ax);
			}
		}
		if(rotate != 0.0) {
			var quat = new h3d_Quat();
			quat.initRotateAxis(_this_x,_this_y,_this_z,rotate);
			this.multiply(quat,this);
		}
	}
	,initDirection: function(dir,up) {
		var _this = dir;
		var x = _this.x;
		var y = _this.y;
		var z = _this.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var k = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		var x = _this_x * k;
		var y = _this_y * k;
		var z = _this_z * k;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var x = -_this_y;
		var y = _this_x;
		var z = 0;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x1 = x1;
		var _this_y1 = y1;
		var _this_z1 = z1;
		if(up != null) {
			var _this = up;
			var x = _this.y * _this_z - _this.z * _this_y;
			var y = _this.z * _this_x - _this.x * _this_z;
			var z = _this.x * _this_y - _this.y * _this_x;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var v_x = x1;
			var v_y = y1;
			var v_z = z1;
			_this_x1 = v_x;
			_this_y1 = v_y;
			_this_z1 = v_z;
		}
		var k = _this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		_this_x1 *= k;
		_this_y1 *= k;
		_this_z1 *= k;
		if(_this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1 < 1e-20) {
			_this_x1 = _this_y;
			_this_y1 = _this_z;
			_this_z1 = _this_x;
		}
		var x = _this_y * _this_z1 - _this_z * _this_y1;
		var y = _this_z * _this_x1 - _this_x * _this_z1;
		var z = _this_x * _this_y1 - _this_y * _this_x1;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var az_x = x1;
		var az_y = y1;
		var az_z = z1;
		var tr = _this_x + _this_y1 + az_z;
		if(tr > 0) {
			var s = Math.sqrt(tr + 1.0) * 2;
			var ins = 1 / s;
			this.x = (_this_z1 - az_y) * ins;
			this.y = (az_x - _this_z) * ins;
			this.z = (_this_y - _this_x1) * ins;
			this.w = 0.25 * s;
		} else if(_this_x > _this_y1 && _this_x > az_z) {
			var s = Math.sqrt(1.0 + _this_x - _this_y1 - az_z) * 2;
			var ins = 1 / s;
			this.x = 0.25 * s;
			this.y = (_this_x1 + _this_y) * ins;
			this.z = (az_x + _this_z) * ins;
			this.w = (_this_z1 - az_y) * ins;
		} else if(_this_y1 > az_z) {
			var s = Math.sqrt(1.0 + _this_y1 - _this_x - az_z) * 2;
			var ins = 1 / s;
			this.x = (_this_x1 + _this_y) * ins;
			this.y = 0.25 * s;
			this.z = (az_y + _this_z1) * ins;
			this.w = (az_x - _this_z) * ins;
		} else {
			var s = Math.sqrt(1.0 + az_z - _this_x - _this_y1) * 2;
			var ins = 1 / s;
			this.x = (az_x + _this_z) * ins;
			this.y = (az_y + _this_z1) * ins;
			this.z = 0.25 * s;
			this.w = (_this_y - _this_x1) * ins;
		}
	}
	,initRotateAxis: function(x,y,z,a) {
		var sin = Math.sin(a / 2);
		var cos = Math.cos(a / 2);
		this.x = x * sin;
		this.y = y * sin;
		this.z = z * sin;
		this.w = cos * Math.sqrt(x * x + y * y + z * z);
		this.normalize();
	}
	,initRotateMatrix: function(m) {
		var tr = m._11 + m._22 + m._33;
		if(tr > 0) {
			var s = Math.sqrt(tr + 1.0) * 2;
			var ins = 1 / s;
			this.x = (m._23 - m._32) * ins;
			this.y = (m._31 - m._13) * ins;
			this.z = (m._12 - m._21) * ins;
			this.w = 0.25 * s;
		} else if(m._11 > m._22 && m._11 > m._33) {
			var s = Math.sqrt(1.0 + m._11 - m._22 - m._33) * 2;
			var ins = 1 / s;
			this.x = 0.25 * s;
			this.y = (m._21 + m._12) * ins;
			this.z = (m._31 + m._13) * ins;
			this.w = (m._23 - m._32) * ins;
		} else if(m._22 > m._33) {
			var s = Math.sqrt(1.0 + m._22 - m._11 - m._33) * 2;
			var ins = 1 / s;
			this.x = (m._21 + m._12) * ins;
			this.y = 0.25 * s;
			this.z = (m._32 + m._23) * ins;
			this.w = (m._31 - m._13) * ins;
		} else {
			var s = Math.sqrt(1.0 + m._33 - m._11 - m._22) * 2;
			var ins = 1 / s;
			this.x = (m._31 + m._13) * ins;
			this.y = (m._32 + m._23) * ins;
			this.z = 0.25 * s;
			this.w = (m._12 - m._21) * ins;
		}
	}
	,normalize: function() {
		var len = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
		if(len < 1e-20) {
			this.x = this.y = this.z = 0;
			this.w = 1;
		} else {
			var m = 1. / Math.sqrt(len);
			this.x *= m;
			this.y *= m;
			this.z *= m;
			this.w *= m;
		}
	}
	,initRotation: function(ax,ay,az) {
		var sinX = Math.sin(ax * 0.5);
		var cosX = Math.cos(ax * 0.5);
		var sinY = Math.sin(ay * 0.5);
		var cosY = Math.cos(ay * 0.5);
		var sinZ = Math.sin(az * 0.5);
		var cosZ = Math.cos(az * 0.5);
		var cosYZ = cosY * cosZ;
		var sinYZ = sinY * sinZ;
		this.x = sinX * cosYZ - cosX * sinYZ;
		this.y = cosX * sinY * cosZ + sinX * cosY * sinZ;
		this.z = cosX * cosY * sinZ - sinX * sinY * cosZ;
		this.w = cosX * cosYZ + sinX * sinYZ;
	}
	,multiply: function(q1,q2) {
		var x2 = q1.x * q2.w + q1.w * q2.x + q1.y * q2.z - q1.z * q2.y;
		var y2 = q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x;
		var z2 = q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w;
		var w2 = q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z;
		this.x = x2;
		this.y = y2;
		this.z = z2;
		this.w = w2;
	}
	,toEuler: function() {
		return this.toMatrix().getEulerAngles();
	}
	,lerp: function(q1,q2,v,nearest) {
		if(nearest == null) {
			nearest = false;
		}
		var v2 = 1 - v;
		if(nearest && q1.x * q2.x + q1.y * q2.y + q1.z * q2.z + q1.w * q2.w < 0) {
			v = -v;
		}
		var x = q1.x * v2 + q2.x * v;
		var y = q1.y * v2 + q2.y * v;
		var z = q1.z * v2 + q2.z * v;
		var w = q1.w * v2 + q2.w * v;
		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;
	}
	,slerp: function(q1,q2,v) {
		var cosHalfTheta = q1.x * q2.x + q1.y * q2.y + q1.z * q2.z + q1.w * q2.w;
		if((cosHalfTheta < 0 ? -cosHalfTheta : cosHalfTheta) >= 1) {
			this.x = q1.x;
			this.y = q1.y;
			this.z = q1.z;
			this.w = q1.w;
			return;
		}
		var halfTheta = Math.acos(cosHalfTheta);
		var invSinHalfTheta = 1. / Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
		if((invSinHalfTheta < 0 ? -invSinHalfTheta : invSinHalfTheta) > 1e3) {
			var v1 = 0.5;
			var nearest = true;
			if(nearest == null) {
				nearest = false;
			}
			var v2 = 1 - v1;
			if(nearest && q1.x * q2.x + q1.y * q2.y + q1.z * q2.z + q1.w * q2.w < 0) {
				v1 = -v1;
			}
			var x = q1.x * v2 + q2.x * v1;
			var y = q1.y * v2 + q2.y * v1;
			var z = q1.z * v2 + q2.z * v1;
			var w = q1.w * v2 + q2.w * v1;
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
			return;
		}
		var a = Math.sin((1 - v) * halfTheta) * invSinHalfTheta;
		var b = Math.sin(v * halfTheta) * invSinHalfTheta * (cosHalfTheta < 0 ? -1 : 1);
		this.x = q1.x * a + q2.x * b;
		this.y = q1.y * a + q2.y * b;
		this.z = q1.z * a + q2.z * b;
		this.w = q1.w * a + q2.w * b;
	}
	,conjugate: function() {
		this.x = -this.x;
		this.y = -this.y;
		this.z = -this.z;
	}
	,pow: function(v) {
		var r = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
		var t = r > 1e-10 ? Math.atan2(r,this.w) / r : 0;
		this.w = 0.5 * Math.log(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
		this.x *= t;
		this.y *= t;
		this.z *= t;
		this.x *= v;
		this.y *= v;
		this.z *= v;
		this.w *= v;
		var r = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
		var et = Math.exp(this.w);
		var s = r > 1e-10 ? et * Math.sin(r) / r : 0;
		this.w = et * Math.cos(r);
		this.x *= s;
		this.y *= s;
		this.z *= s;
	}
	,negate: function() {
		this.x = -this.x;
		this.y = -this.y;
		this.z = -this.z;
		this.w = -this.w;
	}
	,dot: function(q) {
		return this.x * q.x + this.y * q.y + this.z * q.z + this.w * q.w;
	}
	,getDirection: function() {
		var x = 1 - 2 * (this.y * this.y + this.z * this.z);
		var y = 2 * (this.x * this.y + this.z * this.w);
		var z = 2 * (this.x * this.z - this.y * this.w);
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,getUpAxis: function() {
		var x = 2 * (this.x * this.z + this.y * this.w);
		var y = 2 * (this.y * this.z - this.x * this.w);
		var z = 1 - 2 * (this.x * this.x + this.y * this.y);
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,toMatrix: function(m) {
		if(m == null) {
			m = new h3d_MatrixImpl();
		}
		var xx = this.x * this.x;
		var xy = this.x * this.y;
		var xz = this.x * this.z;
		var xw = this.x * this.w;
		var yy = this.y * this.y;
		var yz = this.y * this.z;
		var yw = this.y * this.w;
		var zz = this.z * this.z;
		var zw = this.z * this.w;
		m._11 = 1 - 2 * (yy + zz);
		m._12 = 2 * (xy + zw);
		m._13 = 2 * (xz - yw);
		m._14 = 0;
		m._21 = 2 * (xy - zw);
		m._22 = 1 - 2 * (xx + zz);
		m._23 = 2 * (yz + xw);
		m._24 = 0;
		m._31 = 2 * (xz + yw);
		m._32 = 2 * (yz - xw);
		m._33 = 1 - 2 * (xx + yy);
		m._34 = 0;
		m._41 = 0;
		m._42 = 0;
		m._43 = 0;
		m._44 = 1;
		return m;
	}
	,toString: function() {
		return "{" + hxd_Math.fmt(this.x) + "," + hxd_Math.fmt(this.y) + "," + hxd_Math.fmt(this.z) + "," + hxd_Math.fmt(this.w) + "}";
	}
	,weightedBlend: function(sourceQuats,weights,referenceQuat) {
		this.x = 0;
		this.y = 0;
		this.z = 0;
		this.w = 0;
		var mulRes_x = 0.;
		var mulRes_y = 0.;
		var mulRes_z = 0.;
		var mulRes_w = 1.;
		var x = referenceQuat.x;
		var y = referenceQuat.y;
		var z = referenceQuat.z;
		var w = referenceQuat.w;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var invRef_x = x;
		var invRef_y = y;
		var invRef_z = z;
		var invRef_w = w;
		invRef_x = -invRef_x;
		invRef_y = -invRef_y;
		invRef_z = -invRef_z;
		var _g_current = 0;
		var _g_array = sourceQuats;
		while(_g_current < _g_array.length) {
			var _g_value = _g_array[_g_current];
			var _g_key = _g_current++;
			var index = _g_key;
			var rotation = _g_value;
			var weight = weights[index];
			var x2 = invRef_x * rotation.w + invRef_w * rotation.x + invRef_y * rotation.z - invRef_z * rotation.y;
			var y2 = invRef_w * rotation.y - invRef_x * rotation.z + invRef_y * rotation.w + invRef_z * rotation.x;
			var z2 = invRef_w * rotation.z + invRef_x * rotation.y - invRef_y * rotation.x + invRef_z * rotation.w;
			var w2 = invRef_w * rotation.w - invRef_x * rotation.x - invRef_y * rotation.y - invRef_z * rotation.z;
			mulRes_x = x2;
			mulRes_y = y2;
			mulRes_z = z2;
			mulRes_w = w2;
			if(mulRes_w < 0) {
				mulRes_x = -mulRes_x;
				mulRes_y = -mulRes_y;
				mulRes_z = -mulRes_z;
				mulRes_w = -mulRes_w;
			}
			mulRes_w *= weight;
			mulRes_x *= weight;
			mulRes_y *= weight;
			mulRes_z *= weight;
			this.w += mulRes_w;
			this.x += mulRes_x;
			this.y += mulRes_y;
			this.z += mulRes_z;
		}
		var len = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
		if(len < 1e-20) {
			this.x = this.y = this.z = 0;
			this.w = 1;
		} else {
			var m = 1. / Math.sqrt(len);
			this.x *= m;
			this.y *= m;
			this.z *= m;
			this.w *= m;
		}
		var x2 = referenceQuat.x * this.w + referenceQuat.w * this.x + referenceQuat.y * this.z - referenceQuat.z * this.y;
		var y2 = referenceQuat.w * this.y - referenceQuat.x * this.z + referenceQuat.y * this.w + referenceQuat.z * this.x;
		var z2 = referenceQuat.w * this.z + referenceQuat.x * this.y - referenceQuat.y * this.x + referenceQuat.z * this.w;
		var w2 = referenceQuat.w * this.w - referenceQuat.x * this.x - referenceQuat.y * this.y - referenceQuat.z * this.z;
		this.x = x2;
		this.y = y2;
		this.z = z2;
		this.w = w2;
		if(this.w < 0) {
			this.x = -this.x;
			this.y = -this.y;
			this.z = -this.z;
			this.w = -this.w;
		}
	}
	,__class__: h3d_Quat
};
var h3d_VectorImpl = function(x,y,z) {
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.x = x;
	this.y = y;
	this.z = z;
};
$hxClasses["h3d.VectorImpl"] = h3d_VectorImpl;
h3d_VectorImpl.__name__ = "h3d.VectorImpl";
h3d_VectorImpl.prototype = {
	distance: function(v) {
		var dx = v.x - this.x;
		var dy = v.y - this.y;
		var dz = v.z - this.z;
		return Math.sqrt(dx * dx + dy * dy + dz * dz);
	}
	,distanceSq: function(v) {
		var dx = v.x - this.x;
		var dy = v.y - this.y;
		var dz = v.z - this.z;
		return dx * dx + dy * dy + dz * dz;
	}
	,sub: function(v) {
		var x = this.x - v.x;
		var y = this.y - v.y;
		var z = this.z - v.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,add: function(v) {
		var x = this.x + v.x;
		var y = this.y + v.y;
		var z = this.z + v.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,scaled: function(v) {
		var x = this.x * v;
		var y = this.y * v;
		var z = this.z * v;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,equals: function(v) {
		if(this.x == v.x && this.y == v.y) {
			return this.z == v.z;
		} else {
			return false;
		}
	}
	,cross: function(v) {
		var x = this.y * v.z - this.z * v.y;
		var y = this.z * v.x - this.x * v.z;
		var z = this.x * v.y - this.y * v.x;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,dot: function(v) {
		return this.x * v.x + this.y * v.y + this.z * v.z;
	}
	,lengthSq: function() {
		return this.x * this.x + this.y * this.y + this.z * this.z;
	}
	,length: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
	}
	,normalize: function() {
		var k = this.x * this.x + this.y * this.y + this.z * this.z;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		this.x *= k;
		this.y *= k;
		this.z *= k;
	}
	,normalized: function() {
		var k = this.x * this.x + this.y * this.y + this.z * this.z;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		var x = this.x * k;
		var y = this.y * k;
		var z = this.z * k;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,packNormal: function() {
		this.x = this.x * 0.5 + 0.5;
		this.y = this.y * 0.5 + 0.5;
		this.z = this.z * 0.5 + 0.5;
	}
	,unpackNormal: function() {
		this.x = this.x * 2.0 - 1.0;
		this.y = this.y * 2.0 - 1.0;
		this.z = this.z * 2.0 - 1.0;
	}
	,normalStrength: function(strength) {
		var k = 1.0 / strength;
		this.x *= k;
		this.y *= k;
		var k = this.x * this.x + this.y * this.y + this.z * this.z;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		this.x *= k;
		this.y *= k;
		this.z *= k;
	}
	,set: function(x,y,z) {
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		this.x = x;
		this.y = y;
		this.z = z;
	}
	,load: function(v) {
		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
	}
	,scale: function(f) {
		this.x *= f;
		this.y *= f;
		this.z *= f;
	}
	,lerp: function(v1,v2,k) {
		var a = v1.x;
		this.x = a + k * (v2.x - a);
		var a = v1.y;
		this.y = a + k * (v2.y - a);
		var a = v1.z;
		this.z = a + k * (v2.z - a);
	}
	,transform: function(m) {
		var px = this.x * m._11 + this.y * m._21 + this.z * m._31 + m._41;
		var py = this.x * m._12 + this.y * m._22 + this.z * m._32 + m._42;
		var pz = this.x * m._13 + this.y * m._23 + this.z * m._33 + m._43;
		this.x = px;
		this.y = py;
		this.z = pz;
	}
	,transformed: function(m) {
		var px = this.x * m._11 + this.y * m._21 + this.z * m._31 + m._41;
		var py = this.x * m._12 + this.y * m._22 + this.z * m._32 + m._42;
		var pz = this.x * m._13 + this.y * m._23 + this.z * m._33 + m._43;
		var x = px;
		var y = py;
		var z = pz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,transform3x3: function(m) {
		var px = this.x * m._11 + this.y * m._21 + this.z * m._31;
		var py = this.x * m._12 + this.y * m._22 + this.z * m._32;
		var pz = this.x * m._13 + this.y * m._23 + this.z * m._33;
		this.x = px;
		this.y = py;
		this.z = pz;
	}
	,transformed3x3: function(m) {
		var px = this.x * m._11 + this.y * m._21 + this.z * m._31;
		var py = this.x * m._12 + this.y * m._22 + this.z * m._32;
		var pz = this.x * m._13 + this.y * m._23 + this.z * m._33;
		var x = px;
		var y = py;
		var z = pz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,clone: function() {
		var x = this.x;
		var y = this.y;
		var z = this.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,toVector4: function() {
		var x = this.x;
		var y = this.y;
		var z = this.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_Vector4Impl(x,y,z,1.);
	}
	,toString: function() {
		return "{" + hxd_Math.fmt(this.x) + "," + hxd_Math.fmt(this.y) + "," + hxd_Math.fmt(this.z) + "}";
	}
	,reflect: function(n) {
		var k = 2 * (this.x * n.x + this.y * n.y + this.z * n.z);
		var x = this.x - k * n.x;
		var y = this.y - k * n.y;
		var z = this.z - k * n.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,project: function(m) {
		var px = this.x * m._11 + this.y * m._21 + this.z * m._31 + m._41;
		var py = this.x * m._12 + this.y * m._22 + this.z * m._32 + m._42;
		var pz = this.x * m._13 + this.y * m._23 + this.z * m._33 + m._43;
		var iw = 1 / (this.x * m._14 + this.y * m._24 + this.z * m._34 + m._44);
		this.x = px * iw;
		this.y = py * iw;
		this.z = pz * iw;
	}
	,get_r: function() {
		return this.x;
	}
	,get_g: function() {
		return this.y;
	}
	,get_b: function() {
		return this.z;
	}
	,set_r: function(v) {
		return this.x = v;
	}
	,set_g: function(v) {
		return this.y = v;
	}
	,set_b: function(v) {
		return this.z = v;
	}
	,setColor: function(c) {
		this.x = (c >> 16 & 255) / 255;
		this.y = (c >> 8 & 255) / 255;
		this.z = (c & 255) / 255;
	}
	,makeColor: function(hue,saturation,brightness) {
		if(brightness == null) {
			brightness = 0.5;
		}
		if(saturation == null) {
			saturation = 1.;
		}
		var r = hue % 6.2831853071795862;
		hue = r >= 0 ? r : r + 6.2831853071795862;
		var f = 2 * brightness - 1;
		var c = (1 - (f < 0 ? -f : f)) * saturation;
		var f = hue * 3 / 3.14159265358979323 % 2. - 1;
		var x = c * (1 - (f < 0 ? -f : f));
		var m = brightness - c / 2;
		if(hue < 1.0471975511965976) {
			this.x = c;
			this.y = x;
			this.z = 0;
		} else if(hue < 2.0943951023931953) {
			this.x = x;
			this.y = c;
			this.z = 0;
		} else if(hue < 3.14159265358979323) {
			this.x = 0;
			this.y = c;
			this.z = x;
		} else if(hue < 4.1887902047863905) {
			this.x = 0;
			this.y = x;
			this.z = c;
		} else if(hue < 5.2359877559829888) {
			this.x = x;
			this.y = 0;
			this.z = c;
		} else {
			this.x = c;
			this.y = 0;
			this.z = x;
		}
		this.x += m;
		this.y += m;
		this.z += m;
	}
	,toColor: function() {
		var f = this.x;
		var f1 = this.y;
		var f2 = this.z;
		return -16777216 | ((f < 0. ? 0. : f > 1. ? 1. : f) * 255 + 0.499 | 0) << 16 | ((f1 < 0. ? 0. : f1 > 1. ? 1. : f1) * 255 + 0.499 | 0) << 8 | ((f2 < 0. ? 0. : f2 > 1. ? 1. : f2) * 255 + 0.499 | 0);
	}
	,toColorHSL: function() {
		var a = this.x;
		var b = this.y;
		var a1 = a < b ? b : a;
		var b = this.z;
		var max = a1 < b ? b : a1;
		var a = this.x;
		var b = this.y;
		var a1 = a > b ? b : a;
		var b = this.z;
		var min = a1 > b ? b : a1;
		var h;
		var s;
		var l = (max + min) / 2.0;
		if(max == min) {
			s = 0.0;
			h = s;
		} else {
			var d = max - min;
			s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
			if(max == this.x) {
				h = (this.y - this.z) / d + (this.y < this.z ? 6.0 : 0.0);
			} else if(max == this.y) {
				h = (this.z - this.x) / d + 2.0;
			} else {
				h = (this.x - this.y) / d + 4.0;
			}
			h *= 1.0471975511965976;
		}
		var x = h;
		var y = s;
		var z = l;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,toColorHSV: function() {
		var a = this.x;
		var b = this.y;
		var a1 = a < b ? b : a;
		var b = this.z;
		var max = a1 < b ? b : a1;
		var a = this.x;
		var b = this.y;
		var a1 = a > b ? b : a;
		var b = this.z;
		var min = a1 > b ? b : a1;
		var h;
		var s;
		var v = max;
		if(max == min) {
			s = 0.0;
			h = s;
		} else {
			var d = max - min;
			s = max + min > 1.0 ? d / (2 - max - min) : d / (max + min);
			if(max == this.x) {
				h = (this.y - this.z) / d + (this.y < this.z ? 6.0 : 0.0);
			} else if(max == this.y) {
				h = (this.z - this.x) / d + 2.0;
			} else {
				h = (this.x - this.y) / d + 4.0;
			}
			h *= 1.0471975511965976;
		}
		var x = h;
		var y = s;
		var z = v;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,__class__: h3d_VectorImpl
};
var h3d_Vector = {};
h3d_Vector._new = function(x,y,z) {
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h3d_VectorImpl(x,y,z);
};
h3d_Vector.sub = function(this1,v) {
	var x = this1.x - v.x;
	var y = this1.y - v.y;
	var z = this1.z - v.z;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h3d_VectorImpl(x,y,z);
};
h3d_Vector.add = function(this1,v) {
	var x = this1.x + v.x;
	var y = this1.y + v.y;
	var z = this1.z + v.z;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h3d_VectorImpl(x,y,z);
};
h3d_Vector.transform = function(this1,m) {
	var px = this1.x * m._11 + this1.y * m._21 + this1.z * m._31 + m._41;
	var py = this1.x * m._12 + this1.y * m._22 + this1.z * m._32 + m._42;
	var pz = this1.x * m._13 + this1.y * m._23 + this1.z * m._33 + m._43;
	this1.x = px;
	this1.y = py;
	this1.z = pz;
};
h3d_Vector.transformed = function(this1,m) {
	var px = this1.x * m._11 + this1.y * m._21 + this1.z * m._31 + m._41;
	var py = this1.x * m._12 + this1.y * m._22 + this1.z * m._32 + m._42;
	var pz = this1.x * m._13 + this1.y * m._23 + this1.z * m._33 + m._43;
	var x = px;
	var y = py;
	var z = pz;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h3d_VectorImpl(x,y,z);
};
h3d_Vector.toPoint = function(this1) {
	var x = this1.x;
	var y = this1.y;
	var z = this1.z;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h3d_VectorImpl(x,y,z);
};
h3d_Vector.toVector = function(this1) {
	var x = this1.x;
	var y = this1.y;
	var z = this1.z;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h3d_VectorImpl(x,y,z);
};
h3d_Vector.scale = function(this1,v) {
	this1.x *= v;
	this1.y *= v;
	this1.z *= v;
};
h3d_Vector.scaled = function(this1,v) {
	var x = this1.x * v;
	var y = this1.y * v;
	var z = this1.z * v;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h3d_VectorImpl(x,y,z);
};
h3d_Vector.scaledInv = function(f,v) {
	var x = v.x * f;
	var y = v.y * f;
	var z = v.z * f;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h3d_VectorImpl(x,y,z);
};
h3d_Vector.fromColor = function(c,scale) {
	if(scale == null) {
		scale = 1.0;
	}
	var s = scale / 255;
	var x = (c >> 16 & 255) * s;
	var y = (c >> 8 & 255) * s;
	var z = (c & 255) * s;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h3d_VectorImpl(x,y,z);
};
h3d_Vector.fromArray = function(a) {
	var r = new h3d_VectorImpl(0.,0.,0.);
	if(a.length > 0) {
		r.x = a[0];
	}
	if(a.length > 1) {
		r.y = a[1];
	}
	if(a.length > 2) {
		r.z = a[2];
	}
	return r;
};
var h3d_Vector4Impl = function(x,y,z,w) {
	if(w == null) {
		w = 1.;
	}
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.x = x;
	this.y = y;
	this.z = z;
	this.w = w;
};
$hxClasses["h3d.Vector4Impl"] = h3d_Vector4Impl;
h3d_Vector4Impl.__name__ = "h3d.Vector4Impl";
h3d_Vector4Impl.prototype = {
	dot4: function(v) {
		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
	}
	,dot3: function(v) {
		return this.x * v.x + this.y * v.y + this.z * v.z;
	}
	,scale3: function(f) {
		this.x *= f;
		this.y *= f;
		this.z *= f;
	}
	,scale4: function(f) {
		this.x *= f;
		this.y *= f;
		this.z *= f;
		this.w *= f;
	}
	,sub: function(v) {
		var x = this.x - v.x;
		var y = this.y - v.y;
		var z = this.z - v.z;
		var w = this.w - v.w;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_Vector4Impl(x,y,z,w);
	}
	,add: function(v) {
		var x = this.x + v.x;
		var y = this.y + v.y;
		var z = this.z + v.z;
		var w = this.w + v.w;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_Vector4Impl(x,y,z,w);
	}
	,equals: function(v) {
		if(this.x == v.x && this.y == v.y && this.z == v.z) {
			return this.w == v.w;
		} else {
			return false;
		}
	}
	,cross: function(v) {
		var x = this.y * v.z - this.z * v.y;
		var y = this.z * v.x - this.x * v.z;
		var z = this.x * v.y - this.y * v.x;
		var w = 1;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_Vector4Impl(x,y,z,w);
	}
	,set: function(x,y,z,w) {
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;
	}
	,load: function(v) {
		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = v.w;
	}
	,lerp: function(v1,v2,k) {
		var a = v1.x;
		this.x = a + k * (v2.x - a);
		var a = v1.y;
		this.y = a + k * (v2.y - a);
		var a = v1.z;
		this.z = a + k * (v2.z - a);
		var a = v1.w;
		this.w = a + k * (v2.w - a);
	}
	,transform: function(m) {
		var px = this.x * m._11 + this.y * m._21 + this.z * m._31 + this.w * m._41;
		var py = this.x * m._12 + this.y * m._22 + this.z * m._32 + this.w * m._42;
		var pz = this.x * m._13 + this.y * m._23 + this.z * m._33 + this.w * m._43;
		var pw = this.x * m._14 + this.y * m._24 + this.z * m._34 + this.w * m._44;
		this.x = px;
		this.y = py;
		this.z = pz;
		this.w = pw;
	}
	,transformed: function(m) {
		var px = this.x * m._11 + this.y * m._21 + this.z * m._31 + this.w * m._41;
		var py = this.x * m._12 + this.y * m._22 + this.z * m._32 + this.w * m._42;
		var pz = this.x * m._13 + this.y * m._23 + this.z * m._33 + this.w * m._43;
		var pw = this.x * m._14 + this.y * m._24 + this.z * m._34 + this.w * m._44;
		var x = px;
		var y = py;
		var z = pz;
		var w = pw;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_Vector4Impl(x,y,z,w);
	}
	,transform3x4: function(m) {
		var px = this.x * m._11 + this.y * m._21 + this.z * m._31 + this.w * m._41;
		var py = this.x * m._12 + this.y * m._22 + this.z * m._32 + this.w * m._42;
		var pz = this.x * m._13 + this.y * m._23 + this.z * m._33 + this.w * m._43;
		this.x = px;
		this.y = py;
		this.z = pz;
	}
	,transformed3x4: function(m) {
		var px = this.x * m._11 + this.y * m._21 + this.z * m._31 + this.w * m._41;
		var py = this.x * m._12 + this.y * m._22 + this.z * m._32 + this.w * m._42;
		var pz = this.x * m._13 + this.y * m._23 + this.z * m._33 + this.w * m._43;
		var x = px;
		var y = py;
		var z = pz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_Vector4Impl(x,y,z,1.);
	}
	,transform3x3: function(m) {
		var px = this.x * m._11 + this.y * m._21 + this.z * m._31;
		var py = this.x * m._12 + this.y * m._22 + this.z * m._32;
		var pz = this.x * m._13 + this.y * m._23 + this.z * m._33;
		this.x = px;
		this.y = py;
		this.z = pz;
	}
	,transformed3x3: function(m) {
		var px = this.x * m._11 + this.y * m._21 + this.z * m._31;
		var py = this.x * m._12 + this.y * m._22 + this.z * m._32;
		var pz = this.x * m._13 + this.y * m._23 + this.z * m._33;
		var x = px;
		var y = py;
		var z = pz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_Vector4Impl(x,y,z,1.);
	}
	,clone: function() {
		var x = this.x;
		var y = this.y;
		var z = this.z;
		var w = this.w;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_Vector4Impl(x,y,z,w);
	}
	,toVector: function() {
		var x = this.x;
		var y = this.y;
		var z = this.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,toString: function() {
		return "{" + hxd_Math.fmt(this.x) + "," + hxd_Math.fmt(this.y) + "," + hxd_Math.fmt(this.z) + "," + hxd_Math.fmt(this.w) + "}";
	}
	,project: function(m) {
		var px = this.x * m._11 + this.y * m._21 + this.z * m._31 + this.w * m._41;
		var py = this.x * m._12 + this.y * m._22 + this.z * m._32 + this.w * m._42;
		var pz = this.x * m._13 + this.y * m._23 + this.z * m._33 + this.w * m._43;
		var iw = 1 / (this.x * m._14 + this.y * m._24 + this.z * m._34 + this.w * m._44);
		this.x = px * iw;
		this.y = py * iw;
		this.z = pz * iw;
		this.w = 1;
	}
	,get_r: function() {
		return this.x;
	}
	,get_g: function() {
		return this.y;
	}
	,get_b: function() {
		return this.z;
	}
	,get_a: function() {
		return this.w;
	}
	,set_r: function(v) {
		return this.x = v;
	}
	,set_g: function(v) {
		return this.y = v;
	}
	,set_b: function(v) {
		return this.z = v;
	}
	,set_a: function(v) {
		return this.w = v;
	}
	,setColor: function(c) {
		this.x = (c >> 16 & 255) / 255;
		this.y = (c >> 8 & 255) / 255;
		this.z = (c & 255) / 255;
		this.w = (c >>> 24) / 255;
	}
	,makeColor: function(hue,saturation,brightness) {
		if(brightness == null) {
			brightness = 0.5;
		}
		if(saturation == null) {
			saturation = 1.;
		}
		var r = hue % 6.2831853071795862;
		hue = r >= 0 ? r : r + 6.2831853071795862;
		var f = 2 * brightness - 1;
		var c = (1 - (f < 0 ? -f : f)) * saturation;
		var f = hue * 3 / 3.14159265358979323 % 2. - 1;
		var x = c * (1 - (f < 0 ? -f : f));
		var m = brightness - c / 2;
		if(hue < 1.0471975511965976) {
			this.x = c;
			this.y = x;
			this.z = 0;
		} else if(hue < 2.0943951023931953) {
			this.x = x;
			this.y = c;
			this.z = 0;
		} else if(hue < 3.14159265358979323) {
			this.x = 0;
			this.y = c;
			this.z = x;
		} else if(hue < 4.1887902047863905) {
			this.x = 0;
			this.y = x;
			this.z = c;
		} else if(hue < 5.2359877559829888) {
			this.x = x;
			this.y = 0;
			this.z = c;
		} else {
			this.x = c;
			this.y = 0;
			this.z = x;
		}
		this.x += m;
		this.y += m;
		this.z += m;
		this.w = 1;
	}
	,toColor: function() {
		var f = this.w;
		var f1 = this.x;
		var f2 = this.y;
		var f3 = this.z;
		return ((f < 0. ? 0. : f > 1. ? 1. : f) * 255 + 0.499 | 0) << 24 | ((f1 < 0. ? 0. : f1 > 1. ? 1. : f1) * 255 + 0.499 | 0) << 16 | ((f2 < 0. ? 0. : f2 > 1. ? 1. : f2) * 255 + 0.499 | 0) << 8 | ((f3 < 0. ? 0. : f3 > 1. ? 1. : f3) * 255 + 0.499 | 0);
	}
	,toColorHSL: function() {
		var a = this.x;
		var b = this.y;
		var a1 = a < b ? b : a;
		var b = this.z;
		var max = a1 < b ? b : a1;
		var a = this.x;
		var b = this.y;
		var a1 = a > b ? b : a;
		var b = this.z;
		var min = a1 > b ? b : a1;
		var h;
		var s;
		var l = (max + min) / 2.0;
		if(max == min) {
			s = 0.0;
			h = s;
		} else {
			var d = max - min;
			s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
			if(max == this.x) {
				h = (this.y - this.z) / d + (this.y < this.z ? 6.0 : 0.0);
			} else if(max == this.y) {
				h = (this.z - this.x) / d + 2.0;
			} else {
				h = (this.x - this.y) / d + 4.0;
			}
			h *= 1.0471975511965976;
		}
		var x = h;
		var y = s;
		var z = l;
		var w = this.w;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_Vector4Impl(x,y,z,w);
	}
	,toColorHSV: function() {
		var a = this.x;
		var b = this.y;
		var a1 = a < b ? b : a;
		var b = this.z;
		var max = a1 < b ? b : a1;
		var a = this.x;
		var b = this.y;
		var a1 = a > b ? b : a;
		var b = this.z;
		var min = a1 > b ? b : a1;
		var h;
		var s;
		var v = max;
		if(max == min) {
			s = 0.0;
			h = s;
		} else {
			var d = max - min;
			s = max + min > 1.0 ? d / (2 - max - min) : d / (max + min);
			if(max == this.x) {
				h = (this.y - this.z) / d + (this.y < this.z ? 6.0 : 0.0);
			} else if(max == this.y) {
				h = (this.z - this.x) / d + 2.0;
			} else {
				h = (this.x - this.y) / d + 4.0;
			}
			h *= 1.0471975511965976;
		}
		var x = h;
		var y = s;
		var z = v;
		var w = this.w;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_Vector4Impl(x,y,z,w);
	}
	,__class__: h3d_Vector4Impl
};
var h3d_Vector4 = {};
h3d_Vector4._new = function(x,y,z,w) {
	if(w == null) {
		w = 1.;
	}
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h3d_Vector4Impl(x,y,z,w);
};
h3d_Vector4.sub = function(this1,v) {
	var x = this1.x - v.x;
	var y = this1.y - v.y;
	var z = this1.z - v.z;
	var w = this1.w - v.w;
	if(w == null) {
		w = 1.;
	}
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h3d_Vector4Impl(x,y,z,w);
};
h3d_Vector4.add = function(this1,v) {
	var x = this1.x + v.x;
	var y = this1.y + v.y;
	var z = this1.z + v.z;
	var w = this1.w + v.w;
	if(w == null) {
		w = 1.;
	}
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h3d_Vector4Impl(x,y,z,w);
};
h3d_Vector4.transform = function(this1,m) {
	var px = this1.x * m._11 + this1.y * m._21 + this1.z * m._31 + this1.w * m._41;
	var py = this1.x * m._12 + this1.y * m._22 + this1.z * m._32 + this1.w * m._42;
	var pz = this1.x * m._13 + this1.y * m._23 + this1.z * m._33 + this1.w * m._43;
	var pw = this1.x * m._14 + this1.y * m._24 + this1.z * m._34 + this1.w * m._44;
	this1.x = px;
	this1.y = py;
	this1.z = pz;
	this1.w = pw;
};
h3d_Vector4.transformed = function(this1,m) {
	var px = this1.x * m._11 + this1.y * m._21 + this1.z * m._31 + this1.w * m._41;
	var py = this1.x * m._12 + this1.y * m._22 + this1.z * m._32 + this1.w * m._42;
	var pz = this1.x * m._13 + this1.y * m._23 + this1.z * m._33 + this1.w * m._43;
	var pw = this1.x * m._14 + this1.y * m._24 + this1.z * m._34 + this1.w * m._44;
	var x = px;
	var y = py;
	var z = pz;
	var w = pw;
	if(w == null) {
		w = 1.;
	}
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h3d_Vector4Impl(x,y,z,w);
};
h3d_Vector4.fromColor = function(c,scale) {
	if(scale == null) {
		scale = 1.0;
	}
	var s = scale / 255;
	var x = (c >> 16 & 255) * s;
	var y = (c >> 8 & 255) * s;
	var z = (c & 255) * s;
	var w = (c >>> 24) * s;
	if(w == null) {
		w = 1.;
	}
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h3d_Vector4Impl(x,y,z,w);
};
h3d_Vector4.fromArray = function(a) {
	var r = new h3d_Vector4Impl(0.,0.,0.,1.);
	if(a.length > 0) {
		r.x = a[0];
	}
	if(a.length > 1) {
		r.y = a[1];
	}
	if(a.length > 2) {
		r.z = a[2];
	}
	if(a.length > 3) {
		r.w = a[3];
	}
	return r;
};
var h3d_anim_AnimatedObject = function(name) {
	this.objectName = name;
};
$hxClasses["h3d.anim.AnimatedObject"] = h3d_anim_AnimatedObject;
h3d_anim_AnimatedObject.__name__ = "h3d.anim.AnimatedObject";
h3d_anim_AnimatedObject.prototype = {
	clone: function() {
		return new h3d_anim_AnimatedObject(this.objectName);
	}
	,__class__: h3d_anim_AnimatedObject
};
var h3d_anim_Animation = function(name,frameCount,sampling) {
	this.name = name;
	this.frameCount = frameCount;
	this.sampling = sampling;
	this.objects = [];
	this.lastEvent = -1;
	this.frame = 0.;
	this.speed = 1.;
	this.loop = true;
	this.pause = false;
};
$hxClasses["h3d.anim.Animation"] = h3d_anim_Animation;
h3d_anim_Animation.__name__ = "h3d.anim.Animation";
h3d_anim_Animation.prototype = {
	getDuration: function() {
		return this.frameCount / (this.sampling * this.speed);
	}
	,frameToTime: function(f) {
		return f / (this.sampling * this.speed);
	}
	,getIFrame: function() {
		var f = this.frame | 0;
		var max = this.endFrame();
		if(f == max) {
			--f;
		}
		return f;
	}
	,unbind: function(objectName) {
		var _g = 0;
		var _g1 = this.objects;
		while(_g < _g1.length) {
			var o = _g1[_g];
			++_g;
			if(o.objectName == objectName) {
				this.isSync = false;
				o.targetObject = null;
				o.targetSkin = null;
				return;
			}
		}
	}
	,setEvents: function(el) {
		var _g = [];
		var _g1 = 0;
		var _g2 = this.frameCount;
		while(_g1 < _g2) {
			var i = _g1++;
			_g.push(null);
		}
		this.events = _g;
		var e = $getIterator(el);
		while(e.hasNext()) {
			var e1 = e.next();
			if(this.events[e1.frame] == null) {
				this.events[e1.frame] = [];
			}
			this.events[e1.frame].push(e1.data);
		}
	}
	,addEvent: function(frame,data) {
		if(this.events == null) {
			this.events = [];
		}
		if(this.events[frame] == null) {
			this.events[frame] = [data];
		} else {
			this.events[frame].push(data);
		}
	}
	,removeEvent: function(frame,data) {
		if(this.events == null || this.events[frame] == null || this.events[frame].indexOf(data) == -1) {
			throw haxe_Exception.thrown("Can't delete event " + data + " because it doesn't exist at frame " + frame);
		}
		HxOverrides.remove(this.events[frame],data);
		if(this.events[frame].length == 0) {
			this.events[frame] = null;
		}
	}
	,getEvents: function() {
		return this.events;
	}
	,getObjects: function() {
		return this.objects;
	}
	,getEventTime: function(id) {
		if(this.events == null) {
			return null;
		}
		var _g = 0;
		var _g1 = this.events.length;
		while(_g < _g1) {
			var i = _g++;
			var ev = this.events[i];
			if(ev != null && ev.indexOf(id) >= 0) {
				return i / (this.sampling * this.speed);
			}
		}
		return null;
	}
	,setFrame: function(f) {
		this.frame = f;
		this.lastEvent = -1;
		while(this.frame < 0) this.frame += this.frameCount;
		while(this.frame > this.frameCount) this.frame -= this.frameCount;
	}
	,clone: function(a) {
		if(a == null) {
			a = new h3d_anim_Animation(this.name,this.frameCount,this.sampling);
		}
		a.objects = this.objects;
		a.speed = this.speed;
		a.loop = this.loop;
		a.pause = this.pause;
		a.events = this.events;
		a.resourcePath = this.resourcePath;
		return a;
	}
	,initInstance: function() {
		this.isInstance = true;
	}
	,createInstance: function(base) {
		var _g = [];
		var _g1 = 0;
		var _g2 = this.objects;
		while(_g1 < _g2.length) {
			var a = _g2[_g1];
			++_g1;
			_g.push(a.clone());
		}
		var objects = _g;
		var a = this.clone();
		a.objects = objects;
		a.bind(base);
		a.initInstance();
		return a;
	}
	,bind: function(base) {
		var currentSkin = null;
		var _g = 0;
		var _g1 = this.objects.slice();
		while(_g < _g1.length) {
			var a = _g1[_g];
			++_g;
			if(currentSkin != null) {
				var j = currentSkin.skinData.namedJoints.h[a.objectName];
				if(j != null) {
					a.targetSkin = currentSkin;
					a.targetJoint = j.index;
					continue;
				}
			}
			var obj = base.getObjectByName(a.objectName);
			if(obj == null) {
				HxOverrides.remove(this.objects,a);
				continue;
			}
			var joint = ((obj) instanceof h3d_scene_Joint) ? obj : null;
			if(joint != null) {
				currentSkin = joint.parent;
				a.targetSkin = currentSkin != null ? currentSkin : joint.skin;
				a.targetJoint = joint.index;
			} else {
				a.targetObject = obj;
			}
		}
		this.isSync = false;
	}
	,getPropValue: function(objectName,propName) {
		return null;
	}
	,sync: function(decompose) {
		if(decompose == null) {
			decompose = false;
		}
		throw haxe_Exception.thrown("assert");
	}
	,isPlaying: function() {
		if(!this.pause) {
			return (this.speed < 0 ? -this.speed : this.speed) > 0.000001;
		} else {
			return false;
		}
	}
	,endFrame: function() {
		return this.frameCount;
	}
	,update: function(dt) {
		if(!this.isInstance) {
			throw haxe_Exception.thrown("You must instantiate this animation first");
		}
		if(!this.isPlaying()) {
			return 0;
		}
		if(this.events != null && this.onEvent != null) {
			var f0 = this.frame | 0;
			var f1 = this.frame + dt * this.speed * this.sampling | 0;
			if(f1 >= this.frameCount) {
				f1 = this.frameCount - 1;
			}
			var _g = f0;
			var _g1 = f1 + 1;
			while(_g < _g1) {
				var f = _g++;
				if(f == this.lastEvent) {
					continue;
				}
				this.lastEvent = f;
				if(this.events[f] != null) {
					var oldF = this.frame;
					var oldDT = dt;
					dt -= (f - this.frame) / (this.speed * this.sampling);
					this.frame = f;
					var _g2 = 0;
					var _g3 = this.events[f];
					while(_g2 < _g3.length) {
						var e = _g3[_g2];
						++_g2;
						this.onEvent(e);
					}
					if(this.frame == f && f == this.frameCount - 1) {
						this.frame = oldF;
						dt = oldDT;
						break;
					} else {
						return dt;
					}
				}
			}
		}
		if(this.onAnimEnd != null) {
			var end = this.endFrame();
			var et = this.speed == 0 ? 0 : (end - this.frame) / (this.speed * this.sampling);
			if(et <= dt && et > 0) {
				this.frame = end;
				dt -= et;
				this.onAnimEnd();
				if(this.frame == end && this.isPlaying()) {
					if(this.loop) {
						this.frame = 0;
					} else {
						dt = 0;
					}
				}
				return dt;
			}
		}
		this.frame += dt * this.speed * this.sampling;
		if(this.frame >= this.frameCount) {
			if(this.loop) {
				this.frame %= this.frameCount;
			} else {
				this.frame = this.frameCount;
			}
		}
		return 0;
	}
	,initAndBind: function(obj) {
		this.bind(obj);
		this.initInstance();
		this.pause = true;
	}
	,toString: function() {
		return this.name;
	}
	,__class__: h3d_anim_Animation
};
var h3d_anim_DataLayout = $hxEnums["h3d.anim.DataLayout"] = { __ename__:true,__constructs__:null
	,Position: {_hx_name:"Position",_hx_index:0,__enum__:"h3d.anim.DataLayout",toString:$estr}
	,Rotation: {_hx_name:"Rotation",_hx_index:1,__enum__:"h3d.anim.DataLayout",toString:$estr}
	,Scale: {_hx_name:"Scale",_hx_index:2,__enum__:"h3d.anim.DataLayout",toString:$estr}
	,UV: {_hx_name:"UV",_hx_index:3,__enum__:"h3d.anim.DataLayout",toString:$estr}
	,Alpha: {_hx_name:"Alpha",_hx_index:4,__enum__:"h3d.anim.DataLayout",toString:$estr}
	,Property: {_hx_name:"Property",_hx_index:5,__enum__:"h3d.anim.DataLayout",toString:$estr}
	,SingleFrame: {_hx_name:"SingleFrame",_hx_index:6,__enum__:"h3d.anim.DataLayout",toString:$estr}
};
h3d_anim_DataLayout.__constructs__ = [h3d_anim_DataLayout.Position,h3d_anim_DataLayout.Rotation,h3d_anim_DataLayout.Scale,h3d_anim_DataLayout.UV,h3d_anim_DataLayout.Alpha,h3d_anim_DataLayout.Property,h3d_anim_DataLayout.SingleFrame];
h3d_anim_DataLayout.__empty_constructs__ = [h3d_anim_DataLayout.Position,h3d_anim_DataLayout.Rotation,h3d_anim_DataLayout.Scale,h3d_anim_DataLayout.UV,h3d_anim_DataLayout.Alpha,h3d_anim_DataLayout.Property,h3d_anim_DataLayout.SingleFrame];
var h3d_anim_BufferObject = function(objectName,dataOffset) {
	h3d_anim_AnimatedObject.call(this,objectName);
	this.dataOffset = dataOffset;
};
$hxClasses["h3d.anim.BufferObject"] = h3d_anim_BufferObject;
h3d_anim_BufferObject.__name__ = "h3d.anim.BufferObject";
h3d_anim_BufferObject.__super__ = h3d_anim_AnimatedObject;
h3d_anim_BufferObject.prototype = $extend(h3d_anim_AnimatedObject.prototype,{
	getStride: function() {
		var stride = 0;
		if((this.layout & 1 << h3d_anim_DataLayout.Position._hx_index) != 0) {
			stride += 3;
		}
		if((this.layout & 1 << h3d_anim_DataLayout.Rotation._hx_index) != 0) {
			stride += 3;
		}
		if((this.layout & 1 << h3d_anim_DataLayout.Scale._hx_index) != 0) {
			stride += 3;
		}
		if((this.layout & 1 << h3d_anim_DataLayout.UV._hx_index) != 0) {
			stride += 2;
		}
		if((this.layout & 1 << h3d_anim_DataLayout.Alpha._hx_index) != 0) {
			++stride;
		}
		if((this.layout & 1 << h3d_anim_DataLayout.Property._hx_index) != 0) {
			++stride;
		}
		return stride;
	}
	,clone: function() {
		var o = new h3d_anim_BufferObject(this.objectName,this.dataOffset);
		o.layout = this.layout;
		o.propName = this.propName;
		return o;
	}
	,__class__: h3d_anim_BufferObject
});
var h3d_anim_BufferAnimation = function(name,frame,sampling) {
	h3d_anim_Animation.call(this,name,frame,sampling);
	this.syncFrame = -1;
};
$hxClasses["h3d.anim.BufferAnimation"] = h3d_anim_BufferAnimation;
h3d_anim_BufferAnimation.__name__ = "h3d.anim.BufferAnimation";
h3d_anim_BufferAnimation.__super__ = h3d_anim_Animation;
h3d_anim_BufferAnimation.prototype = $extend(h3d_anim_Animation.prototype,{
	setData: function(data,stride) {
		this.data = data;
		this.stride = stride;
	}
	,addObject: function(objName,offset) {
		var f = new h3d_anim_BufferObject(objName,offset);
		this.objects.push(f);
		return f;
	}
	,getPropValue: function(objName,propName) {
		var _g = 0;
		var _g1 = this.objects;
		while(_g < _g1.length) {
			var o = _g1[_g];
			++_g;
			if(o.objectName == objName && o.propName == propName) {
				return o.propCurrentValue;
			}
		}
		return null;
	}
	,getFrames: function() {
		return this.objects;
	}
	,clone: function(a) {
		if(a == null) {
			a = new h3d_anim_BufferAnimation(this.name,this.frameCount,this.sampling);
		}
		h3d_anim_Animation.prototype.clone.call(this,a);
		var la = ((a) instanceof h3d_anim_BufferAnimation) ? a : null;
		la.setData(this.data,this.stride);
		return a;
	}
	,endFrame: function() {
		if(this.loop) {
			return this.frameCount;
		} else {
			return this.frameCount - 1;
		}
	}
	,initInstance: function() {
		h3d_anim_Animation.prototype.initInstance.call(this);
		var frames = this.objects;
		var _g = 0;
		while(_g < frames.length) {
			var a = frames[_g];
			++_g;
			if((a.layout & 1 << h3d_anim_DataLayout.Property._hx_index) != 0) {
				a.propCurrentValue = this.data[a.dataOffset];
			}
			var tmp;
			if((a.layout & 1 << h3d_anim_DataLayout.Alpha._hx_index) != 0) {
				if(a.targetObject != null) {
					var _this = a.targetObject;
					tmp = (((_this) instanceof h3d_scene_Mesh) ? _this : null) == null;
				} else {
					tmp = true;
				}
			} else {
				tmp = false;
			}
			if(tmp) {
				throw haxe_Exception.thrown(a.objectName + " should be a mesh (for alpha animation)");
			}
			if((a.layout & 1 << h3d_anim_DataLayout.Position._hx_index) != 0 || (a.layout & 1 << h3d_anim_DataLayout.Rotation._hx_index) != 0 || (a.layout & 1 << h3d_anim_DataLayout.Scale._hx_index) != 0) {
				a.matrix = new h3d_MatrixImpl();
				a.matrix.identity();
				if((a.layout & 1 << h3d_anim_DataLayout.Position._hx_index) == 0 && a.targetSkin != null) {
					var m2 = a.targetSkin.getSkinData().allJoints[a.targetJoint].defMat;
					a.matrix._14 = m2._41;
					a.matrix._24 = m2._42;
					a.matrix._34 = m2._43;
				}
			}
		}
		frames.sort($bind(this,this.sortByFrameCountDesc));
	}
	,sortByFrameCountDesc: function(o1,o2) {
		return ((o2.layout & 1 << h3d_anim_DataLayout.SingleFrame._hx_index) != 0 ? 0 : 1) - ((o1.layout & 1 << h3d_anim_DataLayout.SingleFrame._hx_index) != 0 ? 0 : 1);
	}
	,uvLerp: function(v1,v2,k) {
		v1 %= 1.;
		v2 %= 1.;
		if(v1 < v2 - 0.5) {
			++v1;
		} else if(v1 > v2 + 0.5) {
			--v1;
		}
		return v1 * (1 - k) + v2 * k;
	}
	,sync: function(decompose) {
		if(decompose == null) {
			decompose = false;
		}
		var _gthis = this;
		if(this.frame == this.syncFrame && !decompose) {
			return;
		}
		var f = this.frame | 0;
		var max = this.endFrame();
		if(f == max) {
			--f;
		}
		var frame1 = f;
		var frame2 = (frame1 + 1) % this.frameCount;
		var k2 = this.frame - frame1;
		var k1 = 1 - k2;
		if(frame1 < 0) {
			frame2 = 0;
			frame1 = frame2;
		} else if(this.frame >= this.frameCount) {
			frame2 = this.frameCount - 1;
			frame1 = frame2;
		} else if(!this.loop && frame2 == 0) {
			frame2 = this.frameCount - 1;
		}
		this.syncFrame = this.frame;
		if(decompose) {
			this.isSync = false;
		}
		var _g = 0;
		var _g1 = this.objects;
		while(_g < _g1.length) {
			var o = _g1[_g];
			++_g;
			if(o.targetObject == null && o.targetSkin == null) {
				continue;
			}
			var layout = o.layout;
			var offset1 = this.stride * frame1 + o.dataOffset;
			var offset2 = this.stride * frame2 + o.dataOffset;
			var frame11 = frame1;
			var frame21 = frame2;
			if((layout & 1 << h3d_anim_DataLayout.SingleFrame._hx_index) != 0) {
				if(this.isSync) {
					break;
				}
				frame21 = 0;
				frame11 = frame21;
				offset2 = o.dataOffset;
				offset1 = offset2;
			}
			var m = o.matrix;
			if(m != null) {
				var tmp = o.targetSkin;
				var skinData = tmp != null ? tmp.skinData : null;
				if(!(skinData != null && !skinData.allJoints[o.targetJoint].shouldReceiveAnimation())) {
					if((layout & 1 << h3d_anim_DataLayout.Position._hx_index) != 0) {
						m._41 = _gthis.data[offset1++] * k1 + _gthis.data[offset2++] * k2;
						m._42 = _gthis.data[offset1++] * k1 + _gthis.data[offset2++] * k2;
						m._43 = _gthis.data[offset1++] * k1 + _gthis.data[offset2++] * k2;
					} else {
						m._41 = m._14;
						m._42 = m._24;
						m._43 = m._34;
					}
					if((layout & 1 << h3d_anim_DataLayout.Rotation._hx_index) != 0) {
						var q1x = this.data[offset1++];
						var q1y = this.data[offset1++];
						var q1z = this.data[offset1++];
						var f = 1 - (q1x * q1x + q1y * q1y + q1z * q1z);
						var q1w = Math.sqrt(f < 0 ? -f : f);
						var q2x = this.data[offset2++];
						var q2y = this.data[offset2++];
						var q2z = this.data[offset2++];
						var f1 = 1 - (q2x * q2x + q2y * q2y + q2z * q2z);
						var q2w = Math.sqrt(f1 < 0 ? -f1 : f1);
						var dot = q1x * q2x + q1y * q2y + q1z * q2z + q1w * q2w;
						var q2 = dot < 0 ? -k2 : k2;
						var qx = q1x * k1 + q2x * q2;
						var qy = q1y * k1 + q2y * q2;
						var qz = q1z * k1 + q2z * q2;
						var qw = q1w * k1 + q2w * q2;
						var ql = 1 / Math.sqrt(qx * qx + qy * qy + qz * qz + qw * qw);
						qx *= ql;
						qy *= ql;
						qz *= ql;
						qw *= ql;
						if(decompose) {
							m._12 = qx;
							m._13 = qy;
							m._21 = qz;
							m._23 = qw;
							if((layout & 1 << h3d_anim_DataLayout.Scale._hx_index) != 0) {
								m._11 = _gthis.data[offset1++] * k1 + _gthis.data[offset2++] * k2;
								m._22 = _gthis.data[offset1++] * k1 + _gthis.data[offset2++] * k2;
								m._33 = _gthis.data[offset1++] * k1 + _gthis.data[offset2++] * k2;
							} else {
								m._11 = 1;
								m._22 = 1;
								m._33 = 1;
							}
						} else {
							var xx = qx * qx;
							var xy = qx * qy;
							var xz = qx * qz;
							var xw = qx * qw;
							var yy = qy * qy;
							var yz = qy * qz;
							var yw = qy * qw;
							var zz = qz * qz;
							var zw = qz * qw;
							m._11 = 1 - 2 * (yy + zz);
							m._12 = 2 * (xy + zw);
							m._13 = 2 * (xz - yw);
							m._21 = 2 * (xy - zw);
							m._22 = 1 - 2 * (xx + zz);
							m._23 = 2 * (yz + xw);
							m._31 = 2 * (xz + yw);
							m._32 = 2 * (yz - xw);
							m._33 = 1 - 2 * (xx + yy);
							if((layout & 1 << h3d_anim_DataLayout.Scale._hx_index) != 0) {
								var sx = _gthis.data[offset1++] * k1 + _gthis.data[offset2++] * k2;
								var sy = _gthis.data[offset1++] * k1 + _gthis.data[offset2++] * k2;
								var sz = _gthis.data[offset1++] * k1 + _gthis.data[offset2++] * k2;
								m._11 *= sx;
								m._12 *= sx;
								m._13 *= sx;
								m._21 *= sy;
								m._22 *= sy;
								m._23 *= sy;
								m._31 *= sz;
								m._32 *= sz;
								m._33 *= sz;
							}
						}
					} else {
						m._12 = 0;
						m._13 = 0;
						m._21 = 0;
						m._23 = decompose ? 1 : 0;
						if((layout & 1 << h3d_anim_DataLayout.Scale._hx_index) != 0) {
							m._11 = _gthis.data[offset1++] * k1 + _gthis.data[offset2++] * k2;
							m._22 = _gthis.data[offset1++] * k1 + _gthis.data[offset2++] * k2;
							m._33 = _gthis.data[offset1++] * k1 + _gthis.data[offset2++] * k2;
						} else {
							m._11 = 1;
							m._22 = 1;
							m._33 = 1;
						}
					}
				}
				if(o.targetSkin != null) {
					o.targetSkin.jointsData[o.targetJoint].currentRelPose = m;
					o.targetSkin.jointsUpdated = true;
				} else {
					var _this = o.targetObject;
					_this.defaultTransform = m;
					var f2 = 1;
					var b = true;
					if(b) {
						_this.flags |= f2;
					} else {
						_this.flags &= ~f2;
					}
					var c = b;
					if(c && (_this.flags & 131072) != 0) {
						var f3 = 262144;
						_this.flags |= f3;
					}
				}
			}
			if((layout & 1 << h3d_anim_DataLayout.UV._hx_index) != 0) {
				var mat = o.targetObject.toMesh().material;
				var s = mat.passes.getShader(h3d_shader_UVDelta);
				if(s == null) {
					s = mat.passes.addShader(new h3d_shader_UVDelta());
					mat.get_texture().set_wrap(h3d_mat_Wrap.Repeat);
				}
				var v1 = this.data[offset1++];
				var v2 = this.data[offset2++];
				v1 %= 1.;
				v2 %= 1.;
				if(v1 < v2 - 0.5) {
					++v1;
				} else if(v1 > v2 + 0.5) {
					--v1;
				}
				s.uvDelta__.x = v1 * (1 - k2) + v2 * k2;
				var v11 = this.data[offset1++];
				var v21 = this.data[offset2++];
				v11 %= 1.;
				v21 %= 1.;
				if(v11 < v21 - 0.5) {
					++v11;
				} else if(v11 > v21 + 0.5) {
					--v11;
				}
				s.uvDelta__.y = v11 * (1 - k2) + v21 * k2;
			}
			if((layout & 1 << h3d_anim_DataLayout.Alpha._hx_index) != 0) {
				var mat1 = o.targetObject.toMesh().material;
				if(mat1.blendMode == h2d_BlendMode.None) {
					mat1.set_blendMode(h2d_BlendMode.Alpha);
				}
				mat1.mshader.color__.w = _gthis.data[offset1++] * k1 + _gthis.data[offset2++] * k2;
			}
			if((layout & 1 << h3d_anim_DataLayout.Property._hx_index) != 0) {
				o.propCurrentValue = _gthis.data[offset1++] * k1 + _gthis.data[offset2++] * k2;
			}
		}
		if(!decompose) {
			this.isSync = true;
		}
	}
	,__class__: h3d_anim_BufferAnimation
});
var h3d_anim_LinearFrame = function() {
};
$hxClasses["h3d.anim.LinearFrame"] = h3d_anim_LinearFrame;
h3d_anim_LinearFrame.__name__ = "h3d.anim.LinearFrame";
h3d_anim_LinearFrame.prototype = {
	toMatrix: function() {
		var m = new h3d_MatrixImpl();
		new h3d_Quat(this.qx,this.qy,this.qz,this.qw).toMatrix(m);
		m.prependScale(this.sx,this.sy,this.sz);
		m.translate(this.tx,this.ty,this.tz);
		return m;
	}
	,__class__: h3d_anim_LinearFrame
};
var h3d_anim_LinearObject = function(name) {
	this.hasPosition = true;
	h3d_anim_AnimatedObject.call(this,name);
};
$hxClasses["h3d.anim.LinearObject"] = h3d_anim_LinearObject;
h3d_anim_LinearObject.__name__ = "h3d.anim.LinearObject";
h3d_anim_LinearObject.__super__ = h3d_anim_AnimatedObject;
h3d_anim_LinearObject.prototype = $extend(h3d_anim_AnimatedObject.prototype,{
	clone: function() {
		var o = new h3d_anim_LinearObject(this.objectName);
		o.hasPosition = this.hasPosition;
		o.hasRotation = this.hasRotation;
		o.hasScale = this.hasScale;
		o.frames = this.frames;
		o.alphas = this.alphas;
		o.uvs = this.uvs;
		o.propName = this.propName;
		o.propValues = this.propValues;
		return o;
	}
	,__class__: h3d_anim_LinearObject
});
var h3d_anim_LinearAnimation = function(name,frame,sampling) {
	h3d_anim_Animation.call(this,name,frame,sampling);
	this.syncFrame = -1;
};
$hxClasses["h3d.anim.LinearAnimation"] = h3d_anim_LinearAnimation;
h3d_anim_LinearAnimation.__name__ = "h3d.anim.LinearAnimation";
h3d_anim_LinearAnimation.__super__ = h3d_anim_Animation;
h3d_anim_LinearAnimation.prototype = $extend(h3d_anim_Animation.prototype,{
	addCurve: function(objName,frames,hasPos,hasRot,hasScale) {
		var f = new h3d_anim_LinearObject(objName);
		f.frames = frames;
		f.hasPosition = hasPos;
		f.hasRotation = hasRot;
		f.hasScale = hasScale;
		this.objects.push(f);
	}
	,addAlphaCurve: function(objName,alphas) {
		var f = new h3d_anim_LinearObject(objName);
		f.alphas = alphas;
		this.objects.push(f);
	}
	,addUVCurve: function(objName,uvs) {
		var f = new h3d_anim_LinearObject(objName);
		f.uvs = uvs;
		this.objects.push(f);
	}
	,addPropCurve: function(objName,propName,values) {
		var f = new h3d_anim_LinearObject(objName);
		f.propName = propName;
		f.propValues = values;
		this.objects.push(f);
	}
	,getPropValue: function(objName,propName) {
		var _g = 0;
		var _g1 = this.objects;
		while(_g < _g1.length) {
			var o = _g1[_g];
			++_g;
			if(o.objectName == objName && o.propName == propName) {
				return o.propCurrentValue;
			}
		}
		return null;
	}
	,getFrames: function() {
		return this.objects;
	}
	,clone: function(a) {
		if(a == null) {
			a = new h3d_anim_LinearAnimation(this.name,this.frameCount,this.sampling);
		}
		h3d_anim_Animation.prototype.clone.call(this,a);
		return a;
	}
	,endFrame: function() {
		if(this.loop) {
			return this.frameCount;
		} else {
			return this.frameCount - 1;
		}
	}
	,initInstance: function() {
		h3d_anim_Animation.prototype.initInstance.call(this);
		var frames = this.objects;
		var _g = 0;
		while(_g < frames.length) {
			var a = frames[_g];
			++_g;
			if(a.propValues != null) {
				a.propCurrentValue = a.propValues[0];
				continue;
			}
			var tmp;
			if(a.alphas != null) {
				if(a.targetObject != null) {
					var _this = a.targetObject;
					tmp = (((_this) instanceof h3d_scene_Mesh) ? _this : null) == null;
				} else {
					tmp = true;
				}
			} else {
				tmp = false;
			}
			if(tmp) {
				throw haxe_Exception.thrown(a.objectName + " should be a mesh (for alpha animation)");
			}
			if(a.uvs != null || a.alphas != null) {
				continue;
			}
			a.matrix = new h3d_MatrixImpl();
			a.matrix.identity();
		}
		frames.sort($bind(this,this.sortByFrameCountDesc));
	}
	,sortByFrameCountDesc: function(o1,o2) {
		return (o2.frames == null ? 10 : o2.frames.length) - (o1.frames == null ? 10 : o1.frames.length);
	}
	,uvLerp: function(v1,v2,k) {
		v1 %= 1.;
		v2 %= 1.;
		if(v1 < v2 - 0.5) {
			++v1;
		} else if(v1 > v2 + 0.5) {
			--v1;
		}
		return v1 * (1 - k) + v2 * k;
	}
	,sync: function(decompose) {
		if(decompose == null) {
			decompose = false;
		}
		if(this.frame == this.syncFrame && !decompose) {
			return;
		}
		var f = this.frame | 0;
		var max = this.endFrame();
		if(f == max) {
			--f;
		}
		var frame1 = f;
		var frame2 = (frame1 + 1) % this.frameCount;
		var k2 = this.frame - frame1;
		var k1 = 1 - k2;
		if(frame1 < 0) {
			frame2 = 0;
			frame1 = frame2;
		} else if(this.frame >= this.frameCount) {
			frame2 = this.frameCount - 1;
			frame1 = frame2;
		} else if(!this.loop && frame2 == 0) {
			frame2 = this.frameCount - 1;
		}
		this.syncFrame = this.frame;
		if(decompose) {
			this.isSync = false;
		}
		var _g = 0;
		var _g1 = this.objects;
		while(_g < _g1.length) {
			var o = _g1[_g];
			++_g;
			if(o.targetObject == null && o.targetSkin == null) {
				continue;
			}
			if(o.alphas != null) {
				var mat = o.targetObject.toMesh().material;
				if(mat.blendMode == h2d_BlendMode.None) {
					mat.set_blendMode(h2d_BlendMode.Alpha);
				}
				mat.mshader.color__.w = o.alphas[frame1] * k1 + o.alphas[frame2] * k2;
				continue;
			}
			if(o.uvs != null) {
				var mat1 = o.targetObject.toMesh().material;
				var s = mat1.passes.getShader(h3d_shader_UVDelta);
				if(s == null) {
					s = mat1.passes.addShader(new h3d_shader_UVDelta());
					mat1.get_texture().set_wrap(h3d_mat_Wrap.Repeat);
				}
				var v1 = o.uvs[frame1 << 1];
				var v2 = o.uvs[frame2 << 1];
				v1 %= 1.;
				v2 %= 1.;
				if(v1 < v2 - 0.5) {
					++v1;
				} else if(v1 > v2 + 0.5) {
					--v1;
				}
				s.uvDelta__.x = v1 * (1 - k2) + v2 * k2;
				var v11 = o.uvs[frame1 << 1 | 1];
				var v21 = o.uvs[frame2 << 1 | 1];
				v11 %= 1.;
				v21 %= 1.;
				if(v11 < v21 - 0.5) {
					++v11;
				} else if(v11 > v21 + 0.5) {
					--v11;
				}
				s.uvDelta__.y = v11 * (1 - k2) + v21 * k2;
				continue;
			}
			if(o.propValues != null) {
				o.propCurrentValue = o.propValues[frame1] * k1 + o.propValues[frame2] * k2;
				continue;
			}
			var frame11 = frame1;
			var frame21 = frame2;
			if(o.frames.length == 1) {
				if(this.isSync) {
					break;
				}
				frame21 = 0;
				frame11 = frame21;
			}
			var f1 = o.frames[frame11];
			var f2 = o.frames[frame21];
			var m = o.matrix;
			m._41 = f1.tx * k1 + f2.tx * k2;
			m._42 = f1.ty * k1 + f2.ty * k2;
			m._43 = f1.tz * k1 + f2.tz * k2;
			if(o.hasRotation) {
				var dot = f1.qx * f2.qx + f1.qy * f2.qy + f1.qz * f2.qz + f1.qw * f2.qw;
				var q2 = dot < 0 ? -k2 : k2;
				var qx = f1.qx * k1 + f2.qx * q2;
				var qy = f1.qy * k1 + f2.qy * q2;
				var qz = f1.qz * k1 + f2.qz * q2;
				var qw = f1.qw * k1 + f2.qw * q2;
				var ql = 1 / Math.sqrt(qx * qx + qy * qy + qz * qz + qw * qw);
				qx *= ql;
				qy *= ql;
				qz *= ql;
				qw *= ql;
				if(decompose) {
					m._12 = qx;
					m._13 = qy;
					m._21 = qz;
					m._23 = qw;
					if(o.hasScale) {
						m._11 = f1.sx * k1 + f2.sx * k2;
						m._22 = f1.sy * k1 + f2.sy * k2;
						m._33 = f1.sz * k1 + f2.sz * k2;
					} else {
						m._11 = 1;
						m._22 = 1;
						m._33 = 1;
					}
				} else {
					var xx = qx * qx;
					var xy = qx * qy;
					var xz = qx * qz;
					var xw = qx * qw;
					var yy = qy * qy;
					var yz = qy * qz;
					var yw = qy * qw;
					var zz = qz * qz;
					var zw = qz * qw;
					m._11 = 1 - 2 * (yy + zz);
					m._12 = 2 * (xy + zw);
					m._13 = 2 * (xz - yw);
					m._21 = 2 * (xy - zw);
					m._22 = 1 - 2 * (xx + zz);
					m._23 = 2 * (yz + xw);
					m._31 = 2 * (xz + yw);
					m._32 = 2 * (yz - xw);
					m._33 = 1 - 2 * (xx + yy);
					if(o.hasScale) {
						var sx = f1.sx * k1 + f2.sx * k2;
						var sy = f1.sy * k1 + f2.sy * k2;
						var sz = f1.sz * k1 + f2.sz * k2;
						m._11 *= sx;
						m._12 *= sx;
						m._13 *= sx;
						m._21 *= sy;
						m._22 *= sy;
						m._23 *= sy;
						m._31 *= sz;
						m._32 *= sz;
						m._33 *= sz;
					}
				}
			} else {
				m._12 = 0;
				m._13 = 0;
				m._21 = 0;
				m._23 = decompose ? 1 : 0;
				if(o.hasScale) {
					m._11 = f1.sx * k1 + f2.sx * k2;
					m._22 = f1.sy * k1 + f2.sy * k2;
					m._33 = f1.sz * k1 + f2.sz * k2;
				} else {
					m._11 = 1;
					m._22 = 1;
					m._33 = 1;
				}
			}
			if(o.targetSkin != null) {
				o.targetSkin.jointsData[o.targetJoint].currentRelPose = o.matrix;
				o.targetSkin.jointsUpdated = true;
			} else {
				var _this = o.targetObject;
				var v = o.matrix;
				_this.defaultTransform = v;
				var f = 1;
				var b = true;
				if(b) {
					_this.flags |= f;
				} else {
					_this.flags &= ~f;
				}
				var c = b;
				if(c && (_this.flags & 131072) != 0) {
					var f3 = 262144;
					_this.flags |= f3;
				}
			}
		}
		if(!decompose) {
			this.isSync = true;
		}
	}
	,__class__: h3d_anim_LinearAnimation
});
var h3d_anim_Joint = function() {
	this.bindIndex = -1;
	this.splitIndex = -1;
	this.subs = [];
};
$hxClasses["h3d.anim.Joint"] = h3d_anim_Joint;
h3d_anim_Joint.__name__ = "h3d.anim.Joint";
h3d_anim_Joint.prototype = {
	shouldReceiveAnimation: function() {
		return true;
	}
	,makeRuntimeData: function() {
		return new h3d_scene_JointData();
	}
	,__class__: h3d_anim_Joint
};
var h3d_anim_DynamicJoint = function() {
	this.slackness = 0;
	this.resistance = 1;
	this.stiffness = 1;
	this.damping = 1;
	var x = 0;
	var y = 0;
	var z = 0;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.lockAxis = new h3d_VectorImpl(x,y,z);
	this.additive = false;
	var x = 0.0;
	var y = 0.0;
	var z = 0.0;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.globalForce = new h3d_VectorImpl(x,y,z);
	h3d_anim_Joint.call(this);
};
$hxClasses["h3d.anim.DynamicJoint"] = h3d_anim_DynamicJoint;
h3d_anim_DynamicJoint.__name__ = "h3d.anim.DynamicJoint";
h3d_anim_DynamicJoint.__super__ = h3d_anim_Joint;
h3d_anim_DynamicJoint.prototype = $extend(h3d_anim_Joint.prototype,{
	shouldReceiveAnimation: function() {
		return this.additive;
	}
	,makeRuntimeData: function() {
		return new h3d_scene_DynamicJointData();
	}
	,__class__: h3d_anim_DynamicJoint
});
var h3d_anim__$Skin_Permut = function() {
};
$hxClasses["h3d.anim._Skin.Permut"] = h3d_anim__$Skin_Permut;
h3d_anim__$Skin_Permut.__name__ = "h3d.anim._Skin.Permut";
h3d_anim__$Skin_Permut.prototype = {
	__class__: h3d_anim__$Skin_Permut
};
var h3d_anim__$Skin_Influence = function(j,w) {
	this.j = j;
	this.w = w;
};
$hxClasses["h3d.anim._Skin.Influence"] = h3d_anim__$Skin_Influence;
h3d_anim__$Skin_Influence.__name__ = "h3d.anim._Skin.Influence";
h3d_anim__$Skin_Influence.prototype = {
	__class__: h3d_anim__$Skin_Influence
};
var h3d_anim_Skin = function(name,vertexCount,bonesPerVertex) {
	this.name = name;
	this.vertexCount = vertexCount;
	this.bonesPerVertex = bonesPerVertex;
	if(vertexCount > 0) {
		this.vertexJoints = new Array(vertexCount * bonesPerVertex);
		this.vertexWeights = new Array(vertexCount * bonesPerVertex);
		this.envelop = [];
	}
};
$hxClasses["h3d.anim.Skin"] = h3d_anim_Skin;
h3d_anim_Skin.__name__ = "h3d.anim.Skin";
h3d_anim_Skin.prototype = {
	setJoints: function(joints,roots) {
		this.rootJoints = roots;
		this.allJoints = joints;
		this.namedJoints = new haxe_ds_StringMap();
		var _g = 0;
		while(_g < joints.length) {
			var j = joints[_g];
			++_g;
			if(j.name != null) {
				this.namedJoints.h[j.name] = j;
			}
		}
	}
	,addInfluence: function(vid,j,w) {
		var il = this.envelop[vid];
		if(il == null) {
			il = this.envelop[vid] = [];
		}
		il.push(new h3d_anim__$Skin_Influence(j,w));
	}
	,sortInfluences: function(i1,i2) {
		if(i2.w > i1.w) {
			return 1;
		} else {
			return -1;
		}
	}
	,isSplit: function() {
		return this.splitJoints != null;
	}
	,initWeights: function() {
		this.boundJoints = [];
		var pos = 0;
		var _g = 0;
		var _g1 = this.vertexCount;
		while(_g < _g1) {
			var i = _g++;
			var il = this.envelop[i];
			if(il == null) {
				il = [];
			}
			haxe_ds_ArraySort.sort(il,$bind(this,this.sortInfluences));
			if(il.length > this.bonesPerVertex) {
				il = il.slice(0,this.bonesPerVertex);
			}
			var tw = 0.;
			var _g2 = 0;
			while(_g2 < il.length) {
				var i1 = il[_g2];
				++_g2;
				tw += i1.w;
			}
			tw = 1 / tw;
			var _g3 = 0;
			var _g4 = this.bonesPerVertex;
			while(_g3 < _g4) {
				var i2 = _g3++;
				var i3 = il[i2];
				if(i3 == null) {
					this.vertexJoints[pos] = 0;
					this.vertexWeights[pos] = 0;
				} else {
					if(i3.j.bindIndex == -1) {
						i3.j.bindIndex = this.boundJoints.length;
						this.boundJoints.push(i3.j);
					}
					this.vertexJoints[pos] = i3.j.bindIndex;
					this.vertexWeights[pos] = i3.w * tw;
				}
				++pos;
			}
		}
		this.envelop = null;
	}
	,sortByBindIndex: function(j1,j2) {
		return j1.bindIndex - j2.bindIndex;
	}
	,isSub: function(a,b) {
		var j = 0;
		var max = b.length;
		var _g = 0;
		while(_g < a.length) {
			var e = a[_g];
			++_g;
			while(e != b[j++]) if(j >= max) {
				return false;
			}
		}
		return true;
	}
	,merge: function(permuts) {
		var _g = 0;
		while(_g < permuts.length) {
			var p1 = permuts[_g];
			++_g;
			var _g1 = 0;
			while(_g1 < permuts.length) {
				var p2 = permuts[_g1];
				++_g1;
				if(p1 != p2 && p1.material == p2.material && this.isSub(p1.joints,p2.joints)) {
					var _g2 = 0;
					var _g3 = p1.triangles;
					while(_g2 < _g3.length) {
						var t = _g3[_g2];
						++_g2;
						p2.triangles.push(t);
					}
					HxOverrides.remove(permuts,p1);
					return true;
				}
			}
		}
		return false;
	}
	,jointsDiff: function(p1,p2) {
		var diff = 0;
		var i = 0;
		var j = 0;
		var imax = p1.joints.length;
		var jmax = p2.joints.length;
		while(i < imax && j < jmax) {
			var j1 = p1.joints[i];
			var j2 = p2.joints[j];
			if(j1 == j2) {
				++i;
				++j;
			} else {
				++diff;
				if(j1.bindIndex < j2.bindIndex) {
					++i;
				} else {
					++j;
				}
			}
		}
		return diff + (imax - i) + (jmax - j);
	}
	,split: function(maxBones,index,triangleMaterials) {
		if(this.splitJoints != null) {
			return true;
		}
		if(this.boundJoints.length <= maxBones) {
			return false;
		}
		this.splitJoints = [];
		this.triangleGroups = new Array(index.length / 3 | 0);
		var permuts = [];
		var _g = 0;
		var _g1 = index.length / 3 | 0;
		while(_g < _g1) {
			var tri = _g++;
			var iid = tri * 3;
			var mid = triangleMaterials == null ? 0 : triangleMaterials[tri];
			var jl = [];
			var _g2 = 0;
			while(_g2 < 3) {
				var i = _g2++;
				var vid = index[iid + i];
				var _g3 = 0;
				var _g4 = this.bonesPerVertex;
				while(_g3 < _g4) {
					var b = _g3++;
					var bidx = vid * this.bonesPerVertex + b;
					if(this.vertexWeights[bidx] == 0) {
						continue;
					}
					var j = this.boundJoints[this.vertexJoints[bidx]];
					if(j.splitIndex != iid) {
						j.splitIndex = iid;
						jl.push(j);
					}
				}
			}
			jl.sort($bind(this,this.sortByBindIndex));
			var _g5 = 0;
			while(_g5 < permuts.length) {
				var p2 = permuts[_g5];
				++_g5;
				if(p2.material == mid && this.isSub(jl,p2.joints)) {
					p2.triangles.push(tri);
					jl = null;
					break;
				}
			}
			if(jl == null) {
				continue;
			}
			var _g6 = 0;
			while(_g6 < permuts.length) {
				var p21 = permuts[_g6];
				++_g6;
				if(p21.material == mid && this.isSub(p21.joints,jl)) {
					p21.joints = jl;
					p21.triangles.push(tri);
					jl = null;
					break;
				}
			}
			if(jl == null) {
				continue;
			}
			var pr = new h3d_anim__$Skin_Permut();
			pr.joints = jl;
			pr.triangles = [tri];
			pr.material = mid;
			permuts.push(pr);
		}
		while(true) {
			while(this.merge(permuts)) {
			}
			var minDif = 100000;
			var minTot = 100000;
			var minP1 = null;
			var minP2 = null;
			var _g = 0;
			var _g1 = permuts.length;
			while(_g < _g1) {
				var i = _g++;
				var p1 = permuts[i];
				if(p1.joints.length == maxBones) {
					continue;
				}
				var _g2 = i + 1;
				var _g3 = permuts.length;
				while(_g2 < _g3) {
					var j = _g2++;
					var p2 = permuts[j];
					if(p2.joints.length == maxBones || p1.material != p2.material) {
						continue;
					}
					var count = this.jointsDiff(p1,p2);
					var tot = count + (p1.joints.length + p2.joints.length - count >> 1);
					if(tot > maxBones || tot > minTot || tot == minTot && count > minDif) {
						continue;
					}
					minDif = count;
					minTot = tot;
					minP1 = p1;
					minP2 = p2;
				}
			}
			if(minP1 == null) {
				break;
			}
			var p11 = minP1;
			var p21 = minP2;
			var _g4 = 0;
			var _g5 = p11.joints;
			while(_g4 < _g5.length) {
				var j1 = _g5[_g4];
				++_g4;
				HxOverrides.remove(p21.joints,j1);
				p21.joints.push(j1);
			}
			p21.joints.sort($bind(this,this.sortByBindIndex));
			var _g6 = 0;
			var _g7 = p11.triangles;
			while(_g6 < _g7.length) {
				var t = _g7[_g6];
				++_g6;
				p21.triangles.push(t);
			}
			HxOverrides.remove(permuts,p11);
		}
		var _g = 0;
		var _g1 = permuts.length;
		while(_g < _g1) {
			var i = _g++;
			var _g2 = 0;
			var _g3 = permuts[i].triangles;
			while(_g2 < _g3.length) {
				var tri = _g3[_g2];
				++_g2;
				this.triangleGroups[tri] = i;
			}
		}
		var jointsPermuts = [];
		var _g = 0;
		var _g1 = this.boundJoints;
		while(_g < _g1.length) {
			var j = _g1[_g];
			++_g;
			var pl = [];
			var _g2 = 0;
			while(_g2 < permuts.length) {
				var p = permuts[_g2];
				++_g2;
				if(p.joints.indexOf(j) >= 0) {
					pl.push(p);
				}
			}
			jointsPermuts.push({ j : j, pl : pl, priority : 0});
		}
		while(true) {
			jointsPermuts.sort(function(j1,j2) {
				return j2.pl.length + j2.priority * 100 - (j1.pl.length + j1.priority * 100);
			});
			var _g = 0;
			while(_g < permuts.length) {
				var p = permuts[_g];
				++_g;
				p.indexedJoints = [];
			}
			var fail = false;
			var _g1 = 0;
			while(_g1 < jointsPermuts.length) {
				var j = jointsPermuts[_g1];
				++_g1;
				j.j.splitIndex = -1;
				var _g2 = 0;
				var _g3 = maxBones;
				while(_g2 < _g3) {
					var id = _g2++;
					var ok = true;
					var _g4 = 0;
					var _g5 = j.pl;
					while(_g4 < _g5.length) {
						var p1 = _g5[_g4];
						++_g4;
						if(p1.indexedJoints[id] != null) {
							ok = false;
							break;
						}
					}
					if(ok) {
						j.j.splitIndex = id;
						var _g6 = 0;
						var _g7 = j.pl;
						while(_g6 < _g7.length) {
							var p2 = _g7[_g6];
							++_g6;
							p2.indexedJoints[id] = j.j;
						}
						break;
					}
				}
				if(j.j.splitIndex < 0) {
					j.priority++;
					if(j.priority > 10) {
						throw haxe_Exception.thrown("Failed to assign index while spliting skin");
					}
					fail = true;
					break;
				}
			}
			if(!fail) {
				break;
			}
		}
		this.splitJoints = [];
		var _g = 0;
		while(_g < permuts.length) {
			var p = permuts[_g];
			++_g;
			var jl = [];
			var _g1 = 0;
			var _g2 = p.indexedJoints.length;
			while(_g1 < _g2) {
				var i = _g1++;
				var j = p.indexedJoints[i];
				if(j == null) {
					j = this.boundJoints[0];
				}
				jl.push(j);
			}
			this.splitJoints.push({ material : p.material, joints : jl});
		}
		var _g = 0;
		var _g1 = this.vertexJoints.length;
		while(_g < _g1) {
			var i = _g++;
			this.vertexJoints[i] = this.boundJoints[this.vertexJoints[i]].splitIndex;
		}
		return true;
	}
	,__class__: h3d_anim_Skin
};
var h3d_col_Collider = function() { };
$hxClasses["h3d.col.Collider"] = h3d_col_Collider;
h3d_col_Collider.__name__ = "h3d.col.Collider";
h3d_col_Collider.prototype = {
	__class__: h3d_col_Collider
};
var h3d_col_Bounds = function() {
	this.xMin = 1e20;
	this.xMax = -1e20;
	this.yMin = 1e20;
	this.yMax = -1e20;
	this.zMin = 1e20;
	this.zMax = -1e20;
};
$hxClasses["h3d.col.Bounds"] = h3d_col_Bounds;
h3d_col_Bounds.__name__ = "h3d.col.Bounds";
h3d_col_Bounds.fromPoints = function(min,max) {
	var b = new h3d_col_Bounds();
	b.xMin = min.x;
	b.yMin = min.y;
	b.zMin = min.z;
	b.xMax = max.x;
	b.yMax = max.y;
	b.zMax = max.z;
	return b;
};
h3d_col_Bounds.fromValues = function(x,y,z,dx,dy,dz) {
	var b = new h3d_col_Bounds();
	b.xMin = x;
	b.yMin = y;
	b.zMin = z;
	b.xMax = x + dx;
	b.yMax = y + dy;
	b.zMax = z + dz;
	return b;
};
h3d_col_Bounds.__super__ = h3d_col_Collider;
h3d_col_Bounds.prototype = $extend(h3d_col_Collider.prototype,{
	inFrustum: function(f,m) {
		if(m != null) {
			throw haxe_Exception.thrown("Not implemented");
		}
		return f.hasBounds(this);
	}
	,inSphere: function(s) {
		var x = s.x;
		var y = s.y;
		var z = s.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var a = this.xMin;
		var a1 = s.x;
		var b = this.xMax;
		var b1 = a1 > b ? b : a1;
		var x = a < b1 ? b1 : a;
		var a = this.yMin;
		var a1 = s.y;
		var b = this.yMax;
		var b1 = a1 > b ? b : a1;
		var y = a < b1 ? b1 : a;
		var a = this.zMin;
		var a1 = s.z;
		var b = this.zMax;
		var b1 = a1 > b ? b : a1;
		var z = a < b1 ? b1 : a;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var p_x = x1;
		var p_y = y1;
		var p_z = z1;
		var dx = p_x - _this_x;
		var dy = p_y - _this_y;
		var dz = p_z - _this_z;
		return dx * dx + dy * dy + dz * dz < s.r * s.r;
	}
	,testPlane: function(p) {
		var a = p.nx;
		var b = p.ny;
		var c = p.nz;
		var dd = a * (this.xMax + this.xMin) + b * (this.yMax + this.yMin) + c * (this.zMax + this.zMin);
		if(a < 0) {
			a = -a;
		}
		if(b < 0) {
			b = -b;
		}
		if(c < 0) {
			c = -c;
		}
		var rr = a * (this.xMax - this.xMin) + b * (this.yMax - this.yMin) + c * (this.zMax - this.zMin);
		return dd + rr - p.d * 2;
	}
	,rayIntersection: function(r,bestMatch) {
		var minTx = (this.xMin - r.px) / r.lx;
		var minTy = (this.yMin - r.py) / r.ly;
		var minTz = (this.zMin - r.pz) / r.lz;
		var maxTx = (this.xMax - r.px) / r.lx;
		var maxTy = (this.yMax - r.py) / r.ly;
		var maxTz = (this.zMax - r.pz) / r.lz;
		var realMinTx = minTx > maxTx ? maxTx : minTx;
		var realMinTy = minTy > maxTy ? maxTy : minTy;
		var realMinTz = minTz > maxTz ? maxTz : minTz;
		var realMaxTx = minTx < maxTx ? maxTx : minTx;
		var realMaxTy = minTy < maxTy ? maxTy : minTy;
		var realMaxTz = minTz < maxTz ? maxTz : minTz;
		var a = realMaxTx > realMaxTy ? realMaxTy : realMaxTx;
		var minmax = a > realMaxTz ? realMaxTz : a;
		var a = realMinTx < realMinTy ? realMinTy : realMinTx;
		var maxmin = a < realMinTz ? realMinTz : a;
		if(minmax < maxmin) {
			return -1;
		}
		return maxmin;
	}
	,inFrustumDetails: function(mvp,checkZ) {
		if(checkZ == null) {
			checkZ = true;
		}
		var ret = 1;
		var p_nx = mvp._14 + mvp._11;
		var p_ny = mvp._24 + mvp._21;
		var p_nz = mvp._34 + mvp._31;
		var p_d = mvp._44 + mvp._41;
		var m = p_nx * (p_nx > 0 ? this.xMax : this.xMin) + p_ny * (p_ny > 0 ? this.yMax : this.yMin) + p_nz * (p_nz > 0 ? this.zMax : this.zMin);
		if(m + p_d < 0) {
			return -1;
		}
		var n = p_nx * (p_nx > 0 ? this.xMin : this.xMax) + p_ny * (p_ny > 0 ? this.yMin : this.yMax) + p_nz * (p_nz > 0 ? this.zMin : this.zMax);
		if(n + p_d < 0) {
			ret = 0;
		}
		var p_nx = mvp._14 - mvp._11;
		var p_ny = mvp._24 - mvp._21;
		var p_nz = mvp._34 - mvp._31;
		var p_d = mvp._44 - mvp._41;
		var m = p_nx * (p_nx > 0 ? this.xMax : this.xMin) + p_ny * (p_ny > 0 ? this.yMax : this.yMin) + p_nz * (p_nz > 0 ? this.zMax : this.zMin);
		if(m + p_d < 0) {
			return -1;
		}
		var n = p_nx * (p_nx > 0 ? this.xMin : this.xMax) + p_ny * (p_ny > 0 ? this.yMin : this.yMax) + p_nz * (p_nz > 0 ? this.zMin : this.zMax);
		if(n + p_d < 0) {
			ret = 0;
		}
		var p_nx = mvp._14 + mvp._12;
		var p_ny = mvp._24 + mvp._22;
		var p_nz = mvp._34 + mvp._32;
		var p_d = mvp._44 + mvp._42;
		var m = p_nx * (p_nx > 0 ? this.xMax : this.xMin) + p_ny * (p_ny > 0 ? this.yMax : this.yMin) + p_nz * (p_nz > 0 ? this.zMax : this.zMin);
		if(m + p_d < 0) {
			return -1;
		}
		var n = p_nx * (p_nx > 0 ? this.xMin : this.xMax) + p_ny * (p_ny > 0 ? this.yMin : this.yMax) + p_nz * (p_nz > 0 ? this.zMin : this.zMax);
		if(n + p_d < 0) {
			ret = 0;
		}
		var p_nx = mvp._14 - mvp._12;
		var p_ny = mvp._24 - mvp._22;
		var p_nz = mvp._34 - mvp._32;
		var p_d = mvp._44 - mvp._42;
		var m = p_nx * (p_nx > 0 ? this.xMax : this.xMin) + p_ny * (p_ny > 0 ? this.yMax : this.yMin) + p_nz * (p_nz > 0 ? this.zMax : this.zMin);
		if(m + p_d < 0) {
			return -1;
		}
		var n = p_nx * (p_nx > 0 ? this.xMin : this.xMax) + p_ny * (p_ny > 0 ? this.yMin : this.yMax) + p_nz * (p_nz > 0 ? this.zMin : this.zMax);
		if(n + p_d < 0) {
			ret = 0;
		}
		if(checkZ) {
			var p_nx = mvp._13;
			var p_ny = mvp._23;
			var p_nz = mvp._33;
			var p_d = mvp._43;
			var m = p_nx * (p_nx > 0 ? this.xMax : this.xMin) + p_ny * (p_ny > 0 ? this.yMax : this.yMin) + p_nz * (p_nz > 0 ? this.zMax : this.zMin);
			if(m + p_d < 0) {
				return -1;
			}
			var n = p_nx * (p_nx > 0 ? this.xMin : this.xMax) + p_ny * (p_ny > 0 ? this.yMin : this.yMax) + p_nz * (p_nz > 0 ? this.zMin : this.zMax);
			if(n + p_d < 0) {
				ret = 0;
			}
			var p_nx = mvp._14 - mvp._13;
			var p_ny = mvp._24 - mvp._23;
			var p_nz = mvp._34 - mvp._33;
			var p_d = mvp._44 - mvp._43;
			var m = p_nx * (p_nx > 0 ? this.xMax : this.xMin) + p_ny * (p_ny > 0 ? this.yMax : this.yMin) + p_nz * (p_nz > 0 ? this.zMax : this.zMin);
			if(m + p_d < 0) {
				return -1;
			}
			var n = p_nx * (p_nx > 0 ? this.xMin : this.xMax) + p_ny * (p_ny > 0 ? this.yMin : this.yMax) + p_nz * (p_nz > 0 ? this.zMin : this.zMax);
			if(n + p_d < 0) {
				ret = 0;
			}
		}
		return ret;
	}
	,transform3x3: function(m) {
		var xMin = this.xMin;
		var yMin = this.yMin;
		var zMin = this.zMin;
		var xMax = this.xMax;
		var yMax = this.yMax;
		var zMax = this.zMax;
		this.xMin = 1e20;
		this.xMax = -1e20;
		this.yMin = 1e20;
		this.yMax = -1e20;
		this.zMin = 1e20;
		this.zMax = -1e20;
		var x = 0.;
		var y = 0.;
		var z = 0.;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var _this_x = x;
		var _this_y = y;
		var _this_z = z;
		var x = xMin;
		var y = yMin;
		var z = zMin;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this_x = x;
		_this_y = y;
		_this_z = z;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		if(_this_x < this.xMin) {
			this.xMin = _this_x;
		}
		if(_this_x > this.xMax) {
			this.xMax = _this_x;
		}
		if(_this_y < this.yMin) {
			this.yMin = _this_y;
		}
		if(_this_y > this.yMax) {
			this.yMax = _this_y;
		}
		if(_this_z < this.zMin) {
			this.zMin = _this_z;
		}
		if(_this_z > this.zMax) {
			this.zMax = _this_z;
		}
		var x = xMin;
		var y = yMin;
		var z = zMax;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this_x = x;
		_this_y = y;
		_this_z = z;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		if(_this_x < this.xMin) {
			this.xMin = _this_x;
		}
		if(_this_x > this.xMax) {
			this.xMax = _this_x;
		}
		if(_this_y < this.yMin) {
			this.yMin = _this_y;
		}
		if(_this_y > this.yMax) {
			this.yMax = _this_y;
		}
		if(_this_z < this.zMin) {
			this.zMin = _this_z;
		}
		if(_this_z > this.zMax) {
			this.zMax = _this_z;
		}
		var x = xMin;
		var y = yMax;
		var z = zMin;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this_x = x;
		_this_y = y;
		_this_z = z;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		if(_this_x < this.xMin) {
			this.xMin = _this_x;
		}
		if(_this_x > this.xMax) {
			this.xMax = _this_x;
		}
		if(_this_y < this.yMin) {
			this.yMin = _this_y;
		}
		if(_this_y > this.yMax) {
			this.yMax = _this_y;
		}
		if(_this_z < this.zMin) {
			this.zMin = _this_z;
		}
		if(_this_z > this.zMax) {
			this.zMax = _this_z;
		}
		var x = xMin;
		var y = yMax;
		var z = zMax;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this_x = x;
		_this_y = y;
		_this_z = z;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		if(_this_x < this.xMin) {
			this.xMin = _this_x;
		}
		if(_this_x > this.xMax) {
			this.xMax = _this_x;
		}
		if(_this_y < this.yMin) {
			this.yMin = _this_y;
		}
		if(_this_y > this.yMax) {
			this.yMax = _this_y;
		}
		if(_this_z < this.zMin) {
			this.zMin = _this_z;
		}
		if(_this_z > this.zMax) {
			this.zMax = _this_z;
		}
		var x = xMax;
		var y = yMin;
		var z = zMin;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this_x = x;
		_this_y = y;
		_this_z = z;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		if(_this_x < this.xMin) {
			this.xMin = _this_x;
		}
		if(_this_x > this.xMax) {
			this.xMax = _this_x;
		}
		if(_this_y < this.yMin) {
			this.yMin = _this_y;
		}
		if(_this_y > this.yMax) {
			this.yMax = _this_y;
		}
		if(_this_z < this.zMin) {
			this.zMin = _this_z;
		}
		if(_this_z > this.zMax) {
			this.zMax = _this_z;
		}
		var x = xMax;
		var y = yMin;
		var z = zMax;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this_x = x;
		_this_y = y;
		_this_z = z;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		if(_this_x < this.xMin) {
			this.xMin = _this_x;
		}
		if(_this_x > this.xMax) {
			this.xMax = _this_x;
		}
		if(_this_y < this.yMin) {
			this.yMin = _this_y;
		}
		if(_this_y > this.yMax) {
			this.yMax = _this_y;
		}
		if(_this_z < this.zMin) {
			this.zMin = _this_z;
		}
		if(_this_z > this.zMax) {
			this.zMax = _this_z;
		}
		var x = xMax;
		var y = yMax;
		var z = zMin;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this_x = x;
		_this_y = y;
		_this_z = z;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		if(_this_x < this.xMin) {
			this.xMin = _this_x;
		}
		if(_this_x > this.xMax) {
			this.xMax = _this_x;
		}
		if(_this_y < this.yMin) {
			this.yMin = _this_y;
		}
		if(_this_y > this.yMax) {
			this.yMax = _this_y;
		}
		if(_this_z < this.zMin) {
			this.zMin = _this_z;
		}
		if(_this_z > this.zMax) {
			this.zMax = _this_z;
		}
		var x = xMax;
		var y = yMax;
		var z = zMax;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this_x = x;
		_this_y = y;
		_this_z = z;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		if(_this_x < this.xMin) {
			this.xMin = _this_x;
		}
		if(_this_x > this.xMax) {
			this.xMax = _this_x;
		}
		if(_this_y < this.yMin) {
			this.yMin = _this_y;
		}
		if(_this_y > this.yMax) {
			this.yMax = _this_y;
		}
		if(_this_z < this.zMin) {
			this.zMin = _this_z;
		}
		if(_this_z > this.zMax) {
			this.zMax = _this_z;
		}
	}
	,transform: function(m) {
		var xMin = this.xMin;
		var yMin = this.yMin;
		var zMin = this.zMin;
		var xMax = this.xMax;
		var yMax = this.yMax;
		var zMax = this.zMax;
		this.xMin = 1e20;
		this.xMax = -1e20;
		this.yMin = 1e20;
		this.yMax = -1e20;
		this.zMin = 1e20;
		this.zMax = -1e20;
		if(xMax < xMin && yMax < yMin && zMax < zMin) {
			return;
		}
		var x = 0.;
		var y = 0.;
		var z = 0.;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var _this_x = x;
		var _this_y = y;
		var _this_z = z;
		var x = xMin;
		var y = yMin;
		var z = zMin;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this_x = x;
		_this_y = y;
		_this_z = z;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31 + m._41;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32 + m._42;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33 + m._43;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		if(_this_x < this.xMin) {
			this.xMin = _this_x;
		}
		if(_this_x > this.xMax) {
			this.xMax = _this_x;
		}
		if(_this_y < this.yMin) {
			this.yMin = _this_y;
		}
		if(_this_y > this.yMax) {
			this.yMax = _this_y;
		}
		if(_this_z < this.zMin) {
			this.zMin = _this_z;
		}
		if(_this_z > this.zMax) {
			this.zMax = _this_z;
		}
		var x = xMin;
		var y = yMin;
		var z = zMax;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this_x = x;
		_this_y = y;
		_this_z = z;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31 + m._41;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32 + m._42;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33 + m._43;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		if(_this_x < this.xMin) {
			this.xMin = _this_x;
		}
		if(_this_x > this.xMax) {
			this.xMax = _this_x;
		}
		if(_this_y < this.yMin) {
			this.yMin = _this_y;
		}
		if(_this_y > this.yMax) {
			this.yMax = _this_y;
		}
		if(_this_z < this.zMin) {
			this.zMin = _this_z;
		}
		if(_this_z > this.zMax) {
			this.zMax = _this_z;
		}
		var x = xMin;
		var y = yMax;
		var z = zMin;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this_x = x;
		_this_y = y;
		_this_z = z;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31 + m._41;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32 + m._42;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33 + m._43;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		if(_this_x < this.xMin) {
			this.xMin = _this_x;
		}
		if(_this_x > this.xMax) {
			this.xMax = _this_x;
		}
		if(_this_y < this.yMin) {
			this.yMin = _this_y;
		}
		if(_this_y > this.yMax) {
			this.yMax = _this_y;
		}
		if(_this_z < this.zMin) {
			this.zMin = _this_z;
		}
		if(_this_z > this.zMax) {
			this.zMax = _this_z;
		}
		var x = xMin;
		var y = yMax;
		var z = zMax;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this_x = x;
		_this_y = y;
		_this_z = z;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31 + m._41;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32 + m._42;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33 + m._43;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		if(_this_x < this.xMin) {
			this.xMin = _this_x;
		}
		if(_this_x > this.xMax) {
			this.xMax = _this_x;
		}
		if(_this_y < this.yMin) {
			this.yMin = _this_y;
		}
		if(_this_y > this.yMax) {
			this.yMax = _this_y;
		}
		if(_this_z < this.zMin) {
			this.zMin = _this_z;
		}
		if(_this_z > this.zMax) {
			this.zMax = _this_z;
		}
		var x = xMax;
		var y = yMin;
		var z = zMin;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this_x = x;
		_this_y = y;
		_this_z = z;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31 + m._41;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32 + m._42;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33 + m._43;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		if(_this_x < this.xMin) {
			this.xMin = _this_x;
		}
		if(_this_x > this.xMax) {
			this.xMax = _this_x;
		}
		if(_this_y < this.yMin) {
			this.yMin = _this_y;
		}
		if(_this_y > this.yMax) {
			this.yMax = _this_y;
		}
		if(_this_z < this.zMin) {
			this.zMin = _this_z;
		}
		if(_this_z > this.zMax) {
			this.zMax = _this_z;
		}
		var x = xMax;
		var y = yMin;
		var z = zMax;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this_x = x;
		_this_y = y;
		_this_z = z;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31 + m._41;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32 + m._42;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33 + m._43;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		if(_this_x < this.xMin) {
			this.xMin = _this_x;
		}
		if(_this_x > this.xMax) {
			this.xMax = _this_x;
		}
		if(_this_y < this.yMin) {
			this.yMin = _this_y;
		}
		if(_this_y > this.yMax) {
			this.yMax = _this_y;
		}
		if(_this_z < this.zMin) {
			this.zMin = _this_z;
		}
		if(_this_z > this.zMax) {
			this.zMax = _this_z;
		}
		var x = xMax;
		var y = yMax;
		var z = zMin;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this_x = x;
		_this_y = y;
		_this_z = z;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31 + m._41;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32 + m._42;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33 + m._43;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		if(_this_x < this.xMin) {
			this.xMin = _this_x;
		}
		if(_this_x > this.xMax) {
			this.xMax = _this_x;
		}
		if(_this_y < this.yMin) {
			this.yMin = _this_y;
		}
		if(_this_y > this.yMax) {
			this.yMax = _this_y;
		}
		if(_this_z < this.zMin) {
			this.zMin = _this_z;
		}
		if(_this_z > this.zMax) {
			this.zMax = _this_z;
		}
		var x = xMax;
		var y = yMax;
		var z = zMax;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this_x = x;
		_this_y = y;
		_this_z = z;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31 + m._41;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32 + m._42;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33 + m._43;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		if(_this_x < this.xMin) {
			this.xMin = _this_x;
		}
		if(_this_x > this.xMax) {
			this.xMax = _this_x;
		}
		if(_this_y < this.yMin) {
			this.yMin = _this_y;
		}
		if(_this_y > this.yMax) {
			this.yMax = _this_y;
		}
		if(_this_z < this.zMin) {
			this.zMin = _this_z;
		}
		if(_this_z > this.zMax) {
			this.zMax = _this_z;
		}
	}
	,collide: function(b) {
		return !(this.xMin > b.xMax || this.yMin > b.yMax || this.zMin > b.zMax || this.xMax < b.xMin || this.yMax < b.yMin || this.zMax < b.zMin);
	}
	,contains: function(p) {
		if(p.x >= this.xMin && p.x < this.xMax && p.y >= this.yMin && p.y < this.yMax && p.z >= this.zMin) {
			return p.z < this.zMax;
		} else {
			return false;
		}
	}
	,containsBounds: function(b) {
		if(this.xMin <= b.xMin && this.yMin <= b.yMin && this.zMin <= b.zMin && this.xMax >= b.xMax && this.yMax >= b.yMax) {
			return this.zMax >= b.zMax;
		} else {
			return false;
		}
	}
	,containsSphere: function(s) {
		if(this.xMin <= s.x - s.r && this.yMin <= s.y - s.r && this.zMin <= s.z - s.r && this.xMax >= s.x + s.r && this.yMax >= s.y + s.r) {
			return this.zMax >= s.z + s.r;
		} else {
			return false;
		}
	}
	,add: function(b) {
		if(b.xMin < this.xMin) {
			this.xMin = b.xMin;
		}
		if(b.xMax > this.xMax) {
			this.xMax = b.xMax;
		}
		if(b.yMin < this.yMin) {
			this.yMin = b.yMin;
		}
		if(b.yMax > this.yMax) {
			this.yMax = b.yMax;
		}
		if(b.zMin < this.zMin) {
			this.zMin = b.zMin;
		}
		if(b.zMax > this.zMax) {
			this.zMax = b.zMax;
		}
	}
	,addTransform: function(b,m) {
		var b1 = new h3d_col_Bounds();
		b1.xMin = b.xMin;
		b1.xMax = b.xMax;
		b1.yMin = b.yMin;
		b1.yMax = b.yMax;
		b1.zMin = b.zMin;
		b1.zMax = b.zMax;
		var tmp = b1;
		tmp.transform(m);
		if(tmp.xMin < this.xMin) {
			this.xMin = tmp.xMin;
		}
		if(tmp.xMax > this.xMax) {
			this.xMax = tmp.xMax;
		}
		if(tmp.yMin < this.yMin) {
			this.yMin = tmp.yMin;
		}
		if(tmp.yMax > this.yMax) {
			this.yMax = tmp.yMax;
		}
		if(tmp.zMin < this.zMin) {
			this.zMin = tmp.zMin;
		}
		if(tmp.zMax > this.zMax) {
			this.zMax = tmp.zMax;
		}
	}
	,addPoint: function(p) {
		if(p.x < this.xMin) {
			this.xMin = p.x;
		}
		if(p.x > this.xMax) {
			this.xMax = p.x;
		}
		if(p.y < this.yMin) {
			this.yMin = p.y;
		}
		if(p.y > this.yMax) {
			this.yMax = p.y;
		}
		if(p.z < this.zMin) {
			this.zMin = p.z;
		}
		if(p.z > this.zMax) {
			this.zMax = p.z;
		}
	}
	,addPos: function(x,y,z) {
		if(x < this.xMin) {
			this.xMin = x;
		}
		if(x > this.xMax) {
			this.xMax = x;
		}
		if(y < this.yMin) {
			this.yMin = y;
		}
		if(y > this.yMax) {
			this.yMax = y;
		}
		if(z < this.zMin) {
			this.zMin = z;
		}
		if(z > this.zMax) {
			this.zMax = z;
		}
	}
	,addSphere: function(s) {
		var x = s.x;
		var y = s.y;
		var z = s.z;
		var r = s.r;
		if(x - r < this.xMin) {
			this.xMin = x - r;
		}
		if(x + r > this.xMax) {
			this.xMax = x + r;
		}
		if(y - r < this.yMin) {
			this.yMin = y - r;
		}
		if(y + r > this.yMax) {
			this.yMax = y + r;
		}
		if(z - r < this.zMin) {
			this.zMin = z - r;
		}
		if(z + r > this.zMax) {
			this.zMax = z + r;
		}
	}
	,addSpherePos: function(x,y,z,r) {
		if(x - r < this.xMin) {
			this.xMin = x - r;
		}
		if(x + r > this.xMax) {
			this.xMax = x + r;
		}
		if(y - r < this.yMin) {
			this.yMin = y - r;
		}
		if(y + r > this.yMax) {
			this.yMax = y + r;
		}
		if(z - r < this.zMin) {
			this.zMin = z - r;
		}
		if(z + r > this.zMax) {
			this.zMax = z + r;
		}
	}
	,intersection: function(a,b) {
		var a1 = a.xMin;
		var b1 = b.xMin;
		var xMin = a1 < b1 ? b1 : a1;
		var a1 = a.yMin;
		var b1 = b.yMin;
		var yMin = a1 < b1 ? b1 : a1;
		var a1 = a.zMin;
		var b1 = b.zMin;
		var zMin = a1 < b1 ? b1 : a1;
		var a1 = a.xMax;
		var b1 = b.xMax;
		var xMax = a1 > b1 ? b1 : a1;
		var a1 = a.yMax;
		var b1 = b.yMax;
		var yMax = a1 > b1 ? b1 : a1;
		var a1 = a.zMax;
		var b1 = b.zMax;
		var zMax = a1 > b1 ? b1 : a1;
		this.xMin = xMin;
		this.xMax = xMax;
		this.yMin = yMin;
		this.yMax = yMax;
		this.zMin = zMin;
		this.zMax = zMax;
	}
	,offset: function(dx,dy,dz) {
		this.xMin += dx;
		this.xMax += dx;
		this.yMin += dy;
		this.yMax += dy;
		this.zMin += dz;
		this.zMax += dz;
	}
	,setMin: function(p) {
		this.xMin = p.x;
		this.yMin = p.y;
		this.zMin = p.z;
	}
	,setMax: function(p) {
		this.xMax = p.x;
		this.yMax = p.y;
		this.zMax = p.z;
	}
	,load: function(b) {
		this.xMin = b.xMin;
		this.xMax = b.xMax;
		this.yMin = b.yMin;
		this.yMax = b.yMax;
		this.zMin = b.zMin;
		this.zMax = b.zMax;
	}
	,scalePivot: function(v) {
		this.xMin *= v;
		this.yMin *= v;
		this.zMin *= v;
		this.xMax *= v;
		this.yMax *= v;
		this.zMax *= v;
	}
	,scaleCenter: function(v) {
		var dx = (this.xMax - this.xMin) * 0.5 * v;
		var dy = (this.yMax - this.yMin) * 0.5 * v;
		var dz = (this.zMax - this.zMin) * 0.5 * v;
		var mx = (this.xMax + this.xMin) * 0.5;
		var my = (this.yMax + this.yMin) * 0.5;
		var mz = (this.zMax + this.zMin) * 0.5;
		this.xMin = mx - dx;
		this.yMin = my - dy;
		this.zMin = mz - dz;
		this.xMax = mx + dx;
		this.yMax = my + dy;
		this.zMax = mz + dz;
	}
	,getMin: function() {
		var x = this.xMin;
		var y = this.yMin;
		var z = this.zMin;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,getCenter: function() {
		var x = (this.xMin + this.xMax) * 0.5;
		var y = (this.yMin + this.yMax) * 0.5;
		var z = (this.zMin + this.zMax) * 0.5;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,getSize: function() {
		var x = this.xMax - this.xMin;
		var y = this.yMax - this.yMin;
		var z = this.zMax - this.zMin;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,getMax: function() {
		var x = this.xMax;
		var y = this.yMax;
		var z = this.zMax;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,getVolume: function() {
		return (this.xMax - this.xMin) * (this.yMax - this.yMin) * (this.zMax - this.zMin);
	}
	,get_xSize: function() {
		return this.xMax - this.xMin;
	}
	,get_ySize: function() {
		return this.yMax - this.yMin;
	}
	,get_zSize: function() {
		return this.zMax - this.zMin;
	}
	,set_xSize: function(v) {
		this.xMax = this.xMin + v;
		return v;
	}
	,set_ySize: function(v) {
		this.yMax = this.yMin + v;
		return v;
	}
	,set_zSize: function(v) {
		this.zMax = this.zMin + v;
		return v;
	}
	,isEmpty: function() {
		if(!(this.xMax < this.xMin || this.yMax < this.yMin)) {
			return this.zMax < this.zMin;
		} else {
			return true;
		}
	}
	,empty: function() {
		this.xMin = 1e20;
		this.xMax = -1e20;
		this.yMin = 1e20;
		this.yMax = -1e20;
		this.zMin = 1e20;
		this.zMax = -1e20;
	}
	,all: function() {
		this.xMin = -1e20;
		this.xMax = 1e20;
		this.yMin = -1e20;
		this.yMax = 1e20;
		this.zMin = -1e20;
		this.zMax = 1e20;
	}
	,clone: function() {
		var b = new h3d_col_Bounds();
		b.xMin = this.xMin;
		b.xMax = this.xMax;
		b.yMin = this.yMin;
		b.yMax = this.yMax;
		b.zMin = this.zMin;
		b.zMax = this.zMax;
		return b;
	}
	,toString: function() {
		var x = this.xMin;
		var y = this.yMin;
		var z = this.zMin;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var tmp = "Bounds{" + Std.string(new h3d_VectorImpl(x,y,z)) + ",";
		var x = this.xMax - this.xMin;
		var y = this.yMax - this.yMin;
		var z = this.zMax - this.zMin;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return tmp + Std.string(new h3d_VectorImpl(x,y,z)) + "}";
	}
	,toSphere: function() {
		var dx = this.xMax - this.xMin;
		var dy = this.yMax - this.yMin;
		var dz = this.zMax - this.zMin;
		return new h3d_col_Sphere((this.xMin + this.xMax) * 0.5,(this.yMin + this.yMax) * 0.5,(this.zMin + this.zMax) * 0.5,Math.sqrt(dx * dx + dy * dy + dz * dz) * 0.5);
	}
	,dimension: function() {
		var a = this.xMax - this.xMin;
		var a1 = this.yMax - this.yMin;
		var b = this.zMax - this.zMin;
		var b1 = a1 < b ? b : a1;
		if(a < b1) {
			return b1;
		} else {
			return a;
		}
	}
	,closestPoint: function(p) {
		throw haxe_Exception.thrown("Not implemented");
	}
	,makeDebugObj: function() {
		var prim = new h3d_prim_Cube(this.xMax - this.xMin,this.yMax - this.yMin,this.zMax - this.zMin);
		prim.translate(this.xMin,this.yMin,this.zMin);
		prim.addNormals();
		return new h3d_scene_Mesh(prim);
	}
	,__class__: h3d_col_Bounds
});
var h3d_col_OptimizedCollider = function(a,b) {
	this.a = a;
	this.b = b;
};
$hxClasses["h3d.col.OptimizedCollider"] = h3d_col_OptimizedCollider;
h3d_col_OptimizedCollider.__name__ = "h3d.col.OptimizedCollider";
h3d_col_OptimizedCollider.__super__ = h3d_col_Collider;
h3d_col_OptimizedCollider.prototype = $extend(h3d_col_Collider.prototype,{
	rayIntersection: function(r,bestMatch) {
		if(this.a.rayIntersection(r,false) < 0) {
			if(!this.checkInside) {
				return -1;
			}
			var x = r.px + 0 * r.lx;
			var y = r.py + 0 * r.ly;
			var z = r.pz + 0 * r.lz;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			if(!this.a.contains(new h3d_VectorImpl(x,y,z))) {
				return -1;
			}
		}
		return this.b.rayIntersection(r,bestMatch);
	}
	,contains: function(p) {
		if(this.a.contains(p)) {
			return this.b.contains(p);
		} else {
			return false;
		}
	}
	,inFrustum: function(f,m) {
		if(this.a.inFrustum(f,m)) {
			return this.b.inFrustum(f,m);
		} else {
			return false;
		}
	}
	,inSphere: function(s) {
		if(this.a.inSphere(s)) {
			return this.b.inSphere(s);
		} else {
			return false;
		}
	}
	,dimension: function() {
		return Math.max(this.a.dimension(),this.b.dimension());
	}
	,closestPoint: function(p) {
		return this.b.closestPoint(p);
	}
	,makeDebugObj: function() {
		var bobj = this.b.makeDebugObj();
		var aobj = this.a.makeDebugObj();
		if(aobj == null && bobj == null) {
			return null;
		}
		var ret = new h3d_scene_Object();
		if(aobj != null) {
			ret.addChild(aobj);
		}
		if(bobj != null) {
			ret.addChild(bobj);
		}
		return ret;
	}
	,__class__: h3d_col_OptimizedCollider
});
var h3d_col_GroupCollider = function(colliders) {
	this.colliders = colliders;
};
$hxClasses["h3d.col.GroupCollider"] = h3d_col_GroupCollider;
h3d_col_GroupCollider.__name__ = "h3d.col.GroupCollider";
h3d_col_GroupCollider.__super__ = h3d_col_Collider;
h3d_col_GroupCollider.prototype = $extend(h3d_col_Collider.prototype,{
	rayIntersection: function(r,bestMatch) {
		var best = -1.;
		var _g = 0;
		var _g1 = this.colliders;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			var d = c.rayIntersection(r,bestMatch);
			if(d >= 0) {
				if(!bestMatch) {
					return d;
				}
				if(best < 0 || d < best) {
					best = d;
				}
			}
		}
		return best;
	}
	,contains: function(p) {
		var _g = 0;
		var _g1 = this.colliders;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			if(c.contains(p)) {
				return true;
			}
		}
		return false;
	}
	,inFrustum: function(f,m) {
		var _g = 0;
		var _g1 = this.colliders;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			if(c.inFrustum(f,m)) {
				return true;
			}
		}
		return false;
	}
	,inSphere: function(s) {
		var _g = 0;
		var _g1 = this.colliders;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			if(c.inSphere(s)) {
				return true;
			}
		}
		return false;
	}
	,dimension: function() {
		var d = -Infinity;
		var _g = 0;
		var _g1 = this.colliders;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			d = Math.max(d,c.dimension());
		}
		return d;
	}
	,closestPoint: function(p) {
		var result = null;
		var lengthSq = Infinity;
		var _g = 0;
		var _g1 = this.colliders;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			var closest = c.closestPoint(p);
			var _this = closest;
			var dx = p.x - _this.x;
			var dy = p.y - _this.y;
			var dz = p.z - _this.z;
			var lSq = dx * dx + dy * dy + dz * dz;
			if(lSq < lengthSq) {
				result = closest;
				lengthSq = lSq;
			}
		}
		return result;
	}
	,makeDebugObj: function() {
		var ret = null;
		var _g = 0;
		var _g1 = this.colliders;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			var toAdd = c.makeDebugObj();
			if(toAdd == null) {
				continue;
			}
			if(ret == null) {
				ret = new h3d_scene_Object();
			}
			ret.addChild(toAdd);
		}
		return ret;
	}
	,__class__: h3d_col_GroupCollider
});
var h3d_col_FPoint = function(x,y,z) {
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.x = x;
	this.y = y;
	this.z = z;
};
$hxClasses["h3d.col.FPoint"] = h3d_col_FPoint;
h3d_col_FPoint.__name__ = "h3d.col.FPoint";
h3d_col_FPoint.prototype = {
	set: function(x,y,z) {
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		this.x = x;
		this.y = y;
		this.z = z;
	}
	,sub: function(p) {
		return new h3d_col_FPoint(this.x - p.x,this.y - p.y,this.z - p.z);
	}
	,add: function(p) {
		return new h3d_col_FPoint(this.x + p.x,this.y + p.y,this.z + p.z);
	}
	,cross: function(p) {
		return new h3d_col_FPoint(this.y * p.z - this.z * p.y,this.z * p.x - this.x * p.z,this.x * p.y - this.y * p.x);
	}
	,dot: function(p) {
		return this.x * p.x + this.y * p.y + this.z * p.z;
	}
	,distanceSq: function(v) {
		var dx = v.x - this.x;
		var dy = v.y - this.y;
		var dz = v.z - this.z;
		return dx * dx + dy * dy + dz * dz;
	}
	,lengthSq: function() {
		return this.x * this.x + this.y * this.y + this.z * this.z;
	}
	,normalized: function() {
		var k = this.x * this.x + this.y * this.y + this.z * this.z;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		return new h3d_col_FPoint(this.x * k,this.y * k,this.z * k);
	}
	,scaled: function(v) {
		return new h3d_col_FPoint(this.x * v,this.y * v,this.z * v);
	}
	,toString: function() {
		return "FPoint{" + hxd_Math.fmt(this.x) + "," + hxd_Math.fmt(this.y) + "," + hxd_Math.fmt(this.z) + "}";
	}
	,__class__: h3d_col_FPoint
};
var h3d_col_Frustum = function(mvp) {
	this.checkNearFar = true;
	this.pleft = new h3d_col_Plane(1,0,0,0.0);
	this.pright = new h3d_col_Plane(1,0,0,0.0);
	this.ptop = new h3d_col_Plane(1,0,0,0.0);
	this.pbottom = new h3d_col_Plane(1,0,0,0.0);
	this.pnear = new h3d_col_Plane(1,0,0,0.0);
	this.pfar = new h3d_col_Plane(1,0,0,0.0);
	if(mvp != null) {
		this.loadMatrix(mvp);
	}
};
$hxClasses["h3d.col.Frustum"] = h3d_col_Frustum;
h3d_col_Frustum.__name__ = "h3d.col.Frustum";
h3d_col_Frustum.prototype = {
	clone: function() {
		var f = new h3d_col_Frustum();
		var _this = f.pleft;
		var p = this.pleft;
		_this.nx = p.nx;
		_this.ny = p.ny;
		_this.nz = p.nz;
		_this.d = p.d;
		var _this = f.pright;
		var p = this.pright;
		_this.nx = p.nx;
		_this.ny = p.ny;
		_this.nz = p.nz;
		_this.d = p.d;
		var _this = f.ptop;
		var p = this.ptop;
		_this.nx = p.nx;
		_this.ny = p.ny;
		_this.nz = p.nz;
		_this.d = p.d;
		var _this = f.pbottom;
		var p = this.pbottom;
		_this.nx = p.nx;
		_this.ny = p.ny;
		_this.nz = p.nz;
		_this.d = p.d;
		var _this = f.pnear;
		var p = this.pnear;
		_this.nx = p.nx;
		_this.ny = p.ny;
		_this.nz = p.nz;
		_this.d = p.d;
		var _this = f.pfar;
		var p = this.pfar;
		_this.nx = p.nx;
		_this.ny = p.ny;
		_this.nz = p.nz;
		_this.d = p.d;
		f.checkNearFar = this.checkNearFar;
		return f;
	}
	,loadMatrix: function(mvp) {
		var _this = this.pleft;
		var p_nx = mvp._14 + mvp._11;
		var p_ny = mvp._24 + mvp._21;
		var p_nz = mvp._34 + mvp._31;
		var p_d = -(mvp._44 + mvp._41);
		_this.nx = p_nx;
		_this.ny = p_ny;
		_this.nz = p_nz;
		_this.d = p_d;
		var _this = this.pright;
		var p_nx = mvp._14 - mvp._11;
		var p_ny = mvp._24 - mvp._21;
		var p_nz = mvp._34 - mvp._31;
		var p_d = mvp._41 - mvp._44;
		_this.nx = p_nx;
		_this.ny = p_ny;
		_this.nz = p_nz;
		_this.d = p_d;
		var _this = this.ptop;
		var p_nx = mvp._14 - mvp._12;
		var p_ny = mvp._24 - mvp._22;
		var p_nz = mvp._34 - mvp._32;
		var p_d = mvp._42 - mvp._44;
		_this.nx = p_nx;
		_this.ny = p_ny;
		_this.nz = p_nz;
		_this.d = p_d;
		var _this = this.pbottom;
		var p_nx = mvp._14 + mvp._12;
		var p_ny = mvp._24 + mvp._22;
		var p_nz = mvp._34 + mvp._32;
		var p_d = -(mvp._44 + mvp._42);
		_this.nx = p_nx;
		_this.ny = p_ny;
		_this.nz = p_nz;
		_this.d = p_d;
		var _this = this.pnear;
		var p_nx = mvp._13;
		var p_ny = mvp._23;
		var p_nz = mvp._33;
		var p_d = -mvp._43;
		_this.nx = p_nx;
		_this.ny = p_ny;
		_this.nz = p_nz;
		_this.d = p_d;
		var _this = this.pfar;
		var p_nx = mvp._14 - mvp._13;
		var p_ny = mvp._24 - mvp._23;
		var p_nz = mvp._34 - mvp._33;
		var p_d = mvp._43 - mvp._44;
		_this.nx = p_nx;
		_this.ny = p_ny;
		_this.nz = p_nz;
		_this.d = p_d;
		var _this = this.pleft;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
		var _this = this.pright;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
		var _this = this.ptop;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
		var _this = this.pbottom;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
		var _this = this.pnear;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
		var _this = this.pfar;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
	}
	,transform: function(m) {
		var m2 = new h3d_MatrixImpl();
		m2.initInverse(m);
		m2.transpose();
		var _this = this.pleft;
		var x = _this.nx;
		var y = _this.ny;
		var z = _this.nz;
		var w = -_this.d;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		var w1 = w;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var v_w = w1;
		var px = v_x * m2._11 + v_y * m2._21 + v_z * m2._31 + v_w * m2._41;
		var py = v_x * m2._12 + v_y * m2._22 + v_z * m2._32 + v_w * m2._42;
		var pz = v_x * m2._13 + v_y * m2._23 + v_z * m2._33 + v_w * m2._43;
		var pw = v_x * m2._14 + v_y * m2._24 + v_z * m2._34 + v_w * m2._44;
		v_x = px;
		v_y = py;
		v_z = pz;
		v_w = pw;
		_this.nx = v_x;
		_this.ny = v_y;
		_this.nz = v_z;
		_this.d = -v_w;
		var _this = this.pright;
		var x = _this.nx;
		var y = _this.ny;
		var z = _this.nz;
		var w = -_this.d;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		var w1 = w;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var v_w = w1;
		var px = v_x * m2._11 + v_y * m2._21 + v_z * m2._31 + v_w * m2._41;
		var py = v_x * m2._12 + v_y * m2._22 + v_z * m2._32 + v_w * m2._42;
		var pz = v_x * m2._13 + v_y * m2._23 + v_z * m2._33 + v_w * m2._43;
		var pw = v_x * m2._14 + v_y * m2._24 + v_z * m2._34 + v_w * m2._44;
		v_x = px;
		v_y = py;
		v_z = pz;
		v_w = pw;
		_this.nx = v_x;
		_this.ny = v_y;
		_this.nz = v_z;
		_this.d = -v_w;
		var _this = this.ptop;
		var x = _this.nx;
		var y = _this.ny;
		var z = _this.nz;
		var w = -_this.d;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		var w1 = w;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var v_w = w1;
		var px = v_x * m2._11 + v_y * m2._21 + v_z * m2._31 + v_w * m2._41;
		var py = v_x * m2._12 + v_y * m2._22 + v_z * m2._32 + v_w * m2._42;
		var pz = v_x * m2._13 + v_y * m2._23 + v_z * m2._33 + v_w * m2._43;
		var pw = v_x * m2._14 + v_y * m2._24 + v_z * m2._34 + v_w * m2._44;
		v_x = px;
		v_y = py;
		v_z = pz;
		v_w = pw;
		_this.nx = v_x;
		_this.ny = v_y;
		_this.nz = v_z;
		_this.d = -v_w;
		var _this = this.pbottom;
		var x = _this.nx;
		var y = _this.ny;
		var z = _this.nz;
		var w = -_this.d;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		var w1 = w;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var v_w = w1;
		var px = v_x * m2._11 + v_y * m2._21 + v_z * m2._31 + v_w * m2._41;
		var py = v_x * m2._12 + v_y * m2._22 + v_z * m2._32 + v_w * m2._42;
		var pz = v_x * m2._13 + v_y * m2._23 + v_z * m2._33 + v_w * m2._43;
		var pw = v_x * m2._14 + v_y * m2._24 + v_z * m2._34 + v_w * m2._44;
		v_x = px;
		v_y = py;
		v_z = pz;
		v_w = pw;
		_this.nx = v_x;
		_this.ny = v_y;
		_this.nz = v_z;
		_this.d = -v_w;
		var _this = this.pfar;
		var x = _this.nx;
		var y = _this.ny;
		var z = _this.nz;
		var w = -_this.d;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		var w1 = w;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var v_w = w1;
		var px = v_x * m2._11 + v_y * m2._21 + v_z * m2._31 + v_w * m2._41;
		var py = v_x * m2._12 + v_y * m2._22 + v_z * m2._32 + v_w * m2._42;
		var pz = v_x * m2._13 + v_y * m2._23 + v_z * m2._33 + v_w * m2._43;
		var pw = v_x * m2._14 + v_y * m2._24 + v_z * m2._34 + v_w * m2._44;
		v_x = px;
		v_y = py;
		v_z = pz;
		v_w = pw;
		_this.nx = v_x;
		_this.ny = v_y;
		_this.nz = v_z;
		_this.d = -v_w;
		var _this = this.pnear;
		var x = _this.nx;
		var y = _this.ny;
		var z = _this.nz;
		var w = -_this.d;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		var w1 = w;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var v_w = w1;
		var px = v_x * m2._11 + v_y * m2._21 + v_z * m2._31 + v_w * m2._41;
		var py = v_x * m2._12 + v_y * m2._22 + v_z * m2._32 + v_w * m2._42;
		var pz = v_x * m2._13 + v_y * m2._23 + v_z * m2._33 + v_w * m2._43;
		var pw = v_x * m2._14 + v_y * m2._24 + v_z * m2._34 + v_w * m2._44;
		v_x = px;
		v_y = py;
		v_z = pz;
		v_w = pw;
		_this.nx = v_x;
		_this.ny = v_y;
		_this.nz = v_z;
		_this.d = -v_w;
		var _this = this.pleft;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
		var _this = this.pright;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
		var _this = this.ptop;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
		var _this = this.pbottom;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
		var _this = this.pnear;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
		var _this = this.pfar;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
	}
	,transform3x3: function(m) {
		var m2 = new h3d_MatrixImpl();
		m2.initInverse3x3(m);
		m2.transpose();
		var _this = this.pleft;
		var x = _this.nx;
		var y = _this.ny;
		var z = _this.nz;
		var w = -_this.d;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		var w1 = w;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var v_w = w1;
		var px = v_x * m2._11 + v_y * m2._21 + v_z * m2._31 + v_w * m2._41;
		var py = v_x * m2._12 + v_y * m2._22 + v_z * m2._32 + v_w * m2._42;
		var pz = v_x * m2._13 + v_y * m2._23 + v_z * m2._33 + v_w * m2._43;
		var pw = v_x * m2._14 + v_y * m2._24 + v_z * m2._34 + v_w * m2._44;
		v_x = px;
		v_y = py;
		v_z = pz;
		v_w = pw;
		_this.nx = v_x;
		_this.ny = v_y;
		_this.nz = v_z;
		_this.d = -v_w;
		var _this = this.pright;
		var x = _this.nx;
		var y = _this.ny;
		var z = _this.nz;
		var w = -_this.d;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		var w1 = w;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var v_w = w1;
		var px = v_x * m2._11 + v_y * m2._21 + v_z * m2._31 + v_w * m2._41;
		var py = v_x * m2._12 + v_y * m2._22 + v_z * m2._32 + v_w * m2._42;
		var pz = v_x * m2._13 + v_y * m2._23 + v_z * m2._33 + v_w * m2._43;
		var pw = v_x * m2._14 + v_y * m2._24 + v_z * m2._34 + v_w * m2._44;
		v_x = px;
		v_y = py;
		v_z = pz;
		v_w = pw;
		_this.nx = v_x;
		_this.ny = v_y;
		_this.nz = v_z;
		_this.d = -v_w;
		var _this = this.ptop;
		var x = _this.nx;
		var y = _this.ny;
		var z = _this.nz;
		var w = -_this.d;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		var w1 = w;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var v_w = w1;
		var px = v_x * m2._11 + v_y * m2._21 + v_z * m2._31 + v_w * m2._41;
		var py = v_x * m2._12 + v_y * m2._22 + v_z * m2._32 + v_w * m2._42;
		var pz = v_x * m2._13 + v_y * m2._23 + v_z * m2._33 + v_w * m2._43;
		var pw = v_x * m2._14 + v_y * m2._24 + v_z * m2._34 + v_w * m2._44;
		v_x = px;
		v_y = py;
		v_z = pz;
		v_w = pw;
		_this.nx = v_x;
		_this.ny = v_y;
		_this.nz = v_z;
		_this.d = -v_w;
		var _this = this.pbottom;
		var x = _this.nx;
		var y = _this.ny;
		var z = _this.nz;
		var w = -_this.d;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		var w1 = w;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var v_w = w1;
		var px = v_x * m2._11 + v_y * m2._21 + v_z * m2._31 + v_w * m2._41;
		var py = v_x * m2._12 + v_y * m2._22 + v_z * m2._32 + v_w * m2._42;
		var pz = v_x * m2._13 + v_y * m2._23 + v_z * m2._33 + v_w * m2._43;
		var pw = v_x * m2._14 + v_y * m2._24 + v_z * m2._34 + v_w * m2._44;
		v_x = px;
		v_y = py;
		v_z = pz;
		v_w = pw;
		_this.nx = v_x;
		_this.ny = v_y;
		_this.nz = v_z;
		_this.d = -v_w;
		var _this = this.pfar;
		var x = _this.nx;
		var y = _this.ny;
		var z = _this.nz;
		var w = -_this.d;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		var w1 = w;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var v_w = w1;
		var px = v_x * m2._11 + v_y * m2._21 + v_z * m2._31 + v_w * m2._41;
		var py = v_x * m2._12 + v_y * m2._22 + v_z * m2._32 + v_w * m2._42;
		var pz = v_x * m2._13 + v_y * m2._23 + v_z * m2._33 + v_w * m2._43;
		var pw = v_x * m2._14 + v_y * m2._24 + v_z * m2._34 + v_w * m2._44;
		v_x = px;
		v_y = py;
		v_z = pz;
		v_w = pw;
		_this.nx = v_x;
		_this.ny = v_y;
		_this.nz = v_z;
		_this.d = -v_w;
		var _this = this.pnear;
		var x = _this.nx;
		var y = _this.ny;
		var z = _this.nz;
		var w = -_this.d;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		var w1 = w;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var v_w = w1;
		var px = v_x * m2._11 + v_y * m2._21 + v_z * m2._31 + v_w * m2._41;
		var py = v_x * m2._12 + v_y * m2._22 + v_z * m2._32 + v_w * m2._42;
		var pz = v_x * m2._13 + v_y * m2._23 + v_z * m2._33 + v_w * m2._43;
		var pw = v_x * m2._14 + v_y * m2._24 + v_z * m2._34 + v_w * m2._44;
		v_x = px;
		v_y = py;
		v_z = pz;
		v_w = pw;
		_this.nx = v_x;
		_this.ny = v_y;
		_this.nz = v_z;
		_this.d = -v_w;
		var _this = this.pleft;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
		var _this = this.pright;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
		var _this = this.ptop;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
		var _this = this.pbottom;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
		var _this = this.pnear;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
		var _this = this.pfar;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
	}
	,hasPoint: function(p) {
		var _this = this.pleft;
		if(_this.nx * p.x + _this.ny * p.y + _this.nz * p.z - _this.d < 0) {
			return false;
		}
		var _this = this.pright;
		if(_this.nx * p.x + _this.ny * p.y + _this.nz * p.z - _this.d < 0) {
			return false;
		}
		var _this = this.ptop;
		if(_this.nx * p.x + _this.ny * p.y + _this.nz * p.z - _this.d < 0) {
			return false;
		}
		var _this = this.pbottom;
		if(_this.nx * p.x + _this.ny * p.y + _this.nz * p.z - _this.d < 0) {
			return false;
		}
		if(this.checkNearFar) {
			var _this = this.pnear;
			if(_this.nx * p.x + _this.ny * p.y + _this.nz * p.z - _this.d < 0) {
				return false;
			}
			var _this = this.pfar;
			if(_this.nx * p.x + _this.ny * p.y + _this.nz * p.z - _this.d < 0) {
				return false;
			}
		}
		return true;
	}
	,hasSphere: function(s) {
		var x = s.x;
		var y = s.y;
		var z = s.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var p_x = x1;
		var p_y = y1;
		var p_z = z1;
		var _this = this.pleft;
		if(_this.nx * p_x + _this.ny * p_y + _this.nz * p_z - _this.d < -s.r) {
			return false;
		}
		var _this = this.pright;
		if(_this.nx * p_x + _this.ny * p_y + _this.nz * p_z - _this.d < -s.r) {
			return false;
		}
		var _this = this.ptop;
		if(_this.nx * p_x + _this.ny * p_y + _this.nz * p_z - _this.d < -s.r) {
			return false;
		}
		var _this = this.pbottom;
		if(_this.nx * p_x + _this.ny * p_y + _this.nz * p_z - _this.d < -s.r) {
			return false;
		}
		if(this.checkNearFar) {
			var _this = this.pnear;
			if(_this.nx * p_x + _this.ny * p_y + _this.nz * p_z - _this.d < -s.r) {
				return false;
			}
			var _this = this.pfar;
			if(_this.nx * p_x + _this.ny * p_y + _this.nz * p_z - _this.d < -s.r) {
				return false;
			}
		}
		return true;
	}
	,hasBounds: function(b) {
		var p = this.pleft;
		var a = p.nx;
		var b1 = p.ny;
		var c = p.nz;
		var dd = a * (b.xMax + b.xMin) + b1 * (b.yMax + b.yMin) + c * (b.zMax + b.zMin);
		if(a < 0) {
			a = -a;
		}
		if(b1 < 0) {
			b1 = -b1;
		}
		if(c < 0) {
			c = -c;
		}
		var rr = a * (b.xMax - b.xMin) + b1 * (b.yMax - b.yMin) + c * (b.zMax - b.zMin);
		if(dd + rr - p.d * 2 < 0) {
			return false;
		}
		var p = this.pright;
		var a = p.nx;
		var b1 = p.ny;
		var c = p.nz;
		var dd = a * (b.xMax + b.xMin) + b1 * (b.yMax + b.yMin) + c * (b.zMax + b.zMin);
		if(a < 0) {
			a = -a;
		}
		if(b1 < 0) {
			b1 = -b1;
		}
		if(c < 0) {
			c = -c;
		}
		var rr = a * (b.xMax - b.xMin) + b1 * (b.yMax - b.yMin) + c * (b.zMax - b.zMin);
		if(dd + rr - p.d * 2 < 0) {
			return false;
		}
		var p = this.ptop;
		var a = p.nx;
		var b1 = p.ny;
		var c = p.nz;
		var dd = a * (b.xMax + b.xMin) + b1 * (b.yMax + b.yMin) + c * (b.zMax + b.zMin);
		if(a < 0) {
			a = -a;
		}
		if(b1 < 0) {
			b1 = -b1;
		}
		if(c < 0) {
			c = -c;
		}
		var rr = a * (b.xMax - b.xMin) + b1 * (b.yMax - b.yMin) + c * (b.zMax - b.zMin);
		if(dd + rr - p.d * 2 < 0) {
			return false;
		}
		var p = this.pbottom;
		var a = p.nx;
		var b1 = p.ny;
		var c = p.nz;
		var dd = a * (b.xMax + b.xMin) + b1 * (b.yMax + b.yMin) + c * (b.zMax + b.zMin);
		if(a < 0) {
			a = -a;
		}
		if(b1 < 0) {
			b1 = -b1;
		}
		if(c < 0) {
			c = -c;
		}
		var rr = a * (b.xMax - b.xMin) + b1 * (b.yMax - b.yMin) + c * (b.zMax - b.zMin);
		if(dd + rr - p.d * 2 < 0) {
			return false;
		}
		if(this.checkNearFar) {
			var p = this.pnear;
			var a = p.nx;
			var b1 = p.ny;
			var c = p.nz;
			var dd = a * (b.xMax + b.xMin) + b1 * (b.yMax + b.yMin) + c * (b.zMax + b.zMin);
			if(a < 0) {
				a = -a;
			}
			if(b1 < 0) {
				b1 = -b1;
			}
			if(c < 0) {
				c = -c;
			}
			var rr = a * (b.xMax - b.xMin) + b1 * (b.yMax - b.yMin) + c * (b.zMax - b.zMin);
			if(dd + rr - p.d * 2 < 0) {
				return false;
			}
			var p = this.pfar;
			var a = p.nx;
			var b1 = p.ny;
			var c = p.nz;
			var dd = a * (b.xMax + b.xMin) + b1 * (b.yMax + b.yMin) + c * (b.zMax + b.zMin);
			if(a < 0) {
				a = -a;
			}
			if(b1 < 0) {
				b1 = -b1;
			}
			if(c < 0) {
				c = -c;
			}
			var rr = a * (b.xMax - b.xMin) + b1 * (b.yMax - b.yMin) + c * (b.zMax - b.zMin);
			if(dd + rr - p.d * 2 < 0) {
				return false;
			}
		}
		return true;
	}
	,hasOrientedBounds: function(b) {
		var p = this.pleft;
		var x = p.nx;
		var y = p.ny;
		var z = p.nz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var x = b.xx;
		var y = b.xy;
		var z = b.xz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ax_x = x1;
		var ax_y = y1;
		var ax_z = z1;
		var x = b.yx;
		var y = b.yy;
		var z = b.yz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ay_x = x1;
		var ay_y = y1;
		var ay_z = z1;
		var x = b.zx;
		var y = b.zy;
		var z = b.zz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var az_x = x1;
		var az_y = y1;
		var az_z = z1;
		var x = b.centerX;
		var y = b.centerY;
		var z = b.centerZ;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var c_x = x1;
		var c_y = y1;
		var c_z = z1;
		var f = _this_x * ax_x + _this_y * ax_y + _this_z * ax_z;
		var f1 = _this_x * ay_x + _this_y * ay_y + _this_z * ay_z;
		var f2 = _this_x * az_x + _this_y * az_y + _this_z * az_z;
		var r = b.hx * (f < 0 ? -f : f) + b.hy * (f1 < 0 ? -f1 : f1) + b.hz * (f2 < 0 ? -f2 : f2);
		var s = _this_x * c_x + _this_y * c_y + _this_z * c_z - p.d;
		if(s + r < 0) {
			return false;
		}
		var p = this.pright;
		var x = p.nx;
		var y = p.ny;
		var z = p.nz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var x = b.xx;
		var y = b.xy;
		var z = b.xz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ax_x = x1;
		var ax_y = y1;
		var ax_z = z1;
		var x = b.yx;
		var y = b.yy;
		var z = b.yz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ay_x = x1;
		var ay_y = y1;
		var ay_z = z1;
		var x = b.zx;
		var y = b.zy;
		var z = b.zz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var az_x = x1;
		var az_y = y1;
		var az_z = z1;
		var x = b.centerX;
		var y = b.centerY;
		var z = b.centerZ;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var c_x = x1;
		var c_y = y1;
		var c_z = z1;
		var f = _this_x * ax_x + _this_y * ax_y + _this_z * ax_z;
		var f1 = _this_x * ay_x + _this_y * ay_y + _this_z * ay_z;
		var f2 = _this_x * az_x + _this_y * az_y + _this_z * az_z;
		var r = b.hx * (f < 0 ? -f : f) + b.hy * (f1 < 0 ? -f1 : f1) + b.hz * (f2 < 0 ? -f2 : f2);
		var s = _this_x * c_x + _this_y * c_y + _this_z * c_z - p.d;
		if(s + r < 0) {
			return false;
		}
		var p = this.ptop;
		var x = p.nx;
		var y = p.ny;
		var z = p.nz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var x = b.xx;
		var y = b.xy;
		var z = b.xz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ax_x = x1;
		var ax_y = y1;
		var ax_z = z1;
		var x = b.yx;
		var y = b.yy;
		var z = b.yz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ay_x = x1;
		var ay_y = y1;
		var ay_z = z1;
		var x = b.zx;
		var y = b.zy;
		var z = b.zz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var az_x = x1;
		var az_y = y1;
		var az_z = z1;
		var x = b.centerX;
		var y = b.centerY;
		var z = b.centerZ;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var c_x = x1;
		var c_y = y1;
		var c_z = z1;
		var f = _this_x * ax_x + _this_y * ax_y + _this_z * ax_z;
		var f1 = _this_x * ay_x + _this_y * ay_y + _this_z * ay_z;
		var f2 = _this_x * az_x + _this_y * az_y + _this_z * az_z;
		var r = b.hx * (f < 0 ? -f : f) + b.hy * (f1 < 0 ? -f1 : f1) + b.hz * (f2 < 0 ? -f2 : f2);
		var s = _this_x * c_x + _this_y * c_y + _this_z * c_z - p.d;
		if(s + r < 0) {
			return false;
		}
		var p = this.pbottom;
		var x = p.nx;
		var y = p.ny;
		var z = p.nz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var x = b.xx;
		var y = b.xy;
		var z = b.xz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ax_x = x1;
		var ax_y = y1;
		var ax_z = z1;
		var x = b.yx;
		var y = b.yy;
		var z = b.yz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ay_x = x1;
		var ay_y = y1;
		var ay_z = z1;
		var x = b.zx;
		var y = b.zy;
		var z = b.zz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var az_x = x1;
		var az_y = y1;
		var az_z = z1;
		var x = b.centerX;
		var y = b.centerY;
		var z = b.centerZ;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var c_x = x1;
		var c_y = y1;
		var c_z = z1;
		var f = _this_x * ax_x + _this_y * ax_y + _this_z * ax_z;
		var f1 = _this_x * ay_x + _this_y * ay_y + _this_z * ay_z;
		var f2 = _this_x * az_x + _this_y * az_y + _this_z * az_z;
		var r = b.hx * (f < 0 ? -f : f) + b.hy * (f1 < 0 ? -f1 : f1) + b.hz * (f2 < 0 ? -f2 : f2);
		var s = _this_x * c_x + _this_y * c_y + _this_z * c_z - p.d;
		if(s + r < 0) {
			return false;
		}
		if(this.checkNearFar) {
			var p = this.pnear;
			var x = p.nx;
			var y = p.ny;
			var z = p.nz;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var _this_x = x1;
			var _this_y = y1;
			var _this_z = z1;
			var x = b.xx;
			var y = b.xy;
			var z = b.xz;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var ax_x = x1;
			var ax_y = y1;
			var ax_z = z1;
			var x = b.yx;
			var y = b.yy;
			var z = b.yz;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var ay_x = x1;
			var ay_y = y1;
			var ay_z = z1;
			var x = b.zx;
			var y = b.zy;
			var z = b.zz;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var az_x = x1;
			var az_y = y1;
			var az_z = z1;
			var x = b.centerX;
			var y = b.centerY;
			var z = b.centerZ;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var c_x = x1;
			var c_y = y1;
			var c_z = z1;
			var f = _this_x * ax_x + _this_y * ax_y + _this_z * ax_z;
			var f1 = _this_x * ay_x + _this_y * ay_y + _this_z * ay_z;
			var f2 = _this_x * az_x + _this_y * az_y + _this_z * az_z;
			var r = b.hx * (f < 0 ? -f : f) + b.hy * (f1 < 0 ? -f1 : f1) + b.hz * (f2 < 0 ? -f2 : f2);
			var s = _this_x * c_x + _this_y * c_y + _this_z * c_z - p.d;
			if(s + r < 0) {
				return false;
			}
			var p = this.pfar;
			var x = p.nx;
			var y = p.ny;
			var z = p.nz;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var _this_x = x1;
			var _this_y = y1;
			var _this_z = z1;
			var x = b.xx;
			var y = b.xy;
			var z = b.xz;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var ax_x = x1;
			var ax_y = y1;
			var ax_z = z1;
			var x = b.yx;
			var y = b.yy;
			var z = b.yz;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var ay_x = x1;
			var ay_y = y1;
			var ay_z = z1;
			var x = b.zx;
			var y = b.zy;
			var z = b.zz;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var az_x = x1;
			var az_y = y1;
			var az_z = z1;
			var x = b.centerX;
			var y = b.centerY;
			var z = b.centerZ;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var c_x = x1;
			var c_y = y1;
			var c_z = z1;
			var f = _this_x * ax_x + _this_y * ax_y + _this_z * ax_z;
			var f1 = _this_x * ay_x + _this_y * ay_y + _this_z * ay_z;
			var f2 = _this_x * az_x + _this_y * az_y + _this_z * az_z;
			var r = b.hx * (f < 0 ? -f : f) + b.hy * (f1 < 0 ? -f1 : f1) + b.hz * (f2 < 0 ? -f2 : f2);
			var s = _this_x * c_x + _this_y * c_y + _this_z * c_z - p.d;
			if(s + r < 0) {
				return false;
			}
		}
		return true;
	}
	,__class__: h3d_col_Frustum
};
var h3d_col_Ray = function() {
};
$hxClasses["h3d.col.Ray"] = h3d_col_Ray;
h3d_col_Ray.__name__ = "h3d.col.Ray";
h3d_col_Ray.fromPoints = function(p1,p2) {
	var r = new h3d_col_Ray();
	r.px = p1.x;
	r.py = p1.y;
	r.pz = p1.z;
	r.lx = p2.x - p1.x;
	r.ly = p2.y - p1.y;
	r.lz = p2.z - p1.z;
	r.normalize();
	return r;
};
h3d_col_Ray.fromValues = function(x,y,z,dx,dy,dz) {
	var r = new h3d_col_Ray();
	r.px = x;
	r.py = y;
	r.pz = z;
	r.lx = dx;
	r.ly = dy;
	r.lz = dz;
	r.normalize();
	return r;
};
h3d_col_Ray.prototype = {
	clone: function() {
		var r = new h3d_col_Ray();
		r.px = this.px;
		r.py = this.py;
		r.pz = this.pz;
		r.lx = this.lx;
		r.ly = this.ly;
		r.lz = this.lz;
		return r;
	}
	,load: function(r) {
		this.px = r.px;
		this.py = r.py;
		this.pz = r.pz;
		this.lx = r.lx;
		this.ly = r.ly;
		this.lz = r.lz;
	}
	,normalize: function() {
		var l = this.lx * this.lx + this.ly * this.ly + this.lz * this.lz;
		if(l == 1.) {
			return;
		}
		if(l < 1e-20) {
			l = 0;
		} else {
			l = 1. / Math.sqrt(l);
		}
		this.lx *= l;
		this.ly *= l;
		this.lz *= l;
	}
	,transform: function(m) {
		var x = this.px;
		var y = this.py;
		var z = this.pz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var p_x = x1;
		var p_y = y1;
		var p_z = z1;
		var px = p_x * m._11 + p_y * m._21 + p_z * m._31 + m._41;
		var py = p_x * m._12 + p_y * m._22 + p_z * m._32 + m._42;
		var pz = p_x * m._13 + p_y * m._23 + p_z * m._33 + m._43;
		p_x = px;
		p_y = py;
		p_z = pz;
		this.px = p_x;
		this.py = p_y;
		this.pz = p_z;
		var x = this.lx;
		var y = this.ly;
		var z = this.lz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		this.lx = _this_x;
		this.ly = _this_y;
		this.lz = _this_z;
		this.normalize();
	}
	,getPos: function() {
		var x = this.px;
		var y = this.py;
		var z = this.pz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,getDir: function() {
		var x = this.lx;
		var y = this.ly;
		var z = this.lz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,getPoint: function(distance) {
		var x = this.px + distance * this.lx;
		var y = this.py + distance * this.ly;
		var z = this.pz + distance * this.lz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,toString: function() {
		var x = this.px;
		var y = this.py;
		var z = this.pz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var tmp = "Ray{" + Std.string(new h3d_VectorImpl(x,y,z)) + ",";
		var x = this.lx;
		var y = this.ly;
		var z = this.lz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return tmp + Std.string(new h3d_VectorImpl(x,y,z)) + "}";
	}
	,distance: function(p) {
		var d = this.lx * p.nx + this.ly * p.ny + this.lz * p.nz;
		var nd = p.d - (this.px * p.nx + this.py * p.ny + this.pz * p.nz);
		if((d < 0 ? -d : d) < 1e-10) {
			if((nd < 0 ? -nd : nd) < 1e-10) {
				return 0.;
			} else {
				return -1;
			}
		} else {
			return nd / d;
		}
	}
	,intersect: function(p) {
		var d = this.lx * p.nx + this.ly * p.ny + this.lz * p.nz;
		var nd = p.d - (this.px * p.nx + this.py * p.ny + this.pz * p.nz);
		if((d < 0 ? -d : d) < 1e-10) {
			if((nd < 0 ? -nd : nd) < 1e-10) {
				var x = this.px;
				var y = this.py;
				var z = this.pz;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				return new h3d_VectorImpl(x,y,z);
			} else {
				return null;
			}
		} else {
			var k = nd / d;
			var x = this.px + this.lx * k;
			var y = this.py + this.ly * k;
			var z = this.pz + this.lz * k;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			return new h3d_VectorImpl(x,y,z);
		}
	}
	,collideFrustum: function(mvp) {
		var x = this.px;
		var y = this.py;
		var z = this.pz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var px = _this_x * mvp._11 + _this_y * mvp._21 + _this_z * mvp._31 + mvp._41;
		var py = _this_x * mvp._12 + _this_y * mvp._22 + _this_z * mvp._32 + mvp._42;
		var pz = _this_x * mvp._13 + _this_y * mvp._23 + _this_z * mvp._33 + mvp._43;
		var iw = 1 / (_this_x * mvp._14 + _this_y * mvp._24 + _this_z * mvp._34 + mvp._44);
		_this_x = px * iw;
		_this_y = py * iw;
		_this_z = pz * iw;
		var x = this.px + this.lx;
		var y = this.py + this.ly;
		var z = this.pz + this.lz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x1 = x1;
		var _this_y1 = y1;
		var _this_z1 = z1;
		var px = _this_x1 * mvp._11 + _this_y1 * mvp._21 + _this_z1 * mvp._31 + mvp._41;
		var py = _this_x1 * mvp._12 + _this_y1 * mvp._22 + _this_z1 * mvp._32 + mvp._42;
		var pz = _this_x1 * mvp._13 + _this_y1 * mvp._23 + _this_z1 * mvp._33 + mvp._43;
		var iw = 1 / (_this_x1 * mvp._14 + _this_y1 * mvp._24 + _this_z1 * mvp._34 + mvp._44);
		_this_x1 = px * iw;
		_this_y1 = py * iw;
		_this_z1 = pz * iw;
		var lx = _this_x1 - _this_x;
		var ly = _this_y1 - _this_y;
		var lz = _this_z1 - _this_z;
		var dx = 1 / lx;
		var dy = 1 / ly;
		var dz = 1 / lz;
		var t1 = (-1 - _this_x) * dx;
		var t2 = (1 - _this_x) * dx;
		var t3 = (-1 - _this_y) * dy;
		var t4 = (1 - _this_y) * dy;
		var t5 = (0 - _this_z) * dz;
		var t6 = (1 - _this_z) * dz;
		var a = t1 > t2 ? t2 : t1;
		var b = t3 > t4 ? t4 : t3;
		var a1 = a < b ? b : a;
		var b = t5 > t6 ? t6 : t5;
		var tmin = a1 < b ? b : a1;
		var a = t1 < t2 ? t2 : t1;
		var b = t3 < t4 ? t4 : t3;
		var a1 = a > b ? b : a;
		var b = t5 < t6 ? t6 : t5;
		var tmax = a1 > b ? b : a1;
		return !(tmax < 0 || tmin > tmax);
	}
	,collide: function(b) {
		var dx = 1 / this.lx;
		var dy = 1 / this.ly;
		var dz = 1 / this.lz;
		var t1 = (b.xMin - this.px) * dx;
		var t2 = (b.xMax - this.px) * dx;
		var t3 = (b.yMin - this.py) * dy;
		var t4 = (b.yMax - this.py) * dy;
		var t5 = (b.zMin - this.pz) * dz;
		var t6 = (b.zMax - this.pz) * dz;
		var a = t1 > t2 ? t2 : t1;
		var b = t3 > t4 ? t4 : t3;
		var a1 = a < b ? b : a;
		var b = t5 > t6 ? t6 : t5;
		var tmin = a1 < b ? b : a1;
		var a = t1 < t2 ? t2 : t1;
		var b = t3 < t4 ? t4 : t3;
		var a1 = a > b ? b : a;
		var b = t5 < t6 ? t6 : t5;
		var tmax = a1 > b ? b : a1;
		if(tmax < 0) {
			return false;
		} else if(tmin > tmax) {
			return false;
		} else {
			return true;
		}
	}
	,__class__: h3d_col_Ray
};
var h3d_col_ObjectCollider = function(obj,collider) {
	this.obj = obj;
	this.collider = collider;
};
$hxClasses["h3d.col.ObjectCollider"] = h3d_col_ObjectCollider;
h3d_col_ObjectCollider.__name__ = "h3d.col.ObjectCollider";
h3d_col_ObjectCollider.__super__ = h3d_col_Collider;
h3d_col_ObjectCollider.prototype = $extend(h3d_col_Collider.prototype,{
	rayIntersection: function(r,bestMatch) {
		var tmpRay = h3d_col_ObjectCollider.TMP_RAY;
		h3d_col_ObjectCollider.TMP_RAY = null;
		tmpRay.px = r.px;
		tmpRay.py = r.py;
		tmpRay.pz = r.pz;
		tmpRay.lx = r.lx;
		tmpRay.ly = r.ly;
		tmpRay.lz = r.lz;
		var m = this.obj.getInvPos();
		var x = r.px;
		var y = r.py;
		var z = r.pz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var p_x = x1;
		var p_y = y1;
		var p_z = z1;
		var px = p_x * m._11 + p_y * m._21 + p_z * m._31 + m._41;
		var py = p_x * m._12 + p_y * m._22 + p_z * m._32 + m._42;
		var pz = p_x * m._13 + p_y * m._23 + p_z * m._33 + m._43;
		p_x = px;
		p_y = py;
		p_z = pz;
		r.px = p_x;
		r.py = p_y;
		r.pz = p_z;
		var x = r.lx;
		var y = r.ly;
		var z = r.lz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		r.lx = _this_x;
		r.ly = _this_y;
		r.lz = _this_z;
		r.normalize();
		var hit = this.collider.rayIntersection(r,bestMatch);
		if(hit < 0) {
			r.px = tmpRay.px;
			r.py = tmpRay.py;
			r.pz = tmpRay.pz;
			r.lx = tmpRay.lx;
			r.ly = tmpRay.ly;
			r.lz = tmpRay.lz;
			h3d_col_ObjectCollider.TMP_RAY = tmpRay;
			return hit;
		}
		var x = r.px + hit * r.lx;
		var y = r.py + hit * r.ly;
		var z = r.pz + hit * r.lz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var pt_x = x1;
		var pt_y = y1;
		var pt_z = z1;
		var m = this.obj.absPos;
		var px = pt_x * m._11 + pt_y * m._21 + pt_z * m._31 + m._41;
		var py = pt_x * m._12 + pt_y * m._22 + pt_z * m._32 + m._42;
		var pz = pt_x * m._13 + pt_y * m._23 + pt_z * m._33 + m._43;
		pt_x = px;
		pt_y = py;
		pt_z = pz;
		r.px = tmpRay.px;
		r.py = tmpRay.py;
		r.pz = tmpRay.pz;
		r.lx = tmpRay.lx;
		r.ly = tmpRay.ly;
		r.lz = tmpRay.lz;
		h3d_col_ObjectCollider.TMP_RAY = tmpRay;
		var dx = pt_x - r.px;
		var dy = pt_y - r.py;
		var dz = pt_z - r.pz;
		if(dz == null) {
			dz = 0.;
		}
		var dz1 = dz;
		if(dz1 == null) {
			dz1 = 0.;
		}
		return Math.sqrt(dx * dx + dy * dy + dz1 * dz1);
	}
	,contains: function(p) {
		var _this = p;
		var x = _this.x;
		var y = _this.y;
		var z = _this.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ptmp_x = x1;
		var ptmp_y = y1;
		var ptmp_z = z1;
		var m = this.obj.getInvPos();
		var px = p.x * m._11 + p.y * m._21 + p.z * m._31 + m._41;
		var py = p.x * m._12 + p.y * m._22 + p.z * m._32 + m._42;
		var pz = p.x * m._13 + p.y * m._23 + p.z * m._33 + m._43;
		p.x = px;
		p.y = py;
		p.z = pz;
		var b = this.collider.contains(p);
		var _this = p;
		_this.x = ptmp_x;
		_this.y = ptmp_y;
		_this.z = ptmp_z;
		return b;
	}
	,inFrustum: function(f,m) {
		if(m == null) {
			return this.collider.inFrustum(f,this.obj.getAbsPos());
		}
		var mat = h3d_col_ObjectCollider.TMP_MAT;
		var _this = mat;
		var b = this.obj.getAbsPos();
		var m11 = m._11;
		var m12 = m._12;
		var m13 = m._13;
		var m21 = m._21;
		var m22 = m._22;
		var m23 = m._23;
		var a31 = m._31;
		var a32 = m._32;
		var a33 = m._33;
		var a41 = m._41;
		var a42 = m._42;
		var a43 = m._43;
		var b11 = b._11;
		var b12 = b._12;
		var b13 = b._13;
		var b21 = b._21;
		var b22 = b._22;
		var b23 = b._23;
		var b31 = b._31;
		var b32 = b._32;
		var b33 = b._33;
		var b41 = b._41;
		var b42 = b._42;
		var b43 = b._43;
		_this._11 = m11 * b11 + m12 * b21 + m13 * b31;
		_this._12 = m11 * b12 + m12 * b22 + m13 * b32;
		_this._13 = m11 * b13 + m12 * b23 + m13 * b33;
		_this._14 = 0;
		_this._21 = m21 * b11 + m22 * b21 + m23 * b31;
		_this._22 = m21 * b12 + m22 * b22 + m23 * b32;
		_this._23 = m21 * b13 + m22 * b23 + m23 * b33;
		_this._24 = 0;
		_this._31 = a31 * b11 + a32 * b21 + a33 * b31;
		_this._32 = a31 * b12 + a32 * b22 + a33 * b32;
		_this._33 = a31 * b13 + a32 * b23 + a33 * b33;
		_this._34 = 0;
		_this._41 = a41 * b11 + a42 * b21 + a43 * b31 + b41;
		_this._42 = a41 * b12 + a42 * b22 + a43 * b32 + b42;
		_this._43 = a41 * b13 + a42 * b23 + a43 * b33 + b43;
		_this._44 = 1;
		return this.collider.inFrustum(f,mat);
	}
	,inSphere: function(s) {
		var invMat = this.obj.getInvPos();
		var oldX = s.x;
		var oldY = s.y;
		var oldZ = s.z;
		var oldR = s.r;
		var x = s.x;
		var y = s.y;
		var z = s.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var center_x = x1;
		var center_y = y1;
		var center_z = z1;
		var px = center_x * invMat._11 + center_y * invMat._21 + center_z * invMat._31 + invMat._41;
		var py = center_x * invMat._12 + center_y * invMat._22 + center_z * invMat._32 + invMat._42;
		var pz = center_x * invMat._13 + center_y * invMat._23 + center_z * invMat._33 + invMat._43;
		center_x = px;
		center_y = py;
		center_z = pz;
		var _this = invMat;
		var x = 0.;
		var y = 0.;
		var z = 0.;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var scale_x = x;
		var scale_y = y;
		var scale_z = z;
		scale_x = Math.sqrt(_this._11 * _this._11 + _this._12 * _this._12 + _this._13 * _this._13);
		scale_y = Math.sqrt(_this._21 * _this._21 + _this._22 * _this._22 + _this._23 * _this._23);
		scale_z = Math.sqrt(_this._31 * _this._31 + _this._32 * _this._32 + _this._33 * _this._33);
		if(_this._11 * (_this._22 * _this._33 - _this._23 * _this._32) + _this._12 * (_this._23 * _this._31 - _this._21 * _this._33) + _this._13 * (_this._21 * _this._32 - _this._22 * _this._31) < 0) {
			scale_x *= -1;
			scale_y *= -1;
			scale_z *= -1;
		}
		s.x = center_x;
		s.y = center_y;
		s.z = center_z;
		s.r *= Math.max(Math.max(scale_x,scale_y),scale_z);
		var res = this.collider.inSphere(s);
		s.x = oldX;
		s.y = oldY;
		s.z = oldZ;
		s.r = oldR;
		return res;
	}
	,dimension: function() {
		var _this = this.obj.getAbsPos();
		var x = 0.;
		var y = 0.;
		var z = 0.;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var scale_x = x;
		var scale_y = y;
		var scale_z = z;
		scale_x = Math.sqrt(_this._11 * _this._11 + _this._12 * _this._12 + _this._13 * _this._13);
		scale_y = Math.sqrt(_this._21 * _this._21 + _this._22 * _this._22 + _this._23 * _this._23);
		scale_z = Math.sqrt(_this._31 * _this._31 + _this._32 * _this._32 + _this._33 * _this._33);
		if(_this._11 * (_this._22 * _this._33 - _this._23 * _this._32) + _this._12 * (_this._23 * _this._31 - _this._21 * _this._33) + _this._13 * (_this._21 * _this._32 - _this._22 * _this._31) < 0) {
			scale_x *= -1;
			scale_y *= -1;
			scale_z *= -1;
		}
		return this.collider.dimension() * Math.max(Math.max(scale_x,scale_y),scale_z);
	}
	,closestPoint: function(p) {
		throw haxe_Exception.thrown("Not implemented");
	}
	,makeDebugObj: function() {
		var ret = this.collider.makeDebugObj();
		if(ret != null) {
			ret.set_follow(this.obj);
		}
		return ret;
	}
	,__class__: h3d_col_ObjectCollider
});
var h3d_col_OrientedBounds = function() {
	this.hz = 0.5;
	this.hy = 0.5;
	this.hx = 0.5;
	this.zz = 1.0;
	this.zy = 0.0;
	this.zx = 0.0;
	this.yz = 0.0;
	this.yy = 1.0;
	this.yx = 0.0;
	this.xz = 0.0;
	this.xy = 0.0;
	this.xx = 1.0;
	this.centerZ = 0.0;
	this.centerY = 0.0;
	this.centerX = 0.0;
};
$hxClasses["h3d.col.OrientedBounds"] = h3d_col_OrientedBounds;
h3d_col_OrientedBounds.__name__ = "h3d.col.OrientedBounds";
h3d_col_OrientedBounds.__super__ = h3d_col_Collider;
h3d_col_OrientedBounds.prototype = $extend(h3d_col_Collider.prototype,{
	setMatrix: function(m) {
		var _this = m;
		var x = 0.;
		var y = 0.;
		var z = 0.;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var s_x = x;
		var s_y = y;
		var s_z = z;
		s_x = Math.sqrt(_this._11 * _this._11 + _this._12 * _this._12 + _this._13 * _this._13);
		s_y = Math.sqrt(_this._21 * _this._21 + _this._22 * _this._22 + _this._23 * _this._23);
		s_z = Math.sqrt(_this._31 * _this._31 + _this._32 * _this._32 + _this._33 * _this._33);
		if(_this._11 * (_this._22 * _this._33 - _this._23 * _this._32) + _this._12 * (_this._23 * _this._31 - _this._21 * _this._33) + _this._13 * (_this._21 * _this._32 - _this._22 * _this._31) < 0) {
			s_x *= -1;
			s_y *= -1;
			s_z *= -1;
		}
		var isx = 1.0 / s_x;
		var isy = 1.0 / s_y;
		var isz = 1.0 / s_z;
		this.centerX = m._41;
		this.centerY = m._42;
		this.centerZ = m._43;
		this.hx = s_x / 2.0;
		this.hy = s_y / 2.0;
		this.hz = s_z / 2.0;
		this.xx = m._11 * isx;
		this.xy = m._12 * isx;
		this.xz = m._13 * isx;
		this.yx = m._21 * isy;
		this.yy = m._22 * isy;
		this.yz = m._23 * isy;
		this.zx = m._31 * isz;
		this.zy = m._32 * isz;
		this.zz = m._33 * isz;
	}
	,setEulerAngles: function(x,y,z) {
		var cx = Math.cos(x);
		var sx = Math.sin(x);
		var cy = Math.cos(y);
		var sy = Math.sin(y);
		var cz = Math.cos(z);
		var sz = Math.sin(z);
		this.xx = cy * cz;
		this.xy = sx * sy * cz + cx * sz;
		this.xz = -cx * sy * cz + sx * sz;
		this.yx = -cy * sz;
		this.yy = -sx * sy * sz + cx * cz;
		this.yz = cx * sy * sz + sx * cz;
		this.zx = sy;
		this.zy = -sx * cy;
		this.zz = cx * cy;
	}
	,collideOrientedBounds: function(other) {
		var x = this.xx;
		var y = this.xy;
		var z = this.xz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var x = this.yx;
		var y = this.yy;
		var z = this.yz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x1 = x1;
		var _this_y1 = y1;
		var _this_z1 = z1;
		var x = this.zx;
		var y = this.zy;
		var z = this.zz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x2 = x1;
		var _this_y2 = y1;
		var _this_z2 = z1;
		var x = other.xx;
		var y = other.xy;
		var z = other.xz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var bx_x = x1;
		var bx_y = y1;
		var bx_z = z1;
		var x = other.yx;
		var y = other.yy;
		var z = other.yz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var by_x = x1;
		var by_y = y1;
		var by_z = z1;
		var x = other.zx;
		var y = other.zy;
		var z = other.zz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var bz_x = x1;
		var bz_y = y1;
		var bz_z = z1;
		var R00 = _this_x * bx_x + _this_y * bx_y + _this_z * bx_z;
		var R01 = _this_x * by_x + _this_y * by_y + _this_z * by_z;
		var R02 = _this_x * bz_x + _this_y * bz_y + _this_z * bz_z;
		var R10 = _this_x1 * bx_x + _this_y1 * bx_y + _this_z1 * bx_z;
		var R11 = _this_x1 * by_x + _this_y1 * by_y + _this_z1 * by_z;
		var R12 = _this_x1 * bz_x + _this_y1 * bz_y + _this_z1 * bz_z;
		var R20 = _this_x2 * bx_x + _this_y2 * bx_y + _this_z2 * bx_z;
		var R21 = _this_x2 * by_x + _this_y2 * by_y + _this_z2 * by_z;
		var R22 = _this_x2 * bz_x + _this_y2 * bz_y + _this_z2 * bz_z;
		var x = this.centerX;
		var y = this.centerY;
		var z = this.centerZ;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ac_x = x1;
		var ac_y = y1;
		var ac_z = z1;
		var x = other.centerX;
		var y = other.centerY;
		var z = other.centerZ;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var bc_x = x1;
		var bc_y = y1;
		var bc_z = z1;
		var x = bc_x - ac_x;
		var y = bc_y - ac_y;
		var z = bc_z - ac_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x3 = x1;
		var _this_y3 = y1;
		var _this_z3 = z1;
		var tx = _this_x3 * _this_x + _this_y3 * _this_y + _this_z3 * _this_z;
		var ty = _this_x3 * _this_x1 + _this_y3 * _this_y1 + _this_z3 * _this_z1;
		var tz = _this_x3 * _this_x2 + _this_y3 * _this_y2 + _this_z3 * _this_z2;
		_this_x3 = tx;
		_this_y3 = ty;
		_this_z3 = tz;
		var absR00 = (R00 < 0 ? -R00 : R00) + 1e-10;
		var absR01 = (R01 < 0 ? -R01 : R01) + 1e-10;
		var absR02 = (R02 < 0 ? -R02 : R02) + 1e-10;
		var absR10 = (R10 < 0 ? -R10 : R10) + 1e-10;
		var absR11 = (R11 < 0 ? -R11 : R11) + 1e-10;
		var absR12 = (R12 < 0 ? -R12 : R12) + 1e-10;
		var absR20 = (R20 < 0 ? -R20 : R20) + 1e-10;
		var absR21 = (R21 < 0 ? -R21 : R21) + 1e-10;
		var absR22 = (R22 < 0 ? -R22 : R22) + 1e-10;
		var ra = this.hx;
		var rb = other.hx * absR00 + other.hy * absR01 + other.hz * absR02;
		var f = _this_x3;
		if((f < 0 ? -f : f) > ra + rb) {
			return false;
		}
		var ra = this.hy;
		var rb = other.hx * absR10 + other.hy * absR11 + other.hz * absR12;
		var f = _this_y3;
		if((f < 0 ? -f : f) > ra + rb) {
			return false;
		}
		var ra = this.hz;
		var rb = other.hx * absR20 + other.hy * absR21 + other.hz * absR22;
		var f = _this_z3;
		if((f < 0 ? -f : f) > ra + rb) {
			return false;
		}
		var ra = this.hx * absR00 + this.hy * absR10 + this.hz * absR20;
		var rb = other.hx;
		var f = _this_x3 * R00 + _this_y3 * R10 + _this_z3 * R20;
		if((f < 0 ? -f : f) > ra + rb) {
			return false;
		}
		var ra = this.hx * absR01 + this.hy * absR11 + this.hz * absR21;
		var rb = other.hy;
		var f = _this_x3 * R01 + _this_y3 * R11 + _this_z3 * R21;
		if((f < 0 ? -f : f) > ra + rb) {
			return false;
		}
		var ra = this.hx * absR02 + this.hy * absR12 + this.hz * absR22;
		var rb = other.hz;
		var f = _this_x3 * R02 + _this_y3 * R12 + _this_z3 * R22;
		if((f < 0 ? -f : f) > ra + rb) {
			return false;
		}
		var ra = this.hy * absR20 + this.hz * absR10;
		var rb = other.hy * absR02 + other.hz * absR01;
		var f = _this_z3 * R10 - _this_y3 * R20;
		if((f < 0 ? -f : f) > ra + rb) {
			return false;
		}
		var ra = this.hy * absR21 + this.hz * absR11;
		var rb = other.hx * absR02 + other.hz * absR00;
		var f = _this_z3 * R11 - _this_y3 * R21;
		if((f < 0 ? -f : f) > ra + rb) {
			return false;
		}
		var ra = this.hy * absR22 + this.hz * absR12;
		var rb = other.hx * absR01 + other.hy * absR00;
		var f = _this_z3 * R12 - _this_y3 * R22;
		if((f < 0 ? -f : f) > ra + rb) {
			return false;
		}
		var ra = this.hx * absR20 + this.hz * absR00;
		var rb = other.hy * absR12 + other.hz * absR11;
		var f = _this_x3 * R20 - _this_z3 * R00;
		if((f < 0 ? -f : f) > ra + rb) {
			return false;
		}
		var ra = this.hx * absR21 + this.hz * absR01;
		var rb = other.hx * absR12 + other.hz * absR10;
		var f = _this_x3 * R21 - _this_z3 * R01;
		if((f < 0 ? -f : f) > ra + rb) {
			return false;
		}
		var ra = this.hx * absR22 + this.hz * absR02;
		var rb = other.hx * absR11 + other.hy * absR10;
		var f = _this_x3 * R22 - _this_z3 * R02;
		if((f < 0 ? -f : f) > ra + rb) {
			return false;
		}
		var ra = this.hx * absR10 + this.hy * absR00;
		var rb = other.hy * absR22 + other.hz * absR21;
		var f = _this_y3 * R00 - _this_x3 * R10;
		if((f < 0 ? -f : f) > ra + rb) {
			return false;
		}
		var ra = this.hx * absR11 + this.hy * absR01;
		var rb = other.hx * absR22 + other.hz * absR20;
		var f = _this_y3 * R01 - _this_x3 * R11;
		if((f < 0 ? -f : f) > ra + rb) {
			return false;
		}
		var ra = this.hx * absR12 + this.hy * absR02;
		var rb = other.hx * absR21 + other.hy * absR20;
		var f = _this_y3 * R02 - _this_x3 * R12;
		if((f < 0 ? -f : f) > ra + rb) {
			return false;
		}
		return true;
	}
	,rayIntersection: function(r,bestMatch) {
		var dx = r.px - this.centerX;
		var dy = r.py - this.centerY;
		var dz = r.pz - this.centerZ;
		var rpx = dx * this.xx + dy * this.xy + dz * this.xz;
		var rpy = dx * this.yx + dy * this.yy + dz * this.yz;
		var rpz = dx * this.zx + dy * this.zy + dz * this.zz;
		var rlx = r.lx * this.xx + r.ly * this.xy + r.lz * this.xz;
		var rly = r.lx * this.yx + r.ly * this.yy + r.lz * this.yz;
		var rlz = r.lx * this.zx + r.ly * this.zy + r.lz * this.zz;
		var tmin = 0.0;
		var tmax = Infinity;
		if((rlx < 0 ? -rlx : rlx) < 1e-10) {
			if(rpx < -this.hx || rpx > this.hx) {
				return -1.0;
			}
		} else {
			var ood = 1.0 / rlx;
			var t1 = (-this.hx - rpx) * ood;
			var t2 = (this.hx - rpx) * ood;
			if(t1 > t2) {
				var tmp = t2;
				t2 = t1;
				t1 = tmp;
			}
			if(t1 > tmin) {
				tmin = t1;
			}
			if(t2 < tmax) {
				tmax = t2;
			}
			if(tmin > tmax) {
				return -1.0;
			}
		}
		if((rly < 0 ? -rly : rly) < 1e-10) {
			if(rpy < -this.hy || rpy > this.hy) {
				return -1.0;
			}
		} else {
			var ood = 1.0 / rly;
			var t1 = (-this.hy - rpy) * ood;
			var t2 = (this.hy - rpy) * ood;
			if(t1 > t2) {
				var tmp = t2;
				t2 = t1;
				t1 = tmp;
			}
			if(t1 > tmin) {
				tmin = t1;
			}
			if(t2 < tmax) {
				tmax = t2;
			}
			if(tmin > tmax) {
				return -1.0;
			}
		}
		if((rlz < 0 ? -rlz : rlz) < 1e-10) {
			if(rpz < -this.hz || rpz > this.hz) {
				return -1.0;
			}
		} else {
			var ood = 1.0 / rlz;
			var t1 = (-this.hz - rpz) * ood;
			var t2 = (this.hz - rpz) * ood;
			if(t1 > t2) {
				var tmp = t2;
				t2 = t1;
				t1 = tmp;
			}
			if(t1 > tmin) {
				tmin = t1;
			}
			if(t2 < tmax) {
				tmax = t2;
			}
			if(tmin > tmax) {
				return -1.0;
			}
		}
		return tmin;
	}
	,contains: function(p) {
		var dx = p.x - this.centerX;
		var dy = p.y - this.centerY;
		var dz = p.z - this.centerZ;
		var rpx = dx * this.xx + dy * this.xy + dz * this.xz;
		var rpy = dx * this.yx + dy * this.yy + dz * this.yz;
		var rpz = dx * this.zx + dy * this.zy + dz * this.zz;
		var tmp;
		var f = this.hx;
		if((f < 0 ? -f : f) - (rpx < 0 ? -rpx : rpx) > -1e-010) {
			var f = this.hy;
			tmp = (f < 0 ? -f : f) - (rpy < 0 ? -rpy : rpy) > -1e-010;
		} else {
			tmp = false;
		}
		if(tmp) {
			var f = this.hz;
			return (f < 0 ? -f : f) - (rpz < 0 ? -rpz : rpz) > -1e-010;
		} else {
			return false;
		}
	}
	,inFrustum: function(f,m) {
		if(m != null) {
			throw haxe_Exception.thrown("Not implemented");
		}
		return f.hasOrientedBounds(this);
	}
	,inSphere: function(s) {
		var x = s.x;
		var y = s.y;
		var z = s.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var sp_x = x1;
		var sp_y = y1;
		var sp_z = z1;
		var rr = s.r * s.r;
		var sx = -1;
		var sy = -1;
		var sz = -1;
		var x = this.xx;
		var y = this.xy;
		var z = this.xz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ax_x = x1;
		var ax_y = y1;
		var ax_z = z1;
		var x = this.yx;
		var y = this.yy;
		var z = this.yz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ay_x = x1;
		var ay_y = y1;
		var ay_z = z1;
		var x = this.zx;
		var y = this.zy;
		var z = this.zz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var az_x = x1;
		var az_y = y1;
		var az_z = z1;
		var x = this.centerX;
		var y = this.centerY;
		var z = this.centerZ;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var c_x = x1;
		var c_y = y1;
		var c_z = z1;
		var v = sx * this.hx;
		ax_x *= v;
		ax_y *= v;
		ax_z *= v;
		var v = sy * this.hy;
		ay_x *= v;
		ay_y *= v;
		ay_z *= v;
		var v = sz * this.hz;
		az_x *= v;
		az_y *= v;
		az_z *= v;
		var x = c_x + ax_x;
		var y = c_y + ax_y;
		var z = c_z + ax_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var this_x = x1;
		var this_y = y1;
		var this_z = z1;
		var x = this_x + ay_x;
		var y = this_y + ay_y;
		var z = this_z + ay_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var this_x = x1;
		var this_y = y1;
		var this_z = z1;
		var x = this_x + az_x;
		var y = this_y + az_y;
		var z = this_z + az_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var dx = sp_x - _this_x;
		var dy = sp_y - _this_y;
		var dz = sp_z - _this_z;
		if(dx * dx + dy * dy + dz * dz > rr) {
			return false;
		}
		var sx = 1;
		var sy = -1;
		var sz = -1;
		var x = this.xx;
		var y = this.xy;
		var z = this.xz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ax_x = x1;
		var ax_y = y1;
		var ax_z = z1;
		var x = this.yx;
		var y = this.yy;
		var z = this.yz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ay_x = x1;
		var ay_y = y1;
		var ay_z = z1;
		var x = this.zx;
		var y = this.zy;
		var z = this.zz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var az_x = x1;
		var az_y = y1;
		var az_z = z1;
		var x = this.centerX;
		var y = this.centerY;
		var z = this.centerZ;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var c_x = x1;
		var c_y = y1;
		var c_z = z1;
		var v = sx * this.hx;
		ax_x *= v;
		ax_y *= v;
		ax_z *= v;
		var v = sy * this.hy;
		ay_x *= v;
		ay_y *= v;
		ay_z *= v;
		var v = sz * this.hz;
		az_x *= v;
		az_y *= v;
		az_z *= v;
		var x = c_x + ax_x;
		var y = c_y + ax_y;
		var z = c_z + ax_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var this_x = x1;
		var this_y = y1;
		var this_z = z1;
		var x = this_x + ay_x;
		var y = this_y + ay_y;
		var z = this_z + ay_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var this_x = x1;
		var this_y = y1;
		var this_z = z1;
		var x = this_x + az_x;
		var y = this_y + az_y;
		var z = this_z + az_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var dx = sp_x - _this_x;
		var dy = sp_y - _this_y;
		var dz = sp_z - _this_z;
		if(dx * dx + dy * dy + dz * dz > rr) {
			return false;
		}
		var sx = -1;
		var sy = 1;
		var sz = -1;
		var x = this.xx;
		var y = this.xy;
		var z = this.xz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ax_x = x1;
		var ax_y = y1;
		var ax_z = z1;
		var x = this.yx;
		var y = this.yy;
		var z = this.yz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ay_x = x1;
		var ay_y = y1;
		var ay_z = z1;
		var x = this.zx;
		var y = this.zy;
		var z = this.zz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var az_x = x1;
		var az_y = y1;
		var az_z = z1;
		var x = this.centerX;
		var y = this.centerY;
		var z = this.centerZ;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var c_x = x1;
		var c_y = y1;
		var c_z = z1;
		var v = sx * this.hx;
		ax_x *= v;
		ax_y *= v;
		ax_z *= v;
		var v = sy * this.hy;
		ay_x *= v;
		ay_y *= v;
		ay_z *= v;
		var v = sz * this.hz;
		az_x *= v;
		az_y *= v;
		az_z *= v;
		var x = c_x + ax_x;
		var y = c_y + ax_y;
		var z = c_z + ax_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var this_x = x1;
		var this_y = y1;
		var this_z = z1;
		var x = this_x + ay_x;
		var y = this_y + ay_y;
		var z = this_z + ay_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var this_x = x1;
		var this_y = y1;
		var this_z = z1;
		var x = this_x + az_x;
		var y = this_y + az_y;
		var z = this_z + az_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var dx = sp_x - _this_x;
		var dy = sp_y - _this_y;
		var dz = sp_z - _this_z;
		if(dx * dx + dy * dy + dz * dz > rr) {
			return false;
		}
		var sx = 1;
		var sy = 1;
		var sz = -1;
		var x = this.xx;
		var y = this.xy;
		var z = this.xz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ax_x = x1;
		var ax_y = y1;
		var ax_z = z1;
		var x = this.yx;
		var y = this.yy;
		var z = this.yz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ay_x = x1;
		var ay_y = y1;
		var ay_z = z1;
		var x = this.zx;
		var y = this.zy;
		var z = this.zz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var az_x = x1;
		var az_y = y1;
		var az_z = z1;
		var x = this.centerX;
		var y = this.centerY;
		var z = this.centerZ;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var c_x = x1;
		var c_y = y1;
		var c_z = z1;
		var v = sx * this.hx;
		ax_x *= v;
		ax_y *= v;
		ax_z *= v;
		var v = sy * this.hy;
		ay_x *= v;
		ay_y *= v;
		ay_z *= v;
		var v = sz * this.hz;
		az_x *= v;
		az_y *= v;
		az_z *= v;
		var x = c_x + ax_x;
		var y = c_y + ax_y;
		var z = c_z + ax_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var this_x = x1;
		var this_y = y1;
		var this_z = z1;
		var x = this_x + ay_x;
		var y = this_y + ay_y;
		var z = this_z + ay_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var this_x = x1;
		var this_y = y1;
		var this_z = z1;
		var x = this_x + az_x;
		var y = this_y + az_y;
		var z = this_z + az_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var dx = sp_x - _this_x;
		var dy = sp_y - _this_y;
		var dz = sp_z - _this_z;
		if(dx * dx + dy * dy + dz * dz > rr) {
			return false;
		}
		var sx = -1;
		var sy = -1;
		var sz = 1;
		var x = this.xx;
		var y = this.xy;
		var z = this.xz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ax_x = x1;
		var ax_y = y1;
		var ax_z = z1;
		var x = this.yx;
		var y = this.yy;
		var z = this.yz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ay_x = x1;
		var ay_y = y1;
		var ay_z = z1;
		var x = this.zx;
		var y = this.zy;
		var z = this.zz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var az_x = x1;
		var az_y = y1;
		var az_z = z1;
		var x = this.centerX;
		var y = this.centerY;
		var z = this.centerZ;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var c_x = x1;
		var c_y = y1;
		var c_z = z1;
		var v = sx * this.hx;
		ax_x *= v;
		ax_y *= v;
		ax_z *= v;
		var v = sy * this.hy;
		ay_x *= v;
		ay_y *= v;
		ay_z *= v;
		var v = sz * this.hz;
		az_x *= v;
		az_y *= v;
		az_z *= v;
		var x = c_x + ax_x;
		var y = c_y + ax_y;
		var z = c_z + ax_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var this_x = x1;
		var this_y = y1;
		var this_z = z1;
		var x = this_x + ay_x;
		var y = this_y + ay_y;
		var z = this_z + ay_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var this_x = x1;
		var this_y = y1;
		var this_z = z1;
		var x = this_x + az_x;
		var y = this_y + az_y;
		var z = this_z + az_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var dx = sp_x - _this_x;
		var dy = sp_y - _this_y;
		var dz = sp_z - _this_z;
		if(dx * dx + dy * dy + dz * dz > rr) {
			return false;
		}
		var sx = 1;
		var sy = -1;
		var sz = 1;
		var x = this.xx;
		var y = this.xy;
		var z = this.xz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ax_x = x1;
		var ax_y = y1;
		var ax_z = z1;
		var x = this.yx;
		var y = this.yy;
		var z = this.yz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ay_x = x1;
		var ay_y = y1;
		var ay_z = z1;
		var x = this.zx;
		var y = this.zy;
		var z = this.zz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var az_x = x1;
		var az_y = y1;
		var az_z = z1;
		var x = this.centerX;
		var y = this.centerY;
		var z = this.centerZ;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var c_x = x1;
		var c_y = y1;
		var c_z = z1;
		var v = sx * this.hx;
		ax_x *= v;
		ax_y *= v;
		ax_z *= v;
		var v = sy * this.hy;
		ay_x *= v;
		ay_y *= v;
		ay_z *= v;
		var v = sz * this.hz;
		az_x *= v;
		az_y *= v;
		az_z *= v;
		var x = c_x + ax_x;
		var y = c_y + ax_y;
		var z = c_z + ax_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var this_x = x1;
		var this_y = y1;
		var this_z = z1;
		var x = this_x + ay_x;
		var y = this_y + ay_y;
		var z = this_z + ay_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var this_x = x1;
		var this_y = y1;
		var this_z = z1;
		var x = this_x + az_x;
		var y = this_y + az_y;
		var z = this_z + az_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var dx = sp_x - _this_x;
		var dy = sp_y - _this_y;
		var dz = sp_z - _this_z;
		if(dx * dx + dy * dy + dz * dz > rr) {
			return false;
		}
		var sx = -1;
		var sy = 1;
		var sz = 1;
		var x = this.xx;
		var y = this.xy;
		var z = this.xz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ax_x = x1;
		var ax_y = y1;
		var ax_z = z1;
		var x = this.yx;
		var y = this.yy;
		var z = this.yz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ay_x = x1;
		var ay_y = y1;
		var ay_z = z1;
		var x = this.zx;
		var y = this.zy;
		var z = this.zz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var az_x = x1;
		var az_y = y1;
		var az_z = z1;
		var x = this.centerX;
		var y = this.centerY;
		var z = this.centerZ;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var c_x = x1;
		var c_y = y1;
		var c_z = z1;
		var v = sx * this.hx;
		ax_x *= v;
		ax_y *= v;
		ax_z *= v;
		var v = sy * this.hy;
		ay_x *= v;
		ay_y *= v;
		ay_z *= v;
		var v = sz * this.hz;
		az_x *= v;
		az_y *= v;
		az_z *= v;
		var x = c_x + ax_x;
		var y = c_y + ax_y;
		var z = c_z + ax_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var this_x = x1;
		var this_y = y1;
		var this_z = z1;
		var x = this_x + ay_x;
		var y = this_y + ay_y;
		var z = this_z + ay_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var this_x = x1;
		var this_y = y1;
		var this_z = z1;
		var x = this_x + az_x;
		var y = this_y + az_y;
		var z = this_z + az_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var dx = sp_x - _this_x;
		var dy = sp_y - _this_y;
		var dz = sp_z - _this_z;
		if(dx * dx + dy * dy + dz * dz > rr) {
			return false;
		}
		var sx = 1;
		var sy = 1;
		var sz = 1;
		var x = this.xx;
		var y = this.xy;
		var z = this.xz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ax_x = x1;
		var ax_y = y1;
		var ax_z = z1;
		var x = this.yx;
		var y = this.yy;
		var z = this.yz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ay_x = x1;
		var ay_y = y1;
		var ay_z = z1;
		var x = this.zx;
		var y = this.zy;
		var z = this.zz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var az_x = x1;
		var az_y = y1;
		var az_z = z1;
		var x = this.centerX;
		var y = this.centerY;
		var z = this.centerZ;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var c_x = x1;
		var c_y = y1;
		var c_z = z1;
		var v = sx * this.hx;
		ax_x *= v;
		ax_y *= v;
		ax_z *= v;
		var v = sy * this.hy;
		ay_x *= v;
		ay_y *= v;
		ay_z *= v;
		var v = sz * this.hz;
		az_x *= v;
		az_y *= v;
		az_z *= v;
		var x = c_x + ax_x;
		var y = c_y + ax_y;
		var z = c_z + ax_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var this_x = x1;
		var this_y = y1;
		var this_z = z1;
		var x = this_x + ay_x;
		var y = this_y + ay_y;
		var z = this_z + ay_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var this_x = x1;
		var this_y = y1;
		var this_z = z1;
		var x = this_x + az_x;
		var y = this_y + az_y;
		var z = this_z + az_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var dx = sp_x - _this_x;
		var dy = sp_y - _this_y;
		var dz = sp_z - _this_z;
		if(dx * dx + dy * dy + dz * dz > rr) {
			return false;
		}
		return true;
	}
	,dimension: function() {
		var a = this.hx;
		var a1 = this.hy;
		var b = this.hz;
		var b1 = a1 < b ? b : a1;
		return 2.0 * (a < b1 ? b1 : a);
	}
	,getVertice: function(i) {
		var sx = (i & 1) * 2 - 1;
		var sy = (i >> 1 & 1) * 2 - 1;
		var sz = (i >> 2 & 1) * 2 - 1;
		var x = this.xx;
		var y = this.xy;
		var z = this.xz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ax_x = x1;
		var ax_y = y1;
		var ax_z = z1;
		var x = this.yx;
		var y = this.yy;
		var z = this.yz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ay_x = x1;
		var ay_y = y1;
		var ay_z = z1;
		var x = this.zx;
		var y = this.zy;
		var z = this.zz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var az_x = x1;
		var az_y = y1;
		var az_z = z1;
		var x = this.centerX;
		var y = this.centerY;
		var z = this.centerZ;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var c_x = x1;
		var c_y = y1;
		var c_z = z1;
		var v = sx * this.hx;
		ax_x *= v;
		ax_y *= v;
		ax_z *= v;
		var v = sy * this.hy;
		ay_x *= v;
		ay_y *= v;
		ay_z *= v;
		var v = sz * this.hz;
		az_x *= v;
		az_y *= v;
		az_z *= v;
		var x = c_x + ax_x;
		var y = c_y + ax_y;
		var z = c_z + ax_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var this_x = x1;
		var this_y = y1;
		var this_z = z1;
		var x = this_x + ay_x;
		var y = this_y + ay_y;
		var z = this_z + ay_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var this_x = x1;
		var this_y = y1;
		var this_z = z1;
		var x = this_x + az_x;
		var y = this_y + az_y;
		var z = this_z + az_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,getVertices: function(out) {
		var tmp = out;
		out = tmp != null ? tmp : [];
		var sx = -1;
		var sy = -1;
		var sz = -1;
		var x = this.xx;
		var y = this.xy;
		var z = this.xz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ax_x = x1;
		var ax_y = y1;
		var ax_z = z1;
		var x = this.yx;
		var y = this.yy;
		var z = this.yz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ay_x = x1;
		var ay_y = y1;
		var ay_z = z1;
		var x = this.zx;
		var y = this.zy;
		var z = this.zz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var az_x = x1;
		var az_y = y1;
		var az_z = z1;
		var x = this.centerX;
		var y = this.centerY;
		var z = this.centerZ;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var c_x = x1;
		var c_y = y1;
		var c_z = z1;
		var v = sx * this.hx;
		ax_x *= v;
		ax_y *= v;
		ax_z *= v;
		var v = sy * this.hy;
		ay_x *= v;
		ay_y *= v;
		ay_z *= v;
		var v = sz * this.hz;
		az_x *= v;
		az_y *= v;
		az_z *= v;
		var x = c_x + ax_x;
		var y = c_y + ax_y;
		var z = c_z + ax_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var this_x = x1;
		var this_y = y1;
		var this_z = z1;
		var x = this_x + ay_x;
		var y = this_y + ay_y;
		var z = this_z + ay_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var this_x = x1;
		var this_y = y1;
		var this_z = z1;
		var x = this_x + az_x;
		var y = this_y + az_y;
		var z = this_z + az_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		out.push(new h3d_VectorImpl(x,y,z));
		var sx = 1;
		var sy = -1;
		var sz = -1;
		var x = this.xx;
		var y = this.xy;
		var z = this.xz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ax_x = x1;
		var ax_y = y1;
		var ax_z = z1;
		var x = this.yx;
		var y = this.yy;
		var z = this.yz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ay_x = x1;
		var ay_y = y1;
		var ay_z = z1;
		var x = this.zx;
		var y = this.zy;
		var z = this.zz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var az_x = x1;
		var az_y = y1;
		var az_z = z1;
		var x = this.centerX;
		var y = this.centerY;
		var z = this.centerZ;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var c_x = x1;
		var c_y = y1;
		var c_z = z1;
		var v = sx * this.hx;
		ax_x *= v;
		ax_y *= v;
		ax_z *= v;
		var v = sy * this.hy;
		ay_x *= v;
		ay_y *= v;
		ay_z *= v;
		var v = sz * this.hz;
		az_x *= v;
		az_y *= v;
		az_z *= v;
		var x = c_x + ax_x;
		var y = c_y + ax_y;
		var z = c_z + ax_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var this_x = x1;
		var this_y = y1;
		var this_z = z1;
		var x = this_x + ay_x;
		var y = this_y + ay_y;
		var z = this_z + ay_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var this_x = x1;
		var this_y = y1;
		var this_z = z1;
		var x = this_x + az_x;
		var y = this_y + az_y;
		var z = this_z + az_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		out.push(new h3d_VectorImpl(x,y,z));
		var sx = -1;
		var sy = 1;
		var sz = -1;
		var x = this.xx;
		var y = this.xy;
		var z = this.xz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ax_x = x1;
		var ax_y = y1;
		var ax_z = z1;
		var x = this.yx;
		var y = this.yy;
		var z = this.yz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ay_x = x1;
		var ay_y = y1;
		var ay_z = z1;
		var x = this.zx;
		var y = this.zy;
		var z = this.zz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var az_x = x1;
		var az_y = y1;
		var az_z = z1;
		var x = this.centerX;
		var y = this.centerY;
		var z = this.centerZ;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var c_x = x1;
		var c_y = y1;
		var c_z = z1;
		var v = sx * this.hx;
		ax_x *= v;
		ax_y *= v;
		ax_z *= v;
		var v = sy * this.hy;
		ay_x *= v;
		ay_y *= v;
		ay_z *= v;
		var v = sz * this.hz;
		az_x *= v;
		az_y *= v;
		az_z *= v;
		var x = c_x + ax_x;
		var y = c_y + ax_y;
		var z = c_z + ax_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var this_x = x1;
		var this_y = y1;
		var this_z = z1;
		var x = this_x + ay_x;
		var y = this_y + ay_y;
		var z = this_z + ay_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var this_x = x1;
		var this_y = y1;
		var this_z = z1;
		var x = this_x + az_x;
		var y = this_y + az_y;
		var z = this_z + az_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		out.push(new h3d_VectorImpl(x,y,z));
		var sx = 1;
		var sy = 1;
		var sz = -1;
		var x = this.xx;
		var y = this.xy;
		var z = this.xz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ax_x = x1;
		var ax_y = y1;
		var ax_z = z1;
		var x = this.yx;
		var y = this.yy;
		var z = this.yz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ay_x = x1;
		var ay_y = y1;
		var ay_z = z1;
		var x = this.zx;
		var y = this.zy;
		var z = this.zz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var az_x = x1;
		var az_y = y1;
		var az_z = z1;
		var x = this.centerX;
		var y = this.centerY;
		var z = this.centerZ;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var c_x = x1;
		var c_y = y1;
		var c_z = z1;
		var v = sx * this.hx;
		ax_x *= v;
		ax_y *= v;
		ax_z *= v;
		var v = sy * this.hy;
		ay_x *= v;
		ay_y *= v;
		ay_z *= v;
		var v = sz * this.hz;
		az_x *= v;
		az_y *= v;
		az_z *= v;
		var x = c_x + ax_x;
		var y = c_y + ax_y;
		var z = c_z + ax_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var this_x = x1;
		var this_y = y1;
		var this_z = z1;
		var x = this_x + ay_x;
		var y = this_y + ay_y;
		var z = this_z + ay_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var this_x = x1;
		var this_y = y1;
		var this_z = z1;
		var x = this_x + az_x;
		var y = this_y + az_y;
		var z = this_z + az_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		out.push(new h3d_VectorImpl(x,y,z));
		var sx = -1;
		var sy = -1;
		var sz = 1;
		var x = this.xx;
		var y = this.xy;
		var z = this.xz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ax_x = x1;
		var ax_y = y1;
		var ax_z = z1;
		var x = this.yx;
		var y = this.yy;
		var z = this.yz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ay_x = x1;
		var ay_y = y1;
		var ay_z = z1;
		var x = this.zx;
		var y = this.zy;
		var z = this.zz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var az_x = x1;
		var az_y = y1;
		var az_z = z1;
		var x = this.centerX;
		var y = this.centerY;
		var z = this.centerZ;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var c_x = x1;
		var c_y = y1;
		var c_z = z1;
		var v = sx * this.hx;
		ax_x *= v;
		ax_y *= v;
		ax_z *= v;
		var v = sy * this.hy;
		ay_x *= v;
		ay_y *= v;
		ay_z *= v;
		var v = sz * this.hz;
		az_x *= v;
		az_y *= v;
		az_z *= v;
		var x = c_x + ax_x;
		var y = c_y + ax_y;
		var z = c_z + ax_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var this_x = x1;
		var this_y = y1;
		var this_z = z1;
		var x = this_x + ay_x;
		var y = this_y + ay_y;
		var z = this_z + ay_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var this_x = x1;
		var this_y = y1;
		var this_z = z1;
		var x = this_x + az_x;
		var y = this_y + az_y;
		var z = this_z + az_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		out.push(new h3d_VectorImpl(x,y,z));
		var sx = 1;
		var sy = -1;
		var sz = 1;
		var x = this.xx;
		var y = this.xy;
		var z = this.xz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ax_x = x1;
		var ax_y = y1;
		var ax_z = z1;
		var x = this.yx;
		var y = this.yy;
		var z = this.yz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ay_x = x1;
		var ay_y = y1;
		var ay_z = z1;
		var x = this.zx;
		var y = this.zy;
		var z = this.zz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var az_x = x1;
		var az_y = y1;
		var az_z = z1;
		var x = this.centerX;
		var y = this.centerY;
		var z = this.centerZ;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var c_x = x1;
		var c_y = y1;
		var c_z = z1;
		var v = sx * this.hx;
		ax_x *= v;
		ax_y *= v;
		ax_z *= v;
		var v = sy * this.hy;
		ay_x *= v;
		ay_y *= v;
		ay_z *= v;
		var v = sz * this.hz;
		az_x *= v;
		az_y *= v;
		az_z *= v;
		var x = c_x + ax_x;
		var y = c_y + ax_y;
		var z = c_z + ax_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var this_x = x1;
		var this_y = y1;
		var this_z = z1;
		var x = this_x + ay_x;
		var y = this_y + ay_y;
		var z = this_z + ay_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var this_x = x1;
		var this_y = y1;
		var this_z = z1;
		var x = this_x + az_x;
		var y = this_y + az_y;
		var z = this_z + az_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		out.push(new h3d_VectorImpl(x,y,z));
		var sx = -1;
		var sy = 1;
		var sz = 1;
		var x = this.xx;
		var y = this.xy;
		var z = this.xz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ax_x = x1;
		var ax_y = y1;
		var ax_z = z1;
		var x = this.yx;
		var y = this.yy;
		var z = this.yz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ay_x = x1;
		var ay_y = y1;
		var ay_z = z1;
		var x = this.zx;
		var y = this.zy;
		var z = this.zz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var az_x = x1;
		var az_y = y1;
		var az_z = z1;
		var x = this.centerX;
		var y = this.centerY;
		var z = this.centerZ;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var c_x = x1;
		var c_y = y1;
		var c_z = z1;
		var v = sx * this.hx;
		ax_x *= v;
		ax_y *= v;
		ax_z *= v;
		var v = sy * this.hy;
		ay_x *= v;
		ay_y *= v;
		ay_z *= v;
		var v = sz * this.hz;
		az_x *= v;
		az_y *= v;
		az_z *= v;
		var x = c_x + ax_x;
		var y = c_y + ax_y;
		var z = c_z + ax_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var this_x = x1;
		var this_y = y1;
		var this_z = z1;
		var x = this_x + ay_x;
		var y = this_y + ay_y;
		var z = this_z + ay_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var this_x = x1;
		var this_y = y1;
		var this_z = z1;
		var x = this_x + az_x;
		var y = this_y + az_y;
		var z = this_z + az_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		out.push(new h3d_VectorImpl(x,y,z));
		var sx = 1;
		var sy = 1;
		var sz = 1;
		var x = this.xx;
		var y = this.xy;
		var z = this.xz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ax_x = x1;
		var ax_y = y1;
		var ax_z = z1;
		var x = this.yx;
		var y = this.yy;
		var z = this.yz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ay_x = x1;
		var ay_y = y1;
		var ay_z = z1;
		var x = this.zx;
		var y = this.zy;
		var z = this.zz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var az_x = x1;
		var az_y = y1;
		var az_z = z1;
		var x = this.centerX;
		var y = this.centerY;
		var z = this.centerZ;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var c_x = x1;
		var c_y = y1;
		var c_z = z1;
		var v = sx * this.hx;
		ax_x *= v;
		ax_y *= v;
		ax_z *= v;
		var v = sy * this.hy;
		ay_x *= v;
		ay_y *= v;
		ay_z *= v;
		var v = sz * this.hz;
		az_x *= v;
		az_y *= v;
		az_z *= v;
		var x = c_x + ax_x;
		var y = c_y + ax_y;
		var z = c_z + ax_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var this_x = x1;
		var this_y = y1;
		var this_z = z1;
		var x = this_x + ay_x;
		var y = this_y + ay_y;
		var z = this_z + ay_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var this_x = x1;
		var this_y = y1;
		var this_z = z1;
		var x = this_x + az_x;
		var y = this_y + az_y;
		var z = this_z + az_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		out.push(new h3d_VectorImpl(x,y,z));
		return out;
	}
	,closestPoint: function(p) {
		throw haxe_Exception.thrown("not implemented");
	}
	,testPlane: function(p) {
		var x = p.nx;
		var y = p.ny;
		var z = p.nz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var x = this.xx;
		var y = this.xy;
		var z = this.xz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ax_x = x1;
		var ax_y = y1;
		var ax_z = z1;
		var x = this.yx;
		var y = this.yy;
		var z = this.yz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ay_x = x1;
		var ay_y = y1;
		var ay_z = z1;
		var x = this.zx;
		var y = this.zy;
		var z = this.zz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var az_x = x1;
		var az_y = y1;
		var az_z = z1;
		var x = this.centerX;
		var y = this.centerY;
		var z = this.centerZ;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var c_x = x1;
		var c_y = y1;
		var c_z = z1;
		var f = _this_x * ax_x + _this_y * ax_y + _this_z * ax_z;
		var f1 = _this_x * ay_x + _this_y * ay_y + _this_z * ay_z;
		var f2 = _this_x * az_x + _this_y * az_y + _this_z * az_z;
		var r = this.hx * (f < 0 ? -f : f) + this.hy * (f1 < 0 ? -f1 : f1) + this.hz * (f2 < 0 ? -f2 : f2);
		var s = _this_x * c_x + _this_y * c_y + _this_z * c_z - p.d;
		return s + r;
	}
	,makeDebugObj: function() {
		var g = new h3d_scene_Graphics();
		var verts = this.getVertices();
		g.lineStyle(1.0,16777215,1.0);
		g.moveTo(verts[0].x,verts[0].y,verts[0].z);
		g.lineTo(verts[4].x,verts[4].y,verts[4].z);
		g.moveTo(verts[1].x,verts[1].y,verts[1].z);
		g.lineTo(verts[5].x,verts[5].y,verts[5].z);
		g.moveTo(verts[2].x,verts[2].y,verts[2].z);
		g.lineTo(verts[6].x,verts[6].y,verts[6].z);
		g.moveTo(verts[3].x,verts[3].y,verts[3].z);
		g.lineTo(verts[7].x,verts[7].y,verts[7].z);
		g.moveTo(verts[0].x,verts[0].y,verts[0].z);
		g.lineTo(verts[1].x,verts[1].y,verts[1].z);
		g.lineTo(verts[3].x,verts[3].y,verts[3].z);
		g.lineTo(verts[2].x,verts[2].y,verts[2].z);
		g.lineTo(verts[0].x,verts[0].y,verts[0].z);
		g.moveTo(verts[4].x,verts[4].y,verts[4].z);
		g.lineTo(verts[5].x,verts[5].y,verts[5].z);
		g.lineTo(verts[7].x,verts[7].y,verts[7].z);
		g.lineTo(verts[6].x,verts[6].y,verts[6].z);
		g.lineTo(verts[4].x,verts[4].y,verts[4].z);
		return g;
	}
	,__class__: h3d_col_OrientedBounds
});
var h3d_col_Plane = function(nx,ny,nz,d) {
	this.nx = nx;
	this.ny = ny;
	this.nz = nz;
	this.d = d;
};
$hxClasses["h3d.col.Plane"] = h3d_col_Plane;
h3d_col_Plane.__name__ = "h3d.col.Plane";
h3d_col_Plane.fromPoints = function(p0,p1,p2) {
	var x = p1.x - p0.x;
	var y = p1.y - p0.y;
	var z = p1.z - p0.z;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	var x1 = x;
	var y1 = y;
	var z1 = z;
	if(z1 == null) {
		z1 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	var _this_x = x1;
	var _this_y = y1;
	var _this_z = z1;
	var x = p2.x - p0.x;
	var y = p2.y - p0.y;
	var z = p2.z - p0.z;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	var x1 = x;
	var y1 = y;
	var z1 = z;
	if(z1 == null) {
		z1 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	var d2_x = x1;
	var d2_y = y1;
	var d2_z = z1;
	var x = _this_y * d2_z - _this_z * d2_y;
	var y = _this_z * d2_x - _this_x * d2_z;
	var z = _this_x * d2_y - _this_y * d2_x;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	var x1 = x;
	var y1 = y;
	var z1 = z;
	if(z1 == null) {
		z1 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	var _this_x = x1;
	var _this_y = y1;
	var _this_z = z1;
	return new h3d_col_Plane(_this_x,_this_y,_this_z,_this_x * p0.x + _this_y * p0.y + _this_z * p0.z);
};
h3d_col_Plane.fromNormalPoint = function(n,p) {
	var _this = n;
	return new h3d_col_Plane(n.x,n.y,n.z,_this.x * p.x + _this.y * p.y + _this.z * p.z);
};
h3d_col_Plane.X = function(v) {
	if(v == null) {
		v = 0.0;
	}
	return new h3d_col_Plane(1,0,0,v);
};
h3d_col_Plane.Y = function(v) {
	if(v == null) {
		v = 0.0;
	}
	return new h3d_col_Plane(0,1,0,v);
};
h3d_col_Plane.Z = function(v) {
	if(v == null) {
		v = 0.0;
	}
	return new h3d_col_Plane(0,0,1,v);
};
h3d_col_Plane.frustumLeft = function(mvp) {
	return new h3d_col_Plane(mvp._14 + mvp._11,mvp._24 + mvp._21,mvp._34 + mvp._31,-(mvp._44 + mvp._41));
};
h3d_col_Plane.frustumRight = function(mvp) {
	return new h3d_col_Plane(mvp._14 - mvp._11,mvp._24 - mvp._21,mvp._34 - mvp._31,mvp._41 - mvp._44);
};
h3d_col_Plane.frustumBottom = function(mvp) {
	return new h3d_col_Plane(mvp._14 + mvp._12,mvp._24 + mvp._22,mvp._34 + mvp._32,-(mvp._44 + mvp._42));
};
h3d_col_Plane.frustumTop = function(mvp) {
	return new h3d_col_Plane(mvp._14 - mvp._12,mvp._24 - mvp._22,mvp._34 - mvp._32,mvp._42 - mvp._44);
};
h3d_col_Plane.frustumNear = function(mvp) {
	return new h3d_col_Plane(mvp._13,mvp._23,mvp._33,-mvp._43);
};
h3d_col_Plane.frustumFar = function(mvp) {
	return new h3d_col_Plane(mvp._14 - mvp._13,mvp._24 - mvp._23,mvp._34 - mvp._33,mvp._43 - mvp._44);
};
h3d_col_Plane.prototype = {
	getNormal: function() {
		var x = this.nx;
		var y = this.ny;
		var z = this.nz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,getNormalDistance: function() {
		return this.d;
	}
	,load: function(p) {
		this.nx = p.nx;
		this.ny = p.ny;
		this.nz = p.nz;
		this.d = p.d;
	}
	,transform: function(m) {
		var m2 = new h3d_MatrixImpl();
		m2.initInverse(m);
		m2.transpose();
		var x = this.nx;
		var y = this.ny;
		var z = this.nz;
		var w = -this.d;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		var w1 = w;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var v_w = w1;
		var px = v_x * m2._11 + v_y * m2._21 + v_z * m2._31 + v_w * m2._41;
		var py = v_x * m2._12 + v_y * m2._22 + v_z * m2._32 + v_w * m2._42;
		var pz = v_x * m2._13 + v_y * m2._23 + v_z * m2._33 + v_w * m2._43;
		var pw = v_x * m2._14 + v_y * m2._24 + v_z * m2._34 + v_w * m2._44;
		v_x = px;
		v_y = py;
		v_z = pz;
		v_w = pw;
		this.nx = v_x;
		this.ny = v_y;
		this.nz = v_z;
		this.d = -v_w;
	}
	,transform3x3: function(m) {
		var m2 = new h3d_MatrixImpl();
		m2.initInverse3x3(m);
		m2.transpose();
		var x = this.nx;
		var y = this.ny;
		var z = this.nz;
		var w = -this.d;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		var w1 = w;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var v_w = w1;
		var px = v_x * m2._11 + v_y * m2._21 + v_z * m2._31 + v_w * m2._41;
		var py = v_x * m2._12 + v_y * m2._22 + v_z * m2._32 + v_w * m2._42;
		var pz = v_x * m2._13 + v_y * m2._23 + v_z * m2._33 + v_w * m2._43;
		var pw = v_x * m2._14 + v_y * m2._24 + v_z * m2._34 + v_w * m2._44;
		v_x = px;
		v_y = py;
		v_z = pz;
		v_w = pw;
		this.nx = v_x;
		this.ny = v_y;
		this.nz = v_z;
		this.d = -v_w;
	}
	,transformInverseTranspose: function(m) {
		var x = this.nx;
		var y = this.ny;
		var z = this.nz;
		var w = -this.d;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		var w1 = w;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var v_w = w1;
		var px = v_x * m._11 + v_y * m._21 + v_z * m._31 + v_w * m._41;
		var py = v_x * m._12 + v_y * m._22 + v_z * m._32 + v_w * m._42;
		var pz = v_x * m._13 + v_y * m._23 + v_z * m._33 + v_w * m._43;
		var pw = v_x * m._14 + v_y * m._24 + v_z * m._34 + v_w * m._44;
		v_x = px;
		v_y = py;
		v_z = pz;
		v_w = pw;
		this.nx = v_x;
		this.ny = v_y;
		this.nz = v_z;
		this.d = -v_w;
	}
	,normalize: function() {
		var len = 1. / Math.sqrt(this.nx * this.nx + this.ny * this.ny + this.nz * this.nz);
		this.nx *= len;
		this.ny *= len;
		this.nz *= len;
		this.d *= len;
	}
	,toString: function() {
		var x = this.nx;
		var y = this.ny;
		var z = this.nz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return "Plane{" + Std.string(new h3d_VectorImpl(x,y,z)) + "," + hxd_Math.fmt(this.d) + "}";
	}
	,distance: function(p) {
		return this.nx * p.x + this.ny * p.y + this.nz * p.z - this.d;
	}
	,side: function(p) {
		return this.nx * p.x + this.ny * p.y + this.nz * p.z - this.d >= 0;
	}
	,project: function(p) {
		var d = this.nx * p.x + this.ny * p.y + this.nz * p.z - this.d;
		var x = p.x - d * this.nx;
		var y = p.y - d * this.ny;
		var z = p.z - d * this.nz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,projectTo: function(p,out) {
		var d = this.nx * p.x + this.ny * p.y + this.nz * p.z - this.d;
		out.x = p.x - d * this.nx;
		out.y = p.y - d * this.ny;
		out.z = p.z - d * this.nz;
	}
	,__class__: h3d_col_Plane
};
var h3d_col_TriPlane = function(o) {
	if(o == null) {
		o = false;
	}
	this.next = null;
	this.oriented = o;
};
$hxClasses["h3d.col.TriPlane"] = h3d_col_TriPlane;
h3d_col_TriPlane.__name__ = "h3d.col.TriPlane";
h3d_col_TriPlane.__super__ = h3d_col_Collider;
h3d_col_TriPlane.prototype = $extend(h3d_col_Collider.prototype,{
	init: function(p0,p1,p2) {
		this.p0x = p0.x;
		this.p0y = p0.y;
		this.p0z = p0.z;
		var x = p1.x - p0.x;
		var y = p1.y - p0.y;
		var z = p1.z - p0.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var x = p2.x - p0.x;
		var y = p2.y - p0.y;
		var z = p2.z - p0.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x1 = x1;
		var _this_y1 = y1;
		var _this_z1 = z1;
		var x = _this_y * _this_z1 - _this_z * _this_y1;
		var y = _this_z * _this_x1 - _this_x * _this_z1;
		var z = _this_x * _this_y1 - _this_y * _this_x1;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x2 = x1;
		var _this_y2 = y1;
		var _this_z2 = z1;
		this.d = _this_x2 * p0.x + _this_y2 * p0.y + _this_z2 * p0.z;
		this.nx = _this_x2;
		this.ny = _this_y2;
		this.nz = _this_z2;
		this.d1x = _this_x;
		this.d1y = _this_y;
		this.d1z = _this_z;
		this.d2x = _this_x1;
		this.d2y = _this_y1;
		this.d2z = _this_z1;
		this.dot00 = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
		this.dot01 = _this_x * _this_x1 + _this_y * _this_y1 + _this_z * _this_z1;
		this.dot11 = _this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1;
		this.invDenom = 1 / (this.dot00 * this.dot11 - this.dot01 * this.dot01);
	}
	,clone: function() {
		var clone = new h3d_col_TriPlane(this.oriented);
		clone.p0x = this.p0x;
		clone.p0y = this.p0y;
		clone.p0z = this.p0z;
		clone.d1x = this.d1x;
		clone.d1y = this.d1y;
		clone.d1z = this.d1z;
		clone.d2x = this.d2x;
		clone.d2y = this.d2y;
		clone.d2z = this.d2z;
		clone.dot00 = this.dot00;
		clone.dot01 = this.dot01;
		clone.dot11 = this.dot11;
		clone.invDenom = this.invDenom;
		clone.nx = this.nx;
		clone.ny = this.ny;
		clone.nz = this.nz;
		clone.d = this.d;
		if(this.next != null) {
			clone.next = this.next.clone();
		}
		return clone;
	}
	,load: function(tp) {
		this.p0x = tp.p0x;
		this.p0y = tp.p0y;
		this.p0z = tp.p0z;
		this.d1x = tp.d1x;
		this.d1y = tp.d1y;
		this.d1z = tp.d1z;
		this.d2x = tp.d2x;
		this.d2y = tp.d2y;
		this.d2z = tp.d2z;
		this.dot00 = tp.dot00;
		this.dot01 = tp.dot01;
		this.dot11 = tp.dot11;
		this.invDenom = tp.invDenom;
		this.nx = tp.nx;
		this.ny = tp.ny;
		this.nz = tp.nz;
		this.d = tp.d;
	}
	,transform: function(m) {
		var x = this.p0x;
		var y = this.p0y;
		var z = this.p0z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var p0_x = x1;
		var p0_y = y1;
		var p0_z = z1;
		var x = this.d1x + this.p0x;
		var y = this.d1y + this.p0y;
		var z = this.d1z + this.p0z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var p1_x = x1;
		var p1_y = y1;
		var p1_z = z1;
		var x = this.d2x + this.p0x;
		var y = this.d2y + this.p0y;
		var z = this.d2z + this.p0z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var p2_x = x1;
		var p2_y = y1;
		var p2_z = z1;
		var px = p0_x * m._11 + p0_y * m._21 + p0_z * m._31 + m._41;
		var py = p0_x * m._12 + p0_y * m._22 + p0_z * m._32 + m._42;
		var pz = p0_x * m._13 + p0_y * m._23 + p0_z * m._33 + m._43;
		p0_x = px;
		p0_y = py;
		p0_z = pz;
		var px = p1_x * m._11 + p1_y * m._21 + p1_z * m._31 + m._41;
		var py = p1_x * m._12 + p1_y * m._22 + p1_z * m._32 + m._42;
		var pz = p1_x * m._13 + p1_y * m._23 + p1_z * m._33 + m._43;
		p1_x = px;
		p1_y = py;
		p1_z = pz;
		var px = p2_x * m._11 + p2_y * m._21 + p2_z * m._31 + m._41;
		var py = p2_x * m._12 + p2_y * m._22 + p2_z * m._32 + m._42;
		var pz = p2_x * m._13 + p2_y * m._23 + p2_z * m._33 + m._43;
		p2_x = px;
		p2_y = py;
		p2_z = pz;
		this.p0x = p0_x;
		this.p0y = p0_y;
		this.p0z = p0_z;
		var x = p1_x - p0_x;
		var y = p1_y - p0_y;
		var z = p1_z - p0_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var x = p2_x - p0_x;
		var y = p2_y - p0_y;
		var z = p2_z - p0_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x1 = x1;
		var _this_y1 = y1;
		var _this_z1 = z1;
		var x = _this_y * _this_z1 - _this_z * _this_y1;
		var y = _this_z * _this_x1 - _this_x * _this_z1;
		var z = _this_x * _this_y1 - _this_y * _this_x1;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x2 = x1;
		var _this_y2 = y1;
		var _this_z2 = z1;
		this.d = _this_x2 * p0_x + _this_y2 * p0_y + _this_z2 * p0_z;
		this.nx = _this_x2;
		this.ny = _this_y2;
		this.nz = _this_z2;
		this.d1x = _this_x;
		this.d1y = _this_y;
		this.d1z = _this_z;
		this.d2x = _this_x1;
		this.d2y = _this_y1;
		this.d2z = _this_z1;
		this.dot00 = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
		this.dot01 = _this_x * _this_x1 + _this_y * _this_y1 + _this_z * _this_z1;
		this.dot11 = _this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1;
		this.invDenom = 1 / (this.dot00 * this.dot11 - this.dot01 * this.dot01);
	}
	,contains: function(p) {
		var x = p.x - this.p0x;
		var y = p.y - this.p0y;
		var z = p.z - this.p0z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v2_x = x1;
		var v2_y = y1;
		var v2_z = z1;
		var dot02 = this.d1x * v2_x + this.d1y * v2_y + this.d1z * v2_z;
		var dot12 = this.d2x * v2_x + this.d2y * v2_y + this.d2z * v2_z;
		var u = (this.dot11 * dot02 - this.dot01 * dot12) * this.invDenom;
		var v = (this.dot00 * dot12 - this.dot01 * dot02) * this.invDenom;
		if(u >= 0 && v >= 0) {
			return u + v < 1;
		} else {
			return false;
		}
	}
	,side: function(p) {
		return this.nx * p.x + this.ny * p.y + this.nz * p.z - this.d >= 0;
	}
	,inFrustum: function(f,m) {
		throw haxe_Exception.thrown("Not implemented");
	}
	,inSphere: function(s) {
		throw haxe_Exception.thrown("Not implemented");
	}
	,closestPoint: function(p) {
		var x = this.p0x;
		var y = this.p0y;
		var z = this.p0z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var p0_x = x1;
		var p0_y = y1;
		var p0_z = z1;
		var x = p.x - this.p0x;
		var y = p.y - this.p0y;
		var z = p.z - this.p0z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v2_x = x1;
		var v2_y = y1;
		var v2_z = z1;
		var dot02 = this.d1x * v2_x + this.d1y * v2_y + this.d1z * v2_z;
		var dot12 = this.d2x * v2_x + this.d2y * v2_y + this.d2z * v2_z;
		var u = (this.dot11 * dot02 - this.dot01 * dot12) * this.invDenom;
		var v = (this.dot00 * dot12 - this.dot01 * dot02) * this.invDenom;
		if(u >= 0 && v >= 0 && u + v < 1) {
			var x = p.x - p0_x;
			var y = p.y - p0_y;
			var z = p.z - p0_z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var _this_x = x1;
			var _this_y = y1;
			var _this_z = z1;
			var x = this.nx;
			var y = this.ny;
			var z = this.nz;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var _this_x1 = x1;
			var _this_y1 = y1;
			var _this_z1 = z1;
			var k = _this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1;
			if(k < 1e-20) {
				k = 0;
			} else {
				k = 1. / Math.sqrt(k);
			}
			_this_x1 *= k;
			_this_y1 *= k;
			_this_z1 *= k;
			var v = _this_x * _this_x1 + _this_y * _this_y1 + _this_z * _this_z1;
			var x = _this_x1 * v;
			var y = _this_y1 * v;
			var z = _this_z1 * v;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var v_x = x1;
			var v_y = y1;
			var v_z = z1;
			var x = _this_x - v_x;
			var y = _this_y - v_y;
			var z = _this_z - v_z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var dProj_x = x1;
			var dProj_y = y1;
			var dProj_z = z1;
			var x = p0_x + dProj_x;
			var y = p0_y + dProj_y;
			var z = p0_z + dProj_z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			return new h3d_VectorImpl(x,y,z);
		}
		var x = this.d1x;
		var y = this.d1y;
		var z = this.d1z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var x = this.d2x;
		var y = this.d2y;
		var z = this.d2z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x1 = x1;
		var _this_y1 = y1;
		var _this_z1 = z1;
		var x = this.p0x;
		var y = this.p0y;
		var z = this.p0z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var this_x = x1;
		var this_y = y1;
		var this_z = z1;
		var x = this_x + _this_x;
		var y = this_y + _this_y;
		var z = this_z + _this_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var p1_x = x1;
		var p1_y = y1;
		var p1_z = z1;
		var x = p.x - p0_x;
		var y = p.y - p0_y;
		var z = p.z - p0_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x2 = x1;
		var _this_y2 = y1;
		var _this_z2 = z1;
		var t = (_this_x2 * _this_x + _this_y2 * _this_y + _this_z2 * _this_z) / (_this_x * _this_x + _this_y * _this_y + _this_z * _this_z);
		if(t < 0.) {
			t = 0.;
		} else if(t > 1.) {
			t = 1.;
		}
		var x = _this_x * t;
		var y = _this_y * t;
		var z = _this_z * t;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var x = p0_x + v_x;
		var y = p0_y + v_y;
		var z = p0_z + v_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var c1 = new h3d_VectorImpl(x,y,z);
		var x = _this_x1 - _this_x;
		var y = _this_y1 - _this_y;
		var z = _this_z1 - _this_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var x = p.x - p1_x;
		var y = p.y - p1_y;
		var z = p.z - p1_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x2 = x1;
		var _this_y2 = y1;
		var _this_z2 = z1;
		var t = (_this_x2 * _this_x + _this_y2 * _this_y + _this_z2 * _this_z) / (_this_x * _this_x + _this_y * _this_y + _this_z * _this_z);
		if(t < 0.) {
			t = 0.;
		} else if(t > 1.) {
			t = 1.;
		}
		var x = _this_x * t;
		var y = _this_y * t;
		var z = _this_z * t;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var x = p1_x + v_x;
		var y = p1_y + v_y;
		var z = p1_z + v_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var c2 = new h3d_VectorImpl(x,y,z);
		var x = p.x - p0_x;
		var y = p.y - p0_y;
		var z = p.z - p0_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var t = (_this_x * _this_x1 + _this_y * _this_y1 + _this_z * _this_z1) / (_this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1);
		if(t < 0.) {
			t = 0.;
		} else if(t > 1.) {
			t = 1.;
		}
		var x = _this_x1 * t;
		var y = _this_y1 * t;
		var z = _this_z1 * t;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var x = p0_x + v_x;
		var y = p0_y + v_y;
		var z = p0_z + v_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var c3 = new h3d_VectorImpl(x,y,z);
		var x = p.x - c1.x;
		var y = p.y - c1.y;
		var z = p.z - c1.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var mag1 = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
		var x = p.x - c2.x;
		var y = p.y - c2.y;
		var z = p.z - c2.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var mag2 = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
		var x = p.x - c3.x;
		var y = p.y - c3.y;
		var z = p.z - c3.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var mag3 = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
		var min = mag1;
		var c = c1;
		if(mag2 < min) {
			min = mag2;
			c = c2;
		}
		if(mag3 < min) {
			min = mag3;
			c = c3;
		}
		return c;
	}
	,rayIntersection: function(r,bestMatch) {
		var dr = r.lx * this.nx + r.ly * this.ny + r.lz * this.nz;
		if(dr >= 0 && this.oriented) {
			return -1.;
		}
		var nd = this.d - (r.px * this.nx + r.py * this.ny + r.pz * this.nz);
		var k = nd / dr;
		if(k < 0 && this.oriented) {
			return -1;
		}
		var px = r.px + r.lx * k;
		var py = r.py + r.ly * k;
		var pz = r.pz + r.lz * k;
		var x = px - this.p0x;
		var y = py - this.p0y;
		var z = pz - this.p0z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v2_x = x1;
		var v2_y = y1;
		var v2_z = z1;
		var dot02 = this.d1x * v2_x + this.d1y * v2_y + this.d1z * v2_z;
		var dot12 = this.d2x * v2_x + this.d2y * v2_y + this.d2z * v2_z;
		var u = (this.dot11 * dot02 - this.dot01 * dot12) * this.invDenom;
		var v = (this.dot00 * dot12 - this.dot01 * dot02) * this.invDenom;
		if(!(u >= 0 && v >= 0 && u + v < 1)) {
			return -1;
		}
		return k;
	}
	,isPointInTriangle: function(x,y,z) {
		var x1 = x - this.p0x;
		var y1 = y - this.p0y;
		var z1 = z - this.p0z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var x = x1;
		var y = y1;
		var z = z1;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var v2_x = x;
		var v2_y = y;
		var v2_z = z;
		var dot02 = this.d1x * v2_x + this.d1y * v2_y + this.d1z * v2_z;
		var dot12 = this.d2x * v2_x + this.d2y * v2_y + this.d2z * v2_z;
		var u = (this.dot11 * dot02 - this.dot01 * dot12) * this.invDenom;
		var v = (this.dot00 * dot12 - this.dot01 * dot02) * this.invDenom;
		if(u >= 0 && v >= 0) {
			return u + v < 1;
		} else {
			return false;
		}
	}
	,getPoints: function() {
		var x = this.p0x;
		var y = this.p0y;
		var z = this.p0z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var this1 = new h3d_VectorImpl(x,y,z);
		var x = this.d1x + this.p0x;
		var y = this.d1y + this.p0y;
		var z = this.d1z + this.p0z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var this2 = new h3d_VectorImpl(x,y,z);
		var x = this.d2x + this.p0x;
		var y = this.d2y + this.p0y;
		var z = this.d2z + this.p0z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return [this1,this2,new h3d_VectorImpl(x,y,z)];
	}
	,makeDebugObj: function() {
		var x = this.p0x;
		var y = this.p0y;
		var z = this.p0z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var p0 = new h3d_VectorImpl(x,y,z);
		var x = this.d1x;
		var y = this.d1y;
		var z = this.d1z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var d1_x = x1;
		var d1_y = y1;
		var d1_z = z1;
		var x = this.d2x;
		var y = this.d2y;
		var z = this.d2z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var d2_x = x1;
		var d2_y = y1;
		var d2_z = z1;
		var x = d1_x + p0.x;
		var y = d1_y + p0.y;
		var z = d1_z + p0.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var this1 = new h3d_VectorImpl(x,y,z);
		var x = d2_x + p0.x;
		var y = d2_y + p0.y;
		var z = d2_z + p0.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var points = [p0,this1,new h3d_VectorImpl(x,y,z)];
		var prim = new h3d_prim_Polygon(points);
		prim.addNormals();
		return new h3d_scene_Mesh(prim);
	}
	,dimension: function() {
		throw haxe_Exception.thrown("Not implemented");
	}
	,__class__: h3d_col_TriPlane
});
var h3d_col_Polygon = function(o) {
	if(o == null) {
		o = false;
	}
	this.oriented = o;
};
$hxClasses["h3d.col.Polygon"] = h3d_col_Polygon;
h3d_col_Polygon.__name__ = "h3d.col.Polygon";
h3d_col_Polygon.fromPolygon2D = function(p,z,oriented) {
	if(oriented == null) {
		oriented = true;
	}
	if(z == null) {
		z = 0.;
	}
	var pout = new h3d_col_Polygon();
	if(h2d_col_Polygon.isConvex(p)) {
		var p0 = p[0];
		var _g = 0;
		var _g1 = p.length - 2;
		while(_g < _g1) {
			var i = _g++;
			var p1 = p[i + 1];
			var p2 = p[i + 2];
			var t = new h3d_col_TriPlane(oriented);
			var x = p0.x;
			var y = p0.y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z2 = z1;
			if(z2 == null) {
				z2 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var p0_x = x1;
			var p0_y = y1;
			var p0_z = z2;
			var x2 = p1.x;
			var y2 = p1.y;
			var z3 = z;
			if(z3 == null) {
				z3 = 0.;
			}
			if(y2 == null) {
				y2 = 0.;
			}
			if(x2 == null) {
				x2 = 0.;
			}
			var x3 = x2;
			var y3 = y2;
			var z4 = z3;
			if(z4 == null) {
				z4 = 0.;
			}
			if(y3 == null) {
				y3 = 0.;
			}
			if(x3 == null) {
				x3 = 0.;
			}
			var p1_x = x3;
			var p1_y = y3;
			var p1_z = z4;
			var x4 = p2.x;
			var y4 = p2.y;
			var z5 = z;
			if(z5 == null) {
				z5 = 0.;
			}
			if(y4 == null) {
				y4 = 0.;
			}
			if(x4 == null) {
				x4 = 0.;
			}
			var x5 = x4;
			var y5 = y4;
			var z6 = z5;
			if(z6 == null) {
				z6 = 0.;
			}
			if(y5 == null) {
				y5 = 0.;
			}
			if(x5 == null) {
				x5 = 0.;
			}
			var p2_x = x5;
			var p2_y = y5;
			var p2_z = z6;
			t.p0x = p0_x;
			t.p0y = p0_y;
			t.p0z = p0_z;
			var x6 = p1_x - p0_x;
			var y6 = p1_y - p0_y;
			var z7 = p1_z - p0_z;
			if(z7 == null) {
				z7 = 0.;
			}
			if(y6 == null) {
				y6 = 0.;
			}
			if(x6 == null) {
				x6 = 0.;
			}
			var x7 = x6;
			var y7 = y6;
			var z8 = z7;
			if(z8 == null) {
				z8 = 0.;
			}
			if(y7 == null) {
				y7 = 0.;
			}
			if(x7 == null) {
				x7 = 0.;
			}
			var _this_x = x7;
			var _this_y = y7;
			var _this_z = z8;
			var x8 = p2_x - p0_x;
			var y8 = p2_y - p0_y;
			var z9 = p2_z - p0_z;
			if(z9 == null) {
				z9 = 0.;
			}
			if(y8 == null) {
				y8 = 0.;
			}
			if(x8 == null) {
				x8 = 0.;
			}
			var x9 = x8;
			var y9 = y8;
			var z10 = z9;
			if(z10 == null) {
				z10 = 0.;
			}
			if(y9 == null) {
				y9 = 0.;
			}
			if(x9 == null) {
				x9 = 0.;
			}
			var _this_x1 = x9;
			var _this_y1 = y9;
			var _this_z1 = z10;
			var x10 = _this_y * _this_z1 - _this_z * _this_y1;
			var y10 = _this_z * _this_x1 - _this_x * _this_z1;
			var z11 = _this_x * _this_y1 - _this_y * _this_x1;
			if(z11 == null) {
				z11 = 0.;
			}
			if(y10 == null) {
				y10 = 0.;
			}
			if(x10 == null) {
				x10 = 0.;
			}
			var x11 = x10;
			var y11 = y10;
			var z12 = z11;
			if(z12 == null) {
				z12 = 0.;
			}
			if(y11 == null) {
				y11 = 0.;
			}
			if(x11 == null) {
				x11 = 0.;
			}
			var _this_x2 = x11;
			var _this_y2 = y11;
			var _this_z2 = z12;
			t.d = _this_x2 * p0_x + _this_y2 * p0_y + _this_z2 * p0_z;
			t.nx = _this_x2;
			t.ny = _this_y2;
			t.nz = _this_z2;
			t.d1x = _this_x;
			t.d1y = _this_y;
			t.d1z = _this_z;
			t.d2x = _this_x1;
			t.d2y = _this_y1;
			t.d2z = _this_z1;
			t.dot00 = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
			t.dot01 = _this_x * _this_x1 + _this_y * _this_y1 + _this_z * _this_z1;
			t.dot11 = _this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1;
			t.invDenom = 1 / (t.dot00 * t.dot11 - t.dot01 * t.dot01);
			t.next = pout.triPlanes;
			pout.triPlanes = t;
		}
	} else {
		var idx = h2d_col_Polygon.fastTriangulate(p);
		var _g = 0;
		var _g1 = idx.length / 3 | 0;
		while(_g < _g1) {
			var i = _g++;
			var p0 = p[idx[i * 3]];
			var p1 = p[idx[i * 3 + 1]];
			var p2 = p[idx[i * 3 + 2]];
			var t = new h3d_col_TriPlane(oriented);
			var x = p0.x;
			var y = p0.y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z2 = z1;
			if(z2 == null) {
				z2 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var p0_x = x1;
			var p0_y = y1;
			var p0_z = z2;
			var x2 = p1.x;
			var y2 = p1.y;
			var z3 = z;
			if(z3 == null) {
				z3 = 0.;
			}
			if(y2 == null) {
				y2 = 0.;
			}
			if(x2 == null) {
				x2 = 0.;
			}
			var x3 = x2;
			var y3 = y2;
			var z4 = z3;
			if(z4 == null) {
				z4 = 0.;
			}
			if(y3 == null) {
				y3 = 0.;
			}
			if(x3 == null) {
				x3 = 0.;
			}
			var p1_x = x3;
			var p1_y = y3;
			var p1_z = z4;
			var x4 = p2.x;
			var y4 = p2.y;
			var z5 = z;
			if(z5 == null) {
				z5 = 0.;
			}
			if(y4 == null) {
				y4 = 0.;
			}
			if(x4 == null) {
				x4 = 0.;
			}
			var x5 = x4;
			var y5 = y4;
			var z6 = z5;
			if(z6 == null) {
				z6 = 0.;
			}
			if(y5 == null) {
				y5 = 0.;
			}
			if(x5 == null) {
				x5 = 0.;
			}
			var p2_x = x5;
			var p2_y = y5;
			var p2_z = z6;
			t.p0x = p0_x;
			t.p0y = p0_y;
			t.p0z = p0_z;
			var x6 = p1_x - p0_x;
			var y6 = p1_y - p0_y;
			var z7 = p1_z - p0_z;
			if(z7 == null) {
				z7 = 0.;
			}
			if(y6 == null) {
				y6 = 0.;
			}
			if(x6 == null) {
				x6 = 0.;
			}
			var x7 = x6;
			var y7 = y6;
			var z8 = z7;
			if(z8 == null) {
				z8 = 0.;
			}
			if(y7 == null) {
				y7 = 0.;
			}
			if(x7 == null) {
				x7 = 0.;
			}
			var _this_x = x7;
			var _this_y = y7;
			var _this_z = z8;
			var x8 = p2_x - p0_x;
			var y8 = p2_y - p0_y;
			var z9 = p2_z - p0_z;
			if(z9 == null) {
				z9 = 0.;
			}
			if(y8 == null) {
				y8 = 0.;
			}
			if(x8 == null) {
				x8 = 0.;
			}
			var x9 = x8;
			var y9 = y8;
			var z10 = z9;
			if(z10 == null) {
				z10 = 0.;
			}
			if(y9 == null) {
				y9 = 0.;
			}
			if(x9 == null) {
				x9 = 0.;
			}
			var _this_x1 = x9;
			var _this_y1 = y9;
			var _this_z1 = z10;
			var x10 = _this_y * _this_z1 - _this_z * _this_y1;
			var y10 = _this_z * _this_x1 - _this_x * _this_z1;
			var z11 = _this_x * _this_y1 - _this_y * _this_x1;
			if(z11 == null) {
				z11 = 0.;
			}
			if(y10 == null) {
				y10 = 0.;
			}
			if(x10 == null) {
				x10 = 0.;
			}
			var x11 = x10;
			var y11 = y10;
			var z12 = z11;
			if(z12 == null) {
				z12 = 0.;
			}
			if(y11 == null) {
				y11 = 0.;
			}
			if(x11 == null) {
				x11 = 0.;
			}
			var _this_x2 = x11;
			var _this_y2 = y11;
			var _this_z2 = z12;
			t.d = _this_x2 * p0_x + _this_y2 * p0_y + _this_z2 * p0_z;
			t.nx = _this_x2;
			t.ny = _this_y2;
			t.nz = _this_z2;
			t.d1x = _this_x;
			t.d1y = _this_y;
			t.d1z = _this_z;
			t.d2x = _this_x1;
			t.d2y = _this_y1;
			t.d2z = _this_z1;
			t.dot00 = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
			t.dot01 = _this_x * _this_x1 + _this_y * _this_y1 + _this_z * _this_z1;
			t.dot11 = _this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1;
			t.invDenom = 1 / (t.dot00 * t.dot11 - t.dot01 * t.dot01);
			t.next = pout.triPlanes;
			pout.triPlanes = t;
		}
	}
	return pout;
};
h3d_col_Polygon.__super__ = h3d_col_Collider;
h3d_col_Polygon.prototype = $extend(h3d_col_Collider.prototype,{
	addBuffers: function(vertexes,indexes,stride) {
		if(stride == null) {
			stride = 3;
		}
		var _g = 0;
		var _g1 = indexes.length / 3 | 0;
		while(_g < _g1) {
			var i = _g++;
			var k = i * 3;
			var t = new h3d_col_TriPlane(this.oriented);
			var i0 = indexes[k] * stride;
			var i1 = indexes[k + 1] * stride;
			var i2 = indexes[k + 2] * stride;
			var x = vertexes[i0];
			var y = vertexes[i0 + 1];
			var z = vertexes[i0 + 2];
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var p0_x = x1;
			var p0_y = y1;
			var p0_z = z1;
			var x2 = vertexes[i1];
			var y2 = vertexes[i1 + 1];
			var z2 = vertexes[i1 + 2];
			if(z2 == null) {
				z2 = 0.;
			}
			if(y2 == null) {
				y2 = 0.;
			}
			if(x2 == null) {
				x2 = 0.;
			}
			var x3 = x2;
			var y3 = y2;
			var z3 = z2;
			if(z3 == null) {
				z3 = 0.;
			}
			if(y3 == null) {
				y3 = 0.;
			}
			if(x3 == null) {
				x3 = 0.;
			}
			var p1_x = x3;
			var p1_y = y3;
			var p1_z = z3;
			var x4 = vertexes[i2];
			var y4 = vertexes[i2 + 1];
			var z4 = vertexes[i2 + 2];
			if(z4 == null) {
				z4 = 0.;
			}
			if(y4 == null) {
				y4 = 0.;
			}
			if(x4 == null) {
				x4 = 0.;
			}
			var x5 = x4;
			var y5 = y4;
			var z5 = z4;
			if(z5 == null) {
				z5 = 0.;
			}
			if(y5 == null) {
				y5 = 0.;
			}
			if(x5 == null) {
				x5 = 0.;
			}
			var p2_x = x5;
			var p2_y = y5;
			var p2_z = z5;
			t.p0x = p0_x;
			t.p0y = p0_y;
			t.p0z = p0_z;
			var x6 = p1_x - p0_x;
			var y6 = p1_y - p0_y;
			var z6 = p1_z - p0_z;
			if(z6 == null) {
				z6 = 0.;
			}
			if(y6 == null) {
				y6 = 0.;
			}
			if(x6 == null) {
				x6 = 0.;
			}
			var x7 = x6;
			var y7 = y6;
			var z7 = z6;
			if(z7 == null) {
				z7 = 0.;
			}
			if(y7 == null) {
				y7 = 0.;
			}
			if(x7 == null) {
				x7 = 0.;
			}
			var _this_x = x7;
			var _this_y = y7;
			var _this_z = z7;
			var x8 = p2_x - p0_x;
			var y8 = p2_y - p0_y;
			var z8 = p2_z - p0_z;
			if(z8 == null) {
				z8 = 0.;
			}
			if(y8 == null) {
				y8 = 0.;
			}
			if(x8 == null) {
				x8 = 0.;
			}
			var x9 = x8;
			var y9 = y8;
			var z9 = z8;
			if(z9 == null) {
				z9 = 0.;
			}
			if(y9 == null) {
				y9 = 0.;
			}
			if(x9 == null) {
				x9 = 0.;
			}
			var _this_x1 = x9;
			var _this_y1 = y9;
			var _this_z1 = z9;
			var x10 = _this_y * _this_z1 - _this_z * _this_y1;
			var y10 = _this_z * _this_x1 - _this_x * _this_z1;
			var z10 = _this_x * _this_y1 - _this_y * _this_x1;
			if(z10 == null) {
				z10 = 0.;
			}
			if(y10 == null) {
				y10 = 0.;
			}
			if(x10 == null) {
				x10 = 0.;
			}
			var x11 = x10;
			var y11 = y10;
			var z11 = z10;
			if(z11 == null) {
				z11 = 0.;
			}
			if(y11 == null) {
				y11 = 0.;
			}
			if(x11 == null) {
				x11 = 0.;
			}
			var _this_x2 = x11;
			var _this_y2 = y11;
			var _this_z2 = z11;
			t.d = _this_x2 * p0_x + _this_y2 * p0_y + _this_z2 * p0_z;
			t.nx = _this_x2;
			t.ny = _this_y2;
			t.nz = _this_z2;
			t.d1x = _this_x;
			t.d1y = _this_y;
			t.d1z = _this_z;
			t.d2x = _this_x1;
			t.d2y = _this_y1;
			t.d2z = _this_z1;
			t.dot00 = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
			t.dot01 = _this_x * _this_x1 + _this_y * _this_y1 + _this_z * _this_z1;
			t.dot11 = _this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1;
			t.invDenom = 1 / (t.dot00 * t.dot11 - t.dot01 * t.dot01);
			t.next = this.triPlanes;
			this.triPlanes = t;
		}
	}
	,isConvex: function() {
		return true;
	}
	,clone: function() {
		var clone = new h3d_col_Polygon(this.oriented);
		var _this = this.triPlanes;
		var clone1 = new h3d_col_TriPlane(_this.oriented);
		clone1.p0x = _this.p0x;
		clone1.p0y = _this.p0y;
		clone1.p0z = _this.p0z;
		clone1.d1x = _this.d1x;
		clone1.d1y = _this.d1y;
		clone1.d1z = _this.d1z;
		clone1.d2x = _this.d2x;
		clone1.d2y = _this.d2y;
		clone1.d2z = _this.d2z;
		clone1.dot00 = _this.dot00;
		clone1.dot01 = _this.dot01;
		clone1.dot11 = _this.dot11;
		clone1.invDenom = _this.invDenom;
		clone1.nx = _this.nx;
		clone1.ny = _this.ny;
		clone1.nz = _this.nz;
		clone1.d = _this.d;
		if(_this.next != null) {
			var _this1 = _this.next;
			var clone2 = new h3d_col_TriPlane(_this1.oriented);
			clone2.p0x = _this1.p0x;
			clone2.p0y = _this1.p0y;
			clone2.p0z = _this1.p0z;
			clone2.d1x = _this1.d1x;
			clone2.d1y = _this1.d1y;
			clone2.d1z = _this1.d1z;
			clone2.d2x = _this1.d2x;
			clone2.d2y = _this1.d2y;
			clone2.d2z = _this1.d2z;
			clone2.dot00 = _this1.dot00;
			clone2.dot01 = _this1.dot01;
			clone2.dot11 = _this1.dot11;
			clone2.invDenom = _this1.invDenom;
			clone2.nx = _this1.nx;
			clone2.ny = _this1.ny;
			clone2.nz = _this1.nz;
			clone2.d = _this1.d;
			if(_this1.next != null) {
				clone2.next = _this1.next.clone();
			}
			clone1.next = clone2;
		}
		clone.triPlanes = clone1;
		return clone;
	}
	,transform: function(m) {
		var t = this.triPlanes;
		while(t != null) {
			t.transform(m);
			t = t.next;
		}
	}
	,getPoints: function() {
		var ret = [];
		var t = this.triPlanes;
		while(t != null) {
			ret = ret.concat(t.getPoints());
			t = t.next;
		}
		return ret;
	}
	,getBounds: function(bnds) {
		if(bnds == null) {
			bnds = new h3d_col_Bounds();
		}
		bnds.xMin = 1e20;
		bnds.xMax = -1e20;
		bnds.yMin = 1e20;
		bnds.yMax = -1e20;
		bnds.zMin = 1e20;
		bnds.zMax = -1e20;
		var t = this.triPlanes;
		while(t != null) {
			var x = t.p0x;
			var y = t.p0y;
			var z = t.p0z;
			if(x < bnds.xMin) {
				bnds.xMin = x;
			}
			if(x > bnds.xMax) {
				bnds.xMax = x;
			}
			if(y < bnds.yMin) {
				bnds.yMin = y;
			}
			if(y > bnds.yMax) {
				bnds.yMax = y;
			}
			if(z < bnds.zMin) {
				bnds.zMin = z;
			}
			if(z > bnds.zMax) {
				bnds.zMax = z;
			}
			var x1 = t.d1x + t.p0x;
			var y1 = t.d1y + t.p0y;
			var z1 = t.d1z + t.p0z;
			if(x1 < bnds.xMin) {
				bnds.xMin = x1;
			}
			if(x1 > bnds.xMax) {
				bnds.xMax = x1;
			}
			if(y1 < bnds.yMin) {
				bnds.yMin = y1;
			}
			if(y1 > bnds.yMax) {
				bnds.yMax = y1;
			}
			if(z1 < bnds.zMin) {
				bnds.zMin = z1;
			}
			if(z1 > bnds.zMax) {
				bnds.zMax = z1;
			}
			var x2 = t.d2x + t.p0x;
			var y2 = t.d2y + t.p0y;
			var z2 = t.d2z + t.p0z;
			if(x2 < bnds.xMin) {
				bnds.xMin = x2;
			}
			if(x2 > bnds.xMax) {
				bnds.xMax = x2;
			}
			if(y2 < bnds.yMin) {
				bnds.yMin = y2;
			}
			if(y2 > bnds.yMax) {
				bnds.yMax = y2;
			}
			if(z2 < bnds.zMin) {
				bnds.zMin = z2;
			}
			if(z2 > bnds.zMax) {
				bnds.zMax = z2;
			}
			t = t.next;
		}
		return bnds;
	}
	,contains: function(p) {
		if(!this.isConvex()) {
			throw haxe_Exception.thrown("Not implemented for concave polygon");
		}
		var t = this.triPlanes;
		while(t != null) {
			if(t.nx * p.x + t.ny * p.y + t.nz * p.z - t.d >= 0) {
				return false;
			}
			t = t.next;
		}
		return true;
	}
	,rayIntersection: function(r,bestMatch) {
		var t = this.triPlanes;
		var best = -1.;
		while(t != null) {
			var dr = r.lx * t.nx + r.ly * t.ny + r.lz * t.nz;
			var d;
			if(dr >= 0 && t.oriented) {
				d = -1.;
			} else {
				var nd = t.d - (r.px * t.nx + r.py * t.ny + r.pz * t.nz);
				var k = nd / dr;
				if(k < 0 && t.oriented) {
					d = -1;
				} else {
					var px = r.px + r.lx * k;
					var py = r.py + r.ly * k;
					var pz = r.pz + r.lz * k;
					var x = px - t.p0x;
					var y = py - t.p0y;
					var z = pz - t.p0z;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var v2_x = x1;
					var v2_y = y1;
					var v2_z = z1;
					var dot02 = t.d1x * v2_x + t.d1y * v2_y + t.d1z * v2_z;
					var dot12 = t.d2x * v2_x + t.d2y * v2_y + t.d2z * v2_z;
					var u = (t.dot11 * dot02 - t.dot01 * dot12) * t.invDenom;
					var v = (t.dot00 * dot12 - t.dot01 * dot02) * t.invDenom;
					d = !(u >= 0 && v >= 0 && u + v < 1) ? -1 : k;
				}
			}
			if(d >= 0) {
				if(!bestMatch) {
					return d;
				}
				if(best < 0 || d < best) {
					best = d;
				}
			}
			t = t.next;
		}
		return best;
	}
	,inFrustum: function(f,m) {
		throw haxe_Exception.thrown("Not implemented");
	}
	,inSphere: function(s) {
		throw haxe_Exception.thrown("Not implemented");
	}
	,closestPoint: function(p) {
		var t = this.triPlanes;
		var minDistSq = Infinity;
		var closest = null;
		while(t != null) {
			var c = t.closestPoint(p);
			var _this = p;
			var dx = c.x - _this.x;
			var dy = c.y - _this.y;
			var dz = c.z - _this.z;
			var distSq = dx * dx + dy * dy + dz * dz;
			if(distSq < minDistSq) {
				minDistSq = distSq;
				closest = c;
			}
			t = t.next;
		}
		return closest;
	}
	,dimension: function() {
		var _this = this.getBounds();
		var a = _this.xMax - _this.xMin;
		var a1 = _this.yMax - _this.yMin;
		var b = _this.zMax - _this.zMin;
		var b1 = a1 < b ? b : a1;
		if(a < b1) {
			return b1;
		} else {
			return a;
		}
	}
	,makeDebugObj: function() {
		var points = [];
		var idx = new Array(0);
		var t = this.triPlanes;
		while(t != null) {
			var x = t.p0x;
			var y = t.p0y;
			var z = t.p0z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var p0 = new h3d_VectorImpl(x,y,z);
			var x1 = t.d1x;
			var y1 = t.d1y;
			var z1 = t.d1z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var x2 = x1;
			var y2 = y1;
			var z2 = z1;
			if(z2 == null) {
				z2 = 0.;
			}
			if(y2 == null) {
				y2 = 0.;
			}
			if(x2 == null) {
				x2 = 0.;
			}
			var d1_x = x2;
			var d1_y = y2;
			var d1_z = z2;
			var x3 = t.d2x;
			var y3 = t.d2y;
			var z3 = t.d2z;
			if(z3 == null) {
				z3 = 0.;
			}
			if(y3 == null) {
				y3 = 0.;
			}
			if(x3 == null) {
				x3 = 0.;
			}
			var x4 = x3;
			var y4 = y3;
			var z4 = z3;
			if(z4 == null) {
				z4 = 0.;
			}
			if(y4 == null) {
				y4 = 0.;
			}
			if(x4 == null) {
				x4 = 0.;
			}
			var d2_x = x4;
			var d2_y = y4;
			var d2_z = z4;
			points.push(p0);
			var x5 = d1_x + p0.x;
			var y5 = d1_y + p0.y;
			var z5 = d1_z + p0.z;
			if(z5 == null) {
				z5 = 0.;
			}
			if(y5 == null) {
				y5 = 0.;
			}
			if(x5 == null) {
				x5 = 0.;
			}
			points.push(new h3d_VectorImpl(x5,y5,z5));
			var x6 = d2_x + p0.x;
			var y6 = d2_y + p0.y;
			var z6 = d2_z + p0.z;
			if(z6 == null) {
				z6 = 0.;
			}
			if(y6 == null) {
				y6 = 0.;
			}
			if(x6 == null) {
				x6 = 0.;
			}
			points.push(new h3d_VectorImpl(x6,y6,z6));
			t = t.next;
		}
		var prim = new h3d_prim_Polygon(points);
		prim.addNormals();
		var mesh = new h3d_scene_Mesh(prim);
		if(!this.oriented) {
			mesh.material.passes.set_culling(h3d_mat_Face.None);
		}
		return mesh;
	}
	,__class__: h3d_col_Polygon
});
var h3d_col_PolygonBuffer = function() {
};
$hxClasses["h3d.col.PolygonBuffer"] = h3d_col_PolygonBuffer;
h3d_col_PolygonBuffer.__name__ = "h3d.col.PolygonBuffer";
h3d_col_PolygonBuffer.__super__ = h3d_col_Collider;
h3d_col_PolygonBuffer.prototype = $extend(h3d_col_Collider.prototype,{
	setData: function(buffer,indexes,startIndex,triCount) {
		if(triCount == null) {
			triCount = -1;
		}
		if(startIndex == null) {
			startIndex = 0;
		}
		this.buffer = buffer;
		this.indexes = indexes;
		this.startIndex = startIndex;
		this.triCount = triCount >= 0 ? triCount : (indexes.length - startIndex) / 3 | 0;
	}
	,getBounds: function() {
		var i = this.startIndex;
		var b = new h3d_col_Bounds();
		var _g = 0;
		var _g1 = this.triCount * 3;
		while(_g < _g1) {
			var t = _g++;
			var pos = this.indexes[i++] * 3;
			var x = this.buffer[pos++];
			var y = this.buffer[pos++];
			var z = this.buffer[pos];
			if(x < b.xMin) {
				b.xMin = x;
			}
			if(x > b.xMax) {
				b.xMax = x;
			}
			if(y < b.yMin) {
				b.yMin = y;
			}
			if(y > b.yMax) {
				b.yMax = y;
			}
			if(z < b.zMin) {
				b.zMin = z;
			}
			if(z > b.zMax) {
				b.zMax = z;
			}
		}
		return b;
	}
	,getPoints: function() {
		var vmin = 1073741824;
		var vmax = -1073741824;
		var _g = this.startIndex;
		var _g1 = this.startIndex + this.triCount * 3;
		while(_g < _g1) {
			var i = _g++;
			var pos = this.indexes[i];
			if(pos < vmin) {
				vmin = pos;
			}
			if(pos > vmax) {
				vmax = pos;
			}
		}
		var vcount = vmax + 1 - vmin;
		var bits = hxd_impl_BitSet._new(vcount);
		var points = [];
		var _g = this.startIndex;
		var _g1 = this.startIndex + this.triCount * 3;
		while(_g < _g1) {
			var i = _g++;
			var pos = this.indexes[i];
			var vidx = pos - vmin;
			if(!hxd_impl_BitSet.get(bits,vidx)) {
				pos *= 3;
				points.push(new h3d_col_FPoint(this.buffer[pos++],this.buffer[pos++],this.buffer[pos]));
				hxd_impl_BitSet.set(bits,vidx);
			}
		}
		return points;
	}
	,contains: function(p) {
		var i = this.startIndex;
		var x = p.x;
		var y = p.y;
		var z = p.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var p_x = x;
		var p_y = y;
		var p_z = z;
		var _g = 0;
		var _g1 = this.triCount;
		while(_g < _g1) {
			var t = _g++;
			var i0 = this.indexes[i++] * 3;
			var x = this.buffer[i0++];
			var y = this.buffer[i0++];
			var z = this.buffer[i0];
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var p0_x = x;
			var p0_y = y;
			var p0_z = z;
			var i1 = this.indexes[i++] * 3;
			var x1 = this.buffer[i1++];
			var y1 = this.buffer[i1++];
			var z1 = this.buffer[i1];
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var p1_x = x1;
			var p1_y = y1;
			var p1_z = z1;
			var i2 = this.indexes[i++] * 3;
			var x2 = this.buffer[i2++];
			var y2 = this.buffer[i2++];
			var z2 = this.buffer[i2];
			if(z2 == null) {
				z2 = 0.;
			}
			if(y2 == null) {
				y2 = 0.;
			}
			if(x2 == null) {
				x2 = 0.;
			}
			var p2_x = x2;
			var p2_y = y2;
			var p2_z = z2;
			var x3 = p1_x - p0_x;
			var y3 = p1_y - p0_y;
			var z3 = p1_z - p0_z;
			if(z3 == null) {
				z3 = 0.;
			}
			if(y3 == null) {
				y3 = 0.;
			}
			if(x3 == null) {
				x3 = 0.;
			}
			var d1_x = x3;
			var d1_y = y3;
			var d1_z = z3;
			var x4 = p2_x - p0_x;
			var y4 = p2_y - p0_y;
			var z4 = p2_z - p0_z;
			if(z4 == null) {
				z4 = 0.;
			}
			if(y4 == null) {
				y4 = 0.;
			}
			if(x4 == null) {
				x4 = 0.;
			}
			var d2_x = x4;
			var d2_y = y4;
			var d2_z = z4;
			var x5 = d1_y * d2_z - d1_z * d2_y;
			var y5 = d1_z * d2_x - d1_x * d2_z;
			var z5 = d1_x * d2_y - d1_y * d2_x;
			if(z5 == null) {
				z5 = 0.;
			}
			if(y5 == null) {
				y5 = 0.;
			}
			if(x5 == null) {
				x5 = 0.;
			}
			var n_x = x5;
			var n_y = y5;
			var n_z = z5;
			var d = n_x * p0_x + n_y * p0_y + n_z * p0_z;
			if(n_x * p_x + n_y * p_y + n_z * p_z >= d) {
				return false;
			}
		}
		return true;
	}
	,inFrustum: function(f,m) {
		throw haxe_Exception.thrown("Not implemented");
	}
	,inSphere: function(s) {
		throw haxe_Exception.thrown("Not implemented");
	}
	,dimension: function() {
		var _this = this.getBounds();
		var a = _this.xMax - _this.xMin;
		var a1 = _this.yMax - _this.yMin;
		var b = _this.zMax - _this.zMin;
		var b1 = a1 < b ? b : a1;
		if(a < b1) {
			return b1;
		} else {
			return a;
		}
	}
	,isPointInTriangle: function(d,d1,d2) {
		var dot02 = d1.x * d.x + d1.y * d.y + d1.z * d.z;
		var dot12 = d2.x * d.x + d2.y * d.y + d2.z * d.z;
		var dot00 = d1.x * d1.x + d1.y * d1.y + d1.z * d1.z;
		var dot01 = d1.x * d2.x + d1.y * d2.y + d1.z * d2.z;
		var dot11 = d2.x * d2.x + d2.y * d2.y + d2.z * d2.z;
		var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
		var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
		var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
		if(u >= 0 && v >= 0) {
			return u + v < 1;
		} else {
			return false;
		}
	}
	,closestPointLine: function(p,start,d) {
		var x = p.x - start.x;
		var y = p.y - start.y;
		var z = p.z - start.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var _this_x = x;
		var _this_y = y;
		var _this_z = z;
		var t = (_this_x * d.x + _this_y * d.y + _this_z * d.z) / (d.x * d.x + d.y * d.y + d.z * d.z);
		if(t < 0.) {
			t = 0.;
		} else if(t > 1.) {
			t = 1.;
		}
		var x = d.x * t;
		var y = d.y * t;
		var z = d.z * t;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var p_x = x;
		var p_y = y;
		var p_z = z;
		return new h3d_col_FPoint(start.x + p_x,start.y + p_y,start.z + p_z);
	}
	,closestPoint: function(p) {
		var x = p.x;
		var y = p.y;
		var z = p.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var p_x = x;
		var p_y = y;
		var p_z = z;
		var minDistSq = Infinity;
		var closest = null;
		var i = this.startIndex;
		var _g = 0;
		var _g1 = this.triCount;
		while(_g < _g1) {
			var t = _g++;
			var i0 = this.indexes[i++] * 3;
			var x = this.buffer[i0++];
			var y = this.buffer[i0++];
			var z = this.buffer[i0];
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var p0_x = x;
			var p0_y = y;
			var p0_z = z;
			var i1 = this.indexes[i++] * 3;
			var x1 = this.buffer[i1++];
			var y1 = this.buffer[i1++];
			var z1 = this.buffer[i1];
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var p1_x = x1;
			var p1_y = y1;
			var p1_z = z1;
			var i2 = this.indexes[i++] * 3;
			var x2 = this.buffer[i2++];
			var y2 = this.buffer[i2++];
			var z2 = this.buffer[i2];
			if(z2 == null) {
				z2 = 0.;
			}
			if(y2 == null) {
				y2 = 0.;
			}
			if(x2 == null) {
				x2 = 0.;
			}
			var p2_x = x2;
			var p2_y = y2;
			var p2_z = z2;
			var c = null;
			var x3 = p1_x - p0_x;
			var y3 = p1_y - p0_y;
			var z3 = p1_z - p0_z;
			if(z3 == null) {
				z3 = 0.;
			}
			if(y3 == null) {
				y3 = 0.;
			}
			if(x3 == null) {
				x3 = 0.;
			}
			var d1_x = x3;
			var d1_y = y3;
			var d1_z = z3;
			var x4 = p2_x - p0_x;
			var y4 = p2_y - p0_y;
			var z4 = p2_z - p0_z;
			if(z4 == null) {
				z4 = 0.;
			}
			if(y4 == null) {
				y4 = 0.;
			}
			if(x4 == null) {
				x4 = 0.;
			}
			var d2_x = x4;
			var d2_y = y4;
			var d2_z = z4;
			var x5 = p_x - p0_x;
			var y5 = p_y - p0_y;
			var z5 = p_z - p0_z;
			if(z5 == null) {
				z5 = 0.;
			}
			if(y5 == null) {
				y5 = 0.;
			}
			if(x5 == null) {
				x5 = 0.;
			}
			var d_x = x5;
			var d_y = y5;
			var d_z = z5;
			var dot02 = d1_x * d_x + d1_y * d_y + d1_z * d_z;
			var dot12 = d2_x * d_x + d2_y * d_y + d2_z * d_z;
			var dot00 = d1_x * d1_x + d1_y * d1_y + d1_z * d1_z;
			var dot01 = d1_x * d2_x + d1_y * d2_y + d1_z * d2_z;
			var dot11 = d2_x * d2_x + d2_y * d2_y + d2_z * d2_z;
			var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
			var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
			var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
			if(u >= 0 && v >= 0 && u + v < 1) {
				var x6 = d1_y * d2_z - d1_z * d2_y;
				var y6 = d1_z * d2_x - d1_x * d2_z;
				var z6 = d1_x * d2_y - d1_y * d2_x;
				if(z6 == null) {
					z6 = 0.;
				}
				if(y6 == null) {
					y6 = 0.;
				}
				if(x6 == null) {
					x6 = 0.;
				}
				var _this_x = x6;
				var _this_y = y6;
				var _this_z = z6;
				var k = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
				if(k < 1e-20) {
					k = 0;
				} else {
					k = 1. / Math.sqrt(k);
				}
				var x7 = _this_x * k;
				var y7 = _this_y * k;
				var z7 = _this_z * k;
				if(z7 == null) {
					z7 = 0.;
				}
				if(y7 == null) {
					y7 = 0.;
				}
				if(x7 == null) {
					x7 = 0.;
				}
				var n_x = x7;
				var n_y = y7;
				var n_z = z7;
				var v1 = d_x * n_x + d_y * n_y + d_z * n_z;
				var x8 = n_x * v1;
				var y8 = n_y * v1;
				var z8 = n_z * v1;
				if(z8 == null) {
					z8 = 0.;
				}
				if(y8 == null) {
					y8 = 0.;
				}
				if(x8 == null) {
					x8 = 0.;
				}
				var p_x1 = x8;
				var p_y1 = y8;
				var p_z1 = z8;
				var x9 = d_x - p_x1;
				var y9 = d_y - p_y1;
				var z9 = d_z - p_z1;
				if(z9 == null) {
					z9 = 0.;
				}
				if(y9 == null) {
					y9 = 0.;
				}
				if(x9 == null) {
					x9 = 0.;
				}
				var dProj_x = x9;
				var dProj_y = y9;
				var dProj_z = z9;
				c = new h3d_col_FPoint(p0_x + dProj_x,p0_y + dProj_y,p0_z + dProj_z);
			} else {
				var x10 = p_x - p0_x;
				var y10 = p_y - p0_y;
				var z10 = p_z - p0_z;
				if(z10 == null) {
					z10 = 0.;
				}
				if(y10 == null) {
					y10 = 0.;
				}
				if(x10 == null) {
					x10 = 0.;
				}
				var _this_x1 = x10;
				var _this_y1 = y10;
				var _this_z1 = z10;
				var t1 = (_this_x1 * d1_x + _this_y1 * d1_y + _this_z1 * d1_z) / (d1_x * d1_x + d1_y * d1_y + d1_z * d1_z);
				if(t1 < 0.) {
					t1 = 0.;
				} else if(t1 > 1.) {
					t1 = 1.;
				}
				var x11 = d1_x * t1;
				var y11 = d1_y * t1;
				var z11 = d1_z * t1;
				if(z11 == null) {
					z11 = 0.;
				}
				if(y11 == null) {
					y11 = 0.;
				}
				if(x11 == null) {
					x11 = 0.;
				}
				var p_x2 = x11;
				var p_y2 = y11;
				var p_z2 = z11;
				var c1 = new h3d_col_FPoint(p0_x + p_x2,p0_y + p_y2,p0_z + p_z2);
				var x12 = d2_x - d1_x;
				var y12 = d2_y - d1_y;
				var z12 = d2_z - d1_z;
				if(z12 == null) {
					z12 = 0.;
				}
				if(y12 == null) {
					y12 = 0.;
				}
				if(x12 == null) {
					x12 = 0.;
				}
				var d_x1 = x12;
				var d_y1 = y12;
				var d_z1 = z12;
				var x13 = p_x - p1_x;
				var y13 = p_y - p1_y;
				var z13 = p_z - p1_z;
				if(z13 == null) {
					z13 = 0.;
				}
				if(y13 == null) {
					y13 = 0.;
				}
				if(x13 == null) {
					x13 = 0.;
				}
				var _this_x2 = x13;
				var _this_y2 = y13;
				var _this_z2 = z13;
				var t2 = (_this_x2 * d_x1 + _this_y2 * d_y1 + _this_z2 * d_z1) / (d_x1 * d_x1 + d_y1 * d_y1 + d_z1 * d_z1);
				if(t2 < 0.) {
					t2 = 0.;
				} else if(t2 > 1.) {
					t2 = 1.;
				}
				var x14 = d_x1 * t2;
				var y14 = d_y1 * t2;
				var z14 = d_z1 * t2;
				if(z14 == null) {
					z14 = 0.;
				}
				if(y14 == null) {
					y14 = 0.;
				}
				if(x14 == null) {
					x14 = 0.;
				}
				var p_x3 = x14;
				var p_y3 = y14;
				var p_z3 = z14;
				var c2 = new h3d_col_FPoint(p1_x + p_x3,p1_y + p_y3,p1_z + p_z3);
				var x15 = p_x - p0_x;
				var y15 = p_y - p0_y;
				var z15 = p_z - p0_z;
				if(z15 == null) {
					z15 = 0.;
				}
				if(y15 == null) {
					y15 = 0.;
				}
				if(x15 == null) {
					x15 = 0.;
				}
				var _this_x3 = x15;
				var _this_y3 = y15;
				var _this_z3 = z15;
				var t3 = (_this_x3 * d2_x + _this_y3 * d2_y + _this_z3 * d2_z) / (d2_x * d2_x + d2_y * d2_y + d2_z * d2_z);
				if(t3 < 0.) {
					t3 = 0.;
				} else if(t3 > 1.) {
					t3 = 1.;
				}
				var x16 = d2_x * t3;
				var y16 = d2_y * t3;
				var z16 = d2_z * t3;
				if(z16 == null) {
					z16 = 0.;
				}
				if(y16 == null) {
					y16 = 0.;
				}
				if(x16 == null) {
					x16 = 0.;
				}
				var p_x4 = x16;
				var p_y4 = y16;
				var p_z4 = z16;
				var c3 = new h3d_col_FPoint(p0_x + p_x4,p0_y + p_y4,p0_z + p_z4);
				var x17 = p_x - c1.x;
				var y17 = p_y - c1.y;
				var z17 = p_z - c1.z;
				if(z17 == null) {
					z17 = 0.;
				}
				if(y17 == null) {
					y17 = 0.;
				}
				if(x17 == null) {
					x17 = 0.;
				}
				var _this_x4 = x17;
				var _this_y4 = y17;
				var _this_z4 = z17;
				var mag1 = _this_x4 * _this_x4 + _this_y4 * _this_y4 + _this_z4 * _this_z4;
				var x18 = p_x - c2.x;
				var y18 = p_y - c2.y;
				var z18 = p_z - c2.z;
				if(z18 == null) {
					z18 = 0.;
				}
				if(y18 == null) {
					y18 = 0.;
				}
				if(x18 == null) {
					x18 = 0.;
				}
				var _this_x5 = x18;
				var _this_y5 = y18;
				var _this_z5 = z18;
				var mag2 = _this_x5 * _this_x5 + _this_y5 * _this_y5 + _this_z5 * _this_z5;
				var x19 = p_x - c3.x;
				var y19 = p_y - c3.y;
				var z19 = p_z - c3.z;
				if(z19 == null) {
					z19 = 0.;
				}
				if(y19 == null) {
					y19 = 0.;
				}
				if(x19 == null) {
					x19 = 0.;
				}
				var _this_x6 = x19;
				var _this_y6 = y19;
				var _this_z6 = z19;
				var mag3 = _this_x6 * _this_x6 + _this_y6 * _this_y6 + _this_z6 * _this_z6;
				var min = mag1;
				c = c1;
				if(mag2 < min) {
					min = mag2;
					c = c2;
				}
				if(mag3 < min) {
					min = mag3;
					c = c3;
				}
			}
			var dx = c.x - p_x;
			var dy = c.y - p_y;
			var dz = c.z - p_z;
			var distSq = dx * dx + dy * dy + dz * dz;
			if(distSq < minDistSq) {
				closest = c;
				minDistSq = distSq;
			}
		}
		var x = closest.x;
		var y = closest.y;
		var z = closest.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,rayIntersection: function(r,bestMatch) {
		var i = this.startIndex;
		var x = r.lx;
		var y = r.ly;
		var z = r.lz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var rdir_x = x;
		var rdir_y = y;
		var rdir_z = z;
		var x = r.px;
		var y = r.py;
		var z = r.pz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var r0_x = x;
		var r0_y = y;
		var r0_z = z;
		var best = -1.;
		var _g = 0;
		var _g1 = this.triCount;
		while(_g < _g1) {
			var t = _g++;
			var i0 = this.indexes[i++] * 3;
			var x = this.buffer[i0++];
			var y = this.buffer[i0++];
			var z = this.buffer[i0];
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var p0_x = x;
			var p0_y = y;
			var p0_z = z;
			var i1 = this.indexes[i++] * 3;
			var x1 = this.buffer[i1++];
			var y1 = this.buffer[i1++];
			var z1 = this.buffer[i1];
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var p1_x = x1;
			var p1_y = y1;
			var p1_z = z1;
			var i2 = this.indexes[i++] * 3;
			var x2 = this.buffer[i2++];
			var y2 = this.buffer[i2++];
			var z2 = this.buffer[i2];
			if(z2 == null) {
				z2 = 0.;
			}
			if(y2 == null) {
				y2 = 0.;
			}
			if(x2 == null) {
				x2 = 0.;
			}
			var p2_x = x2;
			var p2_y = y2;
			var p2_z = z2;
			var x3 = p1_x - p0_x;
			var y3 = p1_y - p0_y;
			var z3 = p1_z - p0_z;
			if(z3 == null) {
				z3 = 0.;
			}
			if(y3 == null) {
				y3 = 0.;
			}
			if(x3 == null) {
				x3 = 0.;
			}
			var e1_x = x3;
			var e1_y = y3;
			var e1_z = z3;
			var x4 = p2_x - p0_x;
			var y4 = p2_y - p0_y;
			var z4 = p2_z - p0_z;
			if(z4 == null) {
				z4 = 0.;
			}
			if(y4 == null) {
				y4 = 0.;
			}
			if(x4 == null) {
				x4 = 0.;
			}
			var e2_x = x4;
			var e2_y = y4;
			var e2_z = z4;
			var x5 = rdir_y * e2_z - rdir_z * e2_y;
			var y5 = rdir_z * e2_x - rdir_x * e2_z;
			var z5 = rdir_x * e2_y - rdir_y * e2_x;
			if(z5 == null) {
				z5 = 0.;
			}
			if(y5 == null) {
				y5 = 0.;
			}
			if(x5 == null) {
				x5 = 0.;
			}
			var p_x = x5;
			var p_y = y5;
			var p_z = z5;
			var det = e1_x * p_x + e1_y * p_y + e1_z * p_z;
			if(det < 1e-10) {
				continue;
			}
			var invDet = 1 / det;
			var x6 = r0_x - p0_x;
			var y6 = r0_y - p0_y;
			var z6 = r0_z - p0_z;
			if(z6 == null) {
				z6 = 0.;
			}
			if(y6 == null) {
				y6 = 0.;
			}
			if(x6 == null) {
				x6 = 0.;
			}
			var T_x = x6;
			var T_y = y6;
			var T_z = z6;
			var u = (T_x * p_x + T_y * p_y + T_z * p_z) * invDet;
			if(u < 0 || u > 1) {
				continue;
			}
			var x7 = T_y * e1_z - T_z * e1_y;
			var y7 = T_z * e1_x - T_x * e1_z;
			var z7 = T_x * e1_y - T_y * e1_x;
			if(z7 == null) {
				z7 = 0.;
			}
			if(y7 == null) {
				y7 = 0.;
			}
			if(x7 == null) {
				x7 = 0.;
			}
			var q_x = x7;
			var q_y = y7;
			var q_z = z7;
			var v = (rdir_x * q_x + rdir_y * q_y + rdir_z * q_z) * invDet;
			if(v < 0 || u + v > 1) {
				continue;
			}
			var t1 = (e2_x * q_x + e2_y * q_y + e2_z * q_z) * invDet;
			if(t1 < 1e-10) {
				continue;
			}
			if(!bestMatch) {
				return t1;
			}
			if(best < 0 || t1 < best) {
				best = t1;
			}
		}
		return best;
	}
	,makeDebugObj: function() {
		var points = [];
		var idx = new Array(0);
		var i = this.startIndex;
		var _g = 0;
		var _g1 = this.triCount;
		while(_g < _g1) {
			var t = _g++;
			idx.push(this.indexes[i++]);
			idx.push(this.indexes[i++]);
			idx.push(this.indexes[i++]);
		}
		i = 0;
		while(i < this.buffer.length) {
			var x = this.buffer[i++];
			var y = this.buffer[i++];
			var z = this.buffer[i++];
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			points.push(new h3d_VectorImpl(x,y,z));
		}
		var prim = new h3d_prim_Polygon(points,idx);
		prim.addNormals();
		return new h3d_scene_Mesh(prim);
	}
	,__class__: h3d_col_PolygonBuffer
});
var h3d_col_SkinCollider = function(obj,col) {
	this.lastBoundsFrame = -1;
	this.lastFrame = -1;
	this.obj = obj;
	this.col = col;
	this.transform = new h3d_col_PolygonBuffer();
	var tmp = this.transform;
	var this1 = col.buffer;
	var r = new Array(this1.length);
	haxe_ds_Vector.blit(this1,0,r,0,this1.length);
	tmp.setData(r,col.indexes,col.startIndex,col.triCount);
	this.currentBounds = new h3d_col_Bounds();
};
$hxClasses["h3d.col.SkinCollider"] = h3d_col_SkinCollider;
h3d_col_SkinCollider.__name__ = "h3d.col.SkinCollider";
h3d_col_SkinCollider.__super__ = h3d_col_Collider;
h3d_col_SkinCollider.prototype = $extend(h3d_col_Collider.prototype,{
	contains: function(p) {
		this.checkBounds();
		var _this = this.currentBounds;
		if(!(p.x >= _this.xMin && p.x < _this.xMax && p.y >= _this.yMin && p.y < _this.yMax && p.z >= _this.zMin && p.z < _this.zMax)) {
			return false;
		}
		this.applyTransform();
		return this.transform.contains(p);
	}
	,inFrustum: function(p,m) {
		this.checkBounds();
		var _this = this.currentBounds;
		if(m != null) {
			throw haxe_Exception.thrown("Not implemented");
		}
		if(!p.hasBounds(_this)) {
			return false;
		}
		if(m != null) {
			throw haxe_Exception.thrown("Not implemented");
		}
		this.applyTransform();
		return this.transform.inFrustum(p);
	}
	,inSphere: function(s) {
		this.checkBounds();
		var _this = this.currentBounds;
		var x = s.x;
		var y = s.y;
		var z = s.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var a = _this.xMin;
		var a1 = s.x;
		var b = _this.xMax;
		var b1 = a1 > b ? b : a1;
		var x = a < b1 ? b1 : a;
		var a = _this.yMin;
		var a1 = s.y;
		var b = _this.yMax;
		var b1 = a1 > b ? b : a1;
		var y = a < b1 ? b1 : a;
		var a = _this.zMin;
		var a1 = s.z;
		var b = _this.zMax;
		var b1 = a1 > b ? b : a1;
		var z = a < b1 ? b1 : a;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var p_x = x1;
		var p_y = y1;
		var p_z = z1;
		var dx = p_x - _this_x;
		var dy = p_y - _this_y;
		var dz = p_z - _this_z;
		if(!(dx * dx + dy * dy + dz * dz < s.r * s.r)) {
			return false;
		}
		this.applyTransform();
		throw haxe_Exception.thrown("Not implemented");
	}
	,rayIntersection: function(r,bestMatch) {
		this.checkBounds();
		if(this.currentBounds.rayIntersection(r,false) < 0) {
			return -1.;
		}
		this.applyTransform();
		return this.transform.rayIntersection(r,bestMatch);
	}
	,dimension: function() {
		var _this = this.currentBounds;
		var a = _this.xMax - _this.xMin;
		var a1 = _this.yMax - _this.yMin;
		var b = _this.zMax - _this.zMin;
		var b1 = a1 < b ? b : a1;
		if(a < b1) {
			return b1;
		} else {
			return a;
		}
	}
	,checkBounds: function() {
		if(!this.obj.jointsUpdated && this.lastBoundsFrame == this.obj.lastFrame) {
			return;
		}
		this.lastBoundsFrame = this.obj.lastFrame;
		this.obj.syncJoints();
		var _this = this.currentBounds;
		_this.xMin = 1e20;
		_this.xMax = -1e20;
		_this.yMin = 1e20;
		_this.yMax = -1e20;
		_this.zMin = 1e20;
		_this.zMax = -1e20;
		this.obj.addBoundsRec(this.currentBounds,null);
	}
	,applyTransform: function() {
		if(!this.obj.jointsUpdated && this.lastFrame == this.obj.lastFrame) {
			return;
		}
		this.lastFrame = this.obj.lastFrame;
		this.obj.syncJoints();
		var j = 0;
		var v = 0;
		var nbones = this.obj.skinData.bonesPerVertex;
		var _g = 0;
		var _g1 = this.obj.skinData.vertexCount;
		while(_g < _g1) {
			var i = _g++;
			var px = 0.;
			var py = 0.;
			var pz = 0.;
			var x = this.col.buffer[v];
			var y = this.col.buffer[v + 1];
			var z = this.col.buffer[v + 2];
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var _this_x = x1;
			var _this_y = y1;
			var _this_z = z1;
			var _g2 = 0;
			var _g3 = nbones;
			while(_g2 < _g3) {
				var k = _g2++;
				var w = this.obj.skinData.vertexWeights[j];
				if(w == 0) {
					++j;
					continue;
				}
				var bid = this.obj.skinData.vertexJoints[j++];
				var x2 = _this_x;
				var y2 = _this_y;
				var z2 = _this_z;
				if(z2 == null) {
					z2 = 0.;
				}
				if(y2 == null) {
					y2 = 0.;
				}
				if(x2 == null) {
					x2 = 0.;
				}
				var x3 = x2;
				var y3 = y2;
				var z3 = z2;
				if(z3 == null) {
					z3 = 0.;
				}
				if(y3 == null) {
					y3 = 0.;
				}
				if(x3 == null) {
					x3 = 0.;
				}
				var p2_x = x3;
				var p2_y = y3;
				var p2_z = z3;
				var m = this.obj.currentPalette[bid];
				var px1 = p2_x * m._11 + p2_y * m._21 + p2_z * m._31 + m._41;
				var py1 = p2_x * m._12 + p2_y * m._22 + p2_z * m._32 + m._42;
				var pz1 = p2_x * m._13 + p2_y * m._23 + p2_z * m._33 + m._43;
				p2_x = px1;
				p2_y = py1;
				p2_z = pz1;
				px += p2_x * w;
				py += p2_y * w;
				pz += p2_z * w;
			}
			this.transform.buffer[v++] = px;
			this.transform.buffer[v++] = py;
			this.transform.buffer[v++] = pz;
		}
	}
	,closestPoint: function(p) {
		throw haxe_Exception.thrown("Not implemented");
	}
	,makeDebugObj: function() {
		return new h3d_col_SkinColliderDebugObj(this);
	}
	,__class__: h3d_col_SkinCollider
});
var h3d_scene_Object = function(parent) {
	this.prevAbsPosFrame = -1;
	this.flags = 32768;
	this.absPos = new h3d_MatrixImpl();
	this.absPos.identity();
	this.x = 0;
	var f = 1;
	var b = true;
	if(b) {
		this.flags |= f;
	} else {
		this.flags &= ~f;
	}
	var c = b;
	if(c && (this.flags & 131072) != 0) {
		var f = 262144;
		this.flags |= f;
	}
	this.y = 0;
	var f = 1;
	var b = true;
	if(b) {
		this.flags |= f;
	} else {
		this.flags &= ~f;
	}
	var c = b;
	if(c && (this.flags & 131072) != 0) {
		var f = 262144;
		this.flags |= f;
	}
	this.z = 0;
	var f = 1;
	var b = true;
	if(b) {
		this.flags |= f;
	} else {
		this.flags &= ~f;
	}
	var c = b;
	if(c && (this.flags & 131072) != 0) {
		var f = 262144;
		this.flags |= f;
	}
	this.scaleX = 1;
	var f = 1;
	var b = true;
	if(b) {
		this.flags |= f;
	} else {
		this.flags &= ~f;
	}
	var c = b;
	if(c && (this.flags & 131072) != 0) {
		var f = 262144;
		this.flags |= f;
	}
	this.scaleY = 1;
	var f = 1;
	var b = true;
	if(b) {
		this.flags |= f;
	} else {
		this.flags &= ~f;
	}
	var c = b;
	if(c && (this.flags & 131072) != 0) {
		var f = 262144;
		this.flags |= f;
	}
	this.scaleZ = 1;
	var f = 1;
	var b = true;
	if(b) {
		this.flags |= f;
	} else {
		this.flags &= ~f;
	}
	var c = b;
	if(c && (this.flags & 131072) != 0) {
		var f = 262144;
		this.flags |= f;
	}
	this.qRot = new h3d_Quat();
	var f = 1;
	var b = this.follow != null;
	if(b) {
		this.flags |= f;
	} else {
		this.flags &= ~f;
	}
	var c = b;
	if(c && (this.flags & 131072) != 0) {
		var f = 262144;
		this.flags |= f;
	}
	var f = 2;
	this.flags |= f;
	this.children = [];
	if(parent != null) {
		parent.addChild(this);
	}
};
$hxClasses["h3d.scene.Object"] = h3d_scene_Object;
h3d_scene_Object.__name__ = "h3d.scene.Object";
h3d_scene_Object.prototype = {
	set_cullingCollider: function(c) {
		this.cullingCollider = c;
		var f = 4096;
		this.flags &= ~f;
		return c;
	}
	,get_visible: function() {
		return (this.flags & 2) != 0;
	}
	,get_allocated: function() {
		return (this.flags & 32) != 0;
	}
	,get_posChanged: function() {
		return (this.flags & 1) != 0;
	}
	,get_culled: function() {
		return (this.flags & 4) != 0;
	}
	,get_followPositionOnly: function() {
		return (this.flags & 8) != 0;
	}
	,get_lightCameraCenter: function() {
		return (this.flags & 16) != 0;
	}
	,get_alwaysSyncAnimation: function() {
		return (this.flags & 64) != 0;
	}
	,get_inheritCulled: function() {
		return (this.flags & 128) != 0;
	}
	,get_ignoreBounds: function() {
		return (this.flags & 512) != 0;
	}
	,get_ignoreCollide: function() {
		return (this.flags & 1024) != 0;
	}
	,get_modelRoot: function() {
		return (this.flags & 256) != 0;
	}
	,get_ignoreParentTransform: function() {
		return (this.flags & 2048) != 0;
	}
	,get_cullingColliderInherited: function() {
		return (this.flags & 4096) != 0;
	}
	,get_fixedPosition: function() {
		return (this.flags & 8192) != 0;
	}
	,get_alwaysSync: function() {
		return (this.flags & 32768) != 0;
	}
	,get_drawn: function() {
		return (this.flags & 65536) != 0;
	}
	,set_posChanged: function(b) {
		var f = 1;
		var b1 = b || this.follow != null;
		if(b1) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var c = b1;
		if(c && (this.flags & 131072) != 0) {
			var f = 262144;
			this.flags |= f;
		}
		return c;
	}
	,set_culled: function(b) {
		var f = 4;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		return b;
	}
	,set_visible: function(b) {
		var f = 2;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		return b;
	}
	,set_allocated: function(b) {
		var f = 32;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		return b;
	}
	,set_followPositionOnly: function(b) {
		var f = 8;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		return b;
	}
	,set_lightCameraCenter: function(b) {
		var f = 16;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		return b;
	}
	,set_alwaysSyncAnimation: function(b) {
		var f = 64;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		return b;
	}
	,set_ignoreBounds: function(b) {
		var f = 512;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		return b;
	}
	,set_inheritCulled: function(b) {
		var f = 128;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		return b;
	}
	,set_ignoreCollide: function(b) {
		var f = 1024;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		return b;
	}
	,set_modelRoot: function(b) {
		var f = 256;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		return b;
	}
	,set_ignoreParentTransform: function(b) {
		if(b != ((this.flags & 2048) != 0)) {
			var f = 1;
			var b1 = true;
			if(b1) {
				this.flags |= f;
			} else {
				this.flags &= ~f;
			}
			var c = b1;
			if(c && (this.flags & 131072) != 0) {
				var f = 262144;
				this.flags |= f;
			}
		}
		var f = 2048;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		return b;
	}
	,set_cullingColliderInherited: function(b) {
		var f = 4096;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		return b;
	}
	,set_fixedPosition: function(b) {
		var f = 8192;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		return b;
	}
	,set_alwaysSync: function(b) {
		var f = 32768;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		return b;
	}
	,set_drawn: function(b) {
		var f = 65536;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		return b;
	}
	,playAnimation: function(a) {
		return this.currentAnimation = a.createInstance(this);
	}
	,switchToAnimation: function(a) {
		return this.currentAnimation = a;
	}
	,stopAnimation: function(recursive) {
		if(recursive == null) {
			recursive = false;
		}
		this.currentAnimation = null;
		if(recursive) {
			var _g = 0;
			var _g1 = this.children;
			while(_g < _g1.length) {
				var c = _g1[_g];
				++_g;
				c.stopAnimation(true);
			}
		}
	}
	,applyAnimationTransform: function(recursive) {
		if(recursive == null) {
			recursive = true;
		}
		if(this.defaultTransform != null) {
			var _this = this.defaultTransform;
			var x = 0.;
			var y = 0.;
			var z = 0.;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var s_x = x;
			var s_y = y;
			var s_z = z;
			s_x = Math.sqrt(_this._11 * _this._11 + _this._12 * _this._12 + _this._13 * _this._13);
			s_y = Math.sqrt(_this._21 * _this._21 + _this._22 * _this._22 + _this._23 * _this._23);
			s_z = Math.sqrt(_this._31 * _this._31 + _this._32 * _this._32 + _this._33 * _this._33);
			if(_this._11 * (_this._22 * _this._33 - _this._23 * _this._32) + _this._12 * (_this._23 * _this._31 - _this._21 * _this._33) + _this._13 * (_this._21 * _this._32 - _this._22 * _this._31) < 0) {
				s_x *= -1;
				s_y *= -1;
				s_z *= -1;
			}
			var v = s_x;
			this.scaleX = v;
			var f = 1;
			var b = true;
			if(b) {
				this.flags |= f;
			} else {
				this.flags &= ~f;
			}
			var c = b;
			if(c && (this.flags & 131072) != 0) {
				var f = 262144;
				this.flags |= f;
			}
			var v = s_y;
			this.scaleY = v;
			var f = 1;
			var b = true;
			if(b) {
				this.flags |= f;
			} else {
				this.flags &= ~f;
			}
			var c = b;
			if(c && (this.flags & 131072) != 0) {
				var f = 262144;
				this.flags |= f;
			}
			var v = s_z;
			this.scaleZ = v;
			var f = 1;
			var b = true;
			if(b) {
				this.flags |= f;
			} else {
				this.flags &= ~f;
			}
			var c = b;
			if(c && (this.flags & 131072) != 0) {
				var f = 262144;
				this.flags |= f;
			}
			this.qRot.initRotateMatrix(this.defaultTransform);
			var v = this.defaultTransform._41;
			this.x = v;
			var f = 1;
			var b = true;
			if(b) {
				this.flags |= f;
			} else {
				this.flags &= ~f;
			}
			var c = b;
			if(c && (this.flags & 131072) != 0) {
				var f = 262144;
				this.flags |= f;
			}
			var v = this.defaultTransform._42;
			this.y = v;
			var f = 1;
			var b = true;
			if(b) {
				this.flags |= f;
			} else {
				this.flags &= ~f;
			}
			var c = b;
			if(c && (this.flags & 131072) != 0) {
				var f = 262144;
				this.flags |= f;
			}
			var v = this.defaultTransform._43;
			this.z = v;
			var f = 1;
			var b = true;
			if(b) {
				this.flags |= f;
			} else {
				this.flags &= ~f;
			}
			var c = b;
			if(c && (this.flags & 131072) != 0) {
				var f = 262144;
				this.flags |= f;
			}
			var v = null;
			this.defaultTransform = v;
			var f = 1;
			var b = true;
			if(b) {
				this.flags |= f;
			} else {
				this.flags &= ~f;
			}
			var c = b;
			if(c && (this.flags & 131072) != 0) {
				var f = 262144;
				this.flags |= f;
			}
		}
		if(recursive) {
			var _g = 0;
			var _g1 = this.children;
			while(_g < _g1.length) {
				var c = _g1[_g];
				++_g;
				c.applyAnimationTransform();
			}
		}
	}
	,getObjectsCount: function() {
		var k = 0;
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			k += c.getObjectsCount() + 1;
		}
		return k;
	}
	,getMaterialByName: function(name) {
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var o = _g1[_g];
			++_g;
			var m = o.getMaterialByName(name);
			if(m != null) {
				return m;
			}
		}
		return null;
	}
	,contains: function(o) {
		while(o != null) {
			o = o.parent;
			if(o == this) {
				return true;
			}
		}
		return false;
	}
	,find: function(f) {
		var v = f(this);
		if(v != null) {
			return v;
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var o = _g1[_g];
			++_g;
			var v = o.find(f);
			if(v != null) {
				return v;
			}
		}
		return null;
	}
	,findAll: function(f,arr) {
		if(arr == null) {
			arr = [];
		}
		var v = f(this);
		if(v != null) {
			arr.push(v);
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var o = _g1[_g];
			++_g;
			o.findAll(f,arr);
		}
		return arr;
	}
	,getMaterials: function(a,recursive) {
		if(recursive == null) {
			recursive = true;
		}
		if(a == null) {
			a = [];
		}
		if(recursive) {
			var _g = 0;
			var _g1 = this.children;
			while(_g < _g1.length) {
				var o = _g1[_g];
				++_g;
				o.getMaterials(a);
			}
		}
		return a;
	}
	,localToGlobal: function(pt) {
		this.syncPos();
		if(pt == null) {
			pt = new h3d_VectorImpl(0.,0.,0.);
		}
		var m = this.absPos;
		var px = pt.x * m._11 + pt.y * m._21 + pt.z * m._31 + m._41;
		var py = pt.x * m._12 + pt.y * m._22 + pt.z * m._32 + m._42;
		var pz = pt.x * m._13 + pt.y * m._23 + pt.z * m._33 + m._43;
		pt.x = px;
		pt.y = py;
		pt.z = pz;
		return pt;
	}
	,globalToLocal: function(pt) {
		var m = this.getInvPos();
		var px = pt.x * m._11 + pt.y * m._21 + pt.z * m._31 + m._41;
		var py = pt.x * m._12 + pt.y * m._22 + pt.z * m._32 + m._42;
		var pz = pt.x * m._13 + pt.y * m._23 + pt.z * m._33 + m._43;
		pt.x = px;
		pt.y = py;
		pt.z = pz;
		return pt;
	}
	,getInvPos: function() {
		this.syncPos();
		if(this.invPos == null) {
			this.invPos = new h3d_MatrixImpl();
			this.invPos._44 = 0;
		}
		if(this.invPos._44 == 0) {
			this.invPos.inverse3x4(this.absPos);
		}
		return this.invPos;
	}
	,getBounds: function(b,relativeTo) {
		if(b == null) {
			b = new h3d_col_Bounds();
		}
		if(this.parent != null && this.parent != relativeTo) {
			this.parent.syncPos();
		}
		this.addBoundsRec(b,relativeTo == null ? null : relativeTo.getInvPos());
		return b;
	}
	,addBoundsRec: function(b,relativeTo) {
		if((this.flags & 1) != 0) {
			var _g = 0;
			var _g1 = this.children;
			while(_g < _g1.length) {
				var c = _g1[_g];
				++_g;
				var f = 1;
				var b1 = true;
				if(b1) {
					c.flags |= f;
				} else {
					c.flags &= ~f;
				}
				var c1 = b1;
				if(c1 && (c.flags & 131072) != 0) {
					var f1 = 262144;
					c.flags |= f1;
				}
			}
			var f = 1;
			var b1 = this.follow != null;
			if(b1) {
				this.flags |= f;
			} else {
				this.flags &= ~f;
			}
			var c = b1;
			if(c && (this.flags & 131072) != 0) {
				var f = 262144;
				this.flags |= f;
			}
			this.calcAbsPos();
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			c.addBoundsRec(b,relativeTo);
		}
	}
	,getMeshes: function(out) {
		if(out == null) {
			out = [];
		}
		var m = ((this) instanceof h3d_scene_Mesh) ? this : null;
		if(m != null) {
			out.push(m);
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			c.getMeshes(out);
		}
		return out;
	}
	,getMeshByName: function(name) {
		var value = this.getObjectByName(name);
		if(((value) instanceof h3d_scene_Mesh)) {
			return value;
		} else {
			return null;
		}
	}
	,getObjectByName: function(name) {
		if(this.name == name) {
			return this;
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			var o = c.getObjectByName(name);
			if(o != null) {
				return o;
			}
		}
		return null;
	}
	,clone: function(o) {
		if(o == null) {
			o = new h3d_scene_Object();
		}
		if(js_Boot.getClass(o) != js_Boot.getClass(this)) {
			throw haxe_Exception.thrown(Std.string(this) + " is missing clone()");
		}
		var v = this.x;
		o.x = v;
		var f = 1;
		var b = true;
		if(b) {
			o.flags |= f;
		} else {
			o.flags &= ~f;
		}
		var c = b;
		if(c && (o.flags & 131072) != 0) {
			var f = 262144;
			o.flags |= f;
		}
		var v = this.y;
		o.y = v;
		var f = 1;
		var b = true;
		if(b) {
			o.flags |= f;
		} else {
			o.flags &= ~f;
		}
		var c = b;
		if(c && (o.flags & 131072) != 0) {
			var f = 262144;
			o.flags |= f;
		}
		var v = this.z;
		o.z = v;
		var f = 1;
		var b = true;
		if(b) {
			o.flags |= f;
		} else {
			o.flags &= ~f;
		}
		var c = b;
		if(c && (o.flags & 131072) != 0) {
			var f = 262144;
			o.flags |= f;
		}
		var v = this.scaleX;
		o.scaleX = v;
		var f = 1;
		var b = true;
		if(b) {
			o.flags |= f;
		} else {
			o.flags &= ~f;
		}
		var c = b;
		if(c && (o.flags & 131072) != 0) {
			var f = 262144;
			o.flags |= f;
		}
		var v = this.scaleY;
		o.scaleY = v;
		var f = 1;
		var b = true;
		if(b) {
			o.flags |= f;
		} else {
			o.flags &= ~f;
		}
		var c = b;
		if(c && (o.flags & 131072) != 0) {
			var f = 262144;
			o.flags |= f;
		}
		var v = this.scaleZ;
		o.scaleZ = v;
		var f = 1;
		var b = true;
		if(b) {
			o.flags |= f;
		} else {
			o.flags &= ~f;
		}
		var c = b;
		if(c && (o.flags & 131072) != 0) {
			var f = 262144;
			o.flags |= f;
		}
		var _this = o.qRot;
		var q = this.qRot;
		_this.x = q.x;
		_this.y = q.y;
		_this.z = q.z;
		_this.w = q.w;
		o.name = this.name;
		o.set_follow(this.follow);
		var b = (this.flags & 8) != 0;
		var f = 8;
		if(b) {
			o.flags |= f;
		} else {
			o.flags &= ~f;
		}
		var b = (this.flags & 2) != 0;
		var f = 2;
		if(b) {
			o.flags |= f;
		} else {
			o.flags &= ~f;
		}
		if(this.defaultTransform != null) {
			var v = this.defaultTransform.clone();
			o.defaultTransform = v;
			var f = 1;
			var b = true;
			if(b) {
				o.flags |= f;
			} else {
				o.flags &= ~f;
			}
			var c = b;
			if(c && (o.flags & 131072) != 0) {
				var f = 262144;
				o.flags |= f;
			}
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			var c1 = c.clone();
			c1.parent = o;
			o.children.push(c1);
		}
		return o;
	}
	,addChild: function(o) {
		this.addChildAt(o,this.children.length);
	}
	,addChildAt: function(o,pos) {
		if(pos < 0) {
			pos = 0;
		}
		if(pos > this.children.length) {
			pos = this.children.length;
		}
		var p = this;
		while(p != null) {
			if(p == o) {
				throw haxe_Exception.thrown("Recursive addChild");
			}
			p = p.parent;
		}
		if(o.parent != null) {
			var old = (o.flags & 32) != 0;
			var f = 32;
			o.flags &= ~f;
			o.parent.removeChild(o);
			var f = 32;
			if(old) {
				o.flags |= f;
			} else {
				o.flags &= ~f;
			}
		}
		this.children.splice(pos,0,o);
		if((this.flags & 32) == 0 && (o.flags & 32) != 0) {
			o.onRemove();
		}
		o.parent = this;
		var f = 1;
		var b = true;
		if(b) {
			o.flags |= f;
		} else {
			o.flags &= ~f;
		}
		var c = b;
		if(c && (o.flags & 131072) != 0) {
			var f = 262144;
			o.flags |= f;
		}
		if((this.flags & 32) != 0) {
			if((o.flags & 32) == 0) {
				o.onAdd();
			} else {
				o.onParentChanged();
			}
		}
	}
	,iterVisibleMeshes: function(callb) {
		if((this.flags & 2) == 0 || (this.flags & 4) != 0 && (this.flags & 128) != 0) {
			return;
		}
		if((this.flags & 4) == 0) {
			var m = ((this) instanceof h3d_scene_Mesh) ? this : null;
			if(m != null) {
				callb(m);
			}
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var o = _g1[_g];
			++_g;
			o.iterVisibleMeshes(callb);
		}
	}
	,onParentChanged: function() {
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			c.onParentChanged();
		}
	}
	,onAdd: function() {
		var f = 32;
		this.flags |= f;
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			c.onAdd();
		}
	}
	,onRemove: function() {
		var f = 32;
		this.flags &= ~f;
		var i = this.children.length - 1;
		while(i >= 0) this.children[i--].onRemove();
	}
	,removeChild: function(o) {
		if(HxOverrides.remove(this.children,o)) {
			if((o.flags & 32) != 0) {
				o.onRemove();
			}
			o.parent = null;
			var f = 1;
			var b = true;
			if(b) {
				o.flags |= f;
			} else {
				o.flags &= ~f;
			}
			var c = b;
			if(c && (o.flags & 131072) != 0) {
				var f = 262144;
				o.flags |= f;
			}
		}
	}
	,removeChildren: function() {
		while(this.children.length > 0) this.removeChild(this.children[0]);
	}
	,remove: function() {
		if(this.parent != null) {
			this.parent.removeChild(this);
		}
	}
	,getScene: function() {
		var p = this;
		while(p.parent != null) p = p.parent;
		if(((p) instanceof h3d_scene_Scene)) {
			return p;
		} else {
			return null;
		}
	}
	,getAbsPos: function() {
		this.syncPos();
		return this.absPos;
	}
	,getRelPos: function(obj) {
		if(obj == null) {
			return this.getAbsPos();
		}
		this.syncPos();
		var m = new h3d_MatrixImpl();
		m.multiply(this.absPos,obj.getInvPos());
		return m;
	}
	,isMesh: function() {
		return (((this) instanceof h3d_scene_Mesh) ? this : null) != null;
	}
	,toMesh: function() {
		var m = ((this) instanceof h3d_scene_Mesh) ? this : null;
		if(m != null) {
			return m;
		}
		throw haxe_Exception.thrown(Std.string(this) + " is not a Mesh");
	}
	,getCollider: function() {
		if((this.flags & 1024) != 0) {
			return null;
		}
		var colliders = [];
		var col = this.getGlobalCollider();
		if(col != null) {
			colliders.push(col);
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var obj = _g1[_g];
			++_g;
			var c = obj.getCollider();
			if(c == null) {
				continue;
			}
			var cgrp = ((c) instanceof h3d_col_GroupCollider) ? c : null;
			if(cgrp != null) {
				var _g2 = 0;
				var _g3 = cgrp.colliders;
				while(_g2 < _g3.length) {
					var c1 = _g3[_g2];
					++_g2;
					colliders.push(c1);
				}
			} else {
				colliders.push(c);
			}
		}
		if(colliders.length == 0) {
			return null;
		}
		if(colliders.length == 1) {
			return colliders[0];
		}
		return new h3d_col_GroupCollider(colliders);
	}
	,getGlobalCollider: function() {
		if((this.flags & 1024) != 0) {
			return null;
		}
		var col = this.getLocalCollider();
		if(col == null) {
			return null;
		} else {
			return new h3d_col_ObjectCollider(this,col);
		}
	}
	,getLocalCollider: function() {
		return null;
	}
	,draw: function(ctx) {
	}
	,set_follow: function(v) {
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var c = b;
		if(c && (this.flags & 131072) != 0) {
			var f = 262144;
			this.flags |= f;
		}
		return this.follow = v;
	}
	,calcPrevAbsPos: function() {
		if(this.prevAbsPosFrame == -1) {
			this.prevAbsPos = null;
		} else if(this.prevAbsPosFrame < hxd_Timer.frameCount) {
			this.prevAbsPosFrame = hxd_Timer.frameCount;
			if(this.prevAbsPos == null) {
				this.prevAbsPos = this.absPos.clone();
			} else {
				this.prevAbsPos.load(this.absPos);
			}
		}
	}
	,calcAbsPos: function() {
		this.calcPrevAbsPos();
		this.qRot.toMatrix(this.absPos);
		this.absPos._11 *= this.scaleX;
		this.absPos._12 *= this.scaleX;
		this.absPos._13 *= this.scaleX;
		this.absPos._21 *= this.scaleY;
		this.absPos._22 *= this.scaleY;
		this.absPos._23 *= this.scaleY;
		this.absPos._31 *= this.scaleZ;
		this.absPos._32 *= this.scaleZ;
		this.absPos._33 *= this.scaleZ;
		this.absPos._41 = this.x;
		this.absPos._42 = this.y;
		this.absPos._43 = this.z;
		if(this.follow != null) {
			this.follow.syncPos();
			if((this.flags & 8) != 0) {
				var _this = this.absPos;
				var a = this.absPos;
				var b = this.parent.absPos;
				var m11 = a._11;
				var m12 = a._12;
				var m13 = a._13;
				var m21 = a._21;
				var m22 = a._22;
				var m23 = a._23;
				var a31 = a._31;
				var a32 = a._32;
				var a33 = a._33;
				var a41 = a._41;
				var a42 = a._42;
				var a43 = a._43;
				var b11 = b._11;
				var b12 = b._12;
				var b13 = b._13;
				var b21 = b._21;
				var b22 = b._22;
				var b23 = b._23;
				var b31 = b._31;
				var b32 = b._32;
				var b33 = b._33;
				var b41 = b._41;
				var b42 = b._42;
				var b43 = b._43;
				_this._11 = m11 * b11 + m12 * b21 + m13 * b31;
				_this._12 = m11 * b12 + m12 * b22 + m13 * b32;
				_this._13 = m11 * b13 + m12 * b23 + m13 * b33;
				_this._14 = 0;
				_this._21 = m21 * b11 + m22 * b21 + m23 * b31;
				_this._22 = m21 * b12 + m22 * b22 + m23 * b32;
				_this._23 = m21 * b13 + m22 * b23 + m23 * b33;
				_this._24 = 0;
				_this._31 = a31 * b11 + a32 * b21 + a33 * b31;
				_this._32 = a31 * b12 + a32 * b22 + a33 * b32;
				_this._33 = a31 * b13 + a32 * b23 + a33 * b33;
				_this._34 = 0;
				_this._41 = a41 * b11 + a42 * b21 + a43 * b31 + b41;
				_this._42 = a41 * b12 + a42 * b22 + a43 * b32 + b42;
				_this._43 = a41 * b13 + a42 * b23 + a43 * b33 + b43;
				_this._44 = 1;
				this.absPos._41 = this.x + this.follow.absPos._41;
				this.absPos._42 = this.y + this.follow.absPos._42;
				this.absPos._43 = this.z + this.follow.absPos._43;
			} else {
				this.absPos.multiply3x4(this.absPos,this.follow.absPos);
			}
		} else if(this.parent != null && (this.flags & 2048) == 0) {
			var _this = this.absPos;
			var a = this.absPos;
			var b = this.parent.absPos;
			var m11 = a._11;
			var m12 = a._12;
			var m13 = a._13;
			var m21 = a._21;
			var m22 = a._22;
			var m23 = a._23;
			var a31 = a._31;
			var a32 = a._32;
			var a33 = a._33;
			var a41 = a._41;
			var a42 = a._42;
			var a43 = a._43;
			var b11 = b._11;
			var b12 = b._12;
			var b13 = b._13;
			var b21 = b._21;
			var b22 = b._22;
			var b23 = b._23;
			var b31 = b._31;
			var b32 = b._32;
			var b33 = b._33;
			var b41 = b._41;
			var b42 = b._42;
			var b43 = b._43;
			_this._11 = m11 * b11 + m12 * b21 + m13 * b31;
			_this._12 = m11 * b12 + m12 * b22 + m13 * b32;
			_this._13 = m11 * b13 + m12 * b23 + m13 * b33;
			_this._14 = 0;
			_this._21 = m21 * b11 + m22 * b21 + m23 * b31;
			_this._22 = m21 * b12 + m22 * b22 + m23 * b32;
			_this._23 = m21 * b13 + m22 * b23 + m23 * b33;
			_this._24 = 0;
			_this._31 = a31 * b11 + a32 * b21 + a33 * b31;
			_this._32 = a31 * b12 + a32 * b22 + a33 * b32;
			_this._33 = a31 * b13 + a32 * b23 + a33 * b33;
			_this._34 = 0;
			_this._41 = a41 * b11 + a42 * b21 + a43 * b31 + b41;
			_this._42 = a41 * b12 + a42 * b22 + a43 * b32 + b42;
			_this._43 = a41 * b13 + a42 * b23 + a43 * b33 + b43;
			_this._44 = 1;
		}
		if(this.defaultTransform != null) {
			var _this = this.absPos;
			var a = this.defaultTransform;
			var b = this.absPos;
			var m11 = a._11;
			var m12 = a._12;
			var m13 = a._13;
			var m21 = a._21;
			var m22 = a._22;
			var m23 = a._23;
			var a31 = a._31;
			var a32 = a._32;
			var a33 = a._33;
			var a41 = a._41;
			var a42 = a._42;
			var a43 = a._43;
			var b11 = b._11;
			var b12 = b._12;
			var b13 = b._13;
			var b21 = b._21;
			var b22 = b._22;
			var b23 = b._23;
			var b31 = b._31;
			var b32 = b._32;
			var b33 = b._33;
			var b41 = b._41;
			var b42 = b._42;
			var b43 = b._43;
			_this._11 = m11 * b11 + m12 * b21 + m13 * b31;
			_this._12 = m11 * b12 + m12 * b22 + m13 * b32;
			_this._13 = m11 * b13 + m12 * b23 + m13 * b33;
			_this._14 = 0;
			_this._21 = m21 * b11 + m22 * b21 + m23 * b31;
			_this._22 = m21 * b12 + m22 * b22 + m23 * b32;
			_this._23 = m21 * b13 + m22 * b23 + m23 * b33;
			_this._24 = 0;
			_this._31 = a31 * b11 + a32 * b21 + a33 * b31;
			_this._32 = a31 * b12 + a32 * b22 + a33 * b32;
			_this._33 = a31 * b13 + a32 * b23 + a33 * b33;
			_this._34 = 0;
			_this._41 = a41 * b11 + a42 * b21 + a43 * b31 + b41;
			_this._42 = a41 * b12 + a42 * b22 + a43 * b32 + b42;
			_this._43 = a41 * b13 + a42 * b23 + a43 * b33 + b43;
			_this._44 = 1;
		}
		if(this.invPos != null) {
			this.invPos._44 = 0;
		}
	}
	,sync: function(ctx) {
	}
	,syncRec: function(ctx) {
		if(this.currentAnimation != null) {
			var old = this.parent;
			var dt = ctx.elapsedTime;
			while(dt > 0 && this.currentAnimation != null) dt = this.currentAnimation.update(dt);
			if(this.currentAnimation != null && (ctx.visibleFlag && (this.flags & 2) != 0 && (this.flags & 4) == 0 || (this.flags & 64) != 0)) {
				this.currentAnimation.sync();
			}
			if(this.parent == null && old != null) {
				return;
			}
		}
		if((this.flags & 32768) == 0 && ((this.flags & 4) != 0 || (this.flags & 2) == 0 || !ctx.visibleFlag)) {
			return;
		}
		var old = ctx.visibleFlag;
		if((this.flags & 2) == 0 || (this.flags & 4) != 0 && (this.flags & 128) != 0) {
			ctx.visibleFlag = false;
		}
		if(ctx.cullingCollider != null && (this.cullingCollider == null || (this.flags & 4096) != 0)) {
			this.set_cullingCollider(ctx.cullingCollider);
			var f = 4096;
			this.flags |= f;
		} else if((this.flags & 4096) != 0) {
			this.set_cullingCollider(null);
		}
		var prevCollider = ctx.cullingCollider;
		if((this.flags & 128) != 0) {
			ctx.cullingCollider = this.cullingCollider;
		}
		var changed = (this.flags & 1) != 0;
		if(changed) {
			this.calcAbsPos();
		}
		if((this.flags & 8192) != 0) {
			if((this.flags & 16384) != 0 && !changed && !ctx.wasContextLost) {
				ctx.visibleFlag = old;
				ctx.cullingCollider = prevCollider;
				return;
			}
			var f = 16384;
			this.flags |= f;
		}
		var f = 262144;
		this.flags &= ~f;
		var f = 131072;
		this.flags |= f;
		this.sync(ctx);
		var f = 131072;
		this.flags &= ~f;
		changed = changed || (this.flags & 262144) != 0;
		if((this.flags & 262144) != 0) {
			this.calcAbsPos();
		}
		var f = 1;
		var b = this.follow != null;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var c = b;
		if(c && (this.flags & 131072) != 0) {
			var f = 262144;
			this.flags |= f;
		}
		this.lastFrame = ctx.frame;
		var p = 0;
		var len = this.children.length;
		while(p < len) {
			var c = this.children[p];
			if(c == null) {
				break;
			}
			if(c.lastFrame != ctx.frame) {
				if(changed) {
					var f = 1;
					var b = true;
					if(b) {
						c.flags |= f;
					} else {
						c.flags &= ~f;
					}
					var c1 = b;
					if(c1 && (c.flags & 131072) != 0) {
						var f1 = 262144;
						c.flags |= f1;
					}
				}
				c.syncRec(ctx);
			}
			if(this.children[p] != c) {
				p = 0;
				len = this.children.length;
			} else {
				++p;
			}
		}
		ctx.visibleFlag = old;
		ctx.cullingCollider = prevCollider;
	}
	,syncPos: function() {
		if(this.parent != null) {
			this.parent.syncPos();
		}
		if((this.flags & 1) != 0) {
			var f = 1;
			var b = this.follow != null;
			if(b) {
				this.flags |= f;
			} else {
				this.flags &= ~f;
			}
			var c = b;
			if(c && (this.flags & 131072) != 0) {
				var f = 262144;
				this.flags |= f;
			}
			this.calcAbsPos();
			var _g = 0;
			var _g1 = this.children;
			while(_g < _g1.length) {
				var c = _g1[_g];
				++_g;
				var f = 1;
				var b = true;
				if(b) {
					c.flags |= f;
				} else {
					c.flags &= ~f;
				}
				var c1 = b;
				if(c1 && (c.flags & 131072) != 0) {
					var f1 = 262144;
					c.flags |= f1;
				}
			}
		}
	}
	,emit: function(ctx) {
	}
	,emitRec: function(ctx) {
		if((this.flags & 2) == 0 || (this.flags & 4) != 0 && (this.flags & 128) != 0 && !ctx.computingStatic) {
			return;
		}
		if((this.flags & 1) != 0) {
			if(this.currentAnimation != null) {
				this.currentAnimation.sync();
			}
			var f = 1;
			var b = this.follow != null;
			if(b) {
				this.flags |= f;
			} else {
				this.flags &= ~f;
			}
			var c = b;
			if(c && (this.flags & 131072) != 0) {
				var f = 262144;
				this.flags |= f;
			}
			this.calcAbsPos();
			var _g = 0;
			var _g1 = this.children;
			while(_g < _g1.length) {
				var c = _g1[_g];
				++_g;
				var f = 1;
				var b = true;
				if(b) {
					c.flags |= f;
				} else {
					c.flags &= ~f;
				}
				var c1 = b;
				if(c1 && (c.flags & 131072) != 0) {
					var f1 = 262144;
					c.flags |= f1;
				}
			}
		}
		var prevForcedScreenRatio = ctx.forcedScreenRatio;
		if((this.flags & 65536) == 0 || !ctx.computeVelocity || (this.flags & 8192) != 0 || (this.flags & 4) != 0) {
			this.prevAbsPosFrame = -1;
		} else if(this.prevAbsPosFrame == -1) {
			this.prevAbsPosFrame = 0;
		}
		this.calcPrevAbsPos();
		if((this.flags & 4) == 0 || ctx.computingStatic) {
			this.emit(ctx);
			var f = 65536;
			this.flags &= ~f;
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			c.emitRec(ctx);
		}
		ctx.forcedScreenRatio = prevForcedScreenRatio;
	}
	,set_x: function(v) {
		this.x = v;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var c = b;
		if(c && (this.flags & 131072) != 0) {
			var f = 262144;
			this.flags |= f;
		}
		return v;
	}
	,set_y: function(v) {
		this.y = v;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var c = b;
		if(c && (this.flags & 131072) != 0) {
			var f = 262144;
			this.flags |= f;
		}
		return v;
	}
	,set_z: function(v) {
		this.z = v;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var c = b;
		if(c && (this.flags & 131072) != 0) {
			var f = 262144;
			this.flags |= f;
		}
		return v;
	}
	,set_scaleX: function(v) {
		this.scaleX = v;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var c = b;
		if(c && (this.flags & 131072) != 0) {
			var f = 262144;
			this.flags |= f;
		}
		return v;
	}
	,set_scaleY: function(v) {
		this.scaleY = v;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var c = b;
		if(c && (this.flags & 131072) != 0) {
			var f = 262144;
			this.flags |= f;
		}
		return v;
	}
	,set_scaleZ: function(v) {
		this.scaleZ = v;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var c = b;
		if(c && (this.flags & 131072) != 0) {
			var f = 262144;
			this.flags |= f;
		}
		return v;
	}
	,set_defaultTransform: function(v) {
		this.defaultTransform = v;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var c = b;
		if(c && (this.flags & 131072) != 0) {
			var f = 262144;
			this.flags |= f;
		}
		return v;
	}
	,setPosition: function(x,y,z) {
		this.x = x;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var c = b;
		if(c && (this.flags & 131072) != 0) {
			var f = 262144;
			this.flags |= f;
		}
		this.y = y;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var c = b;
		if(c && (this.flags & 131072) != 0) {
			var f = 262144;
			this.flags |= f;
		}
		this.z = z;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var c = b;
		if(c && (this.flags & 131072) != 0) {
			var f = 262144;
			this.flags |= f;
		}
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var c = b;
		if(c && (this.flags & 131072) != 0) {
			var f = 262144;
			this.flags |= f;
		}
	}
	,setTransform: function(mat) {
		var _this = mat;
		var x = 0.;
		var y = 0.;
		var z = 0.;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var s_x = x;
		var s_y = y;
		var s_z = z;
		s_x = Math.sqrt(_this._11 * _this._11 + _this._12 * _this._12 + _this._13 * _this._13);
		s_y = Math.sqrt(_this._21 * _this._21 + _this._22 * _this._22 + _this._23 * _this._23);
		s_z = Math.sqrt(_this._31 * _this._31 + _this._32 * _this._32 + _this._33 * _this._33);
		if(_this._11 * (_this._22 * _this._33 - _this._23 * _this._32) + _this._12 * (_this._23 * _this._31 - _this._21 * _this._33) + _this._13 * (_this._21 * _this._32 - _this._22 * _this._31) < 0) {
			s_x *= -1;
			s_y *= -1;
			s_z *= -1;
		}
		var v = mat._41;
		this.x = v;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var c = b;
		if(c && (this.flags & 131072) != 0) {
			var f = 262144;
			this.flags |= f;
		}
		var v = mat._42;
		this.y = v;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var c = b;
		if(c && (this.flags & 131072) != 0) {
			var f = 262144;
			this.flags |= f;
		}
		var v = mat._43;
		this.z = v;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var c = b;
		if(c && (this.flags & 131072) != 0) {
			var f = 262144;
			this.flags |= f;
		}
		var v = s_x;
		this.scaleX = v;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var c = b;
		if(c && (this.flags & 131072) != 0) {
			var f = 262144;
			this.flags |= f;
		}
		var v = s_y;
		this.scaleY = v;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var c = b;
		if(c && (this.flags & 131072) != 0) {
			var f = 262144;
			this.flags |= f;
		}
		var v = s_z;
		this.scaleZ = v;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var c = b;
		if(c && (this.flags & 131072) != 0) {
			var f = 262144;
			this.flags |= f;
		}
		h3d_scene_Object.tmpMat.load(mat);
		h3d_scene_Object.tmpMat.prependScale(1.0 / s_x,1.0 / s_y,1.0 / s_z);
		this.qRot.initRotateMatrix(h3d_scene_Object.tmpMat);
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var c = b;
		if(c && (this.flags & 131072) != 0) {
			var f = 262144;
			this.flags |= f;
		}
	}
	,getTransform: function(mat) {
		if(mat == null) {
			mat = new h3d_MatrixImpl();
		}
		mat.initScale(this.scaleX,this.scaleY,this.scaleZ);
		this.qRot.toMatrix(h3d_scene_Object.tmpMat);
		mat.multiply3x4(mat,h3d_scene_Object.tmpMat);
		mat._41 = this.x;
		mat._42 = this.y;
		mat._43 = this.z;
		return mat;
	}
	,rotate: function(rx,ry,rz,qTmp) {
		if(qTmp == null) {
			qTmp = new h3d_Quat();
		}
		qTmp.initRotation(rx,ry,rz);
		this.qRot.multiply(qTmp,this.qRot);
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var c = b;
		if(c && (this.flags & 131072) != 0) {
			var f = 262144;
			this.flags |= f;
		}
	}
	,setRotation: function(rx,ry,rz) {
		this.qRot.initRotation(rx,ry,rz);
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var c = b;
		if(c && (this.flags & 131072) != 0) {
			var f = 262144;
			this.flags |= f;
		}
	}
	,setRotationAxis: function(ax,ay,az,angle) {
		this.qRot.initRotateAxis(ax,ay,az,angle);
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var c = b;
		if(c && (this.flags & 131072) != 0) {
			var f = 262144;
			this.flags |= f;
		}
	}
	,setDirection: function(v,up) {
		this.qRot.initDirection(v,up);
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var c = b;
		if(c && (this.flags & 131072) != 0) {
			var f = 262144;
			this.flags |= f;
		}
	}
	,getLocalDirection: function() {
		var _this = this.qRot;
		var x = 1 - 2 * (_this.y * _this.y + _this.z * _this.z);
		var y = 2 * (_this.x * _this.y + _this.z * _this.w);
		var z = 2 * (_this.x * _this.z - _this.y * _this.w);
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,getRotationQuat: function() {
		return this.qRot;
	}
	,setRotationQuat: function(q) {
		this.qRot = q;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var c = b;
		if(c && (this.flags & 131072) != 0) {
			var f = 262144;
			this.flags |= f;
		}
	}
	,scale: function(v) {
		var v1 = this.scaleX * v;
		this.scaleX = v1;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var c = b;
		if(c && (this.flags & 131072) != 0) {
			var f = 262144;
			this.flags |= f;
		}
		var v1 = this.scaleY * v;
		this.scaleY = v1;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var c = b;
		if(c && (this.flags & 131072) != 0) {
			var f = 262144;
			this.flags |= f;
		}
		var v1 = this.scaleZ * v;
		this.scaleZ = v1;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var c = b;
		if(c && (this.flags & 131072) != 0) {
			var f = 262144;
			this.flags |= f;
		}
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var c = b;
		if(c && (this.flags & 131072) != 0) {
			var f = 262144;
			this.flags |= f;
		}
	}
	,setScale: function(v) {
		this.scaleX = v;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var c = b;
		if(c && (this.flags & 131072) != 0) {
			var f = 262144;
			this.flags |= f;
		}
		this.scaleY = v;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var c = b;
		if(c && (this.flags & 131072) != 0) {
			var f = 262144;
			this.flags |= f;
		}
		this.scaleZ = v;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var c = b;
		if(c && (this.flags & 131072) != 0) {
			var f = 262144;
			this.flags |= f;
		}
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var c = b;
		if(c && (this.flags & 131072) != 0) {
			var f = 262144;
			this.flags |= f;
		}
	}
	,toString: function() {
		var c = js_Boot.getClass(this);
		return c.__name__.split(".").pop() + (this.name == null ? "" : "(" + this.name + ")");
	}
	,getChildAt: function(n) {
		return this.children[n];
	}
	,getChildIndex: function(o) {
		var _g = 0;
		var _g1 = this.children.length;
		while(_g < _g1) {
			var i = _g++;
			if(this.children[i] == o) {
				return i;
			}
		}
		return -1;
	}
	,get_numChildren: function() {
		return this.children.length;
	}
	,iterator: function() {
		return new hxd_impl_ArrayIterator_$h3d_$scene_$Object(this.children);
	}
	,__class__: h3d_scene_Object
};
var h3d_col_SkinColliderDebugObj = function(col) {
	this.boxes = [];
	h3d_scene_Object.call(this,null);
	this.col = col;
	this.skin = col.obj;
	this.box = new h3d_scene_Box(16777215,col.currentBounds);
	this.addChild(this.box);
	if(true != ((this.flags & 2048) != 0)) {
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var c = b;
		if(c && (this.flags & 131072) != 0) {
			var f = 262144;
			this.flags |= f;
		}
	}
	var f = 2048;
	this.flags |= f;
	this.createJoints();
};
$hxClasses["h3d.col.SkinColliderDebugObj"] = h3d_col_SkinColliderDebugObj;
h3d_col_SkinColliderDebugObj.__name__ = "h3d.col.SkinColliderDebugObj";
h3d_col_SkinColliderDebugObj.__super__ = h3d_scene_Object;
h3d_col_SkinColliderDebugObj.prototype = $extend(h3d_scene_Object.prototype,{
	createJoints: function() {
		var joints = this.skin.getSkinData().allJoints;
		var _g = 0;
		while(_g < joints.length) {
			var j = joints[_g];
			++_g;
			var b = new h3d_col_Bounds();
			b.xMin = -1;
			b.yMin = -1;
			b.zMin = -1;
			b.xMax = 1;
			b.yMax = 1;
			b.zMax = 1;
			var b1 = new h3d_scene_Box(10526880,b,null,this);
			if(j.offsets != null) {
				var _this = b1.bounds;
				_this.xMin = 1e20;
				_this.xMax = -1e20;
				_this.yMin = 1e20;
				_this.yMax = -1e20;
				_this.zMin = 1e20;
				_this.zMax = -1e20;
				var _this1 = j.offsets;
				var x = _this1.xMin;
				var y = _this1.yMin;
				var z = _this1.zMin;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var x1 = x;
				var y1 = y;
				var z1 = z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				var pt_x = x1;
				var pt_y = y1;
				var pt_z = z1;
				var _this2 = b1.bounds;
				var x2 = pt_x;
				var y2 = pt_y;
				var z2 = pt_z;
				var r = j.offsetRay;
				if(x2 - r < _this2.xMin) {
					_this2.xMin = x2 - r;
				}
				if(x2 + r > _this2.xMax) {
					_this2.xMax = x2 + r;
				}
				if(y2 - r < _this2.yMin) {
					_this2.yMin = y2 - r;
				}
				if(y2 + r > _this2.yMax) {
					_this2.yMax = y2 + r;
				}
				if(z2 - r < _this2.zMin) {
					_this2.zMin = z2 - r;
				}
				if(z2 + r > _this2.zMax) {
					_this2.zMax = z2 + r;
				}
				var _this3 = j.offsets;
				var x3 = _this3.xMax;
				var y3 = _this3.yMax;
				var z3 = _this3.zMax;
				if(z3 == null) {
					z3 = 0.;
				}
				if(y3 == null) {
					y3 = 0.;
				}
				if(x3 == null) {
					x3 = 0.;
				}
				var x4 = x3;
				var y4 = y3;
				var z4 = z3;
				if(z4 == null) {
					z4 = 0.;
				}
				if(y4 == null) {
					y4 = 0.;
				}
				if(x4 == null) {
					x4 = 0.;
				}
				var pt_x1 = x4;
				var pt_y1 = y4;
				var pt_z1 = z4;
				var _this4 = b1.bounds;
				var x5 = pt_x1;
				var y5 = pt_y1;
				var z5 = pt_z1;
				var r1 = j.offsetRay;
				if(x5 - r1 < _this4.xMin) {
					_this4.xMin = x5 - r1;
				}
				if(x5 + r1 > _this4.xMax) {
					_this4.xMax = x5 + r1;
				}
				if(y5 - r1 < _this4.yMin) {
					_this4.yMin = y5 - r1;
				}
				if(y5 + r1 > _this4.yMax) {
					_this4.yMax = y5 + r1;
				}
				if(z5 - r1 < _this4.zMin) {
					_this4.zMin = z5 - r1;
				}
				if(z5 + r1 > _this4.zMax) {
					_this4.zMax = z5 + r1;
				}
			} else {
				var _this5 = b1.bounds;
				_this5.xMin = 1e20;
				_this5.xMax = -1e20;
				_this5.yMin = 1e20;
				_this5.yMax = -1e20;
				_this5.zMin = 1e20;
				_this5.zMax = -1e20;
				var _this6 = b1.bounds;
				if(-0.1 < _this6.xMin) {
					_this6.xMin = -0.1;
				}
				if(0.1 > _this6.xMax) {
					_this6.xMax = 0.1;
				}
				if(-0.1 < _this6.yMin) {
					_this6.yMin = -0.1;
				}
				if(0.1 > _this6.yMax) {
					_this6.yMax = 0.1;
				}
				if(-0.1 < _this6.zMin) {
					_this6.zMin = -0.1;
				}
				if(0.1 > _this6.zMax) {
					_this6.zMax = 0.1;
				}
			}
			this.boxes.push(b1);
		}
	}
	,updateJoints: function() {
		var _g = 0;
		var _g1 = this.boxes.length;
		while(_g < _g1) {
			var i = _g++;
			var j = this.skin.skinData.allJoints[i];
			var b = this.boxes[i];
			if(j.offsets != null) {
				var m = this.skin.currentPalette[j.bindIndex];
				b.setTransform(m);
			} else {
				b.setTransform(this.skin.jointsData[j.index].currentAbsPose);
			}
		}
	}
	,sync: function(ctx) {
		this.col.checkBounds();
		this.updateJoints();
	}
	,__class__: h3d_col_SkinColliderDebugObj
});
var h3d_col_Sphere = function(x,y,z,r) {
	if(r == null) {
		r = 1.;
	}
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	var sx = x;
	var sy = y;
	var sz = z;
	var sr = r;
	if(sr == null) {
		sr = 0.;
	}
	if(sz == null) {
		sz = 0.;
	}
	if(sy == null) {
		sy = 0.;
	}
	if(sx == null) {
		sx = 0.;
	}
	this.x = sx;
	this.y = sy;
	this.z = sz;
	this.r = sr;
};
$hxClasses["h3d.col.Sphere"] = h3d_col_Sphere;
h3d_col_Sphere.__name__ = "h3d.col.Sphere";
h3d_col_Sphere.__super__ = h3d_col_Collider;
h3d_col_Sphere.prototype = $extend(h3d_col_Collider.prototype,{
	load: function(sx,sy,sz,sr) {
		if(sr == null) {
			sr = 0.;
		}
		if(sz == null) {
			sz = 0.;
		}
		if(sy == null) {
			sy = 0.;
		}
		if(sx == null) {
			sx = 0.;
		}
		this.x = sx;
		this.y = sy;
		this.z = sz;
		this.r = sr;
	}
	,getCenter: function() {
		var x = this.x;
		var y = this.y;
		var z = this.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,distance: function(p) {
		var dx = p.x - this.x;
		var dy = p.y - this.y;
		var dz = p.z - this.z;
		var d = dx * dx + dy * dy + dz * dz - this.r * this.r;
		if(d < 0) {
			return -Math.sqrt(-d);
		} else {
			return Math.sqrt(d);
		}
	}
	,distanceSq: function(p) {
		var dx = p.x - this.x;
		var dy = p.y - this.y;
		var dz = p.z - this.z;
		return dx * dx + dy * dy + dz * dz - this.r * this.r;
	}
	,contains: function(p) {
		var dx = p.x - this.x;
		var dy = p.y - this.y;
		var dz = p.z - this.z;
		return dx * dx + dy * dy + dz * dz - this.r * this.r < 0;
	}
	,rayIntersection: function(r,bestMatch) {
		var mx = r.px - this.x;
		var my = r.py - this.y;
		var mz = r.pz - this.z;
		var b = mx * r.lx + my * r.ly + mz * r.lz;
		var c = mx * mx + my * my + mz * mz - this.r * this.r;
		if(c > 0.0 && b > 0.0) {
			return -1;
		}
		var d = b * b - c;
		if(d < 0.0) {
			return -1;
		}
		var t = -b - Math.sqrt(d);
		if(t < 0.0) {
			return 0.0;
		} else {
			return t;
		}
	}
	,inFrustum: function(f,m) {
		if(m != null) {
			return this.inFrustumMatrix(f,m);
		}
		return f.hasSphere(this);
	}
	,inFrustumMatrix: function(f,m) {
		var oldX = this.x;
		var oldY = this.y;
		var oldZ = this.z;
		var oldR = this.r;
		var x = this.x;
		var y = this.y;
		var z = this.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var px = v_x * m._11 + v_y * m._21 + v_z * m._31 + m._41;
		var py = v_x * m._12 + v_y * m._22 + v_z * m._32 + m._42;
		var pz = v_x * m._13 + v_y * m._23 + v_z * m._33 + m._43;
		v_x = px;
		v_y = py;
		v_z = pz;
		this.x = v_x;
		this.y = v_y;
		this.z = v_z;
		var _this = m;
		var x = 0.;
		var y = 0.;
		var z = 0.;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var scale_x = x;
		var scale_y = y;
		var scale_z = z;
		scale_x = Math.sqrt(_this._11 * _this._11 + _this._12 * _this._12 + _this._13 * _this._13);
		scale_y = Math.sqrt(_this._21 * _this._21 + _this._22 * _this._22 + _this._23 * _this._23);
		scale_z = Math.sqrt(_this._31 * _this._31 + _this._32 * _this._32 + _this._33 * _this._33);
		if(_this._11 * (_this._22 * _this._33 - _this._23 * _this._32) + _this._12 * (_this._23 * _this._31 - _this._21 * _this._33) + _this._13 * (_this._21 * _this._32 - _this._22 * _this._31) < 0) {
			scale_x *= -1;
			scale_y *= -1;
			scale_z *= -1;
		}
		this.r *= Math.abs(Math.max(Math.max(scale_x,scale_y),scale_z));
		var res = f.hasSphere(this);
		this.x = oldX;
		this.y = oldY;
		this.z = oldZ;
		this.r = oldR;
		return res;
	}
	,transform: function(m) {
		var _this = m;
		var x = 0.;
		var y = 0.;
		var z = 0.;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var s_x = x;
		var s_y = y;
		var s_z = z;
		s_x = Math.sqrt(_this._11 * _this._11 + _this._12 * _this._12 + _this._13 * _this._13);
		s_y = Math.sqrt(_this._21 * _this._21 + _this._22 * _this._22 + _this._23 * _this._23);
		s_z = Math.sqrt(_this._31 * _this._31 + _this._32 * _this._32 + _this._33 * _this._33);
		if(_this._11 * (_this._22 * _this._33 - _this._23 * _this._32) + _this._12 * (_this._23 * _this._31 - _this._21 * _this._33) + _this._13 * (_this._21 * _this._32 - _this._22 * _this._31) < 0) {
			s_x *= -1;
			s_y *= -1;
			s_z *= -1;
		}
		var f = s_x;
		var a = f < 0 ? -f : f;
		var f = s_y;
		var b = f < 0 ? -f : f;
		var a1 = a < b ? b : a;
		var f = s_z;
		var b = f < 0 ? -f : f;
		var smax = a1 < b ? b : a1;
		this.r *= smax;
		var x = this.x;
		var y = this.y;
		var z = this.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var pt_x = x1;
		var pt_y = y1;
		var pt_z = z1;
		var px = pt_x * m._11 + pt_y * m._21 + pt_z * m._31 + m._41;
		var py = pt_x * m._12 + pt_y * m._22 + pt_z * m._32 + m._42;
		var pz = pt_x * m._13 + pt_y * m._23 + pt_z * m._33 + m._43;
		pt_x = px;
		pt_y = py;
		pt_z = pz;
		this.x = pt_x;
		this.y = pt_y;
		this.z = pt_z;
	}
	,inSphere: function(s) {
		var x = this.x;
		var y = this.y;
		var z = this.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var x = s.x;
		var y = s.y;
		var z = s.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var dx = v_x - _this_x;
		var dy = v_y - _this_y;
		var dz = v_z - _this_z;
		return dx * dx + dy * dy + dz * dz < (s.r + this.r) * (s.r + this.r);
	}
	,toString: function() {
		var x = this.x;
		var y = this.y;
		var z = this.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return "Sphere{" + Std.string(new h3d_VectorImpl(x,y,z)) + "," + hxd_Math.fmt(this.r) + "}";
	}
	,dimension: function() {
		return this.r;
	}
	,closestPoint: function(p) {
		var x = this.x;
		var y = this.y;
		var z = this.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var x = p.x - v_x;
		var y = p.y - v_y;
		var z = p.z - v_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var k = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		var x = _this_x * k;
		var y = _this_y * k;
		var z = _this_z * k;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var this_x = x1;
		var this_y = y1;
		var this_z = z1;
		var v = this.r;
		var x = this_x * v;
		var y = this_y * v;
		var z = this_z * v;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var d_x = x1;
		var d_y = y1;
		var d_z = z1;
		var x = this.x;
		var y = this.y;
		var z = this.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var x = d_x + v_x;
		var y = d_y + v_y;
		var z = d_z + v_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,clone: function() {
		var s = new h3d_col_Sphere();
		s.x = this.x;
		s.y = this.y;
		s.z = this.z;
		s.r = this.r;
		return s;
	}
	,makeDebugObj: function() {
		var prim = new h3d_prim_Sphere(this.r,20,15);
		prim.translate(this.x,this.y,this.z);
		prim.addNormals();
		return new h3d_scene_Mesh(prim);
	}
	,__class__: h3d_col_Sphere
});
var h3d_impl_Feature = $hxEnums["h3d.impl.Feature"] = { __ename__:true,__constructs__:null
	,StandardDerivatives: {_hx_name:"StandardDerivatives",_hx_index:0,__enum__:"h3d.impl.Feature",toString:$estr}
	,FloatTextures: {_hx_name:"FloatTextures",_hx_index:1,__enum__:"h3d.impl.Feature",toString:$estr}
	,AllocDepthBuffer: {_hx_name:"AllocDepthBuffer",_hx_index:2,__enum__:"h3d.impl.Feature",toString:$estr}
	,HardwareAccelerated: {_hx_name:"HardwareAccelerated",_hx_index:3,__enum__:"h3d.impl.Feature",toString:$estr}
	,MultipleRenderTargets: {_hx_name:"MultipleRenderTargets",_hx_index:4,__enum__:"h3d.impl.Feature",toString:$estr}
	,Queries: {_hx_name:"Queries",_hx_index:5,__enum__:"h3d.impl.Feature",toString:$estr}
	,SRGBTextures: {_hx_name:"SRGBTextures",_hx_index:6,__enum__:"h3d.impl.Feature",toString:$estr}
	,ShaderModel3: {_hx_name:"ShaderModel3",_hx_index:7,__enum__:"h3d.impl.Feature",toString:$estr}
	,BottomLeftCoords: {_hx_name:"BottomLeftCoords",_hx_index:8,__enum__:"h3d.impl.Feature",toString:$estr}
	,Wireframe: {_hx_name:"Wireframe",_hx_index:9,__enum__:"h3d.impl.Feature",toString:$estr}
	,InstancedRendering: {_hx_name:"InstancedRendering",_hx_index:10,__enum__:"h3d.impl.Feature",toString:$estr}
};
h3d_impl_Feature.__constructs__ = [h3d_impl_Feature.StandardDerivatives,h3d_impl_Feature.FloatTextures,h3d_impl_Feature.AllocDepthBuffer,h3d_impl_Feature.HardwareAccelerated,h3d_impl_Feature.MultipleRenderTargets,h3d_impl_Feature.Queries,h3d_impl_Feature.SRGBTextures,h3d_impl_Feature.ShaderModel3,h3d_impl_Feature.BottomLeftCoords,h3d_impl_Feature.Wireframe,h3d_impl_Feature.InstancedRendering];
h3d_impl_Feature.__empty_constructs__ = [h3d_impl_Feature.StandardDerivatives,h3d_impl_Feature.FloatTextures,h3d_impl_Feature.AllocDepthBuffer,h3d_impl_Feature.HardwareAccelerated,h3d_impl_Feature.MultipleRenderTargets,h3d_impl_Feature.Queries,h3d_impl_Feature.SRGBTextures,h3d_impl_Feature.ShaderModel3,h3d_impl_Feature.BottomLeftCoords,h3d_impl_Feature.Wireframe,h3d_impl_Feature.InstancedRendering];
var h3d_impl_QueryKind = $hxEnums["h3d.impl.QueryKind"] = { __ename__:true,__constructs__:null
	,TimeStamp: {_hx_name:"TimeStamp",_hx_index:0,__enum__:"h3d.impl.QueryKind",toString:$estr}
	,Samples: {_hx_name:"Samples",_hx_index:1,__enum__:"h3d.impl.QueryKind",toString:$estr}
};
h3d_impl_QueryKind.__constructs__ = [h3d_impl_QueryKind.TimeStamp,h3d_impl_QueryKind.Samples];
h3d_impl_QueryKind.__empty_constructs__ = [h3d_impl_QueryKind.TimeStamp,h3d_impl_QueryKind.Samples];
var h3d_impl_RenderFlag = $hxEnums["h3d.impl.RenderFlag"] = { __ename__:true,__constructs__:null
	,CameraHandness: {_hx_name:"CameraHandness",_hx_index:0,__enum__:"h3d.impl.RenderFlag",toString:$estr}
};
h3d_impl_RenderFlag.__constructs__ = [h3d_impl_RenderFlag.CameraHandness];
h3d_impl_RenderFlag.__empty_constructs__ = [h3d_impl_RenderFlag.CameraHandness];
var h3d_impl_Driver = function() {
	this.shaderCache = h3d_impl_Driver.SHADER_CACHE;
};
$hxClasses["h3d.impl.Driver"] = h3d_impl_Driver;
h3d_impl_Driver.__name__ = "h3d.impl.Driver";
h3d_impl_Driver.setShaderCache = function(cache) {
	h3d_impl_Driver.SHADER_CACHE = cache;
};
h3d_impl_Driver.prototype = {
	hasFeature: function(f) {
		return false;
	}
	,setRenderFlag: function(r,value) {
	}
	,isSupportedFormat: function(fmt) {
		return false;
	}
	,isDisposed: function() {
		return true;
	}
	,dispose: function() {
	}
	,begin: function(frame) {
	}
	,log: function(str) {
		if(this.logEnable) {
			this.logImpl(str);
		}
	}
	,generateMipMaps: function(texture) {
		throw haxe_Exception.thrown("Mipmaps auto generation is not supported on this platform");
	}
	,getNativeShaderCode: function(shader) {
		return null;
	}
	,logImpl: function(str) {
	}
	,clear: function(color,depth,stencil) {
	}
	,captureRenderBuffer: function(pixels) {
	}
	,capturePixels: function(tex,layer,mipLevel,region) {
		throw haxe_Exception.thrown("Can't capture pixels on this platform");
	}
	,getDriverName: function(details) {
		return "Not available";
	}
	,init: function(onCreate,forceSoftware) {
		if(forceSoftware == null) {
			forceSoftware = false;
		}
	}
	,resize: function(width,height) {
	}
	,selectShader: function(shader) {
		return false;
	}
	,selectMaterial: function(pass) {
	}
	,uploadShaderBuffers: function(buffers,which) {
	}
	,selectBuffer: function(buffer) {
	}
	,selectMultiBuffers: function(format,buffers) {
	}
	,draw: function(ibuf,startIndex,ntriangles) {
	}
	,drawInstanced: function(ibuf,commands) {
	}
	,setRenderZone: function(x,y,width,height) {
	}
	,setRenderTarget: function(tex,layer,mipLevel,depthBinding) {
		if(depthBinding == null) {
			depthBinding = h3d_DepthBinding.ReadWrite;
		}
		if(mipLevel == null) {
			mipLevel = 0;
		}
		if(layer == null) {
			layer = 0;
		}
	}
	,setRenderTargets: function(textures,depthBinding) {
		if(depthBinding == null) {
			depthBinding = h3d_DepthBinding.ReadWrite;
		}
	}
	,setDepth: function(tex) {
	}
	,allocDepthBuffer: function(b) {
		return null;
	}
	,disposeDepthBuffer: function(b) {
	}
	,getDefaultDepthBuffer: function() {
		return null;
	}
	,present: function() {
	}
	,end: function() {
	}
	,setDebug: function(b) {
	}
	,allocTexture: function(t) {
		return null;
	}
	,allocBuffer: function(b) {
		return null;
	}
	,allocInstanceBuffer: function(b,bytes) {
	}
	,disposeTexture: function(t) {
	}
	,disposeBuffer: function(b) {
	}
	,disposeInstanceBuffer: function(b) {
	}
	,uploadIndexData: function(i,startIndice,indiceCount,buf,bufPos) {
	}
	,uploadBufferData: function(b,startVertex,vertexCount,buf,bufPos) {
	}
	,uploadBufferBytes: function(b,startVertex,vertexCount,buf,bufPos) {
	}
	,uploadTextureBitmap: function(t,bmp,mipLevel,side) {
	}
	,uploadTexturePixels: function(t,pixels,mipLevel,side) {
	}
	,readBufferBytes: function(b,startVertex,vertexCount,buf,bufPos) {
		throw haxe_Exception.thrown("Driver does not allow to read vertex bytes");
	}
	,onTextureBiasChanged: function(t) {
	}
	,copyTexture: function(from,to) {
		return false;
	}
	,allocQuery: function(queryKind) {
		return null;
	}
	,deleteQuery: function(q) {
	}
	,beginQuery: function(q) {
	}
	,endQuery: function(q) {
	}
	,queryResultAvailable: function(q) {
		return true;
	}
	,queryResult: function(q) {
		return 0.;
	}
	,computeDispatch: function(x,y,z) {
		if(z == null) {
			z = 1;
		}
		if(y == null) {
			y = 1;
		}
		if(x == null) {
			x = 1;
		}
		throw haxe_Exception.thrown("Compute shaders are not implemented on this platform");
	}
	,__class__: h3d_impl_Driver
};
var h3d_impl__$GlDriver_CompiledShader = function(s,kind,shader) {
	this.s = s;
	this.kind = kind;
	this.shader = shader;
};
$hxClasses["h3d.impl._GlDriver.CompiledShader"] = h3d_impl__$GlDriver_CompiledShader;
h3d_impl__$GlDriver_CompiledShader.__name__ = "h3d.impl._GlDriver.CompiledShader";
h3d_impl__$GlDriver_CompiledShader.prototype = {
	__class__: h3d_impl__$GlDriver_CompiledShader
};
var h3d_impl__$GlDriver_CompiledAttribute = function() {
};
$hxClasses["h3d.impl._GlDriver.CompiledAttribute"] = h3d_impl__$GlDriver_CompiledAttribute;
h3d_impl__$GlDriver_CompiledAttribute.__name__ = "h3d.impl._GlDriver.CompiledAttribute";
h3d_impl__$GlDriver_CompiledAttribute.prototype = {
	__class__: h3d_impl__$GlDriver_CompiledAttribute
};
var h3d_impl__$GlDriver_CompiledProgram = function() {
};
$hxClasses["h3d.impl._GlDriver.CompiledProgram"] = h3d_impl__$GlDriver_CompiledProgram;
h3d_impl__$GlDriver_CompiledProgram.__name__ = "h3d.impl._GlDriver.CompiledProgram";
h3d_impl__$GlDriver_CompiledProgram.prototype = {
	__class__: h3d_impl__$GlDriver_CompiledProgram
};
var h3d_impl_GlDriver = function(antiAlias) {
	if(antiAlias == null) {
		antiAlias = 0;
	}
	this.features = new haxe_ds_EnumValueMap();
	this.maxCompressedTexturesSupport = 0;
	this.hasMultiIndirect = false;
	this.rightHanded = false;
	this.firstShader = true;
	this.boundTextures = [];
	this.curTargets = [];
	var _g = [];
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	this.currentDivisor = _g;
	this.curColorMask = -1;
	this.lastActiveIndex = 0;
	this.curStEnabled = false;
	this.curStMaskBits = -1;
	this.curStOpBits = -1;
	this.curMatBits = -1;
	this.maxIdxCurAttribs = 0;
	this.curAttribs = [];
	h3d_impl_Driver.call(this);
	this.canvas = hxd_Window.getInstance().canvas;
	var options = { alpha : false, stencil : true, antialias : antiAlias > 0};
	if(h3d_impl_GlDriver.ALLOW_WEBGL2) {
		this.gl = this.canvas.getContext("webgl2",options);
	}
	if(this.gl == null) {
		this.gl = js_html__$CanvasElement_CanvasUtil.getContextWebGL(this.canvas,options);
	}
	if(this.gl == null) {
		throw haxe_Exception.thrown("Could not acquire GL context");
	}
	if(typeof(WebGLDebugUtils) != "undefined") {
		this.gl = WebGLDebugUtils.makeDebugContext(this.gl);
		this.glDebug = true;
	}
	this.commonFB = this.gl.createFramebuffer();
	this.programs = new haxe_ds_IntMap();
	this.defStencil = new h3d_mat_Stencil();
	this.frame = hxd_Timer.frameCount;
	var v = this.gl.getParameter(7938);
	var reg = new EReg("ES ([0-9]+\\.[0-9]+)","");
	if(reg.match(v)) {
		this.glES = parseFloat(reg.matched(1));
	}
	var reg = new EReg("[0-9]+\\.[0-9]+","");
	var v = this.gl.getParameter(35724);
	if(reg.match(v)) {
		this.glES = parseFloat(reg.matched(0));
		this.shaderVersion = Math.round(parseFloat(reg.matched(0)) * 100);
	}
	this.drawMode = 4;
	this.makeFeatures();
	if(this.hasFeature(h3d_impl_Feature.InstancedRendering) && this.glES < 3) {
		var extension = this.gl.getExtension("ANGLE_instanced_arrays");
		this.gl["vertexAttribDivisor"] = $bind(extension,extension.vertexAttribDivisorANGLE);
		this.gl["drawElementsInstanced"] = $bind(extension,extension.drawElementsInstancedANGLE);
	}
	hxsl_SharedShader.UNROLL_LOOPS = !this.hasFeature(h3d_impl_Feature.ShaderModel3);
	this.gl.pixelStorei(3333,1);
	this.gl.pixelStorei(3317,1);
};
$hxClasses["h3d.impl.GlDriver"] = h3d_impl_GlDriver;
h3d_impl_GlDriver.__name__ = "h3d.impl.GlDriver";
h3d_impl_GlDriver.__super__ = h3d_impl_Driver;
h3d_impl_GlDriver.prototype = $extend(h3d_impl_Driver.prototype,{
	setRenderFlag: function(r,value) {
		this.rightHanded = value > 0;
	}
	,logImpl: function(str) {
		console.log(str);
	}
	,setDebug: function(d) {
		this.debug = d;
	}
	,begin: function(frame) {
		this.frame = frame;
		this.resetStream();
		this.gl.useProgram(null);
		this.curShader = null;
		this.curBuffer = null;
	}
	,makeCompiler: function() {
		var glout = new hxsl_GlslOut();
		glout.glES = this.glES;
		glout.version = this.shaderVersion;
		glout.intelDriverFix = this.isIntelGpu;
		return glout;
	}
	,getNativeShaderCode: function(shader) {
		var _gthis = this;
		if(shader.mode == hxsl_LinkMode.Compute) {
			var sh = shader.vertex.data;
			return _gthis.makeCompiler().run(sh);
		}
		var sh = shader.vertex.data;
		var tmp = "// vertex:\n" + _gthis.makeCompiler().run(sh) + "// fragment:\n";
		var sh = shader.fragment.data;
		return tmp + _gthis.makeCompiler().run(sh);
	}
	,getDriverName: function(details) {
		var render = this.gl.getParameter(7937);
		if(details) {
			render += " GLv" + Std.string(this.gl.getParameter(7938));
		} else {
			render = render.split("/").shift();
		}
		render = render.split("WebGL ").join("");
		return "OpenGL " + render;
	}
	,compileShader: function(glout,shader) {
		var type;
		switch(shader.kind._hx_index) {
		case 0:
			type = 35633;
			break;
		case 1:
			type = 35632;
			break;
		case 4:
			throw haxe_Exception.thrown("Compute shader is not supported");
		default:
			throw haxe_Exception.thrown("assert");
		}
		var s = this.gl.createShader(type);
		if(shader.code == null) {
			shader.code = glout.run(shader.data);
			shader.data.funs = null;
		}
		this.gl.shaderSource(s,shader.code);
		this.gl.compileShader(s);
		if(this.gl.getShaderParameter(s,35713) != 1) {
			var log = this.gl.getShaderInfoLog(s);
			var lid = Std.parseInt(HxOverrides.substr(log,9,null));
			var line = lid == null ? null : shader.code.split("\n")[lid - 1];
			if(line == null) {
				line = "";
			} else {
				line = "(" + StringTools.trim(line) + ")";
			}
			var codeLines = shader.code.split("\n");
			var _g = 0;
			var _g1 = codeLines.length;
			while(_g < _g1) {
				var i = _g++;
				codeLines[i] = i + 1 + "\t" + codeLines[i];
			}
			throw haxe_Exception.thrown("An error occurred compiling the shaders: " + log + line + "\n\n" + codeLines.join("\n"));
		}
		return new h3d_impl__$GlDriver_CompiledShader(s,shader.kind,shader);
	}
	,initShader: function(p,s,shader,rt) {
		var prefix;
		switch(s.kind._hx_index) {
		case 0:
			prefix = "vertex";
			break;
		case 1:
			prefix = "fragment";
			break;
		default:
			prefix = "compute";
		}
		s.globals = this.gl.getUniformLocation(p.p,prefix + "Globals");
		s.params = this.gl.getUniformLocation(p.p,prefix + "Params");
		s.textures = [];
		var index = 0;
		var curT = null;
		var mode = 0;
		var name = "";
		var t = shader.textures;
		while(t != null) {
			var tt = t.type;
			var count = 1;
			switch(tt._hx_index) {
			case 15:
				var _g = tt.size;
				if(_g._hx_index == 0) {
					var n = _g.v;
					var t1 = tt.t;
					tt = t1;
					count = n;
				}
				break;
			case 17:
				var _g1 = tt.size;
				tt = hxsl_Type.TSampler(hxsl_TexDimension.T2D,false);
				break;
			default:
			}
			if(curT == null || !Type.enumEq(tt,curT)) {
				curT = tt;
				switch(tt._hx_index) {
				case 10:
					var dim = tt.dim;
					var arr = tt.isArray;
					switch(dim._hx_index) {
					case 1:
						mode = arr ? 35866 : 3553;
						break;
					case 2:
						if(arr == false) {
							mode = 32879;
						} else {
							throw haxe_Exception.thrown("Texture not supported " + Std.string(tt));
						}
						break;
					case 3:
						if(arr == false) {
							mode = 34067;
						} else {
							throw haxe_Exception.thrown("Texture not supported " + Std.string(tt));
						}
						break;
					default:
						throw haxe_Exception.thrown("Texture not supported " + Std.string(tt));
					}
					name = "Textures" + (dim == hxsl_TexDimension.T2D ? "" : HxOverrides.substr($hxEnums[dim.__enum__].__constructs__[dim._hx_index]._hx_name,1,null)) + (arr ? "Array" : "");
					break;
				case 11:
					var dim1 = tt.dim;
					var arr1 = tt.isArray;
					var chans = tt.channels;
					throw haxe_Exception.thrown("Texture not supported " + Std.string(tt));
				default:
					throw haxe_Exception.thrown("Unsupported texture type " + Std.string(tt));
				}
				index = 0;
			}
			var _g2 = 0;
			var _g3 = count;
			while(_g2 < _g3) {
				var i = _g2++;
				var loc = this.gl.getUniformLocation(p.p,prefix + name + "[" + index + "]");
				if(loc == null) {
					throw haxe_Exception.thrown("Texture " + rt.spec.instances[t.instance].shader.data.name + "." + t.name + " is missing from generated shader");
				}
				s.textures.push({ u : loc, t : curT, mode : mode});
				++index;
			}
			t = t.next;
		}
		if(shader.bufferCount > 0) {
			s.bufferTypes = [];
			var bp = s.shader.buffers;
			while(bp != null) {
				var kind;
				var _g = bp.type;
				if(_g._hx_index == 16) {
					var _g1 = _g.t;
					var _g2 = _g.size;
					var kind1 = _g.kind;
					kind = kind1;
				} else {
					throw haxe_Exception.thrown("assert");
				}
				s.bufferTypes.push(kind);
				bp = bp.next;
			}
			var _g = [];
			var _g1 = 0;
			var _g2 = shader.bufferCount;
			while(_g1 < _g2) {
				var i = _g1++;
				var tmp;
				switch(s.bufferTypes[i]._hx_index) {
				case 0:
					tmp = this.gl.getUniformBlockIndex(p.p,(shader.kind == hxsl_FunctionKind.Vertex ? "vertex_" : "") + "uniform_buffer" + i);
					break;
				case 1:
					throw haxe_Exception.thrown("Storage buffer not supported in WebGL");
				case 2:
					throw haxe_Exception.thrown("RW buffer not supported in WebGL");
				default:
					throw haxe_Exception.thrown("assert");
				}
				_g.push(tmp);
			}
			s.buffers = _g;
			var start = 0;
			if(s.kind == hxsl_FunctionKind.Fragment) {
				start = rt.vertex.bufferCount;
			}
			var _g = 0;
			var _g1 = shader.bufferCount;
			while(_g < _g1) {
				var i = _g++;
				switch(s.bufferTypes[i]._hx_index) {
				case 0:
					this.gl.uniformBlockBinding(p.p,s.buffers[i],i + start);
					break;
				case 1:case 2:
					break;
				default:
					throw haxe_Exception.thrown("assert");
				}
			}
		}
	}
	,selectShader: function(shader) {
		var p = this.programs.h[shader.id];
		if(p == null) {
			p = new h3d_impl__$GlDriver_CompiledProgram();
			var glout = this.makeCompiler();
			p.vertex = this.compileShader(glout,shader.vertex);
			if(shader.fragment != null) {
				p.fragment = this.compileShader(glout,shader.fragment);
			}
			p.p = this.gl.createProgram();
			this.gl.attachShader(p.p,p.vertex.s);
			if(p.fragment != null) {
				this.gl.attachShader(p.p,p.fragment.s);
			}
			var log = null;
			try {
				this.gl.linkProgram(p.p);
				if(this.gl.getProgramParameter(p.p,35714) != 1) {
					log = this.gl.getProgramInfoLog(p.p);
				}
			} catch( _g ) {
				var e = haxe_Exception.caught(_g).unwrap();
				throw haxe_Exception.thrown("Shader linkage error: " + Std.string(e) + " (" + this.getDriverName(false) + ")");
			}
			this.gl.deleteShader(p.vertex.s);
			if(p.fragment != null) {
				this.gl.deleteShader(p.fragment.s);
			}
			if(log != null) {
				this.gl.deleteProgram(p.p);
				throw haxe_Exception.thrown("Program linkage failure: " + log + "\nVertex=\n" + shader.vertex.code + (shader.fragment == null ? "" : "\n\nFragment=\n" + shader.fragment.code));
			}
			this.firstShader = false;
			this.initShader(p,p.vertex,shader.vertex,shader);
			if(p.fragment != null) {
				this.initShader(p,p.fragment,shader.fragment,shader);
			}
			p.attribs = [];
			p.hasAttribIndex = 0;
			var format = [];
			var _g = 0;
			var _g1 = shader.vertex.data.vars;
			while(_g < _g1.length) {
				var v = _g1[_g];
				++_g;
				if(v.kind._hx_index == 1) {
					var t = hxd_InputFormat.fromHXSL(v.type);
					var index = this.gl.getAttribLocation(p.p,glout.varNames.h.hasOwnProperty(v.id) ? glout.varNames.h[v.id] : v.name);
					if(index < 0) {
						continue;
					}
					if(index >= 32) {
						throw haxe_Exception.thrown("assert");
					}
					var a = new h3d_impl__$GlDriver_CompiledAttribute();
					a.type = 5126;
					a.index = index;
					a.size = t & 7;
					var _g2 = v.type;
					if(_g2._hx_index == 9) {
						var n = _g2.size;
						a.type = 5120;
						a.size = n;
					}
					a.divisor = 0;
					if(v.qualifiers != null) {
						var _g3 = 0;
						var _g4 = v.qualifiers;
						while(_g3 < _g4.length) {
							var q = _g4[_g3];
							++_g3;
							if(q._hx_index == 9) {
								var n1 = q.v;
								a.divisor = n1;
							}
						}
					}
					p.attribs.push(a);
					p.hasAttribIndex |= 1 << a.index;
					format.push(new hxd_BufferInput(v.name,t,0));
				}
			}
			p.format = hxd_BufferFormat.make(format);
			this.programs.h[shader.id] = p;
		}
		if(this.curShader == p) {
			return false;
		}
		this.setProgram(p);
		return true;
	}
	,setProgram: function(p) {
		this.gl.useProgram(p.p);
		var _g = 0;
		var _g1 = p.attribs;
		while(_g < _g1.length) {
			var a = _g1[_g];
			++_g;
			if(!this.curAttribs[a.index]) {
				this.gl.enableVertexAttribArray(a.index);
				this.curAttribs[a.index] = true;
				if(this.maxIdxCurAttribs < a.index) {
					this.maxIdxCurAttribs = a.index;
				}
			}
		}
		var lastIdxCurAttribTrue = 0;
		var _g = 0;
		var _g1 = this.maxIdxCurAttribs + 1;
		while(_g < _g1) {
			var i = _g++;
			if(this.curAttribs[i] && (p.hasAttribIndex & 1 << i) == 0) {
				this.gl.disableVertexAttribArray(i);
				this.curAttribs[i] = false;
			} else if(this.curAttribs[i]) {
				lastIdxCurAttribTrue = i;
			}
		}
		this.maxIdxCurAttribs = lastIdxCurAttribTrue;
		this.curShader = p;
		this.curBuffer = null;
		var _g = 0;
		var _g1 = this.boundTextures.length;
		while(_g < _g1) {
			var i = _g++;
			this.boundTextures[i] = null;
		}
	}
	,uploadShaderBuffers: function(buf,which) {
		this.uploadBuffer(buf,this.curShader.vertex,buf.vertex,which);
		if(this.curShader.fragment != null) {
			this.uploadBuffer(buf,this.curShader.fragment,buf.fragment,which);
		}
	}
	,uploadBuffer: function(buffer,s,buf,which) {
		switch(which) {
		case 0:
			if(s.globals != null) {
				var a = buf.globals.subarray(0,s.shader.globalsSize * 4);
				this.gl.uniform4fv(s.globals,a);
			}
			break;
		case 1:
			if(s.params != null) {
				var a = buf.params.subarray(0,s.shader.paramsSize * 4);
				this.gl.uniform4fv(s.params,a);
			}
			break;
		case 2:
			var tcount = s.textures.length;
			var _g = 0;
			var _g1 = s.textures.length;
			while(_g < _g1) {
				var i = _g++;
				var t = buf.tex[i];
				var pt = s.textures[i];
				if(t == null || t.t == null && (t.isDepth() || t.realloc == null)) {
					var _g2 = pt.t;
					if(_g2._hx_index == 10) {
						var _g3 = _g2.isArray;
						if(_g2.dim._hx_index == 3) {
							if(_g3 == false) {
								t = h3d_mat_Texture.defaultCubeTexture();
							} else {
								throw haxe_Exception.thrown("Missing texture");
							}
						} else if(_g3 == false) {
							var color = h3d_mat_Defaults.loadingTextureColor;
							t = h3d_mat_Texture.fromColor(color,(color >>> 24) / 255);
						} else {
							throw haxe_Exception.thrown("Missing texture");
						}
					} else {
						throw haxe_Exception.thrown("Missing texture");
					}
				}
				if(t != null && t.t == null && t.realloc != null) {
					var s1 = this.curShader;
					t.alloc();
					t.realloc();
					if(this.curShader != s1) {
						this.setProgram(s1);
						this.uploadShaderBuffers(buffer,0);
						this.uploadShaderBuffers(buffer,1);
						this.uploadShaderBuffers(buffer,2);
						return;
					}
				}
				t.set_lastFrame(this.frame);
				if(pt.u == null) {
					continue;
				}
				var idx = s.kind == hxsl_FunctionKind.Fragment ? this.curShader.vertex.textures.length + i : i;
				if(this.boundTextures[idx] != t.t) {
					this.boundTextures[idx] = t.t;
					var mode = this.getBindType(t);
					if(mode != pt.mode) {
						throw haxe_Exception.thrown("Texture format mismatch: " + Std.string(t) + " should be " + Std.string(pt.t));
					}
					this.gl.activeTexture(33984 + idx);
					this.gl.uniform1i(pt.u,idx);
					this.gl.bindTexture(mode,t.t.t);
					this.lastActiveIndex = idx;
				}
				var mip = t.mipMap._hx_index;
				var filter = t.filter._hx_index;
				var wrap = t.wrap._hx_index;
				var bits = mip | filter << 3 | wrap << 6;
				if(bits != t.t.bits) {
					t.t.bits = bits;
					var flags = h3d_impl_GlDriver.TFILTERS[mip][filter];
					var mode1 = pt.mode;
					this.gl.texParameteri(mode1,10240,flags[0]);
					this.gl.texParameteri(mode1,10241,flags[1]);
					this.gl.texParameteri(mode1,34892,0);
					var w = h3d_impl_GlDriver.TWRAP[wrap];
					this.gl.texParameteri(mode1,10242,w);
					this.gl.texParameteri(mode1,10243,w);
				}
				if(t.t.startMip != t.startingMip) {
					this.gl.texParameteri(pt.mode,33084,t.startingMip);
					t.t.startMip = t.startingMip;
				}
			}
			break;
		case 3:
			if(s.buffers != null) {
				var start = 0;
				if(s.kind == hxsl_FunctionKind.Fragment && this.curShader.vertex.buffers != null) {
					start = this.curShader.vertex.buffers.length;
				}
				var _g = 0;
				var _g1 = s.buffers.length;
				while(_g < _g1) {
					var i = _g++;
					switch(s.bufferTypes[i]._hx_index) {
					case 0:
						this.gl.bindBufferBase(35345,i + start,buf.buffers[i].vbuf);
						break;
					case 1:
						this.gl.bindBufferBase(37074,i + start,buf.buffers[i].vbuf);
						break;
					case 2:
						if((buf.buffers[i].flags & 1 << h3d_BufferFlag.ReadWriteBuffer._hx_index) == 0) {
							throw haxe_Exception.thrown("Buffer was allocated without ReadWriteBuffer flag");
						}
						this.gl.bindBufferBase(37074,i + start,buf.buffers[i].vbuf);
						break;
					default:
						throw haxe_Exception.thrown("assert");
					}
				}
			}
			break;
		}
	}
	,selectMaterial: function(pass) {
		var bits = pass.bits;
		if(this.curTarget == null == this.rightHanded) {
			switch(pass.culling._hx_index) {
			case 1:
				bits = bits & -4 | 2;
				break;
			case 2:
				bits = bits & -4 | 1;
				break;
			default:
			}
		}
		this.selectMaterialBits(bits);
		if(this.curColorMask != pass.colorMask) {
			var m = pass.colorMask;
			this.gl.colorMask((m & 1) != 0,(m & 2) != 0,(m & 4) != 0,(m & 8) != 0);
			var mi = m >> 4;
			if(mi > 0) {
				throw haxe_Exception.thrown("GL ColorMaski support requires hlsdl 1.14+");
			}
			this.curColorMask = m;
		}
		var s = this.defStencil;
		if(pass.stencil == null) {
			if(this.curStEnabled) {
				this.gl.disable(2960);
				this.curStEnabled = false;
			}
		} else {
			s = pass.stencil;
			if(!this.curStEnabled) {
				this.gl.enable(2960);
				this.curStEnabled = true;
			}
		}
		this.selectStencilBits(s.opBits,s.maskBits);
	}
	,selectMaterialBits: function(bits) {
		var diff = bits ^ this.curMatBits;
		if(this.curMatBits < 0) {
			diff = -1;
		}
		if(diff == 0) {
			return;
		}
		var wireframe = (bits & 268435456) != 0;
		var fallback = true;
		if(fallback) {
			this.drawMode = wireframe ? 3 : 4;
		}
		if((diff & 3) != 0) {
			var cull = bits & 3;
			if(cull == 0) {
				this.gl.disable(2884);
			} else {
				if(this.curMatBits < 0 || (this.curMatBits & 3) == 0) {
					this.gl.enable(2884);
				}
				this.gl.cullFace(h3d_impl_GlDriver.FACES[cull]);
			}
		}
		if((diff & 4194240) != 0) {
			var csrc = bits >> 6 & 15;
			var cdst = bits >> 10 & 15;
			var asrc = bits >> 14 & 15;
			var adst = bits >> 18 & 15;
			if(csrc == asrc && cdst == adst) {
				if(csrc == 0 && cdst == 1) {
					this.gl.disable(3042);
				} else {
					if(this.curMatBits < 0 || (this.curMatBits >> 6 & 15) == 0 && (this.curMatBits >> 10 & 15) == 1) {
						this.gl.enable(3042);
					}
					this.gl.blendFunc(h3d_impl_GlDriver.BLEND[csrc],h3d_impl_GlDriver.BLEND[cdst]);
				}
			} else {
				if(this.curMatBits < 0 || (this.curMatBits >> 6 & 15) == 0 && (this.curMatBits >> 10 & 15) == 1) {
					this.gl.enable(3042);
				}
				this.gl.blendFuncSeparate(h3d_impl_GlDriver.BLEND[csrc],h3d_impl_GlDriver.BLEND[cdst],h3d_impl_GlDriver.BLEND[asrc],h3d_impl_GlDriver.BLEND[adst]);
			}
		}
		if((diff & 264241152) != 0) {
			var cop = bits >> 22 & 7;
			var aop = bits >> 25 & 7;
			if(cop == aop) {
				this.gl.blendEquation(h3d_impl_GlDriver.OP[cop]);
			} else {
				this.gl.blendEquationSeparate(h3d_impl_GlDriver.OP[cop],h3d_impl_GlDriver.OP[aop]);
			}
		}
		if((diff & 4) != 0) {
			this.gl.depthMask((bits >> 2 & 1) != 0);
		}
		if((diff & 56) != 0) {
			var cmp = bits >> 3 & 7;
			if(cmp == 0) {
				this.gl.disable(2929);
			} else {
				if(this.curMatBits < 0 || (this.curMatBits >> 3 & 7) == 0) {
					this.gl.enable(2929);
				}
				this.gl.depthFunc(h3d_impl_GlDriver.COMPARE[cmp]);
			}
		}
		this.curMatBits = bits;
	}
	,selectStencilBits: function(opBits,maskBits) {
		var diffOp = opBits ^ this.curStOpBits;
		var diffMask = maskBits ^ this.curStMaskBits;
		if((diffOp | diffMask) == 0) {
			return;
		}
		if((diffOp & 4088) != 0) {
			this.gl.stencilOpSeparate(h3d_impl_GlDriver.FACES[2],h3d_impl_GlDriver.STENCIL_OP[opBits >> 6 & 7],h3d_impl_GlDriver.STENCIL_OP[opBits >> 9 & 7],h3d_impl_GlDriver.STENCIL_OP[opBits >> 3 & 7]);
		}
		if((diffOp & 16744448) != 0) {
			this.gl.stencilOpSeparate(h3d_impl_GlDriver.FACES[1],h3d_impl_GlDriver.STENCIL_OP[opBits >> 18 & 7],h3d_impl_GlDriver.STENCIL_OP[opBits >> 21 & 7],h3d_impl_GlDriver.STENCIL_OP[opBits >> 15 & 7]);
		}
		if((diffOp & 7 | diffMask & 16711935) != 0) {
			this.gl.stencilFuncSeparate(h3d_impl_GlDriver.FACES[2],h3d_impl_GlDriver.COMPARE[opBits & 7],maskBits >> 16 & 255,maskBits & 255);
		}
		if((diffOp & 28672 | diffMask & 16711935) != 0) {
			this.gl.stencilFuncSeparate(h3d_impl_GlDriver.FACES[1],h3d_impl_GlDriver.COMPARE[opBits >> 12 & 7],maskBits >> 16 & 255,maskBits & 255);
		}
		if((diffMask & 65280) != 0) {
			var w = maskBits >> 8 & 255;
			this.gl.stencilMaskSeparate(h3d_impl_GlDriver.FACES[2],w);
			this.gl.stencilMaskSeparate(h3d_impl_GlDriver.FACES[1],w);
		}
		this.curStOpBits = opBits;
		this.curStMaskBits = maskBits;
	}
	,clear: function(color,depth,stencil) {
		var bits = 0;
		if(color != null) {
			this.gl.colorMask(true,true,true,true);
			this.curColorMask = 15;
			this.gl.clearColor(color.x,color.y,color.z,color.w);
			bits |= 16384;
		}
		if(depth != null) {
			this.gl.depthMask(true);
			if(this.curMatBits >= 0) {
				this.curMatBits |= 4;
			}
			this.gl.clearDepth(depth);
			bits |= 256;
		}
		if(stencil != null) {
			this.selectStencilBits(this.defStencil.opBits,this.defStencil.maskBits);
			this.gl.clearStencil(stencil);
			bits |= 1024;
		}
		if(bits != 0) {
			this.gl.clear(bits);
		}
		if(this.curTarget != null) {
			this.curTarget.flags |= 1 << h3d_mat_TextureFlags.WasCleared._hx_index;
		}
	}
	,resize: function(width,height) {
		if(this.canvas.style.width == "") {
			var tmp = width / window.devicePixelRatio | 0;
			this.canvas.style.width = tmp + "px";
			var tmp = height / window.devicePixelRatio | 0;
			this.canvas.style.height = tmp + "px";
		}
		this.canvas.width = width;
		this.canvas.height = height;
		this.bufferWidth = width;
		this.bufferHeight = height;
		this.gl.viewport(0,0,width,height);
		if(this.defaultDepth != null) {
			this.disposeDepthBuffer(this.defaultDepth);
			this.defaultDepth.width = this.bufferWidth;
			this.defaultDepth.height = this.bufferHeight;
			this.defaultDepth.t = this.allocDepthBuffer(this.defaultDepth);
		}
	}
	,getChannels: function(t) {
		switch(t.internalFmt) {
		case 6407:
			return 6407;
		case 6408:
			return 6408;
		case 32857:
			return 6408;
		case 6403:case 33321:case 33322:case 33325:case 33326:
			return 6403;
		case 33319:case 33323:case 33324:case 33327:case 33328:
			return 33319;
		case 34836:case 34842:
			return 6408;
		case 35898:
			return 6407;
		case 35904:case 35905:
			return 6407;
		case 32859:case 33777:case 33778:case 33779:case 36492:
			return 6408;
		case 32852:case 34837:case 34843:case 36495:
			return 6407;
		default:
			throw haxe_Exception.thrown("Invalid format " + t.internalFmt);
		}
	}
	,isSupportedFormat: function(fmt) {
		switch(fmt._hx_index) {
		case 2:
			return true;
		case 3:case 4:
			return this.hasFeature(h3d_impl_Feature.FloatTextures);
		case 14:case 15:
			return this.hasFeature(h3d_impl_Feature.SRGBTextures);
		case 5:case 6:case 7:case 8:case 9:case 10:case 11:case 12:case 13:case 16:case 17:
			return this.glES >= 3;
		case 22:
			var n = fmt.v;
			return n <= this.maxCompressedTexturesSupport;
		default:
			return false;
		}
	}
	,getBindType: function(t) {
		if((t.flags & 1 << h3d_mat_TextureFlags.Is3D._hx_index) != 0) {
			return 32879;
		}
		var isArray = (t.flags & 1 << h3d_mat_TextureFlags.IsArray._hx_index) != 0;
		if((t.flags & 1 << h3d_mat_TextureFlags.Cube._hx_index) != 0) {
			return 34067;
		}
		if(isArray) {
			return 35866;
		} else {
			return 3553;
		}
	}
	,allocTexture: function(t) {
		var _gthis = this;
		if(h3d_impl_GlDriver.outOfMemoryCheck) {
			this.gl.getError();
		}
		var tt = this.gl.createTexture();
		var bind = this.getBindType(t);
		var tt1 = { t : tt, width : t.width, height : t.height, internalFmt : 6408, pixelFmt : 5121, bits : -1, bind : bind, bias : 0, startMip : t.startingMip};
		var _g = t.format;
		switch(_g._hx_index) {
		case 1:
			tt1.internalFmt = 32856;
			break;
		case 2:
			break;
		case 3:
			if(this.hasFeature(h3d_impl_Feature.FloatTextures)) {
				tt1.pixelFmt = 5131;
				tt1.internalFmt = 34842;
			} else {
				throw haxe_Exception.thrown("Unsupported texture format " + Std.string(t.format));
			}
			break;
		case 4:
			if(this.hasFeature(h3d_impl_Feature.FloatTextures)) {
				tt1.internalFmt = 34836;
				tt1.pixelFmt = 5126;
			} else {
				throw haxe_Exception.thrown("Unsupported texture format " + Std.string(t.format));
			}
			break;
		case 5:
			tt1.internalFmt = 33321;
			break;
		case 6:
			tt1.internalFmt = 33325;
			tt1.pixelFmt = 5131;
			break;
		case 7:
			tt1.internalFmt = 33326;
			tt1.pixelFmt = 5126;
			break;
		case 8:
			tt1.internalFmt = 33323;
			break;
		case 9:
			tt1.internalFmt = 33327;
			tt1.pixelFmt = 5131;
			break;
		case 10:
			tt1.internalFmt = 33328;
			tt1.pixelFmt = 5126;
			break;
		case 11:
			tt1.internalFmt = 6407;
			break;
		case 12:
			tt1.internalFmt = 34843;
			tt1.pixelFmt = 5131;
			break;
		case 13:
			tt1.internalFmt = 34837;
			tt1.pixelFmt = 5126;
			break;
		case 14:
			tt1.internalFmt = 35905;
			break;
		case 16:
			tt1.internalFmt = 32857;
			tt1.pixelFmt = 33640;
			break;
		case 17:
			tt1.internalFmt = 35898;
			tt1.pixelFmt = 35899;
			break;
		case 18:
			tt1.internalFmt = 33322;
			tt1.pixelFmt = 5123;
			break;
		case 19:
			tt1.internalFmt = 33324;
			tt1.pixelFmt = 5123;
			break;
		case 20:
			tt1.internalFmt = 32852;
			tt1.pixelFmt = 5123;
			break;
		case 21:
			tt1.internalFmt = 32859;
			tt1.pixelFmt = 5123;
			break;
		case 22:
			var n = _g.v;
			if(n <= this.maxCompressedTexturesSupport) {
				if((t.width & 3) != 0 || (t.height & 3) != 0) {
					throw haxe_Exception.thrown("Compressed texture " + Std.string(t) + " has size " + t.width + "x" + t.height + " - must be a multiple of 4");
				}
				switch(n) {
				case 1:
					tt1.internalFmt = 33777;
					break;
				case 2:
					tt1.internalFmt = 33778;
					break;
				case 3:
					tt1.internalFmt = 33779;
					break;
				case 6:
					tt1.internalFmt = 36495;
					break;
				case 7:
					tt1.internalFmt = 36492;
					break;
				default:
					throw haxe_Exception.thrown("Unsupported texture format " + Std.string(t.format));
				}
			} else {
				throw haxe_Exception.thrown("Unsupported texture format " + Std.string(t.format));
			}
			break;
		default:
			throw haxe_Exception.thrown("Unsupported texture format " + Std.string(t.format));
		}
		if(tt1.pixelFmt == 5123 && !this.has16Bits) {
			throw haxe_Exception.thrown("16 bit textures requires EXT_texture_norm16 extension");
		}
		t.set_lastFrame(this.frame);
		t.flags &= -1 - (1 << h3d_mat_TextureFlags.WasCleared._hx_index);
		this.gl.bindTexture(bind,tt1.t);
		var outOfMem = false;
		this.gl.texParameteri(bind,33084,t.startingMip);
		this.gl.texParameteri(bind,33085,t.get_mipLevels() - 1);
		var sizedFormat = tt1.internalFmt == 6408 ? 32856 : tt1.internalFmt;
		if(((t.flags & 1 << h3d_mat_TextureFlags.IsArray._hx_index) != 0 || (t.flags & 1 << h3d_mat_TextureFlags.Is3D._hx_index) != 0) && (t.flags & 1 << h3d_mat_TextureFlags.Cube._hx_index) == 0) {
			this.gl.texStorage3D(bind,t.get_mipLevels(),sizedFormat,tt1.width,tt1.height,t.get_layerCount());
			if(h3d_impl_GlDriver.outOfMemoryCheck) {
				var err = _gthis.gl.getError();
				if(err == 1285) {
					outOfMem = true;
				} else if(err != 0) {
					throw haxe_Exception.thrown("Failed to alloc texture " + Std.string(t.format) + "(error " + err + ")");
				}
			}
		} else {
			this.gl.texStorage2D(bind,t.get_mipLevels(),sizedFormat,tt1.width,tt1.height);
			if(h3d_impl_GlDriver.outOfMemoryCheck) {
				var err = _gthis.gl.getError();
				if(err == 1285) {
					outOfMem = true;
				} else if(err != 0) {
					throw haxe_Exception.thrown("Failed to alloc texture " + Std.string(t.format) + "(error " + err + ")");
				}
			}
		}
		this.restoreBind();
		if(outOfMem) {
			this.gl.deleteTexture(tt1.t);
			return null;
		}
		return tt1;
	}
	,restoreBind: function() {
		var t = this.boundTextures[this.lastActiveIndex];
		if(t == null) {
			this.gl.bindTexture(3553,null);
		} else {
			this.gl.bindTexture(t.bind,t.t);
		}
	}
	,allocDepthBuffer: function(t) {
		var tt = this.gl.createTexture();
		var tt1 = { t : tt, width : t.width, height : t.height, internalFmt : 6408, pixelFmt : 5121, bits : -1, bind : 3553, bias : 0, startMip : 0};
		var fmt = 6402;
		switch(t.format._hx_index) {
		case 23:
			tt1.internalFmt = 33189;
			break;
		case 24:
			if(this.glES >= 3) {
				tt1.internalFmt = 6402;
			} else {
				throw haxe_Exception.thrown("Unsupported depth format " + Std.string(t.format));
			}
			break;
		case 25:
			tt1.internalFmt = 35056;
			tt1.pixelFmt = 34042;
			fmt = 34041;
			break;
		case 26:
			tt1.internalFmt = 36012;
			break;
		default:
			throw haxe_Exception.thrown("Unsupported depth format " + Std.string(t.format));
		}
		t.set_lastFrame(this.frame);
		t.flags &= -1 - (1 << h3d_mat_TextureFlags.WasCleared._hx_index);
		this.gl.bindTexture(tt1.bind,tt1.t);
		this.gl.texParameteri(tt1.bind,10241,9728);
		this.gl.texParameteri(tt1.bind,10240,9728);
		this.gl.texParameteri(tt1.bind,10242,33071);
		this.gl.texParameteri(tt1.bind,10243,33071);
		this.gl.texImage2D(tt1.bind,0,tt1.internalFmt,tt1.width,tt1.height,0,fmt,tt1.pixelFmt,null);
		this.restoreBind();
		return tt1;
	}
	,disposeDepthBuffer: function(b) {
		if(b.t != null && b.t.t != null) {
			this.gl.deleteTexture(b.t.t);
			b.t = null;
		}
	}
	,getDefaultDepthBuffer: function() {
		if(this.defaultDepth != null) {
			return this.defaultDepth;
		}
		this.defaultDepth = new h3d_mat_Texture(0,0,null,hxd_PixelFormat.Depth24Stencil8);
		this.defaultDepth.name = "defaultDepthBuffer";
		this.defaultDepth.width = this.bufferWidth;
		this.defaultDepth.height = this.bufferHeight;
		this.defaultDepth.t = this.allocDepthBuffer(this.defaultDepth);
		return this.defaultDepth;
	}
	,discardError: function() {
		if(h3d_impl_GlDriver.outOfMemoryCheck) {
			this.gl.getError();
		}
	}
	,allocBuffer: function(b) {
		if(h3d_impl_GlDriver.outOfMemoryCheck) {
			this.gl.getError();
		}
		var vb = this.gl.createBuffer();
		var type = (b.flags & 1 << h3d_BufferFlag.IndexBuffer._hx_index) != 0 ? 34963 : 34962;
		this.gl.bindBuffer(type,vb);
		if(b.vertices * b.format.stride == 0) {
			throw haxe_Exception.thrown("assert");
		}
		this.gl.bufferData(type,b.vertices * b.format.strideBytes,(b.flags & 1 << h3d_BufferFlag.Dynamic._hx_index) != 0 ? 35048 : 35044);
		var outOfMem = h3d_impl_GlDriver.outOfMemoryCheck && this.gl.getError() == 1285;
		this.gl.bindBuffer(type,null);
		if((b.flags & 1 << h3d_BufferFlag.IndexBuffer._hx_index) != 0) {
			this.curIndexBuffer = null;
		}
		if(outOfMem) {
			this.gl.deleteBuffer(vb);
			return null;
		}
		return vb;
	}
	,disposeTexture: function(t) {
		var tt = t.t;
		if(tt == null) {
			return;
		}
		t.t = null;
		var _g = 0;
		var _g1 = this.boundTextures.length;
		while(_g < _g1) {
			var i = _g++;
			if(this.boundTextures[i] == tt) {
				this.boundTextures[i] = null;
			}
		}
		this.gl.deleteTexture(tt.t);
	}
	,disposeBuffer: function(b) {
		this.gl.deleteBuffer(b.vbuf);
	}
	,generateMipMaps: function(t) {
		var bind = this.getBindType(t);
		this.gl.bindTexture(bind,t.t.t);
		this.gl.generateMipmap(bind);
		this.restoreBind();
	}
	,uploadTextureBitmap: function(t,bmp,mipLevel,side) {
		if(t.format != hxd_PixelFormat.RGBA || t.get_layerCount() != 1) {
			var pixels = bmp.getPixels();
			this.uploadTexturePixels(t,pixels,mipLevel,side);
			pixels.dispose();
		} else {
			var img = bmp.ctx;
			this.gl.bindTexture(3553,t.t.t);
			this.gl.texSubImage2D(3553,mipLevel,0,0,this.getChannels(t.t),t.t.pixelFmt,img.getImageData(0,0,bmp.ctx.canvas.width,bmp.ctx.canvas.height));
			this.restoreBind();
		}
	}
	,resetStream: function() {
	}
	,streamData: function(data,pos,length) {
		return data;
	}
	,uploadTexturePixels: function(t,pixels,mipLevel,side) {
		var cubic = (t.flags & 1 << h3d_mat_TextureFlags.Cube._hx_index) != 0;
		var face = 3553;
		if(cubic) {
			face = h3d_impl_GlDriver.CUBE_FACES[side];
		}
		if((t.flags & 1 << h3d_mat_TextureFlags.IsArray._hx_index) != 0) {
			face = 35866;
		} else if((t.flags & 1 << h3d_mat_TextureFlags.Is3D._hx_index) != 0) {
			face = 32879;
		}
		var bind = this.getBindType(t);
		this.gl.bindTexture(bind,t.t.t);
		pixels.convert(t.format);
		var dataLen = pixels.dataSize;
		var buffer;
		switch(t.format._hx_index) {
		case 4:case 7:case 10:case 13:
			buffer = new Float32Array(pixels.bytes.b.buffer,pixels.offset,dataLen >> 2);
			break;
		case 16:case 17:
			buffer = new Uint32Array(pixels.bytes.b.buffer,pixels.offset,dataLen >> 2);
			break;
		case 3:case 6:case 9:case 12:case 18:case 19:case 20:case 21:
			buffer = new Uint16Array(pixels.bytes.b.buffer,pixels.offset,dataLen >> 1);
			break;
		default:
			buffer = new Uint8Array(pixels.bytes.b.buffer,pixels.offset,dataLen);
		}
		var _g = t.format;
		var tmp;
		if(_g._hx_index == 22) {
			var _g1 = _g.v;
			tmp = true;
		} else {
			tmp = false;
		}
		if(tmp) {
			if((t.flags & 1 << h3d_mat_TextureFlags.IsArray._hx_index) != 0 || (t.flags & 1 << h3d_mat_TextureFlags.Is3D._hx_index) != 0) {
				this.gl.compressedTexSubImage3D(face,mipLevel,0,0,side,pixels.width,pixels.height,1,t.t.internalFmt,buffer);
			} else {
				this.gl.compressedTexSubImage2D(face,mipLevel,0,0,pixels.width,pixels.height,t.t.internalFmt,buffer);
			}
		} else if((t.flags & 1 << h3d_mat_TextureFlags.IsArray._hx_index) != 0 || (t.flags & 1 << h3d_mat_TextureFlags.Is3D._hx_index) != 0) {
			this.gl.texSubImage3D(face,mipLevel,0,0,side,pixels.width,pixels.height,1,this.getChannels(t.t),t.t.pixelFmt,buffer);
		} else {
			this.gl.texSubImage2D(face,mipLevel,0,0,pixels.width,pixels.height,this.getChannels(t.t),t.t.pixelFmt,buffer);
		}
		t.flags |= 1 << h3d_mat_TextureFlags.WasCleared._hx_index;
		this.restoreBind();
	}
	,uploadBufferData: function(b,startVertex,vertexCount,buf,bufPos) {
		var stride = b.format.strideBytes;
		this.gl.bindBuffer(34962,b.vbuf);
		var buf1 = buf.array;
		var sub = new Float32Array(buf1.buffer,bufPos * 4,vertexCount * stride >> 2);
		this.gl.bufferSubData(34962,startVertex * stride,sub);
		this.gl.bindBuffer(34962,null);
	}
	,uploadBufferBytes: function(b,startVertex,vertexCount,buf,bufPos) {
		var stride = b.format.strideBytes;
		var type = (b.flags & 1 << h3d_BufferFlag.IndexBuffer._hx_index) != 0 ? 34963 : 34962;
		this.gl.bindBuffer(type,b.vbuf);
		var sub = new Uint8Array(buf.b.bufferValue,bufPos,vertexCount * stride);
		this.gl.bufferSubData(type,startVertex * stride,sub);
		this.gl.bindBuffer(type,null);
		if((b.flags & 1 << h3d_BufferFlag.IndexBuffer._hx_index) != 0) {
			this.curIndexBuffer = null;
		}
	}
	,uploadIndexData: function(i,startIndice,indiceCount,buf,bufPos) {
		var bits = i.format.strideBytes >> 1;
		this.gl.bindBuffer(34963,i.vbuf);
		var buf1 = new Uint16Array(buf);
		var sub = new Uint16Array(buf1.buffer,bufPos << bits,indiceCount);
		this.gl.bufferSubData(34963,startIndice << bits,sub);
		this.gl.bindBuffer(34963,null);
		this.curIndexBuffer = null;
	}
	,updateDivisor: function(a) {
		if(this.currentDivisor[a.index] != a.divisor) {
			this.currentDivisor[a.index] = a.divisor;
			this.gl.vertexAttribDivisor(a.index,a.divisor);
		}
	}
	,selectBuffer: function(b) {
		if(b == this.curBuffer) {
			return;
		}
		if(this.curShader == null) {
			throw haxe_Exception.thrown("No shader selected");
		}
		this.gl.bindBuffer(34962,b.vbuf);
		this.curBuffer = b;
		var strideBytes = b.format.strideBytes;
		var map = b.format.resolveMapping(this.curShader.format);
		var _g_current = 0;
		var _g_array = this.curShader.attribs;
		while(_g_current < _g_array.length) {
			var _g_value = _g_array[_g_current];
			var _g_key = _g_current++;
			var i = _g_key;
			var a = _g_value;
			var inf = map[i];
			var norm = false;
			var tmp = this.gl;
			var a1 = a.index;
			var a2 = a.size;
			var tmp1;
			switch(inf & 7) {
			case 0:
				tmp1 = a.type;
				break;
			case 1:
				tmp1 = 5131;
				break;
			case 2:
				norm = true;
				tmp1 = 5121;
				break;
			case 3:
				norm = true;
				tmp1 = 5120;
				break;
			}
			tmp.vertexAttribPointer(a1,a2,tmp1,norm,strideBytes,inf >> 16);
			if(this.currentDivisor[a.index] != a.divisor) {
				this.currentDivisor[a.index] = a.divisor;
				this.gl.vertexAttribDivisor(a.index,a.divisor);
			}
		}
	}
	,selectMultiBuffers: function(format,buffers) {
		var format1 = this.curShader.format;
		var m = format.mappings[format1.uid];
		if(m == null) {
			m = format.makeMapping(format1);
		}
		var map = m;
		var _g_current = 0;
		var _g_array = this.curShader.attribs;
		while(_g_current < _g_array.length) {
			var _g_value = _g_array[_g_current];
			var _g_key = _g_current++;
			var i = _g_key;
			var a = _g_value;
			var inf = map[i];
			var b = buffers[inf >> 3 & 255];
			if(this.curBuffer != b) {
				this.gl.bindBuffer(34962,b.vbuf);
				this.curBuffer = b;
			}
			var norm = false;
			var tmp = this.gl;
			var a1 = a.index;
			var a2 = a.size;
			var tmp1;
			switch(inf & 7) {
			case 0:
				tmp1 = a.type;
				break;
			case 1:
				tmp1 = 5131;
				break;
			case 2:
				norm = true;
				tmp1 = 5121;
				break;
			case 3:
				norm = true;
				tmp1 = 5120;
				break;
			}
			tmp.vertexAttribPointer(a1,a2,tmp1,norm,b.format.strideBytes,inf >> 16);
			if(this.currentDivisor[a.index] != a.divisor) {
				this.currentDivisor[a.index] = a.divisor;
				this.gl.vertexAttribDivisor(a.index,a.divisor);
			}
		}
	}
	,draw: function(ibuf,startIndex,ntriangles) {
		if(ibuf != this.curIndexBuffer) {
			this.curIndexBuffer = ibuf;
			this.gl.bindBuffer(34963,ibuf.vbuf);
		}
		if(ibuf.format.strideBytes == 4) {
			this.gl.drawElements(this.drawMode,ntriangles * 3,5125,startIndex * 4);
		} else {
			this.gl.drawElements(this.drawMode,ntriangles * 3,5123,startIndex * 2);
		}
	}
	,allocInstanceBuffer: function(b,bytes) {
		var data = [];
		var _g = 0;
		var _g1 = b.commandCount;
		while(_g < _g1) {
			var i = _g++;
			var p = i * 5 * 4;
			var indexCount = bytes.getInt32(p);
			var instanceCount = bytes.getInt32(p + 4);
			var offIndex = bytes.getInt32(p + 8);
			var offVertex = bytes.getInt32(p + 12);
			var offInstance = bytes.getInt32(p + 16);
			if(offVertex != 0 || offInstance != 0) {
				throw haxe_Exception.thrown("baseVertex and baseInstance must be zero on this platform");
			}
			data.push(indexCount);
			data.push(offIndex);
			data.push(instanceCount);
		}
		b.data = data;
	}
	,disposeInstanceBuffer: function(b) {
		b.data = null;
	}
	,drawInstanced: function(ibuf,commands) {
		if(ibuf != this.curIndexBuffer) {
			this.curIndexBuffer = ibuf;
			this.gl.bindBuffer(34963,ibuf.vbuf);
		}
		var kind;
		var size;
		if(ibuf.format.strideBytes == 4) {
			kind = 5125;
			size = 4;
		} else {
			kind = 5123;
			size = 2;
		}
		var args = commands.data;
		if(args != null) {
			var p = 0;
			var _g = 0;
			var _g1 = args.length / 3 | 0;
			while(_g < _g1) {
				var i = _g++;
				this.gl.drawElementsInstanced(this.drawMode,args[p++],kind,args[p++] * size,args[p++]);
			}
		} else {
			this.gl.drawElementsInstanced(this.drawMode,commands.indexCount,kind,commands.startIndex * size,commands.commandCount);
		}
	}
	,end: function() {
	}
	,present: function() {
	}
	,isDisposed: function() {
		return this.gl.isContextLost();
	}
	,setRenderZone: function(x,y,width,height) {
		if(x == 0 && y == 0 && width < 0 && height < 0) {
			this.gl.disable(3089);
		} else {
			this.gl.enable(3089);
			if(this.curTarget == null) {
				y = this.bufferHeight - (y + height);
			}
			this.gl.scissor(x,y,width,height);
		}
	}
	,setDrawBuffers: function(k) {
		if(this.glES >= 3) {
			this.gl.drawBuffers(h3d_impl_GlDriver.CBUFFERS[k]);
		} else if(this.mrtExt != null) {
			this.mrtExt.drawBuffersWEBGL(h3d_impl_GlDriver.CBUFFERS[k]);
		}
	}
	,unbindTargets: function() {
		if(this.curTarget != null && this.numTargets > 1) {
			while(this.numTargets > 1) {
				this.gl.framebufferTexture2D(36160,36064 + --this.numTargets,3553,null,0);
				this.curTargets[this.numTargets] = null;
			}
			this.setDrawBuffers(1);
		}
	}
	,capturePixels: function(tex,layer,mipLevel,region) {
		var x;
		var y;
		var w;
		var h;
		if(region != null) {
			if(region.xMax > tex.width) {
				region.xMax = tex.width;
			}
			if(region.yMax > tex.height) {
				region.yMax = tex.height;
			}
			if(region.xMin < 0) {
				region.xMin = 0;
			}
			if(region.yMin < 0) {
				region.yMin = 0;
			}
			w = region.xMax - region.xMin;
			h = region.yMax - region.yMin;
			x = region.xMin;
			y = region.yMin;
		} else {
			w = tex.width;
			h = tex.height;
			x = 0;
			y = 0;
		}
		w >>= mipLevel;
		h >>= mipLevel;
		if(w == 0) {
			w = 1;
		}
		if(h == 0) {
			h = 1;
		}
		var pixels = hxd_Pixels.alloc(w,h,tex.format);
		var old = this.curTarget;
		var oldCount = this.numTargets;
		var oldLayer = this.curTargetLayer;
		var oldMip = this.curTargetMip;
		if(oldCount > 1) {
			this.numTargets = 1;
			var _g = 1;
			var _g1 = oldCount;
			while(_g < _g1) {
				var i = _g++;
				if(this.curTargets[i] == tex) {
					this.gl.framebufferTexture2D(36160,36064 + i,3553,null,0);
				}
			}
		}
		this.setRenderTarget(tex,layer,mipLevel);
		this.captureSubRenderBuffer(pixels,x,y);
		this.setRenderTarget(old,oldLayer,oldMip);
		if(oldCount > 1) {
			var _g = 1;
			var _g1 = oldCount;
			while(_g < _g1) {
				var i = _g++;
				if(this.curTargets[i] == tex) {
					this.gl.framebufferTexture2D(36160,36064 + i,3553,tex.t.t,0);
				}
			}
			this.setDrawBuffers(oldCount);
			this.numTargets = oldCount;
		}
		return pixels;
	}
	,setRenderTarget: function(tex,layer,mipLevel,depthBinding) {
		if(depthBinding == null) {
			depthBinding = h3d_DepthBinding.ReadWrite;
		}
		if(mipLevel == null) {
			mipLevel = 0;
		}
		if(layer == null) {
			layer = 0;
		}
		this.unbindTargets();
		this.curTarget = tex;
		if(tex == null) {
			this.gl.bindFramebuffer(36160,null);
			this.gl.viewport(0,0,this.bufferWidth,this.bufferHeight);
			return;
		}
		if(tex.depthBuffer != null && (tex.depthBuffer.width != tex.width || tex.depthBuffer.height != tex.height)) {
			throw haxe_Exception.thrown("Invalid depth buffer size : does not match render target size");
		}
		if(mipLevel > 0 && this.glES == 1) {
			throw haxe_Exception.thrown("Cannot render to mipLevel in WebGL1, use upload() instead");
		}
		if(tex.t == null) {
			tex.alloc();
		}
		if((tex.flags & 1 << h3d_mat_TextureFlags.MipMapped._hx_index) != 0 && (tex.flags & 1 << h3d_mat_TextureFlags.WasCleared._hx_index) == 0) {
			var bind = this.getBindType(tex);
			this.gl.bindTexture(bind,tex.t.t);
			this.gl.generateMipmap(bind);
			this.restoreBind();
		}
		tex.set_lastFrame(this.frame);
		this.curTargetLayer = layer;
		this.curTargetMip = mipLevel;
		this.gl.bindFramebuffer(36160,this.commonFB);
		if((tex.flags & 1 << h3d_mat_TextureFlags.IsArray._hx_index) != 0) {
			this.gl.framebufferTextureLayer(36160,36064,tex.t.t,mipLevel,layer);
		} else {
			this.gl.framebufferTexture2D(36160,36064,(tex.flags & 1 << h3d_mat_TextureFlags.Cube._hx_index) != 0 ? h3d_impl_GlDriver.CUBE_FACES[layer] : 3553,tex.t.t,mipLevel);
		}
		this.setPolygonOffset(tex.depthBuffer);
		this.setDepthClamp(tex.depthBuffer);
		if(tex.depthBuffer != null && depthBinding != h3d_DepthBinding.NotBound) {
			if(tex.depthBuffer.hasStencil() && tex.depthBuffer.format == hxd_PixelFormat.Depth24Stencil8) {
				this.gl.framebufferTexture2D(36160,33306,3553,tex.depthBuffer.t.t,0);
			} else {
				this.gl.framebufferTexture2D(36160,33306,3553,null,0);
				this.gl.framebufferTexture2D(36160,36096,3553,tex.depthBuffer.t.t,0);
				this.gl.framebufferTexture2D(36160,36128,3553,tex.depthBuffer.hasStencil() ? tex.depthBuffer.t.t : null,0);
			}
		} else {
			this.gl.framebufferTexture2D(36160,33306,3553,null,0);
			this.gl.framebufferTexture2D(36160,36096,3553,null,0);
			this.gl.framebufferTexture2D(36160,36128,3553,null,0);
		}
		var w = tex.width >> mipLevel;
		if(w == 0) {
			w = 1;
		}
		var h = tex.height >> mipLevel;
		if(h == 0) {
			h = 1;
		}
		this.gl.viewport(0,0,w,h);
		var _g = 0;
		var _g1 = this.boundTextures.length;
		while(_g < _g1) {
			var i = _g++;
			this.boundTextures[i] = null;
		}
		if((tex.flags & 1 << h3d_mat_TextureFlags.WasCleared._hx_index) == 0) {
			tex.flags |= 1 << h3d_mat_TextureFlags.WasCleared._hx_index;
			this.clear(h3d_impl_GlDriver.BLACK);
		}
		if(this.glDebug) {
			var code = this.gl.checkFramebufferStatus(36160);
			if(code != 36053) {
				throw haxe_Exception.thrown("Invalid frame buffer: " + code);
			}
		}
	}
	,setRenderTargets: function(textures,depthBinding) {
		if(depthBinding == null) {
			depthBinding = h3d_DepthBinding.ReadWrite;
		}
		this.unbindTargets();
		this.setRenderTarget(textures[0],null,null,depthBinding);
		if(textures.length < 2) {
			return;
		}
		this.numTargets = textures.length;
		var needClear = false;
		var _g = 1;
		var _g1 = textures.length;
		while(_g < _g1) {
			var i = _g++;
			var tex = textures[i];
			if(tex.t == null) {
				tex.alloc();
			}
			this.gl.framebufferTexture2D(36160,36064 + i,3553,tex.t.t,0);
			this.curTargets[i] = tex;
			tex.set_lastFrame(this.frame);
			if((tex.flags & 1 << h3d_mat_TextureFlags.WasCleared._hx_index) == 0) {
				tex.flags |= 1 << h3d_mat_TextureFlags.WasCleared._hx_index;
				needClear = true;
			}
		}
		this.setDrawBuffers(textures.length);
		if(needClear) {
			this.clear(h3d_impl_GlDriver.BLACK);
		}
	}
	,setDepth: function(depthBuffer) {
		this.unbindTargets();
		this.curTarget = depthBuffer;
		depthBuffer.set_lastFrame(this.frame);
		this.curTargetLayer = 0;
		this.curTargetMip = 0;
		this.gl.bindFramebuffer(36160,this.commonFB);
		this.gl.framebufferTexture2D(36160,36064,3553,null,0);
		this.setPolygonOffset(depthBuffer);
		this.setDepthClamp(depthBuffer);
		if(depthBuffer.hasStencil() && depthBuffer.format == hxd_PixelFormat.Depth24Stencil8) {
			this.gl.framebufferTexture2D(36160,33306,3553,depthBuffer.t.t,0);
		} else {
			this.gl.framebufferTexture2D(36160,33306,3553,null,0);
			this.gl.framebufferTexture2D(36160,36096,3553,depthBuffer.t.t,0);
			this.gl.framebufferTexture2D(36160,36128,3553,depthBuffer.hasStencil() ? depthBuffer.t.t : null,0);
		}
		var w = depthBuffer.width;
		if(w == 0) {
			w = 1;
		}
		var h = depthBuffer.height;
		if(h == 0) {
			h = 1;
		}
		this.gl.viewport(0,0,w,h);
		var _g = 0;
		var _g1 = this.boundTextures.length;
		while(_g < _g1) {
			var i = _g++;
			this.boundTextures[i] = null;
		}
		if(this.glDebug) {
			var code = this.gl.checkFramebufferStatus(36160);
			if(code != 36053) {
				throw haxe_Exception.thrown("Invalid frame buffer: " + code);
			}
		}
	}
	,onTextureBiasChanged: function(t) {
		this.setPolygonOffset(t);
	}
	,setPolygonOffset: function(depthBuffer) {
		if(depthBuffer != null && (depthBuffer.depthBias != 0 || depthBuffer.slopeScaledBias != 0)) {
			this.gl.enable(32823);
			this.gl.polygonOffset(depthBuffer.slopeScaledBias,depthBuffer.depthBias);
		} else {
			this.gl.disable(32823);
		}
	}
	,setDepthClamp: function(dephTexture) {
	}
	,init: function(onCreate,forceSoftware) {
		if(forceSoftware == null) {
			forceSoftware = false;
		}
		if(window.document.readyState == "complete") {
			var _g = onCreate;
			var a1 = false;
			haxe_Timer.delay(function() {
				_g(a1);
			},1);
		} else {
			var onLoad = null;
			onLoad = function() {
				window.removeEventListener("load",onLoad);
				onCreate(false);
			};
			window.addEventListener("load",onLoad);
		}
	}
	,hasFeature: function(f) {
		return this.features.get(f);
	}
	,makeFeatures: function() {
		var _g = 0;
		var _g1 = h3d_impl_Feature.__empty_constructs__.slice();
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			this.features.set(f,this.checkFeature(f));
		}
		if(this.gl.getExtension("WEBGL_compressed_texture_s3tc") != null) {
			this.maxCompressedTexturesSupport = 3;
			if(this.gl.getExtension("EXT_texture_compression_bptc") != null) {
				this.maxCompressedTexturesSupport = 7;
			}
		}
		if(this.glES < 3) {
			this.gl.getExtension("WEBGL_depth_texture");
		}
		this.has16Bits = this.gl.getExtension("EXT_texture_norm16") != null;
	}
	,checkFeature: function(f) {
		switch(f._hx_index) {
		case 0:
			if(this.glES >= 3) {
				return true;
			} else {
				return this.gl.getExtension("OES_standard_derivatives") != null;
			}
			break;
		case 1:
			if(this.glES >= 3) {
				if(this.gl.getExtension("EXT_color_buffer_float") != null) {
					return this.gl.getExtension("OES_texture_float_linear") != null;
				} else {
					return false;
				}
			} else if(this.gl.getExtension("OES_texture_float") != null && this.gl.getExtension("OES_texture_float_linear") != null && this.gl.getExtension("OES_texture_half_float") != null) {
				return this.gl.getExtension("OES_texture_half_float_linear") != null;
			} else {
				return false;
			}
			break;
		case 4:
			if(this.glES >= 3) {
				return true;
			} else if(this.mrtExt == null) {
				return (this.mrtExt = this.gl.getExtension("WEBGL_draw_buffers")) != null;
			} else {
				return true;
			}
			break;
		case 6:
			if(this.glES >= 3) {
				return true;
			} else {
				return this.gl.getExtension("EXT_sRGB") != null;
			}
			break;
		case 7:
			if(this.glES >= 3) {
				return true;
			} else {
				return false;
			}
			break;
		case 2:case 3:case 8:case 9:
			return true;
		case 10:
			if(this.glES >= 3) {
				return true;
			} else {
				return this.gl.getExtension("ANGLE_instanced_arrays") != null;
			}
			break;
		default:
			return false;
		}
	}
	,uploadTextureVideoElement: function(t,v,mipLevel,side) {
		var cubic = (t.flags & 1 << h3d_mat_TextureFlags.Cube._hx_index) != 0;
		var bind = this.getBindType(t);
		if((t.flags & 1 << h3d_mat_TextureFlags.IsArray._hx_index) != 0) {
			throw haxe_Exception.thrown("TODO:texImage3D");
		}
		var face = cubic ? h3d_impl_GlDriver.CUBE_FACES[side] : 3553;
		this.gl.bindTexture(bind,t.t.t);
		this.gl.texSubImage2D(face,mipLevel,0,0,v.videoWidth,v.videoHeight,this.getChannels(t.t),t.t.pixelFmt,v);
		this.restoreBind();
	}
	,captureRenderBuffer: function(pixels) {
		this.captureSubRenderBuffer(pixels,0,0);
	}
	,captureSubRenderBuffer: function(pixels,x,y) {
		if(this.curTarget == null) {
			throw haxe_Exception.thrown("Can't capture main render buffer in GL");
		}
		this.gl.getError();
		var buffer = pixels.bytes.b;
		switch(this.curTarget.format._hx_index) {
		case 4:case 7:case 10:case 13:
			buffer = new Float32Array(buffer.buffer);
			break;
		case 16:case 17:
			buffer = new Uint32Array(buffer.buffer);
			break;
		case 3:case 6:case 9:case 12:case 18:case 19:case 20:case 21:
			buffer = new Uint16Array(buffer.buffer);
			break;
		default:
		}
		this.gl.readPixels(x,y,pixels.width,pixels.height,this.getChannels(this.curTarget.t),this.curTarget.t.pixelFmt,buffer);
		var error = this.gl.getError();
		if(error != 0) {
			throw haxe_Exception.thrown("Failed to capture pixels (error " + error + ")");
		}
		pixels.set_innerFormat(this.curTarget.format);
	}
	,__class__: h3d_impl_GlDriver
});
var h3d_impl_InstanceBuffer = function() {
	this.triCount = 0;
};
$hxClasses["h3d.impl.InstanceBuffer"] = h3d_impl_InstanceBuffer;
h3d_impl_InstanceBuffer.__name__ = "h3d.impl.InstanceBuffer";
h3d_impl_InstanceBuffer.prototype = {
	setCommand: function(commandCount,indexCount,startIndex) {
		if(startIndex == null) {
			startIndex = 0;
		}
		this.commandCount = commandCount;
		this.indexCount = indexCount;
		this.triCount = commandCount * indexCount / 3 | 0;
		this.startIndex = startIndex;
	}
	,setBuffer: function(commandCount,bytes) {
		this.dispose();
		var _g = 0;
		var _g1 = commandCount;
		while(_g < _g1) {
			var i = _g++;
			var idxCount = bytes.getInt32(i * 20);
			var instCount = bytes.getInt32(i * 20 + 4);
			var tri = idxCount * instCount / 3 | 0;
			this.triCount += tri;
		}
		this.commandCount = commandCount;
		this.indexCount = 0;
		this.driver = h3d_Engine.CURRENT.driver;
		this.driver.allocInstanceBuffer(this,bytes);
	}
	,dispose: function() {
		if(this.data != null) {
			this.driver.disposeInstanceBuffer(this);
		}
	}
	,__class__: h3d_impl_InstanceBuffer
};
var h3d_impl_MemoryManager = function(driver) {
	this.lastAutoDispose = 0;
	this.autoDisposeCooldown = 60;
	this.texMemory = 0;
	this.usedMemory = 0;
	this.driver = driver;
};
$hxClasses["h3d.impl.MemoryManager"] = h3d_impl_MemoryManager;
h3d_impl_MemoryManager.__name__ = "h3d.impl.MemoryManager";
h3d_impl_MemoryManager.enableTrackAlloc = function(b) {
	hxd_impl_AllocPos.ENABLED = b != null ? b : true;
};
h3d_impl_MemoryManager.prototype = {
	init: function() {
		this.textures = [];
		this.buffers = [];
		this.initIndexes();
	}
	,initIndexes: function() {
		var indices = new Array(0);
		var _g = 0;
		while(_g < 65532) {
			var i = _g++;
			indices.push(i);
		}
		this.triIndexes16 = h3d_Indexes.alloc(indices);
		var indices = new Array(0);
		var p = 0;
		var _g = 0;
		while(_g < 10922) {
			var i = _g++;
			var k = i << 2;
			indices.push(k);
			indices.push(k + 1);
			indices.push(k + 2);
			indices.push(k + 2);
			indices.push(k + 1);
			indices.push(k + 3);
		}
		indices.push(65532);
		this.quadIndexes16 = h3d_Indexes.alloc(indices);
	}
	,garbage: function() {
	}
	,getTriIndexes: function(vertices) {
		if(vertices <= 65532) {
			return this.triIndexes16;
		}
		if(this.triIndexes32 == null || this.triIndexes32.vertices < vertices) {
			var sz = 131072;
			while(sz < vertices) sz <<= 1;
			var bytes = new haxe_io_Bytes(new ArrayBuffer(sz << 2));
			var _g = 0;
			var _g1 = sz;
			while(_g < _g1) {
				var i = _g++;
				bytes.setInt32(i << 2,i);
			}
			if(this.triIndexes32 != null) {
				this.triIndexes32.dispose();
			}
			this.triIndexes32 = h3d_Indexes._new(sz,true);
			this.triIndexes32.uploadBytes(bytes,0,sz);
		}
		return this.triIndexes32;
	}
	,getQuadIndexes: function(vertices) {
		var nquads = (vertices + 3 >> 2) * 6;
		if(nquads <= 65532) {
			return this.quadIndexes16;
		}
		if(this.quadIndexes32 == null || this.quadIndexes32.vertices < vertices) {
			var sz = 131072;
			while(sz < nquads) sz <<= 1;
			var bytes = new haxe_io_Bytes(new ArrayBuffer(sz << 2));
			var p = 0;
			var _g = 0;
			var _g1 = sz / 6 | 0;
			while(_g < _g1) {
				var i = _g++;
				var k = i << 2;
				bytes.setInt32(p++ << 2,k);
				bytes.setInt32(p++ << 2,k + 1);
				bytes.setInt32(p++ << 2,k + 2);
				bytes.setInt32(p++ << 2,k + 2);
				bytes.setInt32(p++ << 2,k + 1);
				bytes.setInt32(p++ << 2,k + 3);
			}
			if(this.quadIndexes32 != null) {
				this.quadIndexes32.dispose();
			}
			this.quadIndexes32 = h3d_Indexes._new(sz,true);
			this.quadIndexes32.uploadBytes(bytes,0,sz);
		}
		return this.quadIndexes32;
	}
	,allocBuffer: function(b) {
		if(b.vbuf != null) {
			return;
		}
		var mem = b.vertices * b.format.strideBytes;
		if(mem == 0) {
			return;
		}
		while(this.usedMemory + mem > 4294967296. || (b.vbuf = this.driver.allocBuffer(b)) == null) {
			if(this.driver.isDisposed()) {
				return;
			}
			var size = this.usedMemory;
			this.garbage();
			if(this.usedMemory == size) {
				throw haxe_Exception.thrown("Memory full (" + Math.ceil(size / 1024) + " KB," + this.buffers.length + " buffers)");
			}
		}
		this.usedMemory += mem;
		this.buffers.push(b);
	}
	,freeBuffer: function(b) {
		if(b.vbuf == null) {
			return;
		}
		this.driver.disposeBuffer(b);
		b.vbuf = null;
		if(HxOverrides.remove(this.buffers,b)) {
			this.usedMemory -= b.vertices * b.format.strideBytes;
		}
	}
	,memSize: function(t) {
		if((t.flags & 1 << h3d_mat_TextureFlags.AsyncLoading._hx_index) != 0 && (t.flags & 1 << h3d_mat_TextureFlags.Loading._hx_index) != 0) {
			return 4;
		}
		var size = hxd_Pixels.calcDataSize(t.width,t.height,t.format);
		if(t.get_mipLevels() > 0) {
			var _g = 1;
			var _g1 = t.get_mipLevels();
			while(_g < _g1) {
				var i = _g++;
				var w = t.width >> i;
				if(w == 0) {
					w = 1;
				}
				var h = t.height >> i;
				if(h == 0) {
					h = 1;
				}
				size += hxd_Pixels.calcDataSize(w,h,t.format);
			}
		}
		return size * t.get_layerCount();
	}
	,cleanTextures: function(force) {
		if(force == null) {
			force = true;
		}
		this.textures.sort($bind(this,this.sortByLRU));
		var _g = 0;
		var _g1 = this.textures;
		while(_g < _g1.length) {
			var t = _g1[_g];
			++_g;
			if(t.realloc == null || t.t == null && (t.isDepth() || t.realloc == null)) {
				continue;
			}
			if((force || t._lastFrame < hxd_Timer.frameCount - 3600) && t._lastFrame != h3d_mat_Texture.PREVENT_AUTO_DISPOSE) {
				t.dispose();
				return true;
			}
		}
		return false;
	}
	,sortByLRU: function(t1,t2) {
		return t1._lastFrame - t2._lastFrame;
	}
	,deleteTexture: function(t) {
		if(!HxOverrides.remove(this.textures,t)) {
			return;
		}
		this.driver.disposeTexture(t);
		this.texMemory -= this.memSize(t);
	}
	,allocTexture: function(t) {
		while(true) {
			var free = true;
			if(hxd_Timer.frameCount > this.lastAutoDispose + this.autoDisposeCooldown) {
				free = this.cleanTextures(false);
				this.lastAutoDispose = hxd_Timer.frameCount;
			}
			t.t = t.isDepth() ? this.driver.allocDepthBuffer(t) : this.driver.allocTexture(t);
			if(t.t != null) {
				break;
			}
			if(this.driver.isDisposed()) {
				return;
			}
			while(this.cleanTextures(false)) {
			}
			if(!free && !this.cleanTextures(true)) {
				throw haxe_Exception.thrown("Maximum texture memory reached");
			}
		}
		this.textures.push(t);
		this.texMemory += this.memSize(t);
	}
	,onContextLost: function() {
		this.dispose();
		this.initIndexes();
	}
	,dispose: function() {
		if(this.triIndexes16 != null) {
			this.triIndexes16.dispose();
		}
		if(this.quadIndexes16 != null) {
			this.quadIndexes16.dispose();
		}
		if(this.triIndexes32 != null) {
			this.triIndexes32.dispose();
		}
		if(this.quadIndexes32 != null) {
			this.quadIndexes32.dispose();
		}
		this.triIndexes16 = null;
		this.quadIndexes16 = null;
		this.triIndexes32 = null;
		this.quadIndexes32 = null;
		var _g = 0;
		var _g1 = this.textures.slice();
		while(_g < _g1.length) {
			var t = _g1[_g];
			++_g;
			t.dispose();
		}
		var _g = 0;
		var _g1 = this.buffers.slice();
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			b.dispose();
		}
		this.buffers = [];
		this.textures = [];
		this.usedMemory = 0;
		this.texMemory = 0;
	}
	,stats: function() {
		var total = 0.;
		var _g = 0;
		var _g1 = this.buffers;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			total += b.vertices * b.format.strideBytes;
		}
		return { bufferCount : this.buffers.length, bufferMemory : total, totalMemory : this.usedMemory + this.texMemory, textureCount : this.textures.length, textureMemory : this.texMemory};
	}
	,allocStats: function() {
		var h_h = Object.create(null);
		var all = [];
		var _g = 0;
		var _g1 = this.textures;
		while(_g < _g1.length) {
			var t = _g1[_g];
			++_g;
			if(t.allocPos == null) {
				continue;
			}
			var key = "$" + t.allocPos.position;
			var inf = h_h[key];
			if(inf == null) {
				inf = { position : t.allocPos.position, count : 0, size : 0, tex : true, stacks : []};
				h_h[key] = inf;
				all.push(inf);
			}
			inf.count++;
			var size = this.memSize(t);
			inf.size += size;
			var name = t.name;
			var stacks = inf.stacks;
			var stackStr = t.allocPos.stack.join("\n");
			var _g2 = 0;
			while(_g2 < stacks.length) {
				var s = stacks[_g2];
				++_g2;
				if(s.stack == stackStr) {
					s.size += size;
					s.count++;
					s.stats.push({ name : name, size : size});
					stackStr = null;
				}
			}
			if(stackStr != null) {
				stacks.push({ stats : [{ name : name, size : size}], stack : stackStr, count : 1, size : size});
			}
		}
		var _g = 0;
		var _g1 = this.buffers;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			if(b.allocPos == null) {
				continue;
			}
			var key = b.allocPos.position;
			var inf = h_h[key];
			if(inf == null) {
				inf = { position : key, count : 0, size : 0, tex : false, stacks : []};
				h_h[key] = inf;
				all.push(inf);
			}
			inf.count++;
			var size = b.vertices * b.format.stride * 4;
			inf.size += size;
			var stacks = inf.stacks;
			var stackStr = b.allocPos.stack.join("\n");
			var _g2 = 0;
			while(_g2 < stacks.length) {
				var s = stacks[_g2];
				++_g2;
				if(s.stack == stackStr) {
					s.size += size;
					s.count++;
					s.stats.push({ name : "buffer", size : size});
					stackStr = null;
				}
			}
			if(stackStr != null) {
				stacks.push({ stats : [{ name : "buffer", size : size}], stack : stackStr, count : 1, size : size});
			}
		}
		all.sort(function(a,b) {
			return b.size - a.size;
		});
		return all;
	}
	,__class__: h3d_impl_MemoryManager
};
var h3d_impl_NullDriver = function() {
	h3d_impl_Driver.call(this);
};
$hxClasses["h3d.impl.NullDriver"] = h3d_impl_NullDriver;
h3d_impl_NullDriver.__name__ = "h3d.impl.NullDriver";
h3d_impl_NullDriver.__super__ = h3d_impl_Driver;
h3d_impl_NullDriver.prototype = $extend(h3d_impl_Driver.prototype,{
	hasFeature: function(f) {
		return true;
	}
	,isSupportedFormat: function(fmt) {
		return true;
	}
	,logImpl: function(str) {
		haxe_Log.trace(str,{ fileName : "h3d/impl/NullDriver.hx", lineNumber : 23, className : "h3d.impl.NullDriver", methodName : "logImpl"});
	}
	,isDisposed: function() {
		return false;
	}
	,getDriverName: function(details) {
		return "NullDriver";
	}
	,init: function(onCreate,forceSoftware) {
		if(forceSoftware == null) {
			forceSoftware = false;
		}
		onCreate(false);
	}
	,selectShader: function(shader) {
		if(this.cur == shader) {
			return false;
		}
		this.cur = shader;
		return true;
	}
	,allocTexture: function(t) {
		return { };
	}
	,allocBuffer: function(b) {
		return { };
	}
	,__class__: h3d_impl_NullDriver
});
var h3d_impl_Step = $hxEnums["h3d.impl.Step"] = { __ename__:true,__constructs__:null
	,MainDraw: {_hx_name:"MainDraw",_hx_index:0,__enum__:"h3d.impl.Step",toString:$estr}
	,Decals: {_hx_name:"Decals",_hx_index:1,__enum__:"h3d.impl.Step",toString:$estr}
	,Shadows: {_hx_name:"Shadows",_hx_index:2,__enum__:"h3d.impl.Step",toString:$estr}
	,Lighting: {_hx_name:"Lighting",_hx_index:3,__enum__:"h3d.impl.Step",toString:$estr}
	,Forward: {_hx_name:"Forward",_hx_index:4,__enum__:"h3d.impl.Step",toString:$estr}
	,BeforeTonemapping: {_hx_name:"BeforeTonemapping",_hx_index:5,__enum__:"h3d.impl.Step",toString:$estr}
	,AfterTonemapping: {_hx_name:"AfterTonemapping",_hx_index:6,__enum__:"h3d.impl.Step",toString:$estr}
	,Overlay: {_hx_name:"Overlay",_hx_index:7,__enum__:"h3d.impl.Step",toString:$estr}
	,Custom: ($_=function(name) { return {_hx_index:8,name:name,__enum__:"h3d.impl.Step",toString:$estr}; },$_._hx_name="Custom",$_.__params__ = ["name"],$_)
};
h3d_impl_Step.__constructs__ = [h3d_impl_Step.MainDraw,h3d_impl_Step.Decals,h3d_impl_Step.Shadows,h3d_impl_Step.Lighting,h3d_impl_Step.Forward,h3d_impl_Step.BeforeTonemapping,h3d_impl_Step.AfterTonemapping,h3d_impl_Step.Overlay,h3d_impl_Step.Custom];
h3d_impl_Step.__empty_constructs__ = [h3d_impl_Step.MainDraw,h3d_impl_Step.Decals,h3d_impl_Step.Shadows,h3d_impl_Step.Lighting,h3d_impl_Step.Forward,h3d_impl_Step.BeforeTonemapping,h3d_impl_Step.AfterTonemapping,h3d_impl_Step.Overlay];
var h3d_impl_RendererFX = function() { };
$hxClasses["h3d.impl.RendererFX"] = h3d_impl_RendererFX;
h3d_impl_RendererFX.__name__ = "h3d.impl.RendererFX";
h3d_impl_RendererFX.__isInterface__ = true;
h3d_impl_RendererFX.prototype = {
	__class__: h3d_impl_RendererFX
};
var h3d_impl_ShaderCache = function(file,outputFile) {
	this.file = file;
	var tmp = outputFile;
	this.outputFile = tmp != null ? tmp : file;
	this.sourceFile = file + ".source";
};
$hxClasses["h3d.impl.ShaderCache"] = h3d_impl_ShaderCache;
h3d_impl_ShaderCache.__name__ = "h3d.impl.ShaderCache";
h3d_impl_ShaderCache.prototype = {
	disableSave: function() {
		this.outputFile = null;
	}
	,initEmpty: function() {
		this.data = new haxe_ds_StringMap();
		this.sources = new haxe_ds_StringMap();
	}
	,load: function() {
		this.data = new haxe_ds_StringMap();
		try {
			this.loadFile(this.file);
		} catch( _g ) {
		}
		if(this.outputFile != this.file) {
			try {
				this.loadFile(this.outputFile);
			} catch( _g ) {
			}
		}
		if(this.keepSource) {
			try {
				this.loadSources();
			} catch( _g ) {
			}
		}
	}
	,loadFile: function(file) {
		throw haxe_Exception.thrown("Cannot load shader cache with this platform");
	}
	,loadSources: function() {
		throw haxe_Exception.thrown("Cannot load shader cache with this platform");
	}
	,resolveShaderBinary: function(source,configurationKey) {
		if(configurationKey == null) {
			configurationKey = "";
		}
		if(this.data == null) {
			this.load();
		}
		var this1 = this.data;
		var key = configurationKey + haxe_crypto_Md5.encode(source);
		return this1.h[key];
	}
	,saveCompiledShader: function(source,bytes,configurationKey,saveToFile) {
		if(saveToFile == null) {
			saveToFile = true;
		}
		if(configurationKey == null) {
			configurationKey = "";
		}
		if(this.outputFile == null) {
			return;
		}
		if(this.data == null) {
			this.load();
		}
		var key = configurationKey + haxe_crypto_Md5.encode(source);
		if(this.data.h[key] == bytes && (!this.keepSource || this.sources.h[key] == source)) {
			return;
		}
		this.data.h[key] = bytes;
		if(saveToFile) {
			this.save();
		}
		if(this.keepSource) {
			this.sources.h[key] = source;
			this.saveSources();
		}
	}
	,save: function() {
		var out = new haxe_io_BytesOutput();
		var _e = this.data;
		var keys = Lambda.array({ iterator : function() {
			return new haxe_ds__$StringMap_StringMapKeyIterator(_e.h);
		}});
		keys.sort(Reflect.compare);
		var _g = 0;
		while(_g < keys.length) {
			var key = keys[_g];
			++_g;
			out.writeInt32(key.length);
			out.writeString(key);
			var b64 = haxe_crypto_Base64.encode(this.data.h[key]);
			out.writeInt32(b64.length);
			out.writeString(b64);
			out.writeByte(10);
		}
	}
	,saveSources: function() {
		var out = new haxe_io_BytesOutput();
		var _e = this.sources;
		var keys = Lambda.array({ iterator : function() {
			return new haxe_ds__$StringMap_StringMapKeyIterator(_e.h);
		}});
		keys.sort(Reflect.compare);
		var _g = 0;
		while(_g < keys.length) {
			var key = keys[_g];
			++_g;
			out.writeInt32(key.length);
			out.writeString(key);
			var src = this.sources.h[key];
			out.writeInt32(src.length);
			out.writeString(src);
			out.writeByte(10);
			out.writeByte(10);
		}
	}
	,__class__: h3d_impl_ShaderCache
};
var h3d_impl_TextureCache = function() {
	this.position = 0;
	this.cache = [];
	var engine = h3d_Engine.CURRENT;
	this.defaultFormat = h3d_mat_Texture.nativeFormat;
	this.defaultDepthBuffer = h3d_mat_Texture.getDefaultDepth();
	if(h3d_impl_TextureCache.checkFlags < 0) {
		var flags = 0;
		var flagsArray = [h3d_mat_TextureFlags.Cube,h3d_mat_TextureFlags.MipMapped,h3d_mat_TextureFlags.ManualMipMapGen,h3d_mat_TextureFlags.Dynamic,h3d_mat_TextureFlags.IsArray];
		var _g = 0;
		while(_g < flagsArray.length) {
			var f = flagsArray[_g];
			++_g;
			flags |= 1 << f._hx_index;
		}
		h3d_impl_TextureCache.checkFlags = flags;
	}
};
$hxClasses["h3d.impl.TextureCache"] = h3d_impl_TextureCache;
h3d_impl_TextureCache.__name__ = "h3d.impl.TextureCache";
h3d_impl_TextureCache.prototype = {
	get: function(index) {
		if(index == null) {
			index = 0;
		}
		return this.cache[index];
	}
	,getNamed: function(name) {
		var _g = 0;
		var _g1 = this.position;
		while(_g < _g1) {
			var i = _g++;
			if(this.cache[i].name == name) {
				return this.cache[i];
			}
		}
		return null;
	}
	,set: function(t,index) {
		this.cache[index] = t;
	}
	,begin: function() {
		while(this.cache.length > this.position) {
			var t = this.cache.pop();
			if(t != null) {
				t.dispose();
			}
		}
		this.position = 0;
	}
	,matchTargetFlags: function(t,flags) {
		var enumFlags = 0;
		if(flags != null) {
			var _g = 0;
			while(_g < flags.length) {
				var f = flags[_g];
				++_g;
				enumFlags |= 1 << f._hx_index;
			}
		}
		return (t.flags & h3d_impl_TextureCache.checkFlags) == (enumFlags & h3d_impl_TextureCache.checkFlags);
	}
	,lookupTarget: function(name,width,height,format,flags) {
		var t = this.cache[this.position];
		var _g = this.position + 1;
		var _g1 = this.cache.length;
		while(_g < _g1) {
			var i = _g++;
			var t2 = this.cache[i];
			if(t2 != null && !(t2.t == null && (t2.isDepth() || t2.realloc == null)) && t2.width == width && t2.height == height && t2.format == format) {
				var enumFlags = 0;
				if(flags != null) {
					var _g2 = 0;
					while(_g2 < flags.length) {
						var f = flags[_g2];
						++_g2;
						enumFlags |= 1 << f._hx_index;
					}
				}
				if((t2.flags & h3d_impl_TextureCache.checkFlags) != (enumFlags & h3d_impl_TextureCache.checkFlags)) {
					continue;
				}
				this.cache[this.position] = t2;
				this.cache[i] = t;
				return t2;
			}
		}
		if(t != null && t.name == name) {
			t.dispose();
			t = null;
		}
		if(flags == null) {
			flags = [];
		}
		if(flags.indexOf(h3d_mat_TextureFlags.Target) == -1) {
			flags.push(h3d_mat_TextureFlags.Target);
		}
		var newt = new h3d_mat_Texture(width,height,flags,format);
		newt.realloc = function() {
		};
		if(t != null) {
			this.cache.splice(this.position,0,newt);
		} else {
			this.cache[this.position] = newt;
		}
		return newt;
	}
	,allocTarget: function(name,width,height,defaultDepth,format,flags) {
		if(defaultDepth == null) {
			defaultDepth = true;
		}
		var t = this.cache[this.position];
		if(format == null) {
			format = this.defaultFormat;
		}
		var alloc = false;
		if(t == null || t.t == null && (t.isDepth() || t.realloc == null) || t.width != width || t.height != height || t.format != format) {
			alloc = true;
		} else {
			var enumFlags = 0;
			if(flags != null) {
				var _g = 0;
				while(_g < flags.length) {
					var f = flags[_g];
					++_g;
					enumFlags |= 1 << f._hx_index;
				}
			}
			alloc = (t.flags & h3d_impl_TextureCache.checkFlags) != (enumFlags & h3d_impl_TextureCache.checkFlags);
		}
		if(alloc) {
			t = this.lookupTarget(name,width,height,format,flags);
		}
		t.depthBuffer = defaultDepth ? this.defaultDepthBuffer : null;
		t.setName(name);
		this.position++;
		return t;
	}
	,allocTargetScale: function(name,scale,defaultDepth,format) {
		if(defaultDepth == null) {
			defaultDepth = true;
		}
		var e = h3d_Engine.CURRENT;
		return this.allocTarget(name,Math.ceil(e.width * scale),Math.ceil(e.height * scale),defaultDepth,format);
	}
	,allocTileTarget: function(name,tile,defaultDepth,format) {
		if(defaultDepth == null) {
			defaultDepth = false;
		}
		return this.allocTarget(name,Math.ceil(tile.width + tile.x) - Math.floor(tile.x),Math.ceil(tile.height + tile.y) - Math.floor(tile.y),defaultDepth,format);
	}
	,dispose: function() {
		var _g = 0;
		var _g1 = this.cache;
		while(_g < _g1.length) {
			var t = _g1[_g];
			++_g;
			t.dispose();
		}
		this.cache = [];
	}
	,__class__: h3d_impl_TextureCache
};
var hxd_impl_AnyProps = function() { };
$hxClasses["hxd.impl.AnyProps"] = hxd_impl_AnyProps;
hxd_impl_AnyProps.__name__ = "hxd.impl.AnyProps";
hxd_impl_AnyProps.prototype = {
	set_props: function(p) {
		this.props = p;
		this.refreshProps();
		return p;
	}
	,setDefaultProps: function(kind) {
		this.set_props(this.getDefaultProps(kind));
	}
	,getDefaultProps: function(kind) {
		return { };
	}
	,refreshProps: function() {
	}
	,__class__: hxd_impl_AnyProps
};
var h3d_mat_BaseMaterial = function(shader) {
	if(shader != null) {
		this.addPass(new h3d_mat_Pass("default",null)).addShader(shader);
	}
};
$hxClasses["h3d.mat.BaseMaterial"] = h3d_mat_BaseMaterial;
h3d_mat_BaseMaterial.__name__ = "h3d.mat.BaseMaterial";
h3d_mat_BaseMaterial.__super__ = hxd_impl_AnyProps;
h3d_mat_BaseMaterial.prototype = $extend(hxd_impl_AnyProps.prototype,{
	addPass: function(p) {
		var prev = null;
		var cur = this.passes;
		while(cur != null) {
			prev = cur;
			cur = cur.nextPass;
		}
		if(prev == null) {
			this.passes = p;
		} else {
			prev.nextPass = p;
		}
		p.nextPass = null;
		return p;
	}
	,removePass: function(p) {
		var prev = null;
		var cur = this.passes;
		while(cur != null) {
			if(cur == p) {
				if(prev == null) {
					this.passes = p.nextPass;
				} else {
					prev.nextPass = p.nextPass;
				}
				p.nextPass = null;
				return true;
			}
			prev = cur;
			cur = cur.nextPass;
		}
		return false;
	}
	,get_mainPass: function() {
		return this.passes;
	}
	,getPasses: function() {
		var p = this.passes;
		var out = [];
		while(p != null) {
			out.push(p);
			p = p.nextPass;
		}
		return out;
	}
	,getPass: function(name) {
		var p = this.passes;
		while(p != null) {
			if(p.name == name) {
				return p;
			}
			p = p.nextPass;
		}
		return null;
	}
	,allocPass: function(name,inheritMain) {
		if(inheritMain == null) {
			inheritMain = true;
		}
		var p = this.getPass(name);
		if(p != null) {
			return p;
		}
		var p = new h3d_mat_Pass(name,null,inheritMain ? this.passes : null);
		if(inheritMain && this.passes != null) {
			p.set_batchMode(this.passes.batchMode);
		}
		this.addPass(p);
		return p;
	}
	,clone: function(m) {
		if(m == null) {
			m = new h3d_mat_BaseMaterial();
		}
		m.passes.load(this.passes);
		m.name = this.name;
		m.set_props(this.props);
		return m;
	}
	,__class__: h3d_mat_BaseMaterial
});
var h3d_mat_Face = $hxEnums["h3d.mat.Face"] = { __ename__:true,__constructs__:null
	,None: {_hx_name:"None",_hx_index:0,__enum__:"h3d.mat.Face",toString:$estr}
	,Back: {_hx_name:"Back",_hx_index:1,__enum__:"h3d.mat.Face",toString:$estr}
	,Front: {_hx_name:"Front",_hx_index:2,__enum__:"h3d.mat.Face",toString:$estr}
	,Both: {_hx_name:"Both",_hx_index:3,__enum__:"h3d.mat.Face",toString:$estr}
};
h3d_mat_Face.__constructs__ = [h3d_mat_Face.None,h3d_mat_Face.Back,h3d_mat_Face.Front,h3d_mat_Face.Both];
h3d_mat_Face.__empty_constructs__ = [h3d_mat_Face.None,h3d_mat_Face.Back,h3d_mat_Face.Front,h3d_mat_Face.Both];
var h3d_mat_Blend = $hxEnums["h3d.mat.Blend"] = { __ename__:true,__constructs__:null
	,One: {_hx_name:"One",_hx_index:0,__enum__:"h3d.mat.Blend",toString:$estr}
	,Zero: {_hx_name:"Zero",_hx_index:1,__enum__:"h3d.mat.Blend",toString:$estr}
	,SrcAlpha: {_hx_name:"SrcAlpha",_hx_index:2,__enum__:"h3d.mat.Blend",toString:$estr}
	,SrcColor: {_hx_name:"SrcColor",_hx_index:3,__enum__:"h3d.mat.Blend",toString:$estr}
	,DstAlpha: {_hx_name:"DstAlpha",_hx_index:4,__enum__:"h3d.mat.Blend",toString:$estr}
	,DstColor: {_hx_name:"DstColor",_hx_index:5,__enum__:"h3d.mat.Blend",toString:$estr}
	,OneMinusSrcAlpha: {_hx_name:"OneMinusSrcAlpha",_hx_index:6,__enum__:"h3d.mat.Blend",toString:$estr}
	,OneMinusSrcColor: {_hx_name:"OneMinusSrcColor",_hx_index:7,__enum__:"h3d.mat.Blend",toString:$estr}
	,OneMinusDstAlpha: {_hx_name:"OneMinusDstAlpha",_hx_index:8,__enum__:"h3d.mat.Blend",toString:$estr}
	,OneMinusDstColor: {_hx_name:"OneMinusDstColor",_hx_index:9,__enum__:"h3d.mat.Blend",toString:$estr}
	,ConstantColor: {_hx_name:"ConstantColor",_hx_index:10,__enum__:"h3d.mat.Blend",toString:$estr}
	,ConstantAlpha: {_hx_name:"ConstantAlpha",_hx_index:11,__enum__:"h3d.mat.Blend",toString:$estr}
	,OneMinusConstantColor: {_hx_name:"OneMinusConstantColor",_hx_index:12,__enum__:"h3d.mat.Blend",toString:$estr}
	,OneMinusConstantAlpha: {_hx_name:"OneMinusConstantAlpha",_hx_index:13,__enum__:"h3d.mat.Blend",toString:$estr}
	,SrcAlphaSaturate: {_hx_name:"SrcAlphaSaturate",_hx_index:14,__enum__:"h3d.mat.Blend",toString:$estr}
};
h3d_mat_Blend.__constructs__ = [h3d_mat_Blend.One,h3d_mat_Blend.Zero,h3d_mat_Blend.SrcAlpha,h3d_mat_Blend.SrcColor,h3d_mat_Blend.DstAlpha,h3d_mat_Blend.DstColor,h3d_mat_Blend.OneMinusSrcAlpha,h3d_mat_Blend.OneMinusSrcColor,h3d_mat_Blend.OneMinusDstAlpha,h3d_mat_Blend.OneMinusDstColor,h3d_mat_Blend.ConstantColor,h3d_mat_Blend.ConstantAlpha,h3d_mat_Blend.OneMinusConstantColor,h3d_mat_Blend.OneMinusConstantAlpha,h3d_mat_Blend.SrcAlphaSaturate];
h3d_mat_Blend.__empty_constructs__ = [h3d_mat_Blend.One,h3d_mat_Blend.Zero,h3d_mat_Blend.SrcAlpha,h3d_mat_Blend.SrcColor,h3d_mat_Blend.DstAlpha,h3d_mat_Blend.DstColor,h3d_mat_Blend.OneMinusSrcAlpha,h3d_mat_Blend.OneMinusSrcColor,h3d_mat_Blend.OneMinusDstAlpha,h3d_mat_Blend.OneMinusDstColor,h3d_mat_Blend.ConstantColor,h3d_mat_Blend.ConstantAlpha,h3d_mat_Blend.OneMinusConstantColor,h3d_mat_Blend.OneMinusConstantAlpha,h3d_mat_Blend.SrcAlphaSaturate];
var h3d_mat_Compare = $hxEnums["h3d.mat.Compare"] = { __ename__:true,__constructs__:null
	,Always: {_hx_name:"Always",_hx_index:0,__enum__:"h3d.mat.Compare",toString:$estr}
	,Never: {_hx_name:"Never",_hx_index:1,__enum__:"h3d.mat.Compare",toString:$estr}
	,Equal: {_hx_name:"Equal",_hx_index:2,__enum__:"h3d.mat.Compare",toString:$estr}
	,NotEqual: {_hx_name:"NotEqual",_hx_index:3,__enum__:"h3d.mat.Compare",toString:$estr}
	,Greater: {_hx_name:"Greater",_hx_index:4,__enum__:"h3d.mat.Compare",toString:$estr}
	,GreaterEqual: {_hx_name:"GreaterEqual",_hx_index:5,__enum__:"h3d.mat.Compare",toString:$estr}
	,Less: {_hx_name:"Less",_hx_index:6,__enum__:"h3d.mat.Compare",toString:$estr}
	,LessEqual: {_hx_name:"LessEqual",_hx_index:7,__enum__:"h3d.mat.Compare",toString:$estr}
};
h3d_mat_Compare.__constructs__ = [h3d_mat_Compare.Always,h3d_mat_Compare.Never,h3d_mat_Compare.Equal,h3d_mat_Compare.NotEqual,h3d_mat_Compare.Greater,h3d_mat_Compare.GreaterEqual,h3d_mat_Compare.Less,h3d_mat_Compare.LessEqual];
h3d_mat_Compare.__empty_constructs__ = [h3d_mat_Compare.Always,h3d_mat_Compare.Never,h3d_mat_Compare.Equal,h3d_mat_Compare.NotEqual,h3d_mat_Compare.Greater,h3d_mat_Compare.GreaterEqual,h3d_mat_Compare.Less,h3d_mat_Compare.LessEqual];
var h3d_mat_StencilOp = $hxEnums["h3d.mat.StencilOp"] = { __ename__:true,__constructs__:null
	,Keep: {_hx_name:"Keep",_hx_index:0,__enum__:"h3d.mat.StencilOp",toString:$estr}
	,Zero: {_hx_name:"Zero",_hx_index:1,__enum__:"h3d.mat.StencilOp",toString:$estr}
	,Replace: {_hx_name:"Replace",_hx_index:2,__enum__:"h3d.mat.StencilOp",toString:$estr}
	,Increment: {_hx_name:"Increment",_hx_index:3,__enum__:"h3d.mat.StencilOp",toString:$estr}
	,IncrementWrap: {_hx_name:"IncrementWrap",_hx_index:4,__enum__:"h3d.mat.StencilOp",toString:$estr}
	,Decrement: {_hx_name:"Decrement",_hx_index:5,__enum__:"h3d.mat.StencilOp",toString:$estr}
	,DecrementWrap: {_hx_name:"DecrementWrap",_hx_index:6,__enum__:"h3d.mat.StencilOp",toString:$estr}
	,Invert: {_hx_name:"Invert",_hx_index:7,__enum__:"h3d.mat.StencilOp",toString:$estr}
};
h3d_mat_StencilOp.__constructs__ = [h3d_mat_StencilOp.Keep,h3d_mat_StencilOp.Zero,h3d_mat_StencilOp.Replace,h3d_mat_StencilOp.Increment,h3d_mat_StencilOp.IncrementWrap,h3d_mat_StencilOp.Decrement,h3d_mat_StencilOp.DecrementWrap,h3d_mat_StencilOp.Invert];
h3d_mat_StencilOp.__empty_constructs__ = [h3d_mat_StencilOp.Keep,h3d_mat_StencilOp.Zero,h3d_mat_StencilOp.Replace,h3d_mat_StencilOp.Increment,h3d_mat_StencilOp.IncrementWrap,h3d_mat_StencilOp.Decrement,h3d_mat_StencilOp.DecrementWrap,h3d_mat_StencilOp.Invert];
var h3d_mat_MipMap = $hxEnums["h3d.mat.MipMap"] = { __ename__:true,__constructs__:null
	,None: {_hx_name:"None",_hx_index:0,__enum__:"h3d.mat.MipMap",toString:$estr}
	,Nearest: {_hx_name:"Nearest",_hx_index:1,__enum__:"h3d.mat.MipMap",toString:$estr}
	,Linear: {_hx_name:"Linear",_hx_index:2,__enum__:"h3d.mat.MipMap",toString:$estr}
};
h3d_mat_MipMap.__constructs__ = [h3d_mat_MipMap.None,h3d_mat_MipMap.Nearest,h3d_mat_MipMap.Linear];
h3d_mat_MipMap.__empty_constructs__ = [h3d_mat_MipMap.None,h3d_mat_MipMap.Nearest,h3d_mat_MipMap.Linear];
var h3d_mat_Filter = $hxEnums["h3d.mat.Filter"] = { __ename__:true,__constructs__:null
	,Nearest: {_hx_name:"Nearest",_hx_index:0,__enum__:"h3d.mat.Filter",toString:$estr}
	,Linear: {_hx_name:"Linear",_hx_index:1,__enum__:"h3d.mat.Filter",toString:$estr}
};
h3d_mat_Filter.__constructs__ = [h3d_mat_Filter.Nearest,h3d_mat_Filter.Linear];
h3d_mat_Filter.__empty_constructs__ = [h3d_mat_Filter.Nearest,h3d_mat_Filter.Linear];
var h3d_mat_Wrap = $hxEnums["h3d.mat.Wrap"] = { __ename__:true,__constructs__:null
	,Clamp: {_hx_name:"Clamp",_hx_index:0,__enum__:"h3d.mat.Wrap",toString:$estr}
	,Repeat: {_hx_name:"Repeat",_hx_index:1,__enum__:"h3d.mat.Wrap",toString:$estr}
};
h3d_mat_Wrap.__constructs__ = [h3d_mat_Wrap.Clamp,h3d_mat_Wrap.Repeat];
h3d_mat_Wrap.__empty_constructs__ = [h3d_mat_Wrap.Clamp,h3d_mat_Wrap.Repeat];
var h3d_mat_Operation = $hxEnums["h3d.mat.Operation"] = { __ename__:true,__constructs__:null
	,Add: {_hx_name:"Add",_hx_index:0,__enum__:"h3d.mat.Operation",toString:$estr}
	,Sub: {_hx_name:"Sub",_hx_index:1,__enum__:"h3d.mat.Operation",toString:$estr}
	,ReverseSub: {_hx_name:"ReverseSub",_hx_index:2,__enum__:"h3d.mat.Operation",toString:$estr}
	,Min: {_hx_name:"Min",_hx_index:3,__enum__:"h3d.mat.Operation",toString:$estr}
	,Max: {_hx_name:"Max",_hx_index:4,__enum__:"h3d.mat.Operation",toString:$estr}
};
h3d_mat_Operation.__constructs__ = [h3d_mat_Operation.Add,h3d_mat_Operation.Sub,h3d_mat_Operation.ReverseSub,h3d_mat_Operation.Min,h3d_mat_Operation.Max];
h3d_mat_Operation.__empty_constructs__ = [h3d_mat_Operation.Add,h3d_mat_Operation.Sub,h3d_mat_Operation.ReverseSub,h3d_mat_Operation.Min,h3d_mat_Operation.Max];
var h3d_mat_TextureFlags = $hxEnums["h3d.mat.TextureFlags"] = { __ename__:true,__constructs__:null
	,Target: {_hx_name:"Target",_hx_index:0,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,Cube: {_hx_name:"Cube",_hx_index:1,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,MipMapped: {_hx_name:"MipMapped",_hx_index:2,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,ManualMipMapGen: {_hx_name:"ManualMipMapGen",_hx_index:3,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,IsNPOT: {_hx_name:"IsNPOT",_hx_index:4,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,NoAlloc: {_hx_name:"NoAlloc",_hx_index:5,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,Dynamic: {_hx_name:"Dynamic",_hx_index:6,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,AlphaPremultiplied: {_hx_name:"AlphaPremultiplied",_hx_index:7,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,WasCleared: {_hx_name:"WasCleared",_hx_index:8,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,Loading: {_hx_name:"Loading",_hx_index:9,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,Serialize: {_hx_name:"Serialize",_hx_index:10,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,IsArray: {_hx_name:"IsArray",_hx_index:11,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,AsyncLoading: {_hx_name:"AsyncLoading",_hx_index:12,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,LazyLoading: {_hx_name:"LazyLoading",_hx_index:13,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,Writable: {_hx_name:"Writable",_hx_index:14,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,Is3D: {_hx_name:"Is3D",_hx_index:15,__enum__:"h3d.mat.TextureFlags",toString:$estr}
};
h3d_mat_TextureFlags.__constructs__ = [h3d_mat_TextureFlags.Target,h3d_mat_TextureFlags.Cube,h3d_mat_TextureFlags.MipMapped,h3d_mat_TextureFlags.ManualMipMapGen,h3d_mat_TextureFlags.IsNPOT,h3d_mat_TextureFlags.NoAlloc,h3d_mat_TextureFlags.Dynamic,h3d_mat_TextureFlags.AlphaPremultiplied,h3d_mat_TextureFlags.WasCleared,h3d_mat_TextureFlags.Loading,h3d_mat_TextureFlags.Serialize,h3d_mat_TextureFlags.IsArray,h3d_mat_TextureFlags.AsyncLoading,h3d_mat_TextureFlags.LazyLoading,h3d_mat_TextureFlags.Writable,h3d_mat_TextureFlags.Is3D];
h3d_mat_TextureFlags.__empty_constructs__ = [h3d_mat_TextureFlags.Target,h3d_mat_TextureFlags.Cube,h3d_mat_TextureFlags.MipMapped,h3d_mat_TextureFlags.ManualMipMapGen,h3d_mat_TextureFlags.IsNPOT,h3d_mat_TextureFlags.NoAlloc,h3d_mat_TextureFlags.Dynamic,h3d_mat_TextureFlags.AlphaPremultiplied,h3d_mat_TextureFlags.WasCleared,h3d_mat_TextureFlags.Loading,h3d_mat_TextureFlags.Serialize,h3d_mat_TextureFlags.IsArray,h3d_mat_TextureFlags.AsyncLoading,h3d_mat_TextureFlags.LazyLoading,h3d_mat_TextureFlags.Writable,h3d_mat_TextureFlags.Is3D];
var h3d_mat_Defaults = function() { };
$hxClasses["h3d.mat.Defaults"] = h3d_mat_Defaults;
h3d_mat_Defaults.__name__ = "h3d.mat.Defaults";
h3d_mat_Defaults.get_shadowShader = function() {
	var s = h3d_mat_Defaults.shadowShader;
	if(s == null) {
		s = new h3d_shader_Shadow();
		h3d_mat_Defaults.set_shadowShader(s);
		h3d_mat_Defaults.shadowShader.setPriority(-1);
	}
	return s;
};
h3d_mat_Defaults.set_shadowShader = function(s) {
	return h3d_mat_Defaults.shadowShader = s;
};
h3d_mat_Defaults.makeVolumeDecal = function(bounds) {
	return new h3d_shader_VolumeDecal(bounds.xMax - bounds.xMin,bounds.yMax - bounds.yMin);
};
var h3d_mat_Material = function(texture) {
	this.mshader = new h3d_shader_BaseMesh();
	this.set_blendMode(h2d_BlendMode.None);
	h3d_mat_BaseMaterial.call(this,this.mshader);
	this.set_texture(texture);
};
$hxClasses["h3d.mat.Material"] = h3d_mat_Material;
h3d_mat_Material.__name__ = "h3d.mat.Material";
h3d_mat_Material.create = function(tex) {
	var mat = h3d_mat_MaterialSetup.current.createMaterial();
	mat.set_texture(tex);
	mat.set_props(mat.getDefaultProps());
	return mat;
};
h3d_mat_Material.__super__ = h3d_mat_BaseMaterial;
h3d_mat_Material.prototype = $extend(h3d_mat_BaseMaterial.prototype,{
	get_specularPower: function() {
		return this.mshader.specularPower__;
	}
	,set_specularPower: function(v) {
		return this.mshader.specularPower__ = v;
	}
	,get_specularAmount: function() {
		return this.mshader.specularAmount__;
	}
	,set_specularAmount: function(v) {
		return this.mshader.specularAmount__ = v;
	}
	,get_color: function() {
		return this.mshader.color__;
	}
	,set_color: function(v) {
		return this.mshader.color__ = v;
	}
	,get_shadows: function() {
		if(this.castShadows) {
			return this.receiveShadows;
		} else {
			return false;
		}
	}
	,set_shadows: function(v) {
		this.set_castShadows(v);
		this.set_receiveShadows(v);
		return v;
	}
	,set_castShadows: function(v) {
		if(this.castShadows == v) {
			return v;
		}
		if(this.passes != null) {
			if(v) {
				this.addPass(new h3d_mat_Pass("shadow",null,this.passes)).set_isStatic(this.staticShadows);
			} else {
				this.removePass(this.getPass("shadow"));
			}
		}
		return this.castShadows = v;
	}
	,set_receiveShadows: function(v) {
		if(v == this.receiveShadows) {
			return v;
		}
		if(this.passes != null) {
			var shadows = h3d_mat_Defaults.get_shadowShader();
			if(v) {
				this.passes.addShader(shadows);
			} else {
				this.passes.removeShader(shadows);
			}
		}
		return this.receiveShadows = v;
	}
	,set_staticShadows: function(v) {
		var p = this.getPass("shadow");
		if(p != null) {
			p.set_isStatic(v);
		}
		return this.staticShadows = v;
	}
	,clone: function(m) {
		var m1 = m == null ? new h3d_mat_Material() : m;
		h3d_mat_BaseMaterial.prototype.clone.call(this,m1);
		m1.set_castShadows(this.castShadows);
		m1.set_receiveShadows(this.receiveShadows);
		m1.set_texture(this.get_texture());
		m1.set_specularTexture(this.get_specularTexture());
		m1.set_normalMap(this.get_normalMap());
		if(this.textureShader != null) {
			var _this = m1.textureShader;
			_this.constModified = true;
			_this.additive__ = this.textureShader.additive__;
			var _this = m1.textureShader;
			_this.constModified = true;
			_this.killAlpha__ = this.textureShader.killAlpha__;
			m1.textureShader.killAlphaThreshold__ = this.textureShader.killAlphaThreshold__;
		}
		var _this = this.mshader.color__;
		var x = _this.x;
		var y = _this.y;
		var z = _this.z;
		var w = _this.w;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var this1 = new h3d_Vector4Impl(x,y,z,w);
		m1.mshader.color__ = this1;
		m1.set_blendMode(this.blendMode);
		return m1;
	}
	,set_blendMode: function(v) {
		if(this.passes != null) {
			this.passes.setBlendMode(v);
			switch(v._hx_index) {
			case 0:
				this.passes.set_depthWrite(true);
				this.passes.setPassName("default");
				break;
			case 1:
				this.passes.set_depthWrite(true);
				this.passes.setPassName("alpha");
				break;
			case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:case 11:
				this.passes.set_depthWrite(false);
				this.passes.setPassName("additive");
				break;
			}
		}
		return this.blendMode = v;
	}
	,get_specularTexture: function() {
		if(this.specularShader == null) {
			return null;
		} else {
			return this.specularShader.texture__;
		}
	}
	,get_texture: function() {
		if(this.textureShader == null) {
			return null;
		} else {
			return this.textureShader.texture__;
		}
	}
	,set_texture: function(t) {
		if(t == null) {
			if(this.textureShader != null) {
				this.passes.removeShader(this.textureShader);
				this.textureShader = null;
			}
		} else {
			if(this.textureShader == null) {
				this.textureShader = new h3d_shader_Texture();
				this.passes.addShader(this.textureShader);
			}
			this.textureShader.texture__ = t;
		}
		return t;
	}
	,get_normalMap: function() {
		if(this.normalShader == null) {
			return null;
		} else {
			return this.normalShader.texture__;
		}
	}
	,set_normalMap: function(t) {
		if(t == null) {
			if(this.normalShader != null) {
				this.passes.removeShader(this.normalShader);
				this.normalShader = null;
			}
		} else {
			if(this.normalShader == null) {
				this.normalShader = new h3d_shader_NormalMap();
				if(this.textureShader != null) {
					this.passes.addShaderAtIndex(this.normalShader,this.passes.getShaderIndex(this.textureShader) + 1);
				} else {
					this.passes.addShader(this.normalShader);
				}
			}
			this.normalShader.texture__ = t;
		}
		return t;
	}
	,set_specularTexture: function(t) {
		if(t == null) {
			if(this.specularShader != null) {
				this.passes.removeShader(this.specularShader);
				this.specularShader = null;
			}
		} else {
			if(this.specularShader == null) {
				this.specularShader = new h3d_shader_SpecularTexture();
				this.passes.addShader(this.specularShader);
			}
			this.specularShader.texture__ = t;
		}
		return t;
	}
	,getDefaultModelProps: function() {
		var props = this.getDefaultProps();
		switch(this.blendMode._hx_index) {
		case 0:
			break;
		case 1:
			props.kind = "Alpha";
			break;
		case 2:
			props.kind = "Add";
			props.culling = false;
			props.shadows = false;
			props.light = false;
			break;
		default:
			throw haxe_Exception.thrown("Unsupported HMD material " + Std.string(this.blendMode));
		}
		return props;
	}
	,getDefaultProps: function(type) {
		var props;
		if(type == null) {
			props = { kind : "Opaque", shadows : true, culling : true, light : true};
		} else {
			switch(type) {
			case "particles3D":case "trail3D":
				props = { kind : "Alpha", shadows : false, culling : false, light : true};
				break;
			case "ui":
				props = { kind : "Alpha", shadows : false, culling : false, light : false};
				break;
			default:
				props = { kind : "Opaque", shadows : true, culling : true, light : true};
			}
		}
		return props;
	}
	,refreshProps: function() {
		if(this.props == null || this.passes == null) {
			return;
		}
		var props = this.props;
		switch(props.kind) {
		case "Add":
			this.set_blendMode(h2d_BlendMode.Add);
			break;
		case "Alpha":
			this.set_blendMode(h2d_BlendMode.Alpha);
			break;
		case "AlphaKill":case "Hidden":case "Opaque":
			this.set_blendMode(h2d_BlendMode.None);
			break;
		case "SoftAdd":
			this.set_blendMode(h2d_BlendMode.SoftAdd);
			break;
		}
		var tshader = this.textureShader;
		if(tshader != null) {
			tshader.constModified = true;
			tshader.killAlpha__ = props.kind == "AlphaKill";
			tshader.killAlphaThreshold__ = 0.5;
		}
		this.passes.set_culling(props.kind == "Hidden" ? h3d_mat_Face.Both : props.culling ? h3d_mat_Face.Back : h3d_mat_Face.None);
		this.passes.set_enableLights(props.light);
		var v = props.shadows;
		this.set_castShadows(v);
		this.set_receiveShadows(v);
		if(this.castShadows && this.receiveShadows) {
			this.getPass("shadow").set_culling(this.passes.culling);
		}
	}
	,__class__: h3d_mat_Material
});
var h3d_mat_MaterialDatabase = function() {
	this.db = new haxe_ds_StringMap();
};
$hxClasses["h3d.mat.MaterialDatabase"] = h3d_mat_MaterialDatabase;
h3d_mat_MaterialDatabase.__name__ = "h3d.mat.MaterialDatabase";
h3d_mat_MaterialDatabase.prototype = {
	getFilePath: function(model) {
		var dir = model.entry.get_directory();
		var filename = "materials.props";
		if(dir == null || dir == "") {
			return filename;
		} else {
			return model.entry.get_directory() + "/" + filename;
		}
	}
	,getModelData: function(model) {
		if(model == null) {
			return null;
		}
		var this1 = this.db;
		var key = model.entry.get_directory();
		var cached = this1.h[key];
		if(cached != null) {
			return cached.v;
		}
		var file = this.getFilePath(model);
		var value;
		try {
			var res = hxd_res_Loader.currentInstance.load(file);
			value = JSON.parse(res.toText());
		} catch( _g ) {
			if(((haxe_Exception.caught(_g).unwrap()) instanceof hxd_fs_NotFound)) {
				value = { };
			} else {
				throw _g;
			}
		}
		var this1 = this.db;
		var key = model.entry.get_directory();
		this1.h[key] = { v : value};
		return value;
	}
	,saveData: function(model,data) {
		var file = this.getFilePath(model);
		throw haxe_Exception.thrown("Can't save material props database " + file);
	}
	,loadMatProps: function(material,setup) {
		var p = this.getModelData(material.model);
		if(p == null) {
			return p;
		}
		p = p.materials;
		if(p == null) {
			return p;
		}
		p = Reflect.field(p,setup.name);
		if(p == null) {
			return p;
		}
		if(material.model != null) {
			var specData = Reflect.field(p,material.name + "/" + material.model.entry.name);
			if(specData != null) {
				return specData;
			}
		}
		return Reflect.field(p,material.name);
	}
	,saveMatProps: function(material,setup,defaultProps) {
		var path = ["materials",setup.name,material.name];
		var root = this.getModelData(material.model);
		if(root == null) {
			return;
		}
		var realRoot = root;
		var prevs = [];
		var _g = 0;
		var _g1 = path.length - 1;
		while(_g < _g1) {
			var i = _g++;
			var next = Reflect.field(root,path[i]);
			if(next == null) {
				next = { };
				root[path[i]] = next;
			}
			prevs.push(root);
			root = next;
		}
		var currentProps = material.props;
		var modelSpec = currentProps.__refMode == "modelSpec";
		var name = path.pop();
		if(!modelSpec) {
			Reflect.deleteField(root,name);
		}
		var specName = name + "/" + (material.model != null ? material.model.entry.name : "");
		Reflect.deleteField(root,specName);
		if(defaultProps == null) {
			defaultProps = material.getDefaultProps();
		}
		if(currentProps == null || (defaultProps == null ? "null" : Std.string(defaultProps)) == (currentProps == null ? "null" : Std.string(currentProps))) {
			while(path.length > 0) {
				var name1 = path.pop();
				var root1 = prevs.pop();
				if(Reflect.fields(Reflect.field(root1,name1)).length != 0) {
					break;
				}
				Reflect.deleteField(root1,name1);
			}
		} else {
			root[modelSpec ? specName : name] = currentProps;
		}
		var file = this.getFilePath(material.model);
		if(Reflect.fields(realRoot).length == 0) {
			realRoot = null;
		}
		this.saveData(material.model,realRoot);
	}
	,__class__: h3d_mat_MaterialDatabase
};
var h3d_mat_MaterialSetup = function(name) {
	if(this.database == null) {
		this.database = new h3d_mat_MaterialDatabase();
	}
	this.name = name;
};
$hxClasses["h3d.mat.MaterialSetup"] = h3d_mat_MaterialSetup;
h3d_mat_MaterialSetup.__name__ = "h3d.mat.MaterialSetup";
h3d_mat_MaterialSetup.prototype = {
	createRenderer: function() {
		return new h3d_scene_fwd_Renderer();
	}
	,createLightSystem: function() {
		return new h3d_scene_fwd_LightSystem();
	}
	,createMaterial: function() {
		return new h3d_mat_Material();
	}
	,getDefaults: function(kind) {
		if(this.emptyMat == null) {
			this.emptyMat = this.createMaterial();
		}
		return this.emptyMat.getDefaultProps(kind);
	}
	,loadMaterialProps: function(material) {
		return this.database.loadMatProps(material,this);
	}
	,saveMaterialProps: function(material,defaultProps) {
		this.database.saveMatProps(material,this,defaultProps);
	}
	,customMeshInit: function(mesh) {
	}
	,__class__: h3d_mat_MaterialSetup
};
var h3d_mat_Pass = function(name,shaders,parent) {
	this.layer = 0;
	this.rendererFlags = 0;
	this.bits = 0;
	this.parentPass = parent;
	this.shaders = shaders;
	this.setPassName(name);
	this.set_culling(h3d_mat_Face.Back);
	var src = h3d_mat_Blend.One;
	var dst = h3d_mat_Blend.Zero;
	this.set_blendSrc(src);
	this.set_blendAlphaSrc(src);
	this.set_blendDst(dst);
	this.set_blendAlphaDst(dst);
	this.depth(true,h3d_mat_Compare.Less);
	this.set_blendOp(this.set_blendAlphaOp(h3d_mat_Operation.Add));
	this.colorMask = 15;
};
$hxClasses["h3d.mat.Pass"] = h3d_mat_Pass;
h3d_mat_Pass.__name__ = "h3d.mat.Pass";
h3d_mat_Pass.getEnableLights = function(v) {
	return v & 1;
};
h3d_mat_Pass.getDynamicParameters = function(v) {
	return v >> 1 & 1;
};
h3d_mat_Pass.getIsStatic = function(v) {
	return v >> 2 & 1;
};
h3d_mat_Pass.getBatchMode = function(v) {
	return v >> 3 & 1;
};
h3d_mat_Pass.getCulling = function(v) {
	return v & 3;
};
h3d_mat_Pass.getDepthWrite = function(v) {
	return v >> 2 & 1;
};
h3d_mat_Pass.getDepthTest = function(v) {
	return v >> 3 & 7;
};
h3d_mat_Pass.getBlendSrc = function(v) {
	return v >> 6 & 15;
};
h3d_mat_Pass.getBlendDst = function(v) {
	return v >> 10 & 15;
};
h3d_mat_Pass.getBlendAlphaSrc = function(v) {
	return v >> 14 & 15;
};
h3d_mat_Pass.getBlendAlphaDst = function(v) {
	return v >> 18 & 15;
};
h3d_mat_Pass.getBlendOp = function(v) {
	return v >> 22 & 7;
};
h3d_mat_Pass.getBlendAlphaOp = function(v) {
	return v >> 25 & 7;
};
h3d_mat_Pass.getWireframe = function(v) {
	return v >> 28 & 1;
};
h3d_mat_Pass.getCulled = function(v) {
	return v >> 29 & 1;
};
h3d_mat_Pass.getReserved = function(v) {
	return v >> 30 & 1;
};
h3d_mat_Pass.prototype = {
	load: function(p) {
		this.name = p.name;
		this.passId = p.passId;
		this.bits = p.bits;
		this.set_enableLights(p.enableLights);
		this.set_dynamicParameters(p.dynamicParameters);
		this.set_culling(p.culling);
		this.set_depthWrite(p.depthWrite);
		this.set_depthTest(p.depthTest);
		this.set_blendSrc(p.blendSrc);
		this.set_blendDst(p.blendDst);
		this.set_blendOp(p.blendOp);
		this.set_blendAlphaSrc(p.blendAlphaSrc);
		this.set_blendAlphaDst(p.blendAlphaDst);
		this.set_blendAlphaOp(p.blendAlphaOp);
		this.colorMask = p.colorMask;
		if(p.stencil != null) {
			if(this.stencil == null) {
				this.stencil = new h3d_mat_Stencil();
			}
			this.stencil.load(p.stencil);
		}
	}
	,setPassName: function(name) {
		this.name = name;
		this.passId = hxsl_Globals.allocID(name);
	}
	,blend: function(src,dst) {
		this.set_blendSrc(src);
		this.set_blendAlphaSrc(src);
		this.set_blendDst(dst);
		this.set_blendAlphaDst(dst);
	}
	,setBlendMode: function(b) {
		this.set_blendOp(h3d_mat_Operation.Add);
		this.set_blendAlphaOp(h3d_mat_Operation.Add);
		switch(b._hx_index) {
		case 0:
			var src = h3d_mat_Blend.One;
			var dst = h3d_mat_Blend.Zero;
			this.set_blendSrc(src);
			this.set_blendAlphaSrc(src);
			this.set_blendDst(dst);
			this.set_blendAlphaDst(dst);
			break;
		case 1:
			var src = h3d_mat_Blend.SrcAlpha;
			var dst = h3d_mat_Blend.OneMinusSrcAlpha;
			this.set_blendSrc(src);
			this.set_blendAlphaSrc(src);
			this.set_blendDst(dst);
			this.set_blendAlphaDst(dst);
			this.set_blendAlphaSrc(h3d_mat_Blend.One);
			break;
		case 2:
			var src = h3d_mat_Blend.SrcAlpha;
			var dst = h3d_mat_Blend.One;
			this.set_blendSrc(src);
			this.set_blendAlphaSrc(src);
			this.set_blendDst(dst);
			this.set_blendAlphaDst(dst);
			this.set_blendAlphaSrc(h3d_mat_Blend.One);
			break;
		case 3:
			var src = h3d_mat_Blend.One;
			var dst = h3d_mat_Blend.OneMinusSrcAlpha;
			this.set_blendSrc(src);
			this.set_blendAlphaSrc(src);
			this.set_blendDst(dst);
			this.set_blendAlphaDst(dst);
			break;
		case 4:
			var src = h3d_mat_Blend.OneMinusDstColor;
			var dst = h3d_mat_Blend.One;
			this.set_blendSrc(src);
			this.set_blendAlphaSrc(src);
			this.set_blendDst(dst);
			this.set_blendAlphaDst(dst);
			this.set_blendAlphaSrc(h3d_mat_Blend.One);
			break;
		case 5:
			var src = h3d_mat_Blend.DstColor;
			var dst = h3d_mat_Blend.Zero;
			this.set_blendSrc(src);
			this.set_blendAlphaSrc(src);
			this.set_blendDst(dst);
			this.set_blendAlphaDst(dst);
			this.set_blendAlphaSrc(h3d_mat_Blend.One);
			break;
		case 6:
			var src = h3d_mat_Blend.DstColor;
			var dst = h3d_mat_Blend.OneMinusSrcAlpha;
			this.set_blendSrc(src);
			this.set_blendAlphaSrc(src);
			this.set_blendDst(dst);
			this.set_blendAlphaDst(dst);
			break;
		case 7:
			var src = h3d_mat_Blend.Zero;
			var dst = h3d_mat_Blend.OneMinusSrcColor;
			this.set_blendSrc(src);
			this.set_blendAlphaSrc(src);
			this.set_blendDst(dst);
			this.set_blendAlphaDst(dst);
			break;
		case 8:
			var src = h3d_mat_Blend.One;
			var dst = h3d_mat_Blend.OneMinusSrcColor;
			this.set_blendSrc(src);
			this.set_blendAlphaSrc(src);
			this.set_blendDst(dst);
			this.set_blendAlphaDst(dst);
			break;
		case 9:
			var src = h3d_mat_Blend.SrcAlpha;
			var dst = h3d_mat_Blend.One;
			this.set_blendSrc(src);
			this.set_blendAlphaSrc(src);
			this.set_blendDst(dst);
			this.set_blendAlphaDst(dst);
			this.set_blendOp(h3d_mat_Operation.ReverseSub);
			this.set_blendAlphaOp(h3d_mat_Operation.ReverseSub);
			break;
		case 10:
			var src = h3d_mat_Blend.One;
			var dst = h3d_mat_Blend.One;
			this.set_blendSrc(src);
			this.set_blendAlphaSrc(src);
			this.set_blendDst(dst);
			this.set_blendAlphaDst(dst);
			this.set_blendAlphaOp(h3d_mat_Operation.Max);
			this.set_blendOp(h3d_mat_Operation.Max);
			break;
		case 11:
			var src = h3d_mat_Blend.One;
			var dst = h3d_mat_Blend.One;
			this.set_blendSrc(src);
			this.set_blendAlphaSrc(src);
			this.set_blendDst(dst);
			this.set_blendAlphaDst(dst);
			this.set_blendAlphaOp(h3d_mat_Operation.Min);
			this.set_blendOp(h3d_mat_Operation.Min);
			break;
		}
	}
	,depth: function(write,test) {
		this.set_depthWrite(write);
		this.set_depthTest(test);
	}
	,setColorMask: function(r,g,b,a) {
		this.colorMask = (r ? 1 : 0) | (g ? 2 : 0) | (b ? 4 : 0) | (a ? 8 : 0);
	}
	,setColorChannel: function(c) {
		switch(c._hx_index) {
		case 1:
			this.setColorMask(true,false,false,false);
			break;
		case 2:
			this.setColorMask(false,true,false,false);
			break;
		case 3:
			this.setColorMask(false,false,true,false);
			break;
		case 4:
			this.setColorMask(false,false,false,true);
			break;
		default:
			throw haxe_Exception.thrown("Unsupported channel " + Std.string(c));
		}
	}
	,setColorMaski: function(r,g,b,a,i) {
		if(i > 8) {
			throw haxe_Exception.thrown("Color mask i supports 8 Render target");
		}
		var mask = (r ? 1 : 0) | (g ? 2 : 0) | (b ? 4 : 0) | (a ? 8 : 0);
		mask <<= i * 4;
		this.colorMask |= mask;
	}
	,resetRendererFlags: function() {
		this.rendererFlags = 0;
	}
	,addShader: function(s) {
		if(s == null) {
			return null;
		}
		this.shaders = hxsl_ShaderList.addSort(s,this.shaders);
		this.resetRendererFlags();
		return s;
	}
	,addSelfShader: function(s) {
		if(s == null) {
			return null;
		}
		this.selfShadersChanged = true;
		this.selfShaders = hxsl_ShaderList.addSort(s,this.selfShaders);
		this.resetRendererFlags();
		return s;
	}
	,addShaderAtIndex: function(s,index) {
		var prev = null;
		var cur = this.shaders;
		while(index > 0 && cur != this.parentShaders) {
			prev = cur;
			cur = cur.next;
			--index;
		}
		if(prev == null) {
			this.shaders = new hxsl_ShaderList(s,cur);
		} else {
			prev.next = new hxsl_ShaderList(s,cur);
		}
		return s;
	}
	,getShaderIndex: function(s) {
		var index = 0;
		var cur = this.shaders;
		while(cur != this.parentShaders) {
			if(cur.s == s) {
				return index;
			}
			cur = cur.next;
			++index;
		}
		return -1;
	}
	,removeShader: function(s) {
		var sl = this.shaders;
		var prev = null;
		var shaderFound = false;
		while(sl != null) {
			if(sl.s == s) {
				this.resetRendererFlags();
				if(this.selfShadersCache == sl) {
					this.selfShadersCache = this.selfShadersCache.next;
				}
				if(prev == null) {
					this.shaders = sl.next;
				} else {
					prev.next = sl.next;
				}
				shaderFound = true;
				break;
			}
			prev = sl;
			sl = sl.next;
		}
		sl = this.selfShaders;
		prev = null;
		while(sl != null) {
			if(sl.s == s) {
				this.resetRendererFlags();
				if(this.selfShadersCache == sl) {
					this.selfShadersCache = this.selfShadersCache.next;
				}
				if(prev == null) {
					this.selfShaders = sl.next;
				} else {
					prev.next = sl.next;
				}
				return true;
			}
			prev = sl;
			sl = sl.next;
		}
		return shaderFound;
	}
	,removeShaders: function(t) {
		var sl = this.shaders;
		var prev = null;
		while(sl != null) {
			if(js_Boot.__instanceof(sl.s,t)) {
				this.resetRendererFlags();
				if(this.selfShadersCache == sl) {
					this.selfShadersCache = this.selfShadersCache.next;
				}
				if(prev == null) {
					this.shaders = sl.next;
				} else {
					prev.next = sl.next;
				}
			} else {
				prev = sl;
			}
			sl = sl.next;
		}
		sl = this.selfShaders;
		prev = null;
		while(sl != null) {
			if(js_Boot.__instanceof(sl.s,t)) {
				this.resetRendererFlags();
				if(this.selfShadersCache == sl) {
					this.selfShadersCache = this.selfShadersCache.next;
				}
				if(prev == null) {
					this.selfShaders = sl.next;
				} else {
					prev.next = sl.next;
				}
			} else {
				prev = sl;
			}
			sl = sl.next;
		}
	}
	,getShader: function(t) {
		var s = this._getShader(t,this.shaders);
		if(s != null) {
			return s;
		} else {
			return this._getShader(t,this.selfShaders);
		}
	}
	,_getShader: function(t,s) {
		while(s != null && s != this.parentShaders) {
			var value = s.s;
			var sh = js_Boot.__downcastCheck(value,t) ? value : null;
			if(sh != null) {
				return sh;
			}
			s = s.next;
		}
		return null;
	}
	,getShaderByName: function(name) {
		var s = this._getShaderByName(name,this.shaders);
		if(s != null) {
			return s;
		} else {
			return this._getShaderByName(name,this.selfShaders);
		}
	}
	,_getShaderByName: function(name,sl) {
		while(sl != null && sl != this.parentShaders) {
			if(sl.s.shader.data.name == name) {
				return sl.s;
			}
			sl = sl.next;
		}
		return null;
	}
	,getShaders: function() {
		return new hxsl__$ShaderList_ShaderIterator(this.shaders,this.parentShaders);
	}
	,checkInfiniteLoop: function() {
		var shaderList = [];
		var s = this.selfShaders;
		while(s != null) {
			var _g = 0;
			while(_g < shaderList.length) {
				var already = shaderList[_g];
				++_g;
				if(already == s) {
					throw haxe_Exception.thrown("infinite loop");
				}
			}
			shaderList.push(s);
			s = s.next;
		}
	}
	,selfShadersRec: function(rebuild) {
		if(this.selfShaders == null) {
			return this.shaders;
		}
		if(!this.selfShadersChanged && !rebuild && this.shaders == this.selfShadersCache) {
			return this.selfShaders;
		}
		var sl = this.selfShaders;
		var prev = null;
		while(sl != null && sl != this.selfShadersCache) {
			prev = sl;
			sl = sl.next;
		}
		this.selfShadersCache = this.shaders;
		if(prev != null) {
			prev.next = this.selfShadersCache;
		} else {
			this.selfShaders = this.shaders;
		}
		return this.selfShaders;
	}
	,getShadersRec: function() {
		if(this.parentPass == null || this.parentShaders == this.parentPass.shaders) {
			return this.selfShadersRec(false);
		}
		var s = this.shaders;
		var prev = null;
		while(s != null && s != this.parentShaders) {
			prev = s;
			s = s.next;
		}
		if(s != this.parentShaders) {
			prev = null;
		}
		this.parentShaders = this.parentPass.shaders;
		if(prev == null) {
			this.shaders = this.parentShaders;
		} else {
			prev.next = this.parentShaders;
		}
		return this.selfShadersRec(true);
	}
	,clone: function() {
		var p = new h3d_mat_Pass(this.name,this.shaders.clone());
		p.selfShaders = this.selfShaders;
		p.bits = this.bits;
		p.set_enableLights(this.enableLights);
		if(this.stencil != null) {
			p.stencil = this.stencil.clone();
		}
		return p;
	}
	,set_enableLights: function(v) {
		this.flags = this.flags & -2 | (v ? 1 : 0);
		return this.enableLights = v;
	}
	,set_dynamicParameters: function(v) {
		this.flags = this.flags & -3 | (v ? 1 : 0) << 1;
		return this.dynamicParameters = v;
	}
	,set_isStatic: function(v) {
		this.flags = this.flags & -5 | (v ? 1 : 0) << 2;
		return this.isStatic = v;
	}
	,set_batchMode: function(v) {
		this.flags = this.flags & -9 | (v ? 1 : 0) << 3;
		return this.batchMode = v;
	}
	,set_culling: function(v) {
		this.bits = this.bits & -4 | v._hx_index;
		return this.culling = v;
	}
	,set_depthWrite: function(v) {
		this.bits = this.bits & -5 | (v ? 1 : 0) << 2;
		return this.depthWrite = v;
	}
	,set_depthTest: function(v) {
		this.bits = this.bits & -57 | v._hx_index << 3;
		return this.depthTest = v;
	}
	,set_blendSrc: function(v) {
		this.bits = this.bits & -961 | v._hx_index << 6;
		return this.blendSrc = v;
	}
	,set_blendDst: function(v) {
		this.bits = this.bits & -15361 | v._hx_index << 10;
		return this.blendDst = v;
	}
	,set_blendAlphaSrc: function(v) {
		this.bits = this.bits & -245761 | v._hx_index << 14;
		return this.blendAlphaSrc = v;
	}
	,set_blendAlphaDst: function(v) {
		this.bits = this.bits & -3932161 | v._hx_index << 18;
		return this.blendAlphaDst = v;
	}
	,set_blendOp: function(v) {
		this.bits = this.bits & -29360129 | v._hx_index << 22;
		return this.blendOp = v;
	}
	,set_blendAlphaOp: function(v) {
		this.bits = this.bits & -234881025 | v._hx_index << 25;
		return this.blendAlphaOp = v;
	}
	,set_wireframe: function(v) {
		this.bits = this.bits & -268435457 | (v ? 1 : 0) << 28;
		return this.wireframe = v;
	}
	,set_culled: function(v) {
		this.bits = this.bits & -536870913 | (v ? 1 : 0) << 29;
		return this.culled = v;
	}
	,set_reserved: function(v) {
		this.bits = this.bits & -1073741825 | (v ? 1 : 0) << 30;
		return this.reserved = v;
	}
	,loadFlags: function(bits) {
		this.flags = bits;
		this.set_enableLights((this.flags & 1) != 0);
		this.set_dynamicParameters((this.flags >> 1 & 1) != 0);
		this.set_isStatic((this.flags >> 2 & 1) != 0);
		this.set_batchMode((this.flags >> 3 & 1) != 0);
	}
	,loadBits: function(bits) {
		this.bits = bits;
		this.set_culling(Type.createEnumIndex(h3d_mat_Face,this.bits & 3));
		this.set_depthWrite((this.bits >> 2 & 1) != 0);
		this.set_depthTest(Type.createEnumIndex(h3d_mat_Compare,this.bits >> 3 & 7));
		this.set_blendSrc(Type.createEnumIndex(h3d_mat_Blend,this.bits >> 6 & 15));
		this.set_blendDst(Type.createEnumIndex(h3d_mat_Blend,this.bits >> 10 & 15));
		this.set_blendAlphaSrc(Type.createEnumIndex(h3d_mat_Blend,this.bits >> 14 & 15));
		this.set_blendAlphaDst(Type.createEnumIndex(h3d_mat_Blend,this.bits >> 18 & 15));
		this.set_blendOp(Type.createEnumIndex(h3d_mat_Operation,this.bits >> 22 & 7));
		this.set_blendAlphaOp(Type.createEnumIndex(h3d_mat_Operation,this.bits >> 25 & 7));
		this.set_wireframe((this.bits >> 28 & 1) != 0);
		this.set_culled((this.bits >> 29 & 1) != 0);
		this.set_reserved((this.bits >> 30 & 1) != 0);
	}
	,__class__: h3d_mat_Pass
};
var h3d_mat_Stencil = function() {
	this.opBits = 0;
	this.maskBits = 0;
	this.setOp(h3d_mat_StencilOp.Keep,h3d_mat_StencilOp.Keep,h3d_mat_StencilOp.Keep);
	this.setFunc(h3d_mat_Compare.Always);
};
$hxClasses["h3d.mat.Stencil"] = h3d_mat_Stencil;
h3d_mat_Stencil.__name__ = "h3d.mat.Stencil";
h3d_mat_Stencil.getReadMask = function(v) {
	return v & 255;
};
h3d_mat_Stencil.getWriteMask = function(v) {
	return v >> 8 & 255;
};
h3d_mat_Stencil.getReference = function(v) {
	return v >> 16 & 255;
};
h3d_mat_Stencil.getFrontTest = function(v) {
	return v & 7;
};
h3d_mat_Stencil.getFrontPass = function(v) {
	return v >> 3 & 7;
};
h3d_mat_Stencil.getFrontSTfail = function(v) {
	return v >> 6 & 7;
};
h3d_mat_Stencil.getFrontDPfail = function(v) {
	return v >> 9 & 7;
};
h3d_mat_Stencil.getBackTest = function(v) {
	return v >> 12 & 7;
};
h3d_mat_Stencil.getBackPass = function(v) {
	return v >> 15 & 7;
};
h3d_mat_Stencil.getBackSTfail = function(v) {
	return v >> 18 & 7;
};
h3d_mat_Stencil.getBackDPfail = function(v) {
	return v >> 21 & 7;
};
h3d_mat_Stencil.prototype = {
	setFront: function(stfail,dpfail,pass) {
		this.set_frontSTfail(stfail);
		this.set_frontDPfail(dpfail);
		this.set_frontPass(pass);
	}
	,setBack: function(stfail,dpfail,pass) {
		this.set_backSTfail(stfail);
		this.set_backDPfail(dpfail);
		this.set_backPass(pass);
	}
	,setOp: function(stfail,dpfail,pass) {
		this.setFront(stfail,dpfail,pass);
		this.setBack(stfail,dpfail,pass);
	}
	,setFunc: function(f,reference,readMask,writeMask) {
		if(writeMask == null) {
			writeMask = 255;
		}
		if(readMask == null) {
			readMask = 255;
		}
		if(reference == null) {
			reference = 0;
		}
		this.set_frontTest(this.set_backTest(f));
		this.set_reference(reference);
		this.set_readMask(readMask);
		this.set_writeMask(writeMask);
	}
	,clone: function() {
		var s = new h3d_mat_Stencil();
		s.opBits = this.opBits;
		s.maskBits = this.maskBits;
		return s;
	}
	,load: function(s) {
		this.opBits = s.opBits;
		this.maskBits = s.maskBits;
	}
	,set_readMask: function(v) {
		this.maskBits = this.maskBits & -256 | v & 255;
		return this.readMask = v;
	}
	,set_writeMask: function(v) {
		this.maskBits = this.maskBits & -65281 | (v & 255) << 8;
		return this.writeMask = v;
	}
	,set_reference: function(v) {
		this.maskBits = this.maskBits & -16711681 | (v & 255) << 16;
		return this.reference = v;
	}
	,set_frontTest: function(v) {
		this.opBits = this.opBits & -8 | v._hx_index;
		return this.frontTest = v;
	}
	,set_frontPass: function(v) {
		this.opBits = this.opBits & -57 | v._hx_index << 3;
		return this.frontPass = v;
	}
	,set_frontSTfail: function(v) {
		this.opBits = this.opBits & -449 | v._hx_index << 6;
		return this.frontSTfail = v;
	}
	,set_frontDPfail: function(v) {
		this.opBits = this.opBits & -3585 | v._hx_index << 9;
		return this.frontDPfail = v;
	}
	,set_backTest: function(v) {
		this.opBits = this.opBits & -28673 | v._hx_index << 12;
		return this.backTest = v;
	}
	,set_backPass: function(v) {
		this.opBits = this.opBits & -229377 | v._hx_index << 15;
		return this.backPass = v;
	}
	,set_backSTfail: function(v) {
		this.opBits = this.opBits & -1835009 | v._hx_index << 18;
		return this.backSTfail = v;
	}
	,set_backDPfail: function(v) {
		this.opBits = this.opBits & -14680065 | v._hx_index << 21;
		return this.backDPfail = v;
	}
	,loadOpBits: function(bits) {
		this.opBits = bits;
		this.set_frontTest(Type.createEnumIndex(h3d_mat_Compare,this.opBits & 7));
		this.set_frontPass(Type.createEnumIndex(h3d_mat_StencilOp,this.opBits >> 3 & 7));
		this.set_frontSTfail(Type.createEnumIndex(h3d_mat_StencilOp,this.opBits >> 6 & 7));
		this.set_frontDPfail(Type.createEnumIndex(h3d_mat_StencilOp,this.opBits >> 9 & 7));
		this.set_backTest(Type.createEnumIndex(h3d_mat_Compare,this.opBits >> 12 & 7));
		this.set_backPass(Type.createEnumIndex(h3d_mat_StencilOp,this.opBits >> 15 & 7));
		this.set_backSTfail(Type.createEnumIndex(h3d_mat_StencilOp,this.opBits >> 18 & 7));
		this.set_backDPfail(Type.createEnumIndex(h3d_mat_StencilOp,this.opBits >> 21 & 7));
	}
	,loadMaskBits: function(bits) {
		this.maskBits = bits;
		this.set_readMask(this.maskBits & 255);
		this.set_writeMask(this.maskBits >> 8 & 255);
		this.set_reference(this.maskBits >> 16 & 255);
	}
	,__class__: h3d_mat_Stencil
};
var haxe_IMap = function() { };
$hxClasses["haxe.IMap"] = haxe_IMap;
haxe_IMap.__name__ = "haxe.IMap";
haxe_IMap.__isInterface__ = true;
var haxe_ds_IntMap = function() {
	this.h = { };
};
$hxClasses["haxe.ds.IntMap"] = haxe_ds_IntMap;
haxe_ds_IntMap.__name__ = "haxe.ds.IntMap";
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
haxe_ds_IntMap.prototype = {
	remove: function(key) {
		if(!this.h.hasOwnProperty(key)) {
			return false;
		}
		delete(this.h[key]);
		return true;
	}
	,keys: function() {
		var a = [];
		for( var key in this.h ) if(this.h.hasOwnProperty(key)) a.push(+key);
		return new haxe_iterators_ArrayIterator(a);
	}
	,iterator: function() {
		return { ref : this.h, it : this.keys(), hasNext : function() {
			return this.it.hasNext();
		}, next : function() {
			var i = this.it.next();
			return this.ref[i];
		}};
	}
	,__class__: haxe_ds_IntMap
};
var haxe_ds_StringMap = function() {
	this.h = Object.create(null);
};
$hxClasses["haxe.ds.StringMap"] = haxe_ds_StringMap;
haxe_ds_StringMap.__name__ = "haxe.ds.StringMap";
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.prototype = {
	iterator: function() {
		return new haxe_ds__$StringMap_StringMapValueIterator(this.h);
	}
	,__class__: haxe_ds_StringMap
};
var hxd_PixelFormat = $hxEnums["hxd.PixelFormat"] = { __ename__:true,__constructs__:null
	,ARGB: {_hx_name:"ARGB",_hx_index:0,__enum__:"hxd.PixelFormat",toString:$estr}
	,BGRA: {_hx_name:"BGRA",_hx_index:1,__enum__:"hxd.PixelFormat",toString:$estr}
	,RGBA: {_hx_name:"RGBA",_hx_index:2,__enum__:"hxd.PixelFormat",toString:$estr}
	,RGBA16F: {_hx_name:"RGBA16F",_hx_index:3,__enum__:"hxd.PixelFormat",toString:$estr}
	,RGBA32F: {_hx_name:"RGBA32F",_hx_index:4,__enum__:"hxd.PixelFormat",toString:$estr}
	,R8: {_hx_name:"R8",_hx_index:5,__enum__:"hxd.PixelFormat",toString:$estr}
	,R16F: {_hx_name:"R16F",_hx_index:6,__enum__:"hxd.PixelFormat",toString:$estr}
	,R32F: {_hx_name:"R32F",_hx_index:7,__enum__:"hxd.PixelFormat",toString:$estr}
	,RG8: {_hx_name:"RG8",_hx_index:8,__enum__:"hxd.PixelFormat",toString:$estr}
	,RG16F: {_hx_name:"RG16F",_hx_index:9,__enum__:"hxd.PixelFormat",toString:$estr}
	,RG32F: {_hx_name:"RG32F",_hx_index:10,__enum__:"hxd.PixelFormat",toString:$estr}
	,RGB8: {_hx_name:"RGB8",_hx_index:11,__enum__:"hxd.PixelFormat",toString:$estr}
	,RGB16F: {_hx_name:"RGB16F",_hx_index:12,__enum__:"hxd.PixelFormat",toString:$estr}
	,RGB32F: {_hx_name:"RGB32F",_hx_index:13,__enum__:"hxd.PixelFormat",toString:$estr}
	,SRGB: {_hx_name:"SRGB",_hx_index:14,__enum__:"hxd.PixelFormat",toString:$estr}
	,SRGB_ALPHA: {_hx_name:"SRGB_ALPHA",_hx_index:15,__enum__:"hxd.PixelFormat",toString:$estr}
	,RGB10A2: {_hx_name:"RGB10A2",_hx_index:16,__enum__:"hxd.PixelFormat",toString:$estr}
	,RG11B10UF: {_hx_name:"RG11B10UF",_hx_index:17,__enum__:"hxd.PixelFormat",toString:$estr}
	,R16U: {_hx_name:"R16U",_hx_index:18,__enum__:"hxd.PixelFormat",toString:$estr}
	,RG16U: {_hx_name:"RG16U",_hx_index:19,__enum__:"hxd.PixelFormat",toString:$estr}
	,RGB16U: {_hx_name:"RGB16U",_hx_index:20,__enum__:"hxd.PixelFormat",toString:$estr}
	,RGBA16U: {_hx_name:"RGBA16U",_hx_index:21,__enum__:"hxd.PixelFormat",toString:$estr}
	,S3TC: ($_=function(v) { return {_hx_index:22,v:v,__enum__:"hxd.PixelFormat",toString:$estr}; },$_._hx_name="S3TC",$_.__params__ = ["v"],$_)
	,Depth16: {_hx_name:"Depth16",_hx_index:23,__enum__:"hxd.PixelFormat",toString:$estr}
	,Depth24: {_hx_name:"Depth24",_hx_index:24,__enum__:"hxd.PixelFormat",toString:$estr}
	,Depth24Stencil8: {_hx_name:"Depth24Stencil8",_hx_index:25,__enum__:"hxd.PixelFormat",toString:$estr}
	,Depth32: {_hx_name:"Depth32",_hx_index:26,__enum__:"hxd.PixelFormat",toString:$estr}
};
hxd_PixelFormat.__constructs__ = [hxd_PixelFormat.ARGB,hxd_PixelFormat.BGRA,hxd_PixelFormat.RGBA,hxd_PixelFormat.RGBA16F,hxd_PixelFormat.RGBA32F,hxd_PixelFormat.R8,hxd_PixelFormat.R16F,hxd_PixelFormat.R32F,hxd_PixelFormat.RG8,hxd_PixelFormat.RG16F,hxd_PixelFormat.RG32F,hxd_PixelFormat.RGB8,hxd_PixelFormat.RGB16F,hxd_PixelFormat.RGB32F,hxd_PixelFormat.SRGB,hxd_PixelFormat.SRGB_ALPHA,hxd_PixelFormat.RGB10A2,hxd_PixelFormat.RG11B10UF,hxd_PixelFormat.R16U,hxd_PixelFormat.RG16U,hxd_PixelFormat.RGB16U,hxd_PixelFormat.RGBA16U,hxd_PixelFormat.S3TC,hxd_PixelFormat.Depth16,hxd_PixelFormat.Depth24,hxd_PixelFormat.Depth24Stencil8,hxd_PixelFormat.Depth32];
hxd_PixelFormat.__empty_constructs__ = [hxd_PixelFormat.ARGB,hxd_PixelFormat.BGRA,hxd_PixelFormat.RGBA,hxd_PixelFormat.RGBA16F,hxd_PixelFormat.RGBA32F,hxd_PixelFormat.R8,hxd_PixelFormat.R16F,hxd_PixelFormat.R32F,hxd_PixelFormat.RG8,hxd_PixelFormat.RG16F,hxd_PixelFormat.RG32F,hxd_PixelFormat.RGB8,hxd_PixelFormat.RGB16F,hxd_PixelFormat.RGB32F,hxd_PixelFormat.SRGB,hxd_PixelFormat.SRGB_ALPHA,hxd_PixelFormat.RGB10A2,hxd_PixelFormat.RG11B10UF,hxd_PixelFormat.R16U,hxd_PixelFormat.RG16U,hxd_PixelFormat.RGB16U,hxd_PixelFormat.RGBA16U,hxd_PixelFormat.Depth16,hxd_PixelFormat.Depth24,hxd_PixelFormat.Depth24Stencil8,hxd_PixelFormat.Depth32];
var h3d_mat_Texture = function(w,h,flags,format) {
	this.depthClamp = false;
	this.slopeScaledBias = 0.;
	this.depthBias = 0.;
	this.lodBias = 0.;
	this.startingMip = 0;
	if(format == null) {
		format = h3d_mat_Texture.nativeFormat;
	}
	this.id = ++h3d_mat_Texture.UID;
	this.format = format;
	this.flags = 0;
	if(flags != null) {
		var _g = 0;
		while(_g < flags.length) {
			var f = flags[_g];
			++_g;
			this.flags |= 1 << f._hx_index;
		}
	}
	var engine = h3d_Engine.CURRENT;
	this.mem = engine.mem;
	var tw = 1;
	var th = 1;
	while(tw < w) tw <<= 1;
	while(th < h) th <<= 1;
	if(tw != w || th != h) {
		this.flags |= 1 << h3d_mat_TextureFlags.IsNPOT._hx_index;
	}
	this.width = w;
	this.height = h;
	if((this.flags & 1 << h3d_mat_TextureFlags.MipMapped._hx_index) != 0) {
		this.set_mipMap(h3d_mat_Texture.TRILINEAR_FILTERING_ENABLED ? h3d_mat_MipMap.Linear : h3d_mat_MipMap.Nearest);
	} else {
		this.set_mipMap(h3d_mat_MipMap.None);
	}
	this.set_filter(h3d_mat_Filter.Linear);
	this.set_wrap(h3d_mat_Texture.DEFAULT_WRAP);
	this.bits &= 32767;
	this.allocPos = hxd_impl_AllocPos.make();
	if((this.flags & 1 << h3d_mat_TextureFlags.NoAlloc._hx_index) == 0 && this.width > 0) {
		this.alloc();
	}
};
$hxClasses["h3d.mat.Texture"] = h3d_mat_Texture;
h3d_mat_Texture.__name__ = "h3d.mat.Texture";
h3d_mat_Texture.getDefaultDepth = function() {
	return h3d_Engine.CURRENT.driver.getDefaultDepthBuffer();
};
h3d_mat_Texture.fromBitmap = function(bmp) {
	var t = new h3d_mat_Texture(bmp.ctx.canvas.width,bmp.ctx.canvas.height);
	t.uploadBitmap(bmp);
	return t;
};
h3d_mat_Texture.fromPixels = function(pixels,format) {
	var t = new h3d_mat_Texture(pixels.width,pixels.height,null,format != null ? format : pixels.innerFormat);
	t.uploadPixels(pixels);
	return t;
};
h3d_mat_Texture.fromColor = function(color,alpha) {
	if(alpha == null) {
		alpha = 1.;
	}
	var engine = h3d_Engine.CURRENT;
	var aval = alpha * 255 | 0;
	if(aval < 0) {
		aval = 0;
	} else if(aval > 255) {
		aval = 255;
	}
	var key = color & 16777215 | aval << 24;
	var t = engine.textureColorCache.h[key];
	if(t != null) {
		return t;
	}
	var t = new h3d_mat_Texture(1,1,null);
	t.clear(color,alpha);
	t.realloc = function() {
		t.clear(color,alpha);
	};
	engine.textureColorCache.h[key] = t;
	return t;
};
h3d_mat_Texture.genDisc = function(size,color,alpha) {
	if(alpha == null) {
		alpha = 1.;
	}
	return h3d_mat_Texture.genTexture(0,size,color,alpha);
};
h3d_mat_Texture.genTexture = function(mode,size,color,alpha) {
	var engine = h3d_Engine.CURRENT;
	var aval = alpha * 255 | 0;
	if(aval < 0) {
		aval = 0;
	} else if(aval > 255) {
		aval = 255;
	}
	color = color & 16777215 | aval << 24;
	var key = (size << 16 | mode) + "," + color;
	var k = h3d_mat_Texture.genTextureKeys.h[key];
	var t = k == null ? null : engine.resCache.h[k.__id__];
	if(t != null) {
		return t;
	}
	if(k == null) {
		k = { };
		h3d_mat_Texture.genTextureKeys.h[key] = k;
	}
	t = new h3d_mat_Texture(size,size,[h3d_mat_TextureFlags.Target]);
	t.realloc = function() {
		h3d_mat_Texture.drawGenTexture(t,color,mode);
	};
	h3d_mat_Texture.drawGenTexture(t,color,mode);
	engine.resCache.set(k,t);
	return t;
};
h3d_mat_Texture.drawGenTexture = function(t,color,mode) {
	var s = new h3d_pass_ScreenFx(new h3d_shader_GenTexture());
	var engine = h3d_Engine.CURRENT;
	var _this = s.shader;
	_this.constModified = true;
	_this.mode__ = mode;
	var _this = s.shader.color__;
	_this.x = (color >> 16 & 255) / 255;
	_this.y = (color >> 8 & 255) / 255;
	_this.z = (color & 255) / 255;
	_this.w = (color >>> 24) / 255;
	engine.pushTarget(t);
	s.render();
	engine.popTarget();
};
h3d_mat_Texture.defaultCubeTexture = function() {
	var engine = h3d_Engine.CURRENT;
	var t = engine.resCache.h[h3d_mat_Texture.__id__];
	if(t != null) {
		return t;
	}
	t = new h3d_mat_Texture(1,1,[h3d_mat_TextureFlags.Cube]);
	t.clear(2105376);
	t.realloc = function() {
		t.clear(2105376);
	};
	engine.resCache.set(h3d_mat_Texture,t);
	return t;
};
h3d_mat_Texture.genChecker = function(size) {
	var engine = h3d_Engine.CURRENT;
	var k = h3d_mat_Texture.checkerTextureKeys.h[size];
	var t = k == null ? null : engine.resCache.h[k.__id__];
	if(t != null && !(t.t == null && (t.isDepth() || t.realloc == null))) {
		return t;
	}
	if(k == null) {
		k = { };
		h3d_mat_Texture.checkerTextureKeys.h[size] = k;
	}
	var t = new h3d_mat_Texture(size,size,[h3d_mat_TextureFlags.NoAlloc]);
	var t1 = t;
	var size1 = size;
	t.realloc = function() {
		h3d_mat_Texture.allocChecker(t1,size1);
	};
	engine.resCache.set(k,t);
	return t;
};
h3d_mat_Texture.genNoise = function(size) {
	var engine = h3d_Engine.CURRENT;
	var k = h3d_mat_Texture.noiseTextureKeys.h[size];
	var t = k == null ? null : engine.resCache.h[k.__id__];
	if(t != null && !(t.t == null && (t.isDepth() || t.realloc == null))) {
		return t;
	}
	if(k == null) {
		k = { };
		h3d_mat_Texture.noiseTextureKeys.h[size] = k;
	}
	var t = new h3d_mat_Texture(size,size,[h3d_mat_TextureFlags.NoAlloc]);
	var t1 = t;
	var size1 = size;
	t.realloc = function() {
		h3d_mat_Texture.allocNoise(t1,size1);
	};
	engine.resCache.set(k,t);
	return t;
};
h3d_mat_Texture.allocNoise = function(t,size) {
	var b = new hxd_BitmapData(size,size);
	var _g = 0;
	var _g1 = size;
	while(_g < _g1) {
		var x = _g++;
		var _g2 = 0;
		var _g3 = size;
		while(_g2 < _g3) {
			var y = _g2++;
			var n = Std.random(256);
			b.setPixel(x,y,-16777216 | n | n << 8 | n << 16);
		}
	}
	t.uploadBitmap(b);
	b.ctx = null;
	b.pixel = null;
};
h3d_mat_Texture.allocChecker = function(t,size) {
	var b = new hxd_BitmapData(size,size);
	b.clear(-1);
	var _g = 0;
	var _g1 = size >> 1;
	while(_g < _g1) {
		var x = _g++;
		var _g2 = 0;
		var _g3 = size >> 1;
		while(_g2 < _g3) {
			var y = _g2++;
			b.setPixel(x,y,-16777216);
			b.setPixel(x + (size >> 1),y + (size >> 1),-16777216);
		}
	}
	t.uploadBitmap(b);
	b.ctx = null;
	b.pixel = null;
};
h3d_mat_Texture.prototype = {
	set_lastFrame: function(lf) {
		if(this._lastFrame != h3d_mat_Texture.PREVENT_AUTO_DISPOSE) {
			this._lastFrame = lf;
		}
		return this._lastFrame;
	}
	,get_lastFrame: function() {
		return this._lastFrame;
	}
	,get_mipLevels: function() {
		if((this.flags & 1 << h3d_mat_TextureFlags.MipMapped._hx_index) == 0) {
			return 1;
		}
		if(this.customMipLevels > 0) {
			return this.customMipLevels;
		}
		var lv = 1;
		var w = this.width;
		var h = this.height;
		while(w >> lv >= 1 || h >> lv >= 1) ++lv;
		return lv;
	}
	,get_layerCount: function() {
		if((this.flags & 1 << h3d_mat_TextureFlags.Cube._hx_index) != 0) {
			return 6;
		} else {
			return 1;
		}
	}
	,alloc: function() {
		if(this.t == null) {
			this.mem.allocTexture(this);
		}
	}
	,isSRGB: function() {
		switch(this.format._hx_index) {
		case 14:case 15:
			return true;
		default:
			return false;
		}
	}
	,checkAlloc: function() {
		if(this.t == null && this.realloc != null) {
			this.alloc();
			this.realloc();
		}
	}
	,clone: function() {
		this.checkAlloc();
		if(this.t == null) {
			throw haxe_Exception.thrown("Can't clone disposed texture");
		}
		var old = this._lastFrame;
		this.preventAutoDispose();
		var flags = [];
		var f = h3d_mat_TextureFlags.Target;
		if((this.flags & 1 << f._hx_index) != 0) {
			flags.push(f);
		}
		var f = h3d_mat_TextureFlags.Cube;
		if((this.flags & 1 << f._hx_index) != 0) {
			flags.push(f);
		}
		var f = h3d_mat_TextureFlags.MipMapped;
		if((this.flags & 1 << f._hx_index) != 0) {
			flags.push(f);
		}
		var f = h3d_mat_TextureFlags.IsArray;
		if((this.flags & 1 << f._hx_index) != 0) {
			flags.push(f);
		}
		var t = new h3d_mat_Texture(this.width,this.height,flags,this.format);
		t.name = this.name;
		if((this.flags & 1 << h3d_mat_TextureFlags.Cube._hx_index) != 0) {
			h3d_pass_CubeCopy.run(this,t);
		} else {
			h3d_pass_Copy.run(this,t);
		}
		this.set_lastFrame(old);
		return t;
	}
	,preventAutoDispose: function() {
		this.set_lastFrame(h3d_mat_Texture.PREVENT_AUTO_DISPOSE);
	}
	,preventForcedDispose: function() {
		this.set_lastFrame(h3d_mat_Texture.PREVENT_FORCED_DISPOSE);
	}
	,waitLoad: function(f) {
		if((this.flags & 1 << h3d_mat_TextureFlags.Loading._hx_index) == 0) {
			f();
			return;
		}
		if(this.waitLoads == null) {
			this.waitLoads = [];
		}
		this.waitLoads.push(f);
	}
	,toString: function() {
		var str = this.name;
		if(this.name == null) {
			str = "Texture_" + this.id;
			if(this.allocPos != null) {
				str += "(" + this.allocPos.position + ")";
			}
		}
		if((this.flags & 1 << h3d_mat_TextureFlags.Is3D._hx_index) != 0) {
			str += "(" + this.width + "x" + this.height + "x" + this.get_layerCount() + ")";
		} else {
			str += "(" + this.width + "x" + this.height + ")";
		}
		return str;
	}
	,setName: function(n) {
		this.name = n;
	}
	,set_depthBias: function(v) {
		if(v != this.depthBias) {
			this.depthBias = v;
			h3d_Engine.CURRENT.onTextureBiasChanged(this);
		}
		return this.depthBias;
	}
	,set_slopeScaledBias: function(v) {
		if(v != this.slopeScaledBias) {
			this.slopeScaledBias = v;
			h3d_Engine.CURRENT.onTextureBiasChanged(this);
		}
		return this.slopeScaledBias;
	}
	,set_mipMap: function(m) {
		this.bits = this.bits & -4 | m._hx_index;
		return this.mipMap = m;
	}
	,set_filter: function(f) {
		this.bits = this.bits & -25 | f._hx_index << 3;
		return this.filter = f;
	}
	,set_wrap: function(w) {
		this.bits = this.bits & -193 | w._hx_index << 6;
		return this.wrap = w;
	}
	,isDisposed: function() {
		if(this.t == null) {
			if(!this.isDepth()) {
				return this.realloc == null;
			} else {
				return true;
			}
		} else {
			return false;
		}
	}
	,resize: function(width,height) {
		this.dispose();
		var tw = 1;
		var th = 1;
		while(tw < width) tw <<= 1;
		while(th < height) th <<= 1;
		if(tw != width || th != height) {
			this.flags |= 1 << h3d_mat_TextureFlags.IsNPOT._hx_index;
		} else {
			this.flags &= -1 - (1 << h3d_mat_TextureFlags.IsNPOT._hx_index);
		}
		this.width = width;
		this.height = height;
		if((this.flags & 1 << h3d_mat_TextureFlags.NoAlloc._hx_index) == 0) {
			this.alloc();
		}
	}
	,clearF: function(r,g,b,a,layer) {
		if(layer == null) {
			layer = -1;
		}
		if(a == null) {
			a = 0.;
		}
		if(b == null) {
			b = 0.;
		}
		if(g == null) {
			g = 0.;
		}
		if(r == null) {
			r = 0.;
		}
		this.alloc();
		if((this.flags & 1 << h3d_mat_TextureFlags.Target._hx_index) == 0) {
			throw haxe_Exception.thrown("Texture should be target");
		}
		var engine = h3d_Engine.CURRENT;
		var x = r;
		var y = g;
		var z = b;
		var w = a;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var color = new h3d_Vector4Impl(x,y,z,w);
		if(layer < 0) {
			var _g = 0;
			var _g1 = this.get_layerCount();
			while(_g < _g1) {
				var i = _g++;
				engine.pushTarget(this,i);
				engine.clearF(color);
				engine.popTarget();
			}
		} else {
			engine.pushTarget(this,layer);
			engine.clearF(color);
			engine.popTarget();
		}
	}
	,clear: function(color,alpha,layer) {
		if(layer == null) {
			layer = -1;
		}
		if(alpha == null) {
			alpha = 1.;
		}
		this.alloc();
		if(this.width == 0 || this.height == 0) {
			return;
		}
		if(this.width != 1 || this.height != 1) {
			var engine = h3d_Engine.CURRENT;
			color |= ((alpha < 0. ? 0. : alpha > 1. ? 1. : alpha) * 255 | 0) << 24;
			if(layer < 0) {
				var _g = 0;
				var _g1 = this.get_layerCount();
				while(_g < _g1) {
					var i = _g++;
					engine.pushTarget(this,i);
					engine.clear(color);
					engine.popTarget();
				}
			} else {
				engine.pushTarget(this,layer);
				engine.clear(color);
				engine.popTarget();
			}
		} else {
			var p = hxd_Pixels.alloc(this.width,this.height,h3d_mat_Texture.nativeFormat);
			var k = 0;
			var b = color & 255;
			var g = color >> 8 & 255;
			var r = color >> 16 & 255;
			var a = alpha * 255 | 0;
			if(a < 0) {
				a = 0;
			} else if(a > 255) {
				a = 255;
			}
			switch(h3d_mat_Texture.nativeFormat._hx_index) {
			case 1:
				var tmp = r;
				r = b;
				b = tmp;
				break;
			case 2:
				break;
			default:
				throw haxe_Exception.thrown("TODO");
			}
			var _g = 0;
			var _g1 = this.width * this.height;
			while(_g < _g1) {
				var i = _g++;
				p.bytes.b[k++] = r;
				p.bytes.b[k++] = g;
				p.bytes.b[k++] = b;
				p.bytes.b[k++] = a;
			}
			if(layer < 0) {
				var _g = 0;
				var _g1 = this.get_layerCount();
				while(_g < _g1) {
					var i = _g++;
					this.uploadPixels(p,0,i);
				}
			} else {
				this.uploadPixels(p,0,layer);
			}
			p.dispose();
		}
	}
	,checkSize: function(width,height,mip) {
		var mw = this.width >> mip;
		if(mw == 0) {
			mw = 1;
		}
		var mh = this.height >> mip;
		if(mh == 0) {
			mh = 1;
		}
		if(width != mw || height != mh) {
			throw haxe_Exception.thrown("Invalid upload size : " + width + "x" + height + " should be " + mw + "x" + mh);
		}
	}
	,checkMipMapGen: function(mipLevel,layer) {
		if(mipLevel == 0 && (this.flags & 1 << h3d_mat_TextureFlags.MipMapped._hx_index) != 0 && (this.flags & 1 << h3d_mat_TextureFlags.ManualMipMapGen._hx_index) == 0 && layer == this.get_layerCount() - 1) {
			this.mem.driver.generateMipMaps(this);
		}
	}
	,uploadBitmap: function(bmp,mipLevel,layer) {
		if(layer == null) {
			layer = 0;
		}
		if(mipLevel == null) {
			mipLevel = 0;
		}
		this.alloc();
		this.checkSize(bmp.ctx.canvas.width,bmp.ctx.canvas.height,mipLevel);
		this.mem.driver.uploadTextureBitmap(this,bmp,mipLevel,layer);
		this.flags |= 1 << h3d_mat_TextureFlags.WasCleared._hx_index;
		this.checkMipMapGen(mipLevel,layer);
	}
	,uploadPixels: function(pixels,mipLevel,layer) {
		if(layer == null) {
			layer = 0;
		}
		if(mipLevel == null) {
			mipLevel = 0;
		}
		this.alloc();
		this.checkSize(pixels.width,pixels.height,mipLevel);
		this.mem.driver.uploadTexturePixels(this,pixels,mipLevel,layer);
		this.flags |= 1 << h3d_mat_TextureFlags.WasCleared._hx_index;
		this.checkMipMapGen(mipLevel,layer);
	}
	,dispose: function() {
		if(this.t != null) {
			this.mem.deleteTexture(this);
		}
	}
	,hasStencil: function() {
		if(this.format._hx_index == 25) {
			return true;
		} else {
			return false;
		}
	}
	,isDepth: function() {
		switch(this.format._hx_index) {
		case 23:case 24:case 25:case 26:
			return true;
		default:
			return false;
		}
	}
	,capturePixels: function(face,mipLevel,region) {
		if(mipLevel == null) {
			mipLevel = 0;
		}
		if(face == null) {
			face = 0;
		}
		var old = this._lastFrame;
		this.preventAutoDispose();
		var pix = this.mem.driver.capturePixels(this,face,mipLevel,region);
		this.set_lastFrame(old);
		return pix;
	}
	,__class__: h3d_mat_Texture
};
var h3d_mat_TextureArray = function(w,h,layers,flags,format) {
	this.layers = layers;
	if(flags == null) {
		flags = [];
	}
	flags.push(h3d_mat_TextureFlags.IsArray);
	h3d_mat_Texture.call(this,w,h,flags,format);
};
$hxClasses["h3d.mat.TextureArray"] = h3d_mat_TextureArray;
h3d_mat_TextureArray.__name__ = "h3d.mat.TextureArray";
h3d_mat_TextureArray.__super__ = h3d_mat_Texture;
h3d_mat_TextureArray.prototype = $extend(h3d_mat_Texture.prototype,{
	get_layerCount: function() {
		return this.layers;
	}
	,clone: function() {
		var old = this._lastFrame;
		this.preventAutoDispose();
		var t = new h3d_mat_TextureArray(this.width,this.height,this.layers,null,this.format);
		h3d_pass_Copy.run(this,t);
		this.set_lastFrame(old);
		return t;
	}
	,toString: function() {
		return h3d_mat_Texture.prototype.toString.call(this) + "[" + this.layers + "]";
	}
	,__class__: h3d_mat_TextureArray
});
var h3d_pass_ScreenFx = function(shader,output) {
	this.shader = shader;
	this.output = new h3d_pass_OutputShader(output);
	this.pass = new h3d_mat_Pass("screenfx",new hxsl_ShaderList(shader));
	this.pass.set_culling(h3d_mat_Face.None);
	this.pass.depth(false,h3d_mat_Compare.Always);
};
$hxClasses["h3d.pass.ScreenFx"] = h3d_pass_ScreenFx;
h3d_pass_ScreenFx.__name__ = "h3d.pass.ScreenFx";
h3d_pass_ScreenFx.run = function(shader,output,layer) {
	var engine = h3d_Engine.CURRENT;
	engine.pushTarget(output,layer);
	new h3d_pass_ScreenFx(shader).render();
	engine.popTarget();
};
h3d_pass_ScreenFx.prototype = {
	get_engine: function() {
		if(this._engine == null) {
			this._engine = h3d_Engine.CURRENT;
		}
		return this._engine;
	}
	,copy: function(src,dst) {
		h3d_pass_Copy.run(src,dst);
	}
	,addShader: function(s) {
		return this.pass.addShader(s);
	}
	,removeShader: function(s) {
		return this.pass.removeShader(s);
	}
	,getShader: function(cl) {
		return this.pass.getShader(cl);
	}
	,render: function() {
		if(this.primitive == null) {
			this.primitive = h3d_prim_Plane2D.get();
		}
		this.shader.flipY__ = this.get_engine().driver.hasFeature(h3d_impl_Feature.BottomLeftCoords) && this.get_engine().getCurrentTarget() != null ? -1 : 1;
		var shaders = this.pass.shaders;
		var ctx = h3d_impl_RenderContext.get();
		var isNewCtx = false;
		if(ctx == null) {
			isNewCtx = true;
			ctx = new h3d_impl_RenderContext();
			ctx.setCurrent();
		}
		var rts = this.output.compileShaders(ctx.globals,shaders);
		this.get_engine().selectMaterial(this.pass);
		this.get_engine().selectShader(rts);
		var buffers = ctx.shaderBuffers;
		buffers.vertex.grow(rts.vertex);
		if(rts.fragment != null) {
			buffers.fragment.grow(rts.fragment);
		}
		ctx.fillGlobals(buffers,rts);
		ctx.fillParams(buffers,rts,shaders);
		this.get_engine().uploadShaderBuffers(buffers,0);
		this.get_engine().uploadShaderBuffers(buffers,1);
		this.get_engine().uploadShaderBuffers(buffers,2);
		this.get_engine().uploadShaderBuffers(buffers,3);
		this.primitive.render(this.get_engine());
		if(isNewCtx) {
			ctx.clearCurrent();
		}
	}
	,dispose: function() {
	}
	,__class__: h3d_pass_ScreenFx
};
var h3d_pass_Blur = function(radius,gain,linear,quality) {
	if(quality == null) {
		quality = 1.;
	}
	if(linear == null) {
		linear = 0.;
	}
	if(gain == null) {
		gain = 1.;
	}
	if(radius == null) {
		radius = 1.;
	}
	this.cubeDir = [h3d_Matrix.L([0,0,-1,0,0,-1,0,0,1,0,0,0]),h3d_Matrix.L([0,0,1,0,0,-1,0,0,-1,0,0,0]),h3d_Matrix.L([1,0,0,0,0,0,1,0,0,1,0,0]),h3d_Matrix.L([1,0,0,0,0,0,-1,0,0,-1,0,0]),h3d_Matrix.L([1,0,0,0,0,-1,0,0,0,0,1,0]),h3d_Matrix.L([-1,0,0,0,0,-1,0,0,0,0,-1,0])];
	h3d_pass_ScreenFx.call(this,new h3d_shader_Blur());
	this.set_radius(radius);
	this.set_quality(quality);
	this.set_gain(gain);
	this.set_linear(linear);
};
$hxClasses["h3d.pass.Blur"] = h3d_pass_Blur;
h3d_pass_Blur.__name__ = "h3d.pass.Blur";
h3d_pass_Blur.__super__ = h3d_pass_ScreenFx;
h3d_pass_Blur.prototype = $extend(h3d_pass_ScreenFx.prototype,{
	set_radius: function(r) {
		if(this.radius == r) {
			return r;
		}
		this.values = null;
		return this.radius = r;
	}
	,set_quality: function(q) {
		if(this.quality == q) {
			return q;
		}
		this.values = null;
		return this.quality = q;
	}
	,set_gain: function(s) {
		if(this.gain == s) {
			return s;
		}
		this.values = null;
		return this.gain = s;
	}
	,set_linear: function(b) {
		if(this.linear == b) {
			return b;
		}
		this.values = null;
		return this.linear = b;
	}
	,gauss: function(x,s) {
		if(s <= 0) {
			if(x == 0) {
				return 1;
			} else {
				return 0;
			}
		}
		var sq = s * s;
		var p = Math.pow(2.718281828459,-(x * x) / (2 * sq));
		return p / Math.sqrt(2 * Math.PI * sq);
	}
	,calcValues: function() {
		this.values = [];
		this.offsets = [];
		var tot = 0.;
		var f = this.quality;
		var qadj = (f < 0. ? 0. : f > 1. ? 1. : f) * 0.7 + 0.3;
		var width;
		if(this.radius > 0) {
			var a = this.radius - 1;
			width = Math.ceil((a < 1 ? 1 : a) * qadj / 2);
		} else {
			width = 0;
		}
		var sigma = Math.sqrt(this.radius);
		var _g = 0;
		var _g1 = width + 1;
		while(_g < _g1) {
			var i = _g++;
			var i1 = i * 2;
			var i2 = i == 0 ? 0 : i * 2 - 1;
			var g1 = this.gauss(i1,sigma);
			var g2 = this.gauss(i2,sigma);
			var g = g1 + g2;
			this.values[i] = g;
			this.offsets[i] = i == 0 ? 0 : (g1 * i1 + g2 * i2) / (g * i * Math.sqrt(qadj));
			tot += g;
			if(i > 0) {
				tot += g;
			}
		}
		var minVal = this.values[0] * (0.01 / qadj);
		while(this.values.length > 2) {
			var last = this.values[this.values.length - 1];
			if(last > minVal) {
				break;
			}
			tot -= last * 2;
			this.values.pop();
		}
		tot /= this.gain;
		var _g = 0;
		var _g1 = this.values.length;
		while(_g < _g1) {
			var i = _g++;
			this.values[i] /= tot;
		}
		if(this.linear > 0) {
			var m = this.gain / (this.values.length * 2 - 1);
			var _g = 0;
			var _g1 = this.values.length;
			while(_g < _g1) {
				var i = _g++;
				var a = this.values[i];
				this.values[i] = a + this.linear * (m - a);
				var a1 = this.offsets[i];
				this.offsets[i] = a1 + this.linear * ((i == 0 ? 0 : (i * 2 - 0.5) / (i * qadj)) - a1);
			}
		}
	}
	,getKernelSize: function() {
		if(this.values == null) {
			this.calcValues();
		}
		if(this.radius <= 0) {
			return 0;
		} else {
			return this.values.length * 2 - 1;
		}
	}
	,apply: function(ctx,src,output) {
		if(this.radius <= 0 && this.shader.fixedColor__ == null) {
			if(output != null) {
				h3d_pass_Copy.run(src,output);
			}
			return;
		}
		if(output == null) {
			output = src;
		}
		if(this.values == null) {
			this.calcValues();
		}
		var isCube = (src.flags & 1 << h3d_mat_TextureFlags.Cube._hx_index) != 0;
		var faceCount = isCube ? 6 : 1;
		var tmp = ctx.textures.allocTarget(src.name + "BlurTmp",src.width,src.height,false,src.format,isCube ? [h3d_mat_TextureFlags.Cube] : null);
		var _this = this.shader;
		_this.constModified = true;
		_this.Quality__ = this.values.length;
		this.shader.values__ = this.values;
		this.shader.offsets__ = this.offsets;
		if(isCube) {
			this.shader.cubeTexture__ = src;
			var _this = this.shader;
			_this.constModified = true;
			_this.isCube__ = true;
		} else {
			this.shader.texture__ = src;
			var _this = this.shader;
			_this.constModified = true;
			_this.isCube__ = false;
		}
		var _this = this.shader.pixel__;
		var x = 1 / src.width;
		var y = 0;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = 0.;
		var _g = 0;
		var _g1 = faceCount;
		while(_g < _g1) {
			var i = _g++;
			this.get_engine().pushTarget(tmp,i);
			if(isCube) {
				this.shader.cubeDir__ = this.cubeDir[i];
			}
			this.render();
			this.get_engine().popTarget();
		}
		if(isCube) {
			this.shader.cubeTexture__ = tmp;
		} else {
			this.shader.texture__ = tmp;
		}
		var _this = this.shader.pixel__;
		var x = 0;
		var y = 1 / src.height;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = 0.;
		var outDepth = output.depthBuffer;
		output.depthBuffer = null;
		var _g = 0;
		var _g1 = faceCount;
		while(_g < _g1) {
			var i = _g++;
			this.get_engine().pushTarget(output,i);
			if(isCube) {
				this.shader.cubeDir__ = this.cubeDir[i];
			}
			this.render();
			this.get_engine().popTarget();
		}
		output.depthBuffer = outDepth;
	}
	,__class__: h3d_pass_Blur
});
var hxsl_Shader = function() {
	this.priority = 0;
	this.initialize();
};
$hxClasses["hxsl.Shader"] = hxsl_Shader;
hxsl_Shader.__name__ = "hxsl.Shader";
hxsl_Shader.prototype = {
	initialize: function() {
		this.constModified = true;
		if(this.shader != null) {
			return;
		}
		var cl = js_Boot.getClass(this);
		this.shader = cl._SHADER;
		if(this.shader == null) {
			var curClass = cl;
			while(curClass != null && curClass.SRC == null) curClass = curClass.__super__;
			if(curClass == null) {
				throw haxe_Exception.thrown(cl.__name__ + " has no shader source");
			}
			this.shader = curClass._SHADER;
			if(this.shader == null) {
				this.shader = new hxsl_SharedShader(curClass.SRC,curClass._MODULE);
				curClass._SHADER = this.shader;
			}
		}
	}
	,setPriority: function(v) {
		this.priority = v;
	}
	,getParamValue: function(index) {
		throw haxe_Exception.thrown("assert");
	}
	,getParamFloatValue: function(index) {
		throw haxe_Exception.thrown("assert");
	}
	,setParamIndexValue: function(index,val) {
		throw haxe_Exception.thrown("assert");
	}
	,setParamIndexFloatValue: function(index,val) {
		throw haxe_Exception.thrown("assert");
	}
	,updateConstants: function(globals) {
		throw haxe_Exception.thrown("assert");
	}
	,updateConstantsFinal: function(globals) {
		var c = this.shader.consts;
		while(c != null) {
			if(c.globalId == 0) {
				c = c.next;
				continue;
			}
			var v = globals.map.h[c.globalId];
			var _g = c.v.type;
			switch(_g._hx_index) {
			case 1:
				var v1 = v;
				if(v1 >>> c.bits != 0) {
					throw haxe_Exception.thrown("Constant " + c.v.name + " is outside range (" + v1 + " > " + ((1 << c.bits) - 1) + ")");
				}
				this.constBits |= v1 << c.pos;
				break;
			case 2:
				var v2 = v;
				if(v2) {
					this.constBits |= 1 << c.pos;
				}
				break;
			case 17:
				var count = _g.size;
				if(v == null) {
					c = c.next;
					continue;
				}
				var v3 = v;
				var sel = v3.channel;
				if(v3.texture == null) {
					sel = hxsl_Channel.Unknown;
				} else if(sel == null || sel == hxsl_Channel.Unknown) {
					switch(count) {
					case 1:
						if(v3.texture.format == h3d_mat_Texture.nativeFormat) {
							sel = hxsl_Channel.PackedFloat;
						} else {
							throw haxe_Exception.thrown("Constant " + c.v.name + " does not define channel select value");
						}
						break;
					case 3:
						if(v3.texture.format == h3d_mat_Texture.nativeFormat) {
							sel = hxsl_Channel.PackedNormal;
						} else {
							throw haxe_Exception.thrown("Constant " + c.v.name + " does not define channel select value");
						}
						break;
					default:
						throw haxe_Exception.thrown("Constant " + c.v.name + " does not define channel select value");
					}
				}
				this.constBits |= (globals.allocChannelID(v3.texture) << 3 | sel._hx_index) << c.pos;
				break;
			default:
				throw haxe_Exception.thrown("assert");
			}
			c = c.next;
		}
		var _this = this.shader;
		var constBits = this.constBits;
		var i = _this.instanceCache.h[constBits];
		this.instance = i == null ? _this.makeInstance(constBits) : i;
	}
	,clone: function() {
		return this;
	}
	,toString: function() {
		var c = js_Boot.getClass(this);
		return c.__name__;
	}
	,__class__: hxsl_Shader
};
var h3d_shader_ScreenShader = function() {
	this.flipY__ = 0;
	hxsl_Shader.call(this);
};
$hxClasses["h3d.shader.ScreenShader"] = h3d_shader_ScreenShader;
h3d_shader_ScreenShader.__name__ = "h3d.shader.ScreenShader";
h3d_shader_ScreenShader.__super__ = hxsl_Shader;
h3d_shader_ScreenShader.prototype = $extend(hxsl_Shader.prototype,{
	get_flipY: function() {
		return this.flipY__;
	}
	,set_flipY: function(_v) {
		return this.flipY__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
		if(index == 0) {
			this.flipY__ = val;
		}
	}
	,setParamIndexFloatValue: function(index,val) {
		if(index == 0) {
			this.flipY__ = val;
		}
	}
	,clone: function() {
		var s = Object.create(h3d_shader_ScreenShader.prototype);
		s.shader = this.shader;
		s.flipY__ = this.flipY__;
		return s;
	}
	,__class__: h3d_shader_ScreenShader
});
var h3d_pass__$Border_BorderShader = function() {
	this.color__ = new h3d_Vector4Impl(0.,0.,0.,1.);
	h3d_shader_ScreenShader.call(this);
};
$hxClasses["h3d.pass._Border.BorderShader"] = h3d_pass__$Border_BorderShader;
h3d_pass__$Border_BorderShader.__name__ = "h3d.pass._Border.BorderShader";
h3d_pass__$Border_BorderShader.__super__ = h3d_shader_ScreenShader;
h3d_pass__$Border_BorderShader.prototype = $extend(h3d_shader_ScreenShader.prototype,{
	get_color: function() {
		return this.color__;
	}
	,set_color: function(_v) {
		return this.color__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.color__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return 0.;
	}
	,clone: function() {
		var s = Object.create(h3d_pass__$Border_BorderShader.prototype);
		s.shader = this.shader;
		s.flipY__ = this.flipY__;
		s.color__ = this.color__;
		return s;
	}
	,__class__: h3d_pass__$Border_BorderShader
});
var h3d_pass_Border = function(width,height,size) {
	if(size == null) {
		size = 1;
	}
	h3d_pass_ScreenFx.call(this,new h3d_pass__$Border_BorderShader());
	this.width = width;
	this.height = height;
	this.size = size;
	var _this = this.shader.color__;
	var x = 1;
	var y = 1;
	var z = 1;
	var w = 1;
	if(w == null) {
		w = 1.;
	}
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	_this.x = x;
	_this.y = y;
	_this.z = z;
	_this.w = w;
};
$hxClasses["h3d.pass.Border"] = h3d_pass_Border;
h3d_pass_Border.__name__ = "h3d.pass.Border";
h3d_pass_Border.__super__ = h3d_pass_ScreenFx;
h3d_pass_Border.prototype = $extend(h3d_pass_ScreenFx.prototype,{
	createPrimitive: function() {
		var _gthis = this;
		var bbuf = hxd__$FloatBuffer_Float32Expand._new(0);
		var v = 0 / _gthis.width * 2 - 1;
		if(bbuf.pos == bbuf.array.length) {
			var newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = v;
		var v = 1 - 0 / _gthis.height * 2;
		if(bbuf.pos == bbuf.array.length) {
			var newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = v;
		var v = this.width / _gthis.width * 2 - 1;
		if(bbuf.pos == bbuf.array.length) {
			var newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = v;
		var v = 1 - 0 / _gthis.height * 2;
		if(bbuf.pos == bbuf.array.length) {
			var newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = v;
		var y = this.size;
		var v = 0 / _gthis.width * 2 - 1;
		if(bbuf.pos == bbuf.array.length) {
			var newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = v;
		var v = 1 - y / _gthis.height * 2;
		if(bbuf.pos == bbuf.array.length) {
			var newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = v;
		var y = this.size;
		var v = this.width / _gthis.width * 2 - 1;
		if(bbuf.pos == bbuf.array.length) {
			var newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = v;
		var v = 1 - y / _gthis.height * 2;
		if(bbuf.pos == bbuf.array.length) {
			var newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = v;
		var v = 0 / _gthis.width * 2 - 1;
		if(bbuf.pos == bbuf.array.length) {
			var newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = v;
		var v = 1 - 0 / _gthis.height * 2;
		if(bbuf.pos == bbuf.array.length) {
			var newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = v;
		var v = this.size / _gthis.width * 2 - 1;
		if(bbuf.pos == bbuf.array.length) {
			var newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = v;
		var v = 1 - 0 / _gthis.height * 2;
		if(bbuf.pos == bbuf.array.length) {
			var newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = v;
		var y = this.height;
		var v = 0 / _gthis.width * 2 - 1;
		if(bbuf.pos == bbuf.array.length) {
			var newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = v;
		var v = 1 - y / _gthis.height * 2;
		if(bbuf.pos == bbuf.array.length) {
			var newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = v;
		var y = this.height;
		var v = this.size / _gthis.width * 2 - 1;
		if(bbuf.pos == bbuf.array.length) {
			var newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = v;
		var v = 1 - y / _gthis.height * 2;
		if(bbuf.pos == bbuf.array.length) {
			var newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = v;
		var y = this.height - this.size;
		var v = 0 / _gthis.width * 2 - 1;
		if(bbuf.pos == bbuf.array.length) {
			var newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = v;
		var v = 1 - y / _gthis.height * 2;
		if(bbuf.pos == bbuf.array.length) {
			var newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = v;
		var y = this.height - this.size;
		var v = this.width / _gthis.width * 2 - 1;
		if(bbuf.pos == bbuf.array.length) {
			var newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = v;
		var v = 1 - y / _gthis.height * 2;
		if(bbuf.pos == bbuf.array.length) {
			var newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = v;
		var y = this.height;
		var v = 0 / _gthis.width * 2 - 1;
		if(bbuf.pos == bbuf.array.length) {
			var newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = v;
		var v = 1 - y / _gthis.height * 2;
		if(bbuf.pos == bbuf.array.length) {
			var newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = v;
		var y = this.height;
		var v = this.width / _gthis.width * 2 - 1;
		if(bbuf.pos == bbuf.array.length) {
			var newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = v;
		var v = 1 - y / _gthis.height * 2;
		if(bbuf.pos == bbuf.array.length) {
			var newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = v;
		var v = (this.width - this.size) / _gthis.width * 2 - 1;
		if(bbuf.pos == bbuf.array.length) {
			var newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = v;
		var v = 1 - 0 / _gthis.height * 2;
		if(bbuf.pos == bbuf.array.length) {
			var newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = v;
		var v = this.width / _gthis.width * 2 - 1;
		if(bbuf.pos == bbuf.array.length) {
			var newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = v;
		var v = 1 - 0 / _gthis.height * 2;
		if(bbuf.pos == bbuf.array.length) {
			var newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = v;
		var y = this.height;
		var v = (this.width - this.size) / _gthis.width * 2 - 1;
		if(bbuf.pos == bbuf.array.length) {
			var newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = v;
		var v = 1 - y / _gthis.height * 2;
		if(bbuf.pos == bbuf.array.length) {
			var newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = v;
		var y = this.height;
		var v = this.width / _gthis.width * 2 - 1;
		if(bbuf.pos == bbuf.array.length) {
			var newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = v;
		var v = 1 - y / _gthis.height * 2;
		if(bbuf.pos == bbuf.array.length) {
			var newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = v;
		this.primitive = new h3d_prim_RawPrimitive({ vbuf : bbuf, format : hxd_BufferFormat.make([new hxd_BufferInput("position",2,0)])},true);
	}
	,render: function() {
		if(this.primitive == null) {
			this.createPrimitive();
		}
		h3d_pass_ScreenFx.prototype.render.call(this);
	}
	,dispose: function() {
		if(this.primitive != null) {
			this.primitive.dispose();
		}
		h3d_pass_ScreenFx.prototype.dispose.call(this);
	}
	,__class__: h3d_pass_Border
});
var h3d_pass__$Copy_ArrayCopyShader = function() {
	this.layer__ = 0;
	h3d_shader_ScreenShader.call(this);
};
$hxClasses["h3d.pass._Copy.ArrayCopyShader"] = h3d_pass__$Copy_ArrayCopyShader;
h3d_pass__$Copy_ArrayCopyShader.__name__ = "h3d.pass._Copy.ArrayCopyShader";
h3d_pass__$Copy_ArrayCopyShader.__super__ = h3d_shader_ScreenShader;
h3d_pass__$Copy_ArrayCopyShader.prototype = $extend(h3d_shader_ScreenShader.prototype,{
	get_texture: function() {
		return this.texture__;
	}
	,set_texture: function(_v) {
		return this.texture__ = _v;
	}
	,get_layer: function() {
		return this.layer__;
	}
	,set_layer: function(_v) {
		return this.layer__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.texture__;
		case 2:
			return this.layer__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 2:
			return this.layer__;
		default:
		}
		return 0.;
	}
	,clone: function() {
		var s = Object.create(h3d_pass__$Copy_ArrayCopyShader.prototype);
		s.shader = this.shader;
		s.flipY__ = this.flipY__;
		s.texture__ = this.texture__;
		s.layer__ = this.layer__;
		return s;
	}
	,__class__: h3d_pass__$Copy_ArrayCopyShader
});
var h3d_pass_ArrayCopy = function() {
	h3d_pass_ScreenFx.call(this,new h3d_pass__$Copy_ArrayCopyShader());
};
$hxClasses["h3d.pass.ArrayCopy"] = h3d_pass_ArrayCopy;
h3d_pass_ArrayCopy.__name__ = "h3d.pass.ArrayCopy";
h3d_pass_ArrayCopy.run = function(from,fromLayer,to,blend,pass,layer) {
	var engine = h3d_Engine.CURRENT;
	if(to != null && from != null && (blend == null || blend == h2d_BlendMode.None) && pass == null && engine.driver.copyTexture(from,to)) {
		return;
	}
	var inst = engine.resCache.h[h3d_pass_ArrayCopy.__id__];
	if(inst == null) {
		inst = new h3d_pass_ArrayCopy();
		engine.resCache.set(h3d_pass_ArrayCopy,inst);
	}
	inst.apply(from,fromLayer,to,blend,pass,layer);
};
h3d_pass_ArrayCopy.__super__ = h3d_pass_ScreenFx;
h3d_pass_ArrayCopy.prototype = $extend(h3d_pass_ScreenFx.prototype,{
	apply: function(from,fromLayer,to,blend,customPass,layer) {
		if(to != null) {
			this.get_engine().pushTarget(to,layer != null ? layer : 0);
		}
		this.shader.texture__ = from;
		this.shader.layer__ = fromLayer;
		if(customPass != null) {
			if(blend != null) {
				customPass.setBlendMode(blend);
			}
			var h = customPass.shaders;
			while(h.next != null) h = h.next;
			h.next = this.pass.shaders;
			var old = this.pass;
			this.pass = customPass;
			this.render();
			this.pass = old;
			h.next = null;
		} else {
			this.pass.setBlendMode(blend == null ? h2d_BlendMode.None : blend);
			this.render();
		}
		this.shader.texture__ = null;
		this.shader.layer__ = 0;
		if(to != null) {
			this.get_engine().popTarget();
		}
	}
	,__class__: h3d_pass_ArrayCopy
});
var h3d_pass__$Copy_CopyShader = function() {
	h3d_shader_ScreenShader.call(this);
};
$hxClasses["h3d.pass._Copy.CopyShader"] = h3d_pass__$Copy_CopyShader;
h3d_pass__$Copy_CopyShader.__name__ = "h3d.pass._Copy.CopyShader";
h3d_pass__$Copy_CopyShader.__super__ = h3d_shader_ScreenShader;
h3d_pass__$Copy_CopyShader.prototype = $extend(h3d_shader_ScreenShader.prototype,{
	get_texture: function() {
		return this.texture__;
	}
	,set_texture: function(_v) {
		return this.texture__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.texture__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return 0.;
	}
	,clone: function() {
		var s = Object.create(h3d_pass__$Copy_CopyShader.prototype);
		s.shader = this.shader;
		s.flipY__ = this.flipY__;
		s.texture__ = this.texture__;
		return s;
	}
	,__class__: h3d_pass__$Copy_CopyShader
});
var h3d_pass_Copy = function() {
	h3d_pass_ScreenFx.call(this,new h3d_pass__$Copy_CopyShader());
};
$hxClasses["h3d.pass.Copy"] = h3d_pass_Copy;
h3d_pass_Copy.__name__ = "h3d.pass.Copy";
h3d_pass_Copy.run = function(from,to,blend,pass,layer) {
	var engine = h3d_Engine.CURRENT;
	if(to != null && from != null && (blend == null || blend == h2d_BlendMode.None) && pass == null && layer == null && engine.driver.copyTexture(from,to)) {
		return;
	}
	var inst = engine.resCache.h[h3d_pass_Copy.__id__];
	if(inst == null) {
		inst = new h3d_pass_Copy();
		engine.resCache.set(h3d_pass_Copy,inst);
	}
	inst.apply(from,to,blend,pass,layer);
};
h3d_pass_Copy.__super__ = h3d_pass_ScreenFx;
h3d_pass_Copy.prototype = $extend(h3d_pass_ScreenFx.prototype,{
	apply: function(from,to,blend,customPass,layer) {
		if(to != null) {
			this.get_engine().pushTarget(to,layer != null ? layer : 0,null,h3d_DepthBinding.NotBound);
		}
		this.shader.texture__ = from;
		if(customPass != null) {
			if(blend != null) {
				customPass.setBlendMode(blend);
			}
			var h = customPass.shaders;
			while(h.next != null) h = h.next;
			h.next = this.pass.shaders;
			var old = this.pass;
			this.pass = customPass;
			this.render();
			this.pass = old;
			h.next = null;
		} else {
			this.pass.setBlendMode(blend == null ? h2d_BlendMode.None : blend);
			this.render();
		}
		this.shader.texture__ = null;
		if(to != null) {
			this.get_engine().popTarget();
		}
	}
	,__class__: h3d_pass_Copy
});
var h3d_pass__$CubeCopy_CubeCopyShader = function() {
	this.mat__ = new h3d_MatrixImpl();
	h3d_shader_ScreenShader.call(this);
};
$hxClasses["h3d.pass._CubeCopy.CubeCopyShader"] = h3d_pass__$CubeCopy_CubeCopyShader;
h3d_pass__$CubeCopy_CubeCopyShader.__name__ = "h3d.pass._CubeCopy.CubeCopyShader";
h3d_pass__$CubeCopy_CubeCopyShader.__super__ = h3d_shader_ScreenShader;
h3d_pass__$CubeCopy_CubeCopyShader.prototype = $extend(h3d_shader_ScreenShader.prototype,{
	get_texture: function() {
		return this.texture__;
	}
	,set_texture: function(_v) {
		return this.texture__ = _v;
	}
	,get_mat: function() {
		return this.mat__;
	}
	,set_mat: function(_v) {
		return this.mat__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.texture__;
		case 2:
			return this.mat__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return 0.;
	}
	,clone: function() {
		var s = Object.create(h3d_pass__$CubeCopy_CubeCopyShader.prototype);
		s.shader = this.shader;
		s.flipY__ = this.flipY__;
		s.texture__ = this.texture__;
		s.mat__ = this.mat__;
		return s;
	}
	,__class__: h3d_pass__$CubeCopy_CubeCopyShader
});
var h3d_pass_CubeCopy = function() {
	this.cubeDir = [h3d_Matrix.L([0,0,-1,0,0,-1,0,0,1,0,0,0]),h3d_Matrix.L([0,0,1,0,0,-1,0,0,-1,0,0,0]),h3d_Matrix.L([1,0,0,0,0,0,1,0,0,1,0,0]),h3d_Matrix.L([1,0,0,0,0,0,-1,0,0,-1,0,0]),h3d_Matrix.L([1,0,0,0,0,-1,0,0,0,0,1,0]),h3d_Matrix.L([-1,0,0,0,0,-1,0,0,0,0,-1,0])];
	h3d_pass_ScreenFx.call(this,new h3d_pass__$CubeCopy_CubeCopyShader());
};
$hxClasses["h3d.pass.CubeCopy"] = h3d_pass_CubeCopy;
h3d_pass_CubeCopy.__name__ = "h3d.pass.CubeCopy";
h3d_pass_CubeCopy.run = function(from,to,blend,mip) {
	if(mip == null) {
		mip = 0;
	}
	var engine = h3d_Engine.CURRENT;
	if(to != null && from != null && (blend == null || blend == h2d_BlendMode.None) && mip == 0 && engine.driver.copyTexture(from,to)) {
		return;
	}
	var inst = engine.resCache.h[h3d_pass_CubeCopy.__id__];
	if(inst == null) {
		inst = new h3d_pass_CubeCopy();
		engine.resCache.set(h3d_pass_CubeCopy,inst);
	}
	inst.apply(from,to,blend,mip);
};
h3d_pass_CubeCopy.__super__ = h3d_pass_ScreenFx;
h3d_pass_CubeCopy.prototype = $extend(h3d_pass_ScreenFx.prototype,{
	apply: function(from,to,blend,mip) {
		if(mip == null) {
			mip = 0;
		}
		this.shader.texture__ = from;
		if(to != null) {
			this.get_engine().pushTarget(to,0,mip);
		}
		this.shader.mat__ = this.cubeDir[0];
		this.pass.setBlendMode(blend == null ? h2d_BlendMode.None : blend);
		this.render();
		if(to != null) {
			this.get_engine().popTarget();
		}
		if(to != null) {
			this.get_engine().pushTarget(to,1,mip);
		}
		this.shader.mat__ = this.cubeDir[1];
		this.pass.setBlendMode(blend == null ? h2d_BlendMode.None : blend);
		this.render();
		if(to != null) {
			this.get_engine().popTarget();
		}
		if(to != null) {
			this.get_engine().pushTarget(to,2,mip);
		}
		this.shader.mat__ = this.cubeDir[2];
		this.pass.setBlendMode(blend == null ? h2d_BlendMode.None : blend);
		this.render();
		if(to != null) {
			this.get_engine().popTarget();
		}
		if(to != null) {
			this.get_engine().pushTarget(to,3,mip);
		}
		this.shader.mat__ = this.cubeDir[3];
		this.pass.setBlendMode(blend == null ? h2d_BlendMode.None : blend);
		this.render();
		if(to != null) {
			this.get_engine().popTarget();
		}
		if(to != null) {
			this.get_engine().pushTarget(to,4,mip);
		}
		this.shader.mat__ = this.cubeDir[4];
		this.pass.setBlendMode(blend == null ? h2d_BlendMode.None : blend);
		this.render();
		if(to != null) {
			this.get_engine().popTarget();
		}
		if(to != null) {
			this.get_engine().pushTarget(to,5,mip);
		}
		this.shader.mat__ = this.cubeDir[5];
		this.pass.setBlendMode(blend == null ? h2d_BlendMode.None : blend);
		this.render();
		if(to != null) {
			this.get_engine().popTarget();
		}
		this.shader.texture__ = null;
	}
	,__class__: h3d_pass_CubeCopy
});
var h3d_pass_Output = function(name,output) {
	this.defaultSort = ($_=new h3d_pass_SortByMaterial(),$bind($_,$_.sort));
	this.name = name;
	this.output = new h3d_pass_OutputShader(output);
};
$hxClasses["h3d.pass.Output"] = h3d_pass_Output;
h3d_pass_Output.__name__ = "h3d.pass.Output";
h3d_pass_Output.prototype = {
	get_globals: function() {
		return this.ctx.globals;
	}
	,setContext: function(ctx) {
		this.ctx = ctx;
	}
	,dispose: function() {
	}
	,processShaders: function(p,shaders) {
		var p = this.ctx.extraShaders;
		while(p != null) {
			shaders = this.ctx.allocShaderList(p.s,shaders);
			p = p.next;
		}
		return shaders;
	}
	,setupShaders: function(passes) {
		var lightInit = false;
		var _g_o = passes.current;
		while(_g_o != null) {
			var tmp = _g_o;
			_g_o = _g_o.next;
			var p = tmp;
			var shaders = p.pass.getShadersRec();
			shaders = this.processShaders(p,shaders);
			if(p.pass.enableLights && this.ctx.lightSystem != null) {
				if(!lightInit) {
					this.ctx.lightSystem.initGlobals(this.ctx.globals);
					lightInit = true;
				}
				shaders = this.ctx.lightSystem.computeLight(p.obj,shaders);
			}
			p.shader = this.output.compileShaders(this.ctx.globals,shaders,p.pass.batchMode ? hxsl_LinkMode.Batch : hxsl_LinkMode.Default);
			p.shaders = shaders;
			var t = p.shader.fragment.textures;
			var tmp1;
			if(t != null) {
				var _g = t.type;
				if(_g._hx_index == 15) {
					var _g1 = _g.t;
					var _g2 = _g.size;
					tmp1 = true;
				} else {
					tmp1 = false;
				}
			} else {
				tmp1 = true;
			}
			if(tmp1) {
				p.texture = 0;
			} else {
				var _this = this.ctx;
				var opt = true;
				if(opt == null) {
					opt = false;
				}
				var t1;
				if(t.perObjectGlobal != null) {
					var v = _this.globals.map.h[t.perObjectGlobal.gid];
					if(v == null) {
						throw haxe_Exception.thrown("Missing global value " + t.perObjectGlobal.path + " for shader " + _this.shaderInfo(shaders,t.perObjectGlobal.path));
					}
					var _g3 = t.type;
					var t2;
					if(_g3._hx_index == 17) {
						var _g4 = _g3.size;
						t2 = true;
					} else {
						t2 = false;
					}
					t1 = t2 ? v.texture : v;
				} else {
					var si = shaders;
					var n = t.instance;
					while(--n > 0) si = si.next;
					var v1 = si.s.getParamValue(t.index);
					if(v1 == null && !opt) {
						throw haxe_Exception.thrown("Missing param value " + Std.string(si.s) + "." + t.name);
					}
					t1 = v1;
				}
				p.texture = t1 == null ? 0 : t1.id;
			}
		}
	}
	,log: function(str) {
		var _this = this.ctx.engine.driver;
		if(_this.logEnable) {
			_this.logImpl(str);
		}
	}
	,drawObject: function(p) {
		this.ctx.drawPass = p;
		this.ctx.engine.selectMaterial(p.pass);
		var _this = p.obj;
		var f = 65536;
		_this.flags |= f;
		p.obj.draw(this.ctx);
	}
	,draw: function(passes,sort) {
		if(passes.current == null) {
			return;
		}
		this.ctx.setupTarget();
		this.setupShaders(passes);
		if(sort == null) {
			this.defaultSort(passes);
		} else {
			sort(passes);
		}
		var buf = this.ctx.shaderBuffers;
		var prevShader = null;
		var _g_o = passes.current;
		while(_g_o != null) {
			var tmp = _g_o;
			_g_o = _g_o.next;
			var p = tmp;
			var _this = this.ctx;
			var tmp1 = p.obj.prevAbsPos;
			var v = tmp1 != null ? tmp1 : p.obj.absPos;
			_this.globals.map.h[_this.globalPreviousModelView_id] = v;
			var _this1 = this.ctx;
			var v1 = p.obj.absPos;
			_this1.globals.map.h[_this1.globalModelView_id] = v1;
			if(p.shader.globals.h.hasOwnProperty(this.ctx.globalModelViewInverse_id)) {
				var _this2 = this.ctx;
				var v2 = p.obj.getInvPos();
				_this2.globals.map.h[_this2.globalModelViewInverse_id] = v2;
			}
			if(prevShader != p.shader) {
				prevShader = p.shader;
				if(h3d_pass_Output.onShaderError != null) {
					try {
						this.ctx.engine.selectShader(p.shader);
					} catch( _g ) {
						var e = haxe_Exception.caught(_g).unwrap();
						h3d_pass_Output.onShaderError(e,p);
						continue;
					}
				} else {
					this.ctx.engine.selectShader(p.shader);
				}
				var s = p.shader;
				buf.vertex.grow(s.vertex);
				if(s.fragment != null) {
					buf.fragment.grow(s.fragment);
				}
				this.ctx.fillGlobals(buf,p.shader);
				this.ctx.engine.uploadShaderBuffers(buf,0);
			}
			if(!p.pass.dynamicParameters) {
				this.ctx.fillParams(buf,p.shader,p.shaders);
				this.ctx.engine.uploadShaderBuffers(buf,1);
				this.ctx.engine.uploadShaderBuffers(buf,2);
				this.ctx.engine.uploadShaderBuffers(buf,3);
			}
			this.drawObject(p);
		}
		var _this = this.ctx;
		_this.cachedPos = 0;
		_this.drawPass = null;
	}
	,__class__: h3d_pass_Output
};
var h3d_pass_Shadows = function(light) {
	this.pcfScale = 1.0;
	this.pcfQuality = 1;
	this.bias = 0.01;
	this.power = 30.0;
	this.samplingKind = h3d_pass_ShadowSamplingKind.None;
	this.size = 1024;
	this.mode = h3d_pass_RenderMode.None;
	this.enabled = true;
	this.updateStatic = false;
	if(this.format == null) {
		this.format = hxd_PixelFormat.R16F;
	}
	if(!h3d_Engine.CURRENT.driver.isSupportedFormat(this.format)) {
		this.format = h3d_mat_Texture.nativeFormat;
	}
	h3d_pass_Output.call(this,"shadow",this.getOutputs());
	this.light = light;
	this.blur = new h3d_pass_Blur(5);
	this.blur.set_quality(0.5);
	var _this = this.blur.shader;
	_this.constModified = true;
	_this.isDepth__ = this.format == h3d_mat_Texture.nativeFormat;
};
$hxClasses["h3d.pass.Shadows"] = h3d_pass_Shadows;
h3d_pass_Shadows.__name__ = "h3d.pass.Shadows";
h3d_pass_Shadows.__super__ = h3d_pass_Output;
h3d_pass_Shadows.prototype = $extend(h3d_pass_Output.prototype,{
	set_mode: function(m) {
		if(m != h3d_pass_RenderMode.None) {
			throw haxe_Exception.thrown("Shadow mode " + Std.string(m) + " not supported for " + Std.string(this.light));
		}
		return this.mode = m;
	}
	,set_enabled: function(b) {
		return this.enabled = b;
	}
	,set_size: function(s) {
		if(s != this.size && this.staticTexture != null) {
			this.staticTexture.dispose();
			this.staticTexture = null;
		}
		return this.size = s;
	}
	,dispose: function() {
		h3d_pass_Output.prototype.dispose.call(this);
		this.blur.dispose();
		if(this.staticTexture != null) {
			this.staticTexture.dispose();
		}
	}
	,getShadowProj: function() {
		return this.lightCamera.m;
	}
	,getShadowTex: function() {
		return null;
	}
	,isUsingWorldDist: function() {
		return false;
	}
	,getOutputs: function() {
		if(this.isUsingWorldDist()) {
			return [hxsl_Output.Swiz(hxsl_Output.Value("output.worldDist",1),[hxsl_Component.X,hxsl_Component.X,hxsl_Component.X,hxsl_Component.X])];
		}
		if(this.format == h3d_mat_Texture.nativeFormat) {
			return [hxsl_Output.PackFloat(hxsl_Output.Value("output.depth"))];
		}
		return [hxsl_Output.Swiz(hxsl_Output.Value("output.depth",1),[hxsl_Component.X,hxsl_Component.X,hxsl_Component.X,hxsl_Component.X])];
	}
	,loadStaticData: function(bytes) {
		return false;
	}
	,saveStaticData: function() {
		return null;
	}
	,computeStatic: function(passes) {
		throw haxe_Exception.thrown("Not implemented");
	}
	,needStaticUpdate: function() {
		switch(this.mode._hx_index) {
		case 1:case 3:
			this.updateStatic = true;
			break;
		case 0:case 2:
			break;
		}
	}
	,createDefaultShadowMap: function() {
		var tex = h3d_mat_Texture.fromColor(16777215);
		tex.name = "defaultShadowMap";
		return tex;
	}
	,syncEarlyExit: function() {
		this.syncShader(this.staticTexture == null ? this.createDefaultShadowMap() : this.staticTexture);
	}
	,syncShader: function(texture) {
	}
	,filterPasses: function(passes) {
		if(this.ctx.computingStatic || this.updateStatic) {
			switch(this.mode._hx_index) {
			case 0:
				return false;
			case 1:
				var head = null;
				var prev = null;
				var disc = passes.discarded;
				var discQueue = passes.lastDisc;
				var cur = passes.current;
				while(cur != null) {
					if(cur.pass.isStatic == true) {
						if(head == null) {
							prev = cur;
							head = prev;
						} else {
							prev.next = cur;
							prev = cur;
						}
					} else if(disc == null) {
						discQueue = cur;
						disc = discQueue;
					} else {
						discQueue.next = cur;
						discQueue = cur;
					}
					cur = cur.next;
				}
				if(prev != null) {
					prev.next = null;
				}
				if(discQueue != null) {
					discQueue.next = null;
				}
				passes.current = head;
				passes.discarded = disc;
				passes.lastDisc = discQueue;
				return true;
			case 2:
				return false;
			case 3:
				var head = null;
				var prev = null;
				var disc = passes.discarded;
				var discQueue = passes.lastDisc;
				var cur = passes.current;
				while(cur != null) {
					if(cur.pass.isStatic == true) {
						if(head == null) {
							prev = cur;
							head = prev;
						} else {
							prev.next = cur;
							prev = cur;
						}
					} else if(disc == null) {
						discQueue = cur;
						disc = discQueue;
					} else {
						discQueue.next = cur;
						discQueue = cur;
					}
					cur = cur.next;
				}
				if(prev != null) {
					prev.next = null;
				}
				if(discQueue != null) {
					discQueue.next = null;
				}
				passes.current = head;
				passes.discarded = disc;
				passes.lastDisc = discQueue;
				return true;
			}
		} else {
			switch(this.mode._hx_index) {
			case 0:
				return false;
			case 1:
				this.syncEarlyExit();
				return false;
			case 2:
				return true;
			case 3:
				var head = null;
				var prev = null;
				var disc = passes.discarded;
				var discQueue = passes.lastDisc;
				var cur = passes.current;
				while(cur != null) {
					if(cur.pass.isStatic == false) {
						if(head == null) {
							prev = cur;
							head = prev;
						} else {
							prev.next = cur;
							prev = cur;
						}
					} else if(disc == null) {
						discQueue = cur;
						disc = discQueue;
					} else {
						discQueue.next = cur;
						discQueue = cur;
					}
					cur = cur.next;
				}
				if(prev != null) {
					prev.next = null;
				}
				if(discQueue != null) {
					discQueue.next = null;
				}
				passes.current = head;
				passes.discarded = disc;
				passes.lastDisc = discQueue;
				return true;
			}
		}
	}
	,cullPasses: function(passes,f) {
		var prevCollider = null;
		var prevResult = true;
		var head = null;
		var prev = null;
		var disc = passes.discarded;
		var discQueue = passes.lastDisc;
		var cur = passes.current;
		while(cur != null) {
			var col = cur.obj.cullingCollider;
			var tmp;
			if(col == null) {
				tmp = true;
			} else {
				if(col != prevCollider) {
					prevCollider = col;
					prevResult = f(col);
				}
				tmp = prevResult;
			}
			if(tmp) {
				if(head == null) {
					prev = cur;
					head = prev;
				} else {
					prev.next = cur;
					prev = cur;
				}
			} else if(disc == null) {
				discQueue = cur;
				disc = discQueue;
			} else {
				discQueue.next = cur;
				discQueue = cur;
			}
			cur = cur.next;
		}
		if(prev != null) {
			prev.next = null;
		}
		if(discQueue != null) {
			discQueue.next = null;
		}
		passes.current = head;
		passes.discarded = disc;
		passes.lastDisc = discQueue;
	}
	,__class__: h3d_pass_Shadows
});
var h3d_pass_DirShadowMap = function(light) {
	this.minDist = -1.0;
	this.maxDist = -1.0;
	this.autoZPlanes = false;
	this.autoShrink = true;
	this.mergePass = new h3d_pass_ScreenFx(new h3d_shader_MinMaxShader());
	h3d_pass_Shadows.call(this,light);
	this.lightCamera = new h3d_Camera();
	this.lightCamera.orthoBounds = new h3d_col_Bounds();
	this.shader = this.dshader = new h3d_shader_DirShadow();
	this.border = new h3d_pass_Border(this.size,this.size);
};
$hxClasses["h3d.pass.DirShadowMap"] = h3d_pass_DirShadowMap;
h3d_pass_DirShadowMap.__name__ = "h3d.pass.DirShadowMap";
h3d_pass_DirShadowMap.__super__ = h3d_pass_Shadows;
h3d_pass_DirShadowMap.prototype = $extend(h3d_pass_Shadows.prototype,{
	set_mode: function(m) {
		var _this = this.dshader;
		_this.constModified = true;
		_this.enable__ = m != h3d_pass_RenderMode.None;
		return this.mode = m;
	}
	,set_enabled: function(b) {
		var _this = this.dshader;
		_this.constModified = true;
		_this.enable__ = b && this.mode != h3d_pass_RenderMode.None;
		return this.enabled = b;
	}
	,set_size: function(s) {
		if(this.border != null && this.size != s) {
			this.border.dispose();
			this.border = new h3d_pass_Border(s,s);
		}
		return h3d_pass_Shadows.prototype.set_size.call(this,s);
	}
	,dispose: function() {
		h3d_pass_Shadows.prototype.dispose.call(this);
		if(this.depth != null) {
			this.depth.dispose();
		}
		if(this.border != null) {
			this.border.dispose();
		}
	}
	,getShadowTex: function() {
		return this.dshader.shadowMap__;
	}
	,calcShadowBounds: function(camera) {
		var _gthis = this;
		var bounds = camera.orthoBounds;
		var zMax = -1e9;
		var zMin = 1e9;
		if(this.autoShrink) {
			var mtmp = new h3d_MatrixImpl();
			var identity = h3d_Matrix.I();
			var btmp = this.autoZPlanes ? new h3d_col_Bounds() : null;
			var obj = this.boundingObject != null ? this.boundingObject : this.ctx.scene;
			obj.iterVisibleMeshes(function(m) {
				if(m.primitive == null || !m.material.castShadows) {
					return;
				}
				var b = m.primitive.getBounds();
				if(b.xMin > b.xMax) {
					return;
				}
				var absPos = ((m.primitive) instanceof h3d_prim_Instanced) ? identity : m.getAbsPos();
				if(_gthis.autoZPlanes) {
					btmp.load(b);
					btmp.transform(absPos);
					if(btmp.zMax > zMax) {
						zMax = btmp.zMax;
					}
					if(btmp.zMin < zMin) {
						zMin = btmp.zMin;
					}
				}
				mtmp.multiply3x4(absPos,camera.mcam);
				var x = b.xMin;
				var y = b.yMin;
				var z = b.zMin;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var x1 = x;
				var y1 = y;
				var z1 = z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				var p_x = x1;
				var p_y = y1;
				var p_z = z1;
				var px = p_x * mtmp._11 + p_y * mtmp._21 + p_z * mtmp._31 + mtmp._41;
				var py = p_x * mtmp._12 + p_y * mtmp._22 + p_z * mtmp._32 + mtmp._42;
				var pz = p_x * mtmp._13 + p_y * mtmp._23 + p_z * mtmp._33 + mtmp._43;
				p_x = px;
				p_y = py;
				p_z = pz;
				if(p_x < bounds.xMin) {
					bounds.xMin = p_x;
				}
				if(p_x > bounds.xMax) {
					bounds.xMax = p_x;
				}
				if(p_y < bounds.yMin) {
					bounds.yMin = p_y;
				}
				if(p_y > bounds.yMax) {
					bounds.yMax = p_y;
				}
				if(p_z < bounds.zMin) {
					bounds.zMin = p_z;
				}
				if(p_z > bounds.zMax) {
					bounds.zMax = p_z;
				}
				var x = b.xMin;
				var y = b.yMin;
				var z = b.zMax;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var x1 = x;
				var y1 = y;
				var z1 = z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				var p_x = x1;
				var p_y = y1;
				var p_z = z1;
				var px = p_x * mtmp._11 + p_y * mtmp._21 + p_z * mtmp._31 + mtmp._41;
				var py = p_x * mtmp._12 + p_y * mtmp._22 + p_z * mtmp._32 + mtmp._42;
				var pz = p_x * mtmp._13 + p_y * mtmp._23 + p_z * mtmp._33 + mtmp._43;
				p_x = px;
				p_y = py;
				p_z = pz;
				if(p_x < bounds.xMin) {
					bounds.xMin = p_x;
				}
				if(p_x > bounds.xMax) {
					bounds.xMax = p_x;
				}
				if(p_y < bounds.yMin) {
					bounds.yMin = p_y;
				}
				if(p_y > bounds.yMax) {
					bounds.yMax = p_y;
				}
				if(p_z < bounds.zMin) {
					bounds.zMin = p_z;
				}
				if(p_z > bounds.zMax) {
					bounds.zMax = p_z;
				}
				var x = b.xMin;
				var y = b.yMax;
				var z = b.zMin;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var x1 = x;
				var y1 = y;
				var z1 = z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				var p_x = x1;
				var p_y = y1;
				var p_z = z1;
				var px = p_x * mtmp._11 + p_y * mtmp._21 + p_z * mtmp._31 + mtmp._41;
				var py = p_x * mtmp._12 + p_y * mtmp._22 + p_z * mtmp._32 + mtmp._42;
				var pz = p_x * mtmp._13 + p_y * mtmp._23 + p_z * mtmp._33 + mtmp._43;
				p_x = px;
				p_y = py;
				p_z = pz;
				if(p_x < bounds.xMin) {
					bounds.xMin = p_x;
				}
				if(p_x > bounds.xMax) {
					bounds.xMax = p_x;
				}
				if(p_y < bounds.yMin) {
					bounds.yMin = p_y;
				}
				if(p_y > bounds.yMax) {
					bounds.yMax = p_y;
				}
				if(p_z < bounds.zMin) {
					bounds.zMin = p_z;
				}
				if(p_z > bounds.zMax) {
					bounds.zMax = p_z;
				}
				var x = b.xMin;
				var y = b.yMax;
				var z = b.zMax;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var x1 = x;
				var y1 = y;
				var z1 = z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				var p_x = x1;
				var p_y = y1;
				var p_z = z1;
				var px = p_x * mtmp._11 + p_y * mtmp._21 + p_z * mtmp._31 + mtmp._41;
				var py = p_x * mtmp._12 + p_y * mtmp._22 + p_z * mtmp._32 + mtmp._42;
				var pz = p_x * mtmp._13 + p_y * mtmp._23 + p_z * mtmp._33 + mtmp._43;
				p_x = px;
				p_y = py;
				p_z = pz;
				if(p_x < bounds.xMin) {
					bounds.xMin = p_x;
				}
				if(p_x > bounds.xMax) {
					bounds.xMax = p_x;
				}
				if(p_y < bounds.yMin) {
					bounds.yMin = p_y;
				}
				if(p_y > bounds.yMax) {
					bounds.yMax = p_y;
				}
				if(p_z < bounds.zMin) {
					bounds.zMin = p_z;
				}
				if(p_z > bounds.zMax) {
					bounds.zMax = p_z;
				}
				var x = b.xMax;
				var y = b.yMin;
				var z = b.zMin;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var x1 = x;
				var y1 = y;
				var z1 = z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				var p_x = x1;
				var p_y = y1;
				var p_z = z1;
				var px = p_x * mtmp._11 + p_y * mtmp._21 + p_z * mtmp._31 + mtmp._41;
				var py = p_x * mtmp._12 + p_y * mtmp._22 + p_z * mtmp._32 + mtmp._42;
				var pz = p_x * mtmp._13 + p_y * mtmp._23 + p_z * mtmp._33 + mtmp._43;
				p_x = px;
				p_y = py;
				p_z = pz;
				if(p_x < bounds.xMin) {
					bounds.xMin = p_x;
				}
				if(p_x > bounds.xMax) {
					bounds.xMax = p_x;
				}
				if(p_y < bounds.yMin) {
					bounds.yMin = p_y;
				}
				if(p_y > bounds.yMax) {
					bounds.yMax = p_y;
				}
				if(p_z < bounds.zMin) {
					bounds.zMin = p_z;
				}
				if(p_z > bounds.zMax) {
					bounds.zMax = p_z;
				}
				var x = b.xMax;
				var y = b.yMin;
				var z = b.zMax;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var x1 = x;
				var y1 = y;
				var z1 = z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				var p_x = x1;
				var p_y = y1;
				var p_z = z1;
				var px = p_x * mtmp._11 + p_y * mtmp._21 + p_z * mtmp._31 + mtmp._41;
				var py = p_x * mtmp._12 + p_y * mtmp._22 + p_z * mtmp._32 + mtmp._42;
				var pz = p_x * mtmp._13 + p_y * mtmp._23 + p_z * mtmp._33 + mtmp._43;
				p_x = px;
				p_y = py;
				p_z = pz;
				if(p_x < bounds.xMin) {
					bounds.xMin = p_x;
				}
				if(p_x > bounds.xMax) {
					bounds.xMax = p_x;
				}
				if(p_y < bounds.yMin) {
					bounds.yMin = p_y;
				}
				if(p_y > bounds.yMax) {
					bounds.yMax = p_y;
				}
				if(p_z < bounds.zMin) {
					bounds.zMin = p_z;
				}
				if(p_z > bounds.zMax) {
					bounds.zMax = p_z;
				}
				var x = b.xMax;
				var y = b.yMax;
				var z = b.zMin;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var x1 = x;
				var y1 = y;
				var z1 = z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				var p_x = x1;
				var p_y = y1;
				var p_z = z1;
				var px = p_x * mtmp._11 + p_y * mtmp._21 + p_z * mtmp._31 + mtmp._41;
				var py = p_x * mtmp._12 + p_y * mtmp._22 + p_z * mtmp._32 + mtmp._42;
				var pz = p_x * mtmp._13 + p_y * mtmp._23 + p_z * mtmp._33 + mtmp._43;
				p_x = px;
				p_y = py;
				p_z = pz;
				if(p_x < bounds.xMin) {
					bounds.xMin = p_x;
				}
				if(p_x > bounds.xMax) {
					bounds.xMax = p_x;
				}
				if(p_y < bounds.yMin) {
					bounds.yMin = p_y;
				}
				if(p_y > bounds.yMax) {
					bounds.yMax = p_y;
				}
				if(p_z < bounds.zMin) {
					bounds.zMin = p_z;
				}
				if(p_z > bounds.zMax) {
					bounds.zMax = p_z;
				}
				var x = b.xMax;
				var y = b.yMax;
				var z = b.zMax;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var x1 = x;
				var y1 = y;
				var z1 = z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				var p_x = x1;
				var p_y = y1;
				var p_z = z1;
				var px = p_x * mtmp._11 + p_y * mtmp._21 + p_z * mtmp._31 + mtmp._41;
				var py = p_x * mtmp._12 + p_y * mtmp._22 + p_z * mtmp._32 + mtmp._42;
				var pz = p_x * mtmp._13 + p_y * mtmp._23 + p_z * mtmp._33 + mtmp._43;
				p_x = px;
				p_y = py;
				p_z = pz;
				if(p_x < bounds.xMin) {
					bounds.xMin = p_x;
				}
				if(p_x > bounds.xMax) {
					bounds.xMax = p_x;
				}
				if(p_y < bounds.yMin) {
					bounds.yMin = p_y;
				}
				if(p_y > bounds.yMax) {
					bounds.yMax = p_y;
				}
				if(p_z < bounds.zMin) {
					bounds.zMin = p_z;
				}
				if(p_z > bounds.zMax) {
					bounds.zMax = p_z;
				}
			});
		} else if(this.mode == h3d_pass_RenderMode.Dynamic) {
			bounds.xMin = -1e20;
			bounds.xMax = 1e20;
			bounds.yMin = -1e20;
			bounds.yMax = 1e20;
			bounds.zMin = -1e20;
			bounds.zMax = 1e20;
		}
		if(this.mode == h3d_pass_RenderMode.Dynamic) {
			var cameraBounds = new h3d_col_Bounds();
			var minDist = this.minDist < 0 ? this.ctx.camera.zNear : this.minDist;
			var maxDist = this.maxDist < 0 ? this.ctx.camera.zFar : this.maxDist;
			var dist = minDist;
			var this1 = _gthis.ctx.camera.unproject(-1,-1,_gthis.ctx.camera.distanceToDepth(dist));
			var x = this1.x;
			var y = this1.y;
			var z = this1.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var _this_x = x1;
			var _this_y = y1;
			var _this_z = z1;
			if(_gthis.autoShrink && _gthis.autoZPlanes) {
				var this1 = _gthis.ctx.camera.pos;
				var x = this1.x;
				var y = this1.y;
				var z = this1.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var x1 = x;
				var y1 = y;
				var z1 = z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				var p1_x = x1;
				var p1_y = y1;
				var p1_z = z1;
				var r = new h3d_col_Ray();
				r.px = p1_x;
				r.py = p1_y;
				r.pz = p1_z;
				r.lx = _this_x - p1_x;
				r.ly = _this_y - p1_y;
				r.lz = _this_z - p1_z;
				r.normalize();
				var r1 = r;
				var v = zMax;
				if(v == null) {
					v = 0.0;
				}
				var p_nx = 0;
				var p_ny = 0;
				var p_nz = 1;
				var p_d = v;
				var d = r1.lx * p_nx + r1.ly * p_ny + r1.lz * p_nz;
				var nd = p_d - (r1.px * p_nx + r1.py * p_ny + r1.pz * p_nz);
				var d2 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
				var k = 1;
				if(d2 > 0 && d2 * k > dist * k) {
					var x = r1.px + d2 * r1.lx;
					var y = r1.py + d2 * r1.ly;
					var z = r1.pz + d2 * r1.lz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var v_x = x1;
					var v_y = y1;
					var v_z = z1;
					_this_x = v_x;
					_this_y = v_y;
					_this_z = v_z;
				}
			}
			var m = camera.mcam;
			var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31 + m._41;
			var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32 + m._42;
			var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33 + m._43;
			_this_x = px;
			_this_y = py;
			_this_z = pz;
			var x = _this_x;
			var y = _this_y;
			var z = _this_z;
			if(x < cameraBounds.xMin) {
				cameraBounds.xMin = x;
			}
			if(x > cameraBounds.xMax) {
				cameraBounds.xMax = x;
			}
			if(y < cameraBounds.yMin) {
				cameraBounds.yMin = y;
			}
			if(y > cameraBounds.yMax) {
				cameraBounds.yMax = y;
			}
			if(z < cameraBounds.zMin) {
				cameraBounds.zMin = z;
			}
			if(z > cameraBounds.zMax) {
				cameraBounds.zMax = z;
			}
			var dist = minDist;
			var this1 = _gthis.ctx.camera.unproject(-1,1,_gthis.ctx.camera.distanceToDepth(dist));
			var x = this1.x;
			var y = this1.y;
			var z = this1.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var _this_x = x1;
			var _this_y = y1;
			var _this_z = z1;
			if(_gthis.autoShrink && _gthis.autoZPlanes) {
				var this1 = _gthis.ctx.camera.pos;
				var x = this1.x;
				var y = this1.y;
				var z = this1.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var x1 = x;
				var y1 = y;
				var z1 = z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				var p1_x = x1;
				var p1_y = y1;
				var p1_z = z1;
				var r = new h3d_col_Ray();
				r.px = p1_x;
				r.py = p1_y;
				r.pz = p1_z;
				r.lx = _this_x - p1_x;
				r.ly = _this_y - p1_y;
				r.lz = _this_z - p1_z;
				r.normalize();
				var r1 = r;
				var v = zMax;
				if(v == null) {
					v = 0.0;
				}
				var p_nx = 0;
				var p_ny = 0;
				var p_nz = 1;
				var p_d = v;
				var d = r1.lx * p_nx + r1.ly * p_ny + r1.lz * p_nz;
				var nd = p_d - (r1.px * p_nx + r1.py * p_ny + r1.pz * p_nz);
				var d2 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
				var k = 1;
				if(d2 > 0 && d2 * k > dist * k) {
					var x = r1.px + d2 * r1.lx;
					var y = r1.py + d2 * r1.ly;
					var z = r1.pz + d2 * r1.lz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var v_x = x1;
					var v_y = y1;
					var v_z = z1;
					_this_x = v_x;
					_this_y = v_y;
					_this_z = v_z;
				}
			}
			var m = camera.mcam;
			var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31 + m._41;
			var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32 + m._42;
			var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33 + m._43;
			_this_x = px;
			_this_y = py;
			_this_z = pz;
			var x = _this_x;
			var y = _this_y;
			var z = _this_z;
			if(x < cameraBounds.xMin) {
				cameraBounds.xMin = x;
			}
			if(x > cameraBounds.xMax) {
				cameraBounds.xMax = x;
			}
			if(y < cameraBounds.yMin) {
				cameraBounds.yMin = y;
			}
			if(y > cameraBounds.yMax) {
				cameraBounds.yMax = y;
			}
			if(z < cameraBounds.zMin) {
				cameraBounds.zMin = z;
			}
			if(z > cameraBounds.zMax) {
				cameraBounds.zMax = z;
			}
			var dist = minDist;
			var this1 = _gthis.ctx.camera.unproject(1,-1,_gthis.ctx.camera.distanceToDepth(dist));
			var x = this1.x;
			var y = this1.y;
			var z = this1.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var _this_x = x1;
			var _this_y = y1;
			var _this_z = z1;
			if(_gthis.autoShrink && _gthis.autoZPlanes) {
				var this1 = _gthis.ctx.camera.pos;
				var x = this1.x;
				var y = this1.y;
				var z = this1.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var x1 = x;
				var y1 = y;
				var z1 = z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				var p1_x = x1;
				var p1_y = y1;
				var p1_z = z1;
				var r = new h3d_col_Ray();
				r.px = p1_x;
				r.py = p1_y;
				r.pz = p1_z;
				r.lx = _this_x - p1_x;
				r.ly = _this_y - p1_y;
				r.lz = _this_z - p1_z;
				r.normalize();
				var r1 = r;
				var v = zMax;
				if(v == null) {
					v = 0.0;
				}
				var p_nx = 0;
				var p_ny = 0;
				var p_nz = 1;
				var p_d = v;
				var d = r1.lx * p_nx + r1.ly * p_ny + r1.lz * p_nz;
				var nd = p_d - (r1.px * p_nx + r1.py * p_ny + r1.pz * p_nz);
				var d2 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
				var k = 1;
				if(d2 > 0 && d2 * k > dist * k) {
					var x = r1.px + d2 * r1.lx;
					var y = r1.py + d2 * r1.ly;
					var z = r1.pz + d2 * r1.lz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var v_x = x1;
					var v_y = y1;
					var v_z = z1;
					_this_x = v_x;
					_this_y = v_y;
					_this_z = v_z;
				}
			}
			var m = camera.mcam;
			var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31 + m._41;
			var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32 + m._42;
			var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33 + m._43;
			_this_x = px;
			_this_y = py;
			_this_z = pz;
			var x = _this_x;
			var y = _this_y;
			var z = _this_z;
			if(x < cameraBounds.xMin) {
				cameraBounds.xMin = x;
			}
			if(x > cameraBounds.xMax) {
				cameraBounds.xMax = x;
			}
			if(y < cameraBounds.yMin) {
				cameraBounds.yMin = y;
			}
			if(y > cameraBounds.yMax) {
				cameraBounds.yMax = y;
			}
			if(z < cameraBounds.zMin) {
				cameraBounds.zMin = z;
			}
			if(z > cameraBounds.zMax) {
				cameraBounds.zMax = z;
			}
			var dist = minDist;
			var this1 = _gthis.ctx.camera.unproject(1,1,_gthis.ctx.camera.distanceToDepth(dist));
			var x = this1.x;
			var y = this1.y;
			var z = this1.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var _this_x = x1;
			var _this_y = y1;
			var _this_z = z1;
			if(_gthis.autoShrink && _gthis.autoZPlanes) {
				var this1 = _gthis.ctx.camera.pos;
				var x = this1.x;
				var y = this1.y;
				var z = this1.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var x1 = x;
				var y1 = y;
				var z1 = z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				var p1_x = x1;
				var p1_y = y1;
				var p1_z = z1;
				var r = new h3d_col_Ray();
				r.px = p1_x;
				r.py = p1_y;
				r.pz = p1_z;
				r.lx = _this_x - p1_x;
				r.ly = _this_y - p1_y;
				r.lz = _this_z - p1_z;
				r.normalize();
				var r1 = r;
				var v = zMax;
				if(v == null) {
					v = 0.0;
				}
				var p_nx = 0;
				var p_ny = 0;
				var p_nz = 1;
				var p_d = v;
				var d = r1.lx * p_nx + r1.ly * p_ny + r1.lz * p_nz;
				var nd = p_d - (r1.px * p_nx + r1.py * p_ny + r1.pz * p_nz);
				var d2 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
				var k = 1;
				if(d2 > 0 && d2 * k > dist * k) {
					var x = r1.px + d2 * r1.lx;
					var y = r1.py + d2 * r1.ly;
					var z = r1.pz + d2 * r1.lz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var v_x = x1;
					var v_y = y1;
					var v_z = z1;
					_this_x = v_x;
					_this_y = v_y;
					_this_z = v_z;
				}
			}
			var m = camera.mcam;
			var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31 + m._41;
			var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32 + m._42;
			var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33 + m._43;
			_this_x = px;
			_this_y = py;
			_this_z = pz;
			var x = _this_x;
			var y = _this_y;
			var z = _this_z;
			if(x < cameraBounds.xMin) {
				cameraBounds.xMin = x;
			}
			if(x > cameraBounds.xMax) {
				cameraBounds.xMax = x;
			}
			if(y < cameraBounds.yMin) {
				cameraBounds.yMin = y;
			}
			if(y > cameraBounds.yMax) {
				cameraBounds.yMax = y;
			}
			if(z < cameraBounds.zMin) {
				cameraBounds.zMin = z;
			}
			if(z > cameraBounds.zMax) {
				cameraBounds.zMax = z;
			}
			var dist = maxDist;
			var this1 = _gthis.ctx.camera.unproject(-1,-1,_gthis.ctx.camera.distanceToDepth(dist));
			var x = this1.x;
			var y = this1.y;
			var z = this1.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var _this_x = x1;
			var _this_y = y1;
			var _this_z = z1;
			if(_gthis.autoShrink && _gthis.autoZPlanes) {
				var this1 = _gthis.ctx.camera.pos;
				var x = this1.x;
				var y = this1.y;
				var z = this1.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var x1 = x;
				var y1 = y;
				var z1 = z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				var p1_x = x1;
				var p1_y = y1;
				var p1_z = z1;
				var r = new h3d_col_Ray();
				r.px = p1_x;
				r.py = p1_y;
				r.pz = p1_z;
				r.lx = _this_x - p1_x;
				r.ly = _this_y - p1_y;
				r.lz = _this_z - p1_z;
				r.normalize();
				var r1 = r;
				var v = zMin;
				if(v == null) {
					v = 0.0;
				}
				var p_nx = 0;
				var p_ny = 0;
				var p_nz = 1;
				var p_d = v;
				var d = r1.lx * p_nx + r1.ly * p_ny + r1.lz * p_nz;
				var nd = p_d - (r1.px * p_nx + r1.py * p_ny + r1.pz * p_nz);
				var d2 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
				var k = -1;
				if(d2 > 0 && d2 * k > dist * k) {
					var x = r1.px + d2 * r1.lx;
					var y = r1.py + d2 * r1.ly;
					var z = r1.pz + d2 * r1.lz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var v_x = x1;
					var v_y = y1;
					var v_z = z1;
					_this_x = v_x;
					_this_y = v_y;
					_this_z = v_z;
				}
			}
			var m = camera.mcam;
			var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31 + m._41;
			var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32 + m._42;
			var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33 + m._43;
			_this_x = px;
			_this_y = py;
			_this_z = pz;
			var x = _this_x;
			var y = _this_y;
			var z = _this_z;
			if(x < cameraBounds.xMin) {
				cameraBounds.xMin = x;
			}
			if(x > cameraBounds.xMax) {
				cameraBounds.xMax = x;
			}
			if(y < cameraBounds.yMin) {
				cameraBounds.yMin = y;
			}
			if(y > cameraBounds.yMax) {
				cameraBounds.yMax = y;
			}
			if(z < cameraBounds.zMin) {
				cameraBounds.zMin = z;
			}
			if(z > cameraBounds.zMax) {
				cameraBounds.zMax = z;
			}
			var dist = maxDist;
			var this1 = _gthis.ctx.camera.unproject(-1,1,_gthis.ctx.camera.distanceToDepth(dist));
			var x = this1.x;
			var y = this1.y;
			var z = this1.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var _this_x = x1;
			var _this_y = y1;
			var _this_z = z1;
			if(_gthis.autoShrink && _gthis.autoZPlanes) {
				var this1 = _gthis.ctx.camera.pos;
				var x = this1.x;
				var y = this1.y;
				var z = this1.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var x1 = x;
				var y1 = y;
				var z1 = z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				var p1_x = x1;
				var p1_y = y1;
				var p1_z = z1;
				var r = new h3d_col_Ray();
				r.px = p1_x;
				r.py = p1_y;
				r.pz = p1_z;
				r.lx = _this_x - p1_x;
				r.ly = _this_y - p1_y;
				r.lz = _this_z - p1_z;
				r.normalize();
				var r1 = r;
				var v = zMin;
				if(v == null) {
					v = 0.0;
				}
				var p_nx = 0;
				var p_ny = 0;
				var p_nz = 1;
				var p_d = v;
				var d = r1.lx * p_nx + r1.ly * p_ny + r1.lz * p_nz;
				var nd = p_d - (r1.px * p_nx + r1.py * p_ny + r1.pz * p_nz);
				var d2 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
				var k = -1;
				if(d2 > 0 && d2 * k > dist * k) {
					var x = r1.px + d2 * r1.lx;
					var y = r1.py + d2 * r1.ly;
					var z = r1.pz + d2 * r1.lz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var v_x = x1;
					var v_y = y1;
					var v_z = z1;
					_this_x = v_x;
					_this_y = v_y;
					_this_z = v_z;
				}
			}
			var m = camera.mcam;
			var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31 + m._41;
			var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32 + m._42;
			var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33 + m._43;
			_this_x = px;
			_this_y = py;
			_this_z = pz;
			var x = _this_x;
			var y = _this_y;
			var z = _this_z;
			if(x < cameraBounds.xMin) {
				cameraBounds.xMin = x;
			}
			if(x > cameraBounds.xMax) {
				cameraBounds.xMax = x;
			}
			if(y < cameraBounds.yMin) {
				cameraBounds.yMin = y;
			}
			if(y > cameraBounds.yMax) {
				cameraBounds.yMax = y;
			}
			if(z < cameraBounds.zMin) {
				cameraBounds.zMin = z;
			}
			if(z > cameraBounds.zMax) {
				cameraBounds.zMax = z;
			}
			var dist = maxDist;
			var this1 = _gthis.ctx.camera.unproject(1,-1,_gthis.ctx.camera.distanceToDepth(dist));
			var x = this1.x;
			var y = this1.y;
			var z = this1.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var _this_x = x1;
			var _this_y = y1;
			var _this_z = z1;
			if(_gthis.autoShrink && _gthis.autoZPlanes) {
				var this1 = _gthis.ctx.camera.pos;
				var x = this1.x;
				var y = this1.y;
				var z = this1.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var x1 = x;
				var y1 = y;
				var z1 = z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				var p1_x = x1;
				var p1_y = y1;
				var p1_z = z1;
				var r = new h3d_col_Ray();
				r.px = p1_x;
				r.py = p1_y;
				r.pz = p1_z;
				r.lx = _this_x - p1_x;
				r.ly = _this_y - p1_y;
				r.lz = _this_z - p1_z;
				r.normalize();
				var r1 = r;
				var v = zMin;
				if(v == null) {
					v = 0.0;
				}
				var p_nx = 0;
				var p_ny = 0;
				var p_nz = 1;
				var p_d = v;
				var d = r1.lx * p_nx + r1.ly * p_ny + r1.lz * p_nz;
				var nd = p_d - (r1.px * p_nx + r1.py * p_ny + r1.pz * p_nz);
				var d2 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
				var k = -1;
				if(d2 > 0 && d2 * k > dist * k) {
					var x = r1.px + d2 * r1.lx;
					var y = r1.py + d2 * r1.ly;
					var z = r1.pz + d2 * r1.lz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var v_x = x1;
					var v_y = y1;
					var v_z = z1;
					_this_x = v_x;
					_this_y = v_y;
					_this_z = v_z;
				}
			}
			var m = camera.mcam;
			var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31 + m._41;
			var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32 + m._42;
			var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33 + m._43;
			_this_x = px;
			_this_y = py;
			_this_z = pz;
			var x = _this_x;
			var y = _this_y;
			var z = _this_z;
			if(x < cameraBounds.xMin) {
				cameraBounds.xMin = x;
			}
			if(x > cameraBounds.xMax) {
				cameraBounds.xMax = x;
			}
			if(y < cameraBounds.yMin) {
				cameraBounds.yMin = y;
			}
			if(y > cameraBounds.yMax) {
				cameraBounds.yMax = y;
			}
			if(z < cameraBounds.zMin) {
				cameraBounds.zMin = z;
			}
			if(z > cameraBounds.zMax) {
				cameraBounds.zMax = z;
			}
			var dist = maxDist;
			var this1 = _gthis.ctx.camera.unproject(1,1,_gthis.ctx.camera.distanceToDepth(dist));
			var x = this1.x;
			var y = this1.y;
			var z = this1.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var _this_x = x1;
			var _this_y = y1;
			var _this_z = z1;
			if(_gthis.autoShrink && _gthis.autoZPlanes) {
				var this1 = _gthis.ctx.camera.pos;
				var x = this1.x;
				var y = this1.y;
				var z = this1.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var x1 = x;
				var y1 = y;
				var z1 = z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				var p1_x = x1;
				var p1_y = y1;
				var p1_z = z1;
				var r = new h3d_col_Ray();
				r.px = p1_x;
				r.py = p1_y;
				r.pz = p1_z;
				r.lx = _this_x - p1_x;
				r.ly = _this_y - p1_y;
				r.lz = _this_z - p1_z;
				r.normalize();
				var r1 = r;
				var v = zMin;
				if(v == null) {
					v = 0.0;
				}
				var p_nx = 0;
				var p_ny = 0;
				var p_nz = 1;
				var p_d = v;
				var d = r1.lx * p_nx + r1.ly * p_ny + r1.lz * p_nz;
				var nd = p_d - (r1.px * p_nx + r1.py * p_ny + r1.pz * p_nz);
				var d2 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
				var k = -1;
				if(d2 > 0 && d2 * k > dist * k) {
					var x = r1.px + d2 * r1.lx;
					var y = r1.py + d2 * r1.ly;
					var z = r1.pz + d2 * r1.lz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var v_x = x1;
					var v_y = y1;
					var v_z = z1;
					_this_x = v_x;
					_this_y = v_y;
					_this_z = v_z;
				}
			}
			var m = camera.mcam;
			var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31 + m._41;
			var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32 + m._42;
			var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33 + m._43;
			_this_x = px;
			_this_y = py;
			_this_z = pz;
			var x = _this_x;
			var y = _this_y;
			var z = _this_z;
			if(x < cameraBounds.xMin) {
				cameraBounds.xMin = x;
			}
			if(x > cameraBounds.xMax) {
				cameraBounds.xMax = x;
			}
			if(y < cameraBounds.yMin) {
				cameraBounds.yMin = y;
			}
			if(y > cameraBounds.yMax) {
				cameraBounds.yMax = y;
			}
			if(z < cameraBounds.zMin) {
				cameraBounds.zMin = z;
			}
			if(z > cameraBounds.zMax) {
				cameraBounds.zMax = z;
			}
			if(this.autoShrink) {
				cameraBounds.zMin = bounds.zMin;
				bounds.intersection(bounds,cameraBounds);
				if(this.autoZPlanes) {
					var this1 = camera.target;
					var v = camera.pos;
					var x = this1.x - v.x;
					var y = this1.y - v.y;
					var z = this1.z - v.z;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var _this_x = x1;
					var _this_y = y1;
					var _this_z = z1;
					var k = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
					if(k < 1e-20) {
						k = 0;
					} else {
						k = 1. / Math.sqrt(k);
					}
					var x = _this_x * k;
					var y = _this_y * k;
					var z = _this_z * k;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var v_x = x1;
					var v_y = y1;
					var v_z = z1;
					var dMin = 1e9;
					var px = bounds.xMin;
					var py = bounds.yMin;
					var x = px;
					var y = py;
					var z = bounds.zMin;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var this_x = x1;
					var this_y = y1;
					var this_z = z1;
					var m = camera.getInverseView();
					var px = this_x * m._11 + this_y * m._21 + this_z * m._31 + m._41;
					var py = this_x * m._12 + this_y * m._22 + this_z * m._32 + m._42;
					var pz = this_x * m._13 + this_y * m._23 + this_z * m._33 + m._43;
					var x = px;
					var y = py;
					var z = pz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var r0_x = x1;
					var r0_y = y1;
					var r0_z = z1;
					var r = new h3d_col_Ray();
					r.px = r0_x;
					r.py = r0_y;
					r.pz = r0_z;
					r.lx = v_x;
					r.ly = v_y;
					r.lz = v_z;
					r.normalize();
					var r1 = r;
					var v = zMax;
					if(v == null) {
						v = 0.0;
					}
					var p_nx = 0;
					var p_ny = 0;
					var p_nz = 1;
					var p_d = v;
					var d = r1.lx * p_nx + r1.ly * p_ny + r1.lz * p_nz;
					var nd = p_d - (r1.px * p_nx + r1.py * p_ny + r1.pz * p_nz);
					var d1 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
					if(d1 < dMin) {
						dMin = d1;
					}
					var px = bounds.xMin;
					var py = bounds.yMax;
					var x = px;
					var y = py;
					var z = bounds.zMin;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var this_x = x1;
					var this_y = y1;
					var this_z = z1;
					var m = camera.getInverseView();
					var px = this_x * m._11 + this_y * m._21 + this_z * m._31 + m._41;
					var py = this_x * m._12 + this_y * m._22 + this_z * m._32 + m._42;
					var pz = this_x * m._13 + this_y * m._23 + this_z * m._33 + m._43;
					var x = px;
					var y = py;
					var z = pz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var r0_x = x1;
					var r0_y = y1;
					var r0_z = z1;
					var r = new h3d_col_Ray();
					r.px = r0_x;
					r.py = r0_y;
					r.pz = r0_z;
					r.lx = v_x;
					r.ly = v_y;
					r.lz = v_z;
					r.normalize();
					var r1 = r;
					var v = zMax;
					if(v == null) {
						v = 0.0;
					}
					var p_nx = 0;
					var p_ny = 0;
					var p_nz = 1;
					var p_d = v;
					var d = r1.lx * p_nx + r1.ly * p_ny + r1.lz * p_nz;
					var nd = p_d - (r1.px * p_nx + r1.py * p_ny + r1.pz * p_nz);
					var d1 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
					if(d1 < dMin) {
						dMin = d1;
					}
					var px = bounds.xMax;
					var py = bounds.yMin;
					var x = px;
					var y = py;
					var z = bounds.zMin;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var this_x = x1;
					var this_y = y1;
					var this_z = z1;
					var m = camera.getInverseView();
					var px = this_x * m._11 + this_y * m._21 + this_z * m._31 + m._41;
					var py = this_x * m._12 + this_y * m._22 + this_z * m._32 + m._42;
					var pz = this_x * m._13 + this_y * m._23 + this_z * m._33 + m._43;
					var x = px;
					var y = py;
					var z = pz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var r0_x = x1;
					var r0_y = y1;
					var r0_z = z1;
					var r = new h3d_col_Ray();
					r.px = r0_x;
					r.py = r0_y;
					r.pz = r0_z;
					r.lx = v_x;
					r.ly = v_y;
					r.lz = v_z;
					r.normalize();
					var r1 = r;
					var v = zMax;
					if(v == null) {
						v = 0.0;
					}
					var p_nx = 0;
					var p_ny = 0;
					var p_nz = 1;
					var p_d = v;
					var d = r1.lx * p_nx + r1.ly * p_ny + r1.lz * p_nz;
					var nd = p_d - (r1.px * p_nx + r1.py * p_ny + r1.pz * p_nz);
					var d1 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
					if(d1 < dMin) {
						dMin = d1;
					}
					var px = bounds.xMax;
					var py = bounds.yMax;
					var x = px;
					var y = py;
					var z = bounds.zMin;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var this_x = x1;
					var this_y = y1;
					var this_z = z1;
					var m = camera.getInverseView();
					var px = this_x * m._11 + this_y * m._21 + this_z * m._31 + m._41;
					var py = this_x * m._12 + this_y * m._22 + this_z * m._32 + m._42;
					var pz = this_x * m._13 + this_y * m._23 + this_z * m._33 + m._43;
					var x = px;
					var y = py;
					var z = pz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var r0_x = x1;
					var r0_y = y1;
					var r0_z = z1;
					var r = new h3d_col_Ray();
					r.px = r0_x;
					r.py = r0_y;
					r.pz = r0_z;
					r.lx = v_x;
					r.ly = v_y;
					r.lz = v_z;
					r.normalize();
					var r1 = r;
					var v = zMax;
					if(v == null) {
						v = 0.0;
					}
					var p_nx = 0;
					var p_ny = 0;
					var p_nz = 1;
					var p_d = v;
					var d = r1.lx * p_nx + r1.ly * p_ny + r1.lz * p_nz;
					var nd = p_d - (r1.px * p_nx + r1.py * p_ny + r1.pz * p_nz);
					var d1 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
					if(d1 < dMin) {
						dMin = d1;
					}
					bounds.zMin += dMin;
				}
			} else {
				bounds.load(cameraBounds);
			}
		}
		bounds.scaleCenter(1.01);
	}
	,syncShader: function(texture) {
		var _this = this.dshader;
		_this.constModified = true;
		_this.shadowMap__ = texture;
		var _this = this.dshader;
		_this.constModified = true;
		_this.shadowMapChannel__ = this.format == h3d_mat_Texture.nativeFormat ? hxsl_Channel.PackedFloat : hxsl_Channel.R;
		this.dshader.shadowBias__ = this.bias;
		this.dshader.shadowPower__ = this.power;
		this.dshader.shadowProj__ = this.getShadowProj();
		var _this = this.dshader;
		_this.constModified = true;
		_this.USE_ESM__ = this.samplingKind == h3d_pass_ShadowSamplingKind.ESM;
		this.dshader.shadowPower__ = this.power;
		var _this = this.dshader;
		_this.constModified = true;
		_this.USE_PCF__ = this.samplingKind == h3d_pass_ShadowSamplingKind.PCF;
		var _this = this.dshader.shadowRes__;
		var x = texture.width;
		var y = texture.height;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = 0.;
		this.dshader.pcfScale__ = this.pcfScale;
		this.dshader.set_pcfQuality(this.pcfQuality);
	}
	,saveStaticData: function() {
		if(this.mode != h3d_pass_RenderMode.Mixed && this.mode != h3d_pass_RenderMode.Static) {
			return null;
		}
		if(this.staticTexture == null) {
			throw haxe_Exception.thrown("Data not computed");
		}
		var bytes = haxe_zip_Compress.run(this.staticTexture.capturePixels().bytes,9);
		var buffer = new haxe_io_BytesBuffer();
		buffer.addInt32(this.staticTexture.width);
		buffer.addFloat(this.lightCamera.pos.x);
		buffer.addFloat(this.lightCamera.pos.y);
		buffer.addFloat(this.lightCamera.pos.z);
		buffer.addFloat(this.lightCamera.target.x);
		buffer.addFloat(this.lightCamera.target.y);
		buffer.addFloat(this.lightCamera.target.z);
		buffer.addFloat(this.lightCamera.orthoBounds.xMin);
		buffer.addFloat(this.lightCamera.orthoBounds.yMin);
		buffer.addFloat(this.lightCamera.orthoBounds.zMin);
		buffer.addFloat(this.lightCamera.orthoBounds.xMax);
		buffer.addFloat(this.lightCamera.orthoBounds.yMax);
		buffer.addFloat(this.lightCamera.orthoBounds.zMax);
		buffer.addInt32(bytes.length);
		buffer.add(bytes);
		return buffer.getBytes();
	}
	,loadStaticData: function(bytes) {
		if(this.mode != h3d_pass_RenderMode.Mixed && this.mode != h3d_pass_RenderMode.Static || bytes == null) {
			return false;
		}
		var buffer = new haxe_io_BytesInput(bytes);
		var size = buffer.readInt32();
		if(size != this.size) {
			return false;
		}
		this.lightCamera.pos.x = buffer.readFloat();
		this.lightCamera.pos.y = buffer.readFloat();
		this.lightCamera.pos.z = buffer.readFloat();
		this.lightCamera.target.x = buffer.readFloat();
		this.lightCamera.target.y = buffer.readFloat();
		this.lightCamera.target.z = buffer.readFloat();
		this.lightCamera.orthoBounds.xMin = buffer.readFloat();
		this.lightCamera.orthoBounds.yMin = buffer.readFloat();
		this.lightCamera.orthoBounds.zMin = buffer.readFloat();
		this.lightCamera.orthoBounds.xMax = buffer.readFloat();
		this.lightCamera.orthoBounds.yMax = buffer.readFloat();
		this.lightCamera.orthoBounds.zMax = buffer.readFloat();
		this.lightCamera.update();
		var len = buffer.readInt32();
		var pixels = new hxd_Pixels(size,size,haxe_zip_Uncompress.run(buffer.read(len)),this.format);
		if(this.staticTexture != null) {
			this.staticTexture.dispose();
		}
		this.staticTexture = new h3d_mat_Texture(size,size,[h3d_mat_TextureFlags.Target],this.format);
		this.staticTexture.uploadPixels(pixels);
		this.staticTexture.name = "staticTexture";
		this.staticTexture.preventAutoDispose();
		this.syncShader(this.staticTexture);
		return true;
	}
	,processShadowMap: function(passes,tex,sort) {
		var _this = this.ctx;
		var prevViewProj = _this.globals.map.h[_this.cameraViewProj_id];
		var _this = this.ctx;
		var v = this.getShadowProj();
		_this.globals.map.h[_this.cameraViewProj_id] = v;
		if(tex.isDepth()) {
			this.ctx.engine.pushDepth(tex);
			this.ctx.engine.clear(null,1.0);
		} else {
			this.ctx.engine.pushTarget(tex);
			this.ctx.engine.clear(16777215,1.0);
		}
		h3d_pass_Shadows.prototype.draw.call(this,passes,sort);
		var computingStatic = this.ctx.computingStatic || this.updateStatic;
		var doBlur = this.blur.radius > 0 && (this.mode != h3d_pass_RenderMode.Mixed || !computingStatic);
		if(this.border != null && !doBlur) {
			this.border.render();
		}
		this.ctx.engine.popTarget();
		var tmp;
		if(this.mode == h3d_pass_RenderMode.Mixed && !computingStatic && this.staticTexture != null) {
			var _this = this.staticTexture;
			tmp = !(_this.t == null && (_this.isDepth() || _this.realloc == null));
		} else {
			tmp = false;
		}
		if(tmp) {
			if(this.staticTexture.width != tex.width) {
				throw haxe_Exception.thrown("Static shadow map doesnt match dynamic shadow map");
			}
			var merge = this.ctx.textures.allocTarget("mergedDirShadowMap",this.size,this.size,false,this.format);
			this.mergePass.shader.texA__ = tex;
			this.mergePass.shader.texB__ = this.staticTexture;
			this.ctx.engine.pushTarget(merge);
			this.mergePass.render();
			this.ctx.engine.popTarget();
			tex = merge;
		}
		if(doBlur) {
			if(tex.isDepth()) {
				var tmp = this.ctx.textures.allocTarget("dirShadowMapFloat",this.size,this.size,false,this.format);
				h3d_pass_Copy.run(tex,tmp);
				tex = tmp;
			}
			this.blur.apply(this.ctx,tex);
			if(this.border != null) {
				this.ctx.engine.pushTarget(tex);
				this.border.render();
				this.ctx.engine.popTarget();
			}
		}
		var _this = this.ctx;
		_this.globals.map.h[_this.cameraViewProj_id] = prevViewProj;
		return tex;
	}
	,draw: function(passes,sort) {
		var _gthis = this;
		if(!this.enabled) {
			return;
		}
		if(!this.filterPasses(passes)) {
			return;
		}
		var computingStatic = this.ctx.computingStatic || this.updateStatic;
		if(this.mode != h3d_pass_RenderMode.Mixed || computingStatic) {
			var ct = this.ctx.camera.target;
			var slight = this.light == null ? this.ctx.lightSystem.shadowLight : this.light;
			var ldir = slight == null ? null : slight.getShadowDirection();
			if(ldir == null) {
				var _this = this.lightCamera.target;
				var x = 0;
				var y = 0;
				var z = -1;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				_this.x = x;
				_this.y = y;
				_this.z = z;
			} else {
				var _this = this.lightCamera.target;
				var x = ldir.x;
				var y = ldir.y;
				var z = ldir.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				_this.x = x;
				_this.y = y;
				_this.z = z;
				var _this = this.lightCamera.target;
				var k = _this.x * _this.x + _this.y * _this.y + _this.z * _this.z;
				if(k < 1e-20) {
					k = 0;
				} else {
					k = 1. / Math.sqrt(k);
				}
				_this.x *= k;
				_this.y *= k;
				_this.z *= k;
			}
			this.lightCamera.target.x += ct.x;
			this.lightCamera.target.y += ct.y;
			this.lightCamera.target.z += ct.z;
			var _this = this.lightCamera.pos;
			_this.x = ct.x;
			_this.y = ct.y;
			_this.z = ct.z;
			this.lightCamera.update();
			var _this = this.lightCamera.orthoBounds;
			_this.xMin = 1e20;
			_this.xMax = -1e20;
			_this.yMin = 1e20;
			_this.yMax = -1e20;
			_this.zMin = 1e20;
			_this.zMax = -1e20;
			if(passes.current != null) {
				this.calcShadowBounds(this.lightCamera);
			}
			this.lightCamera.update();
		}
		var f = function(col) {
			return col.inFrustum(_gthis.lightCamera.frustum);
		};
		var prevCollider = null;
		var prevResult = true;
		var head = null;
		var prev = null;
		var disc = passes.discarded;
		var discQueue = passes.lastDisc;
		var cur = passes.current;
		while(cur != null) {
			var col = cur.obj.cullingCollider;
			var tmp;
			if(col == null) {
				tmp = true;
			} else {
				if(col != prevCollider) {
					prevCollider = col;
					prevResult = f(col);
				}
				tmp = prevResult;
			}
			if(tmp) {
				if(head == null) {
					prev = cur;
					head = prev;
				} else {
					prev.next = cur;
					prev = cur;
				}
			} else if(disc == null) {
				discQueue = cur;
				disc = discQueue;
			} else {
				discQueue.next = cur;
				discQueue = cur;
			}
			cur = cur.next;
		}
		if(prev != null) {
			prev.next = null;
		}
		if(discQueue != null) {
			discQueue.next = null;
		}
		passes.current = head;
		passes.discarded = disc;
		passes.lastDisc = discQueue;
		var texture = this.ctx.textures.allocTarget("dirShadowMap",this.size,this.size,false,this.format);
		var tmp;
		if(!(this.depth == null || this.depth.width != this.size || this.depth.height != this.size)) {
			var _this = this.depth;
			tmp = _this.t == null && (_this.isDepth() || _this.realloc == null);
		} else {
			tmp = true;
		}
		if(tmp) {
			if(this.depth != null) {
				this.depth.dispose();
			}
			this.depth = new h3d_mat_Texture(this.size,this.size,null,hxd_PixelFormat.Depth24Stencil8);
			this.depth.name = "dirShadowMapDepth";
		}
		texture.depthBuffer = this.depth;
		texture = this.processShadowMap(passes,texture,sort);
		this.syncShader(texture);
		this.updateStatic = false;
	}
	,computeStatic: function(passes) {
		if(this.mode != h3d_pass_RenderMode.Static && this.mode != h3d_pass_RenderMode.Mixed) {
			return;
		}
		this.draw(passes);
		var texture = this.dshader.shadowMap__;
		var old = this.staticTexture;
		this.staticTexture = texture.clone();
		this.staticTexture.name = "StaticDirShadowMap";
		this.staticTexture.preventAutoDispose();
		var _this = this.dshader;
		_this.constModified = true;
		_this.shadowMap__ = this.staticTexture;
		if(old != null) {
			old.dispose();
		}
	}
	,drawDebug: function() {
		if(this.g == null) {
			this.g = new h3d_scene_Graphics(this.ctx.scene);
			this.g.name = "frustumDebug";
			this.g.material.passes.setPassName("overlay");
			var _this = this.g;
			var f = 512;
			_this.flags |= f;
		}
		if(!this.debug) {
			return;
		}
		this.g.clear();
		this.drawBounds(this.lightCamera.getInverseViewProj(),16777215);
	}
	,drawBounds: function(invViewModel,color) {
		var _gthis = this;
		var x = -1;
		var y = 1;
		var z = 0;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var p = new h3d_VectorImpl(x,y,z);
		var _this = p;
		var px = _this.x * invViewModel._11 + _this.y * invViewModel._21 + _this.z * invViewModel._31 + invViewModel._41;
		var py = _this.x * invViewModel._12 + _this.y * invViewModel._22 + _this.z * invViewModel._32 + invViewModel._42;
		var pz = _this.x * invViewModel._13 + _this.y * invViewModel._23 + _this.z * invViewModel._33 + invViewModel._43;
		var iw = 1 / (_this.x * invViewModel._14 + _this.y * invViewModel._24 + _this.z * invViewModel._34 + invViewModel._44);
		_this.x = px * iw;
		_this.y = py * iw;
		_this.z = pz * iw;
		var x = 1;
		var y = 1;
		var z = 0;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var p1 = new h3d_VectorImpl(x,y,z);
		var _this = p1;
		var px = _this.x * invViewModel._11 + _this.y * invViewModel._21 + _this.z * invViewModel._31 + invViewModel._41;
		var py = _this.x * invViewModel._12 + _this.y * invViewModel._22 + _this.z * invViewModel._32 + invViewModel._42;
		var pz = _this.x * invViewModel._13 + _this.y * invViewModel._23 + _this.z * invViewModel._33 + invViewModel._43;
		var iw = 1 / (_this.x * invViewModel._14 + _this.y * invViewModel._24 + _this.z * invViewModel._34 + invViewModel._44);
		_this.x = px * iw;
		_this.y = py * iw;
		_this.z = pz * iw;
		var x = 1;
		var y = -1;
		var z = 0;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var p2 = new h3d_VectorImpl(x,y,z);
		var _this = p2;
		var px = _this.x * invViewModel._11 + _this.y * invViewModel._21 + _this.z * invViewModel._31 + invViewModel._41;
		var py = _this.x * invViewModel._12 + _this.y * invViewModel._22 + _this.z * invViewModel._32 + invViewModel._42;
		var pz = _this.x * invViewModel._13 + _this.y * invViewModel._23 + _this.z * invViewModel._33 + invViewModel._43;
		var iw = 1 / (_this.x * invViewModel._14 + _this.y * invViewModel._24 + _this.z * invViewModel._34 + invViewModel._44);
		_this.x = px * iw;
		_this.y = py * iw;
		_this.z = pz * iw;
		var x = -1;
		var y = -1;
		var z = 0;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var p3 = new h3d_VectorImpl(x,y,z);
		var _this = p3;
		var px = _this.x * invViewModel._11 + _this.y * invViewModel._21 + _this.z * invViewModel._31 + invViewModel._41;
		var py = _this.x * invViewModel._12 + _this.y * invViewModel._22 + _this.z * invViewModel._32 + invViewModel._42;
		var pz = _this.x * invViewModel._13 + _this.y * invViewModel._23 + _this.z * invViewModel._33 + invViewModel._43;
		var iw = 1 / (_this.x * invViewModel._14 + _this.y * invViewModel._24 + _this.z * invViewModel._34 + invViewModel._44);
		_this.x = px * iw;
		_this.y = py * iw;
		_this.z = pz * iw;
		var nearPlaneCorner = [p,p1,p2,p3];
		var x = -1;
		var y = 1;
		var z = 1;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var p = new h3d_VectorImpl(x,y,z);
		var _this = p;
		var px = _this.x * invViewModel._11 + _this.y * invViewModel._21 + _this.z * invViewModel._31 + invViewModel._41;
		var py = _this.x * invViewModel._12 + _this.y * invViewModel._22 + _this.z * invViewModel._32 + invViewModel._42;
		var pz = _this.x * invViewModel._13 + _this.y * invViewModel._23 + _this.z * invViewModel._33 + invViewModel._43;
		var iw = 1 / (_this.x * invViewModel._14 + _this.y * invViewModel._24 + _this.z * invViewModel._34 + invViewModel._44);
		_this.x = px * iw;
		_this.y = py * iw;
		_this.z = pz * iw;
		var x = 1;
		var y = 1;
		var z = 1;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var p1 = new h3d_VectorImpl(x,y,z);
		var _this = p1;
		var px = _this.x * invViewModel._11 + _this.y * invViewModel._21 + _this.z * invViewModel._31 + invViewModel._41;
		var py = _this.x * invViewModel._12 + _this.y * invViewModel._22 + _this.z * invViewModel._32 + invViewModel._42;
		var pz = _this.x * invViewModel._13 + _this.y * invViewModel._23 + _this.z * invViewModel._33 + invViewModel._43;
		var iw = 1 / (_this.x * invViewModel._14 + _this.y * invViewModel._24 + _this.z * invViewModel._34 + invViewModel._44);
		_this.x = px * iw;
		_this.y = py * iw;
		_this.z = pz * iw;
		var x = 1;
		var y = -1;
		var z = 1;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var p2 = new h3d_VectorImpl(x,y,z);
		var _this = p2;
		var px = _this.x * invViewModel._11 + _this.y * invViewModel._21 + _this.z * invViewModel._31 + invViewModel._41;
		var py = _this.x * invViewModel._12 + _this.y * invViewModel._22 + _this.z * invViewModel._32 + invViewModel._42;
		var pz = _this.x * invViewModel._13 + _this.y * invViewModel._23 + _this.z * invViewModel._33 + invViewModel._43;
		var iw = 1 / (_this.x * invViewModel._14 + _this.y * invViewModel._24 + _this.z * invViewModel._34 + invViewModel._44);
		_this.x = px * iw;
		_this.y = py * iw;
		_this.z = pz * iw;
		var x = -1;
		var y = -1;
		var z = 1;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var p3 = new h3d_VectorImpl(x,y,z);
		var _this = p3;
		var px = _this.x * invViewModel._11 + _this.y * invViewModel._21 + _this.z * invViewModel._31 + invViewModel._41;
		var py = _this.x * invViewModel._12 + _this.y * invViewModel._22 + _this.z * invViewModel._32 + invViewModel._42;
		var pz = _this.x * invViewModel._13 + _this.y * invViewModel._23 + _this.z * invViewModel._33 + invViewModel._43;
		var iw = 1 / (_this.x * invViewModel._14 + _this.y * invViewModel._24 + _this.z * invViewModel._34 + invViewModel._44);
		_this.x = px * iw;
		_this.y = py * iw;
		_this.z = pz * iw;
		var farPlaneCorner = [p,p1,p2,p3];
		this.g.lineStyle(1,color);
		var last = nearPlaneCorner[nearPlaneCorner.length - 1];
		_gthis.g.moveTo(last.x - _gthis.ctx.scene.x,last.y - _gthis.ctx.scene.y,last.z - _gthis.ctx.scene.z);
		var _g = 0;
		while(_g < nearPlaneCorner.length) {
			var fc = nearPlaneCorner[_g];
			++_g;
			_gthis.g.lineTo(fc.x - _gthis.ctx.scene.x,fc.y - _gthis.ctx.scene.y,fc.z - _gthis.ctx.scene.z);
		}
		var last = farPlaneCorner[farPlaneCorner.length - 1];
		_gthis.g.moveTo(last.x - _gthis.ctx.scene.x,last.y - _gthis.ctx.scene.y,last.z - _gthis.ctx.scene.z);
		var _g = 0;
		while(_g < farPlaneCorner.length) {
			var fc = farPlaneCorner[_g];
			++_g;
			_gthis.g.lineTo(fc.x - _gthis.ctx.scene.x,fc.y - _gthis.ctx.scene.y,fc.z - _gthis.ctx.scene.z);
		}
		var np = nearPlaneCorner[0];
		var fp = farPlaneCorner[0];
		_gthis.g.moveTo(np.x - _gthis.ctx.scene.x,np.y - _gthis.ctx.scene.y,np.z - _gthis.ctx.scene.z);
		_gthis.g.lineTo(fp.x - _gthis.ctx.scene.x,fp.y - _gthis.ctx.scene.y,fp.z - _gthis.ctx.scene.z);
		var np = nearPlaneCorner[1];
		var fp = farPlaneCorner[1];
		_gthis.g.moveTo(np.x - _gthis.ctx.scene.x,np.y - _gthis.ctx.scene.y,np.z - _gthis.ctx.scene.z);
		_gthis.g.lineTo(fp.x - _gthis.ctx.scene.x,fp.y - _gthis.ctx.scene.y,fp.z - _gthis.ctx.scene.z);
		var np = nearPlaneCorner[2];
		var fp = farPlaneCorner[2];
		_gthis.g.moveTo(np.x - _gthis.ctx.scene.x,np.y - _gthis.ctx.scene.y,np.z - _gthis.ctx.scene.z);
		_gthis.g.lineTo(fp.x - _gthis.ctx.scene.x,fp.y - _gthis.ctx.scene.y,fp.z - _gthis.ctx.scene.z);
		var np = nearPlaneCorner[3];
		var fp = farPlaneCorner[3];
		_gthis.g.moveTo(np.x - _gthis.ctx.scene.x,np.y - _gthis.ctx.scene.y,np.z - _gthis.ctx.scene.z);
		_gthis.g.lineTo(fp.x - _gthis.ctx.scene.x,fp.y - _gthis.ctx.scene.y,fp.z - _gthis.ctx.scene.z);
	}
	,__class__: h3d_pass_DirShadowMap
});
var h3d_pass_DefaultShadowMap = function(size,format) {
	if(size == null) {
		size = 1024;
	}
	if(format != null) {
		this.format = format;
	}
	h3d_pass_DirShadowMap.call(this,null);
	this.set_size(size);
	this.color = new h3d_VectorImpl(0.,0.,0.);
	this.set_mode(h3d_pass_RenderMode.Dynamic);
	this.shadowMapId = hxsl_Globals.allocID("shadow.map");
	this.shadowProjId = hxsl_Globals.allocID("shadow.proj");
	this.shadowColorId = hxsl_Globals.allocID("shadow.color");
	this.shadowPowerId = hxsl_Globals.allocID("shadow.power");
	this.shadowBiasId = hxsl_Globals.allocID("shadow.bias");
};
$hxClasses["h3d.pass.DefaultShadowMap"] = h3d_pass_DefaultShadowMap;
h3d_pass_DefaultShadowMap.__name__ = "h3d.pass.DefaultShadowMap";
h3d_pass_DefaultShadowMap.__super__ = h3d_pass_DirShadowMap;
h3d_pass_DefaultShadowMap.prototype = $extend(h3d_pass_DirShadowMap.prototype,{
	draw: function(passes,sort) {
		h3d_pass_DirShadowMap.prototype.draw.call(this,passes,sort);
		this.ctx.globals.map.h[this.shadowMapId] = { texture : this.dshader.shadowMap__, channel : this.format == h3d_mat_Texture.nativeFormat ? hxsl_Channel.PackedFloat : hxsl_Channel.R};
		var _this = this.ctx.globals;
		var id = this.shadowProjId;
		var v = this.getShadowProj();
		_this.map.h[id] = v;
		this.ctx.globals.map.h[this.shadowColorId] = this.color;
		this.ctx.globals.map.h[this.shadowPowerId] = this.power;
		this.ctx.globals.map.h[this.shadowBiasId] = this.bias;
	}
	,__class__: h3d_pass_DefaultShadowMap
});
var h3d_pass_OutputShader = function(output) {
	this.shaderCache = hxsl_Cache.get();
	this.currentOutput = new hxsl_ShaderList(null);
	this.setOutput(output);
};
$hxClasses["h3d.pass.OutputShader"] = h3d_pass_OutputShader;
h3d_pass_OutputShader.__name__ = "h3d.pass.OutputShader";
h3d_pass_OutputShader.prototype = {
	setOutput: function(output) {
		if(output == null) {
			output = [hxsl_Output.Value("output.color")];
		}
		this.currentOutput.s = this.shaderCache.getLinkShader(output);
	}
	,compileShaders: function(globals,shaders,mode) {
		if(mode == null) {
			mode = hxsl_LinkMode.Default;
		}
		globals.maxChannels = 0;
		var _g_l = shaders;
		var _g_last = null;
		while(_g_l != _g_last) {
			var s = _g_l.s;
			_g_l = _g_l.next;
			var s1 = s;
			s1.updateConstants(globals);
		}
		this.currentOutput.next = shaders;
		var s = this.shaderCache.link(this.currentOutput,mode);
		this.currentOutput.next = null;
		return s;
	}
	,__class__: h3d_pass_OutputShader
};
var h3d_pass_PassListIterator = function(o) {
	this.o = o;
};
$hxClasses["h3d.pass.PassListIterator"] = h3d_pass_PassListIterator;
h3d_pass_PassListIterator.__name__ = "h3d.pass.PassListIterator";
h3d_pass_PassListIterator.prototype = {
	hasNext: function() {
		return this.o != null;
	}
	,next: function() {
		var tmp = this.o;
		this.o = this.o.next;
		return tmp;
	}
	,__class__: h3d_pass_PassListIterator
};
var h3d_pass_PassList = function(current) {
	this.current = current;
	this.discarded = this.lastDisc = null;
};
$hxClasses["h3d.pass.PassList"] = h3d_pass_PassList;
h3d_pass_PassList.__name__ = "h3d.pass.PassList";
h3d_pass_PassList.prototype = {
	init: function(pass) {
		this.current = pass;
		this.discarded = this.lastDisc = null;
	}
	,reset: function() {
		if(this.discarded != null) {
			this.lastDisc.next = this.current;
			this.current = this.discarded;
			this.discarded = this.lastDisc = null;
		}
	}
	,count: function() {
		var c = this.current;
		var n = 0;
		while(c != null) {
			++n;
			c = c.next;
		}
		return n;
	}
	,save: function() {
		return this.lastDisc;
	}
	,load: function(p) {
		if(this.lastDisc != p) {
			this.lastDisc.next = this.current;
			if(p == null) {
				this.current = this.discarded;
				this.discarded = null;
			} else {
				this.current = p.next;
				p.next = null;
			}
			this.lastDisc = p;
		}
	}
	,isEmpty: function() {
		return this.current == null;
	}
	,clear: function() {
		if(this.current == null) {
			return;
		}
		if(this.discarded == null) {
			this.discarded = this.current;
		} else {
			this.lastDisc.next = this.current;
		}
		var p = this.current;
		while(p.next != null) p = p.next;
		this.lastDisc = p;
		this.current = null;
	}
	,sort: function(f) {
		var list = this.current;
		var tmp;
		if(list == null) {
			tmp = null;
		} else {
			var insize = 1;
			var nmerges;
			var psize = 0;
			var qsize = 0;
			var p;
			var q;
			var e;
			var tail;
			while(true) {
				p = list;
				list = null;
				tail = null;
				nmerges = 0;
				while(p != null) {
					++nmerges;
					q = p;
					psize = 0;
					var _g = 0;
					var _g1 = insize;
					while(_g < _g1) {
						var i = _g++;
						++psize;
						q = q.next;
						if(q == null) {
							break;
						}
					}
					qsize = insize;
					while(psize > 0 || qsize > 0 && q != null) {
						if(psize == 0) {
							e = q;
							q = q.next;
							--qsize;
						} else if(qsize == 0 || q == null || f(p,q) <= 0) {
							e = p;
							p = p.next;
							--psize;
						} else {
							e = q;
							q = q.next;
							--qsize;
						}
						if(tail != null) {
							tail.next = e;
						} else {
							list = e;
						}
						tail = e;
					}
					p = q;
				}
				tail.next = null;
				if(nmerges <= 1) {
					break;
				}
				insize *= 2;
			}
			tmp = list;
		}
		this.current = tmp;
	}
	,filter: function(f) {
		var head = null;
		var prev = null;
		var disc = this.discarded;
		var discQueue = this.lastDisc;
		var cur = this.current;
		while(cur != null) {
			if(f(cur)) {
				if(head == null) {
					prev = cur;
					head = prev;
				} else {
					prev.next = cur;
					prev = cur;
				}
			} else if(disc == null) {
				discQueue = cur;
				disc = discQueue;
			} else {
				discQueue.next = cur;
				discQueue = cur;
			}
			cur = cur.next;
		}
		if(prev != null) {
			prev.next = null;
		}
		if(discQueue != null) {
			discQueue.next = null;
		}
		this.current = head;
		this.discarded = disc;
		this.lastDisc = discQueue;
	}
	,iterator: function() {
		return new h3d_pass_PassListIterator(this.current);
	}
	,getFiltered: function() {
		return new h3d_pass_PassListIterator(this.discarded);
	}
	,__class__: h3d_pass_PassList
};
var h3d_pass_PassObject = function() {
	this.texture = 0;
};
$hxClasses["h3d.pass.PassObject"] = h3d_pass_PassObject;
h3d_pass_PassObject.__name__ = "h3d.pass.PassObject";
h3d_pass_PassObject.prototype = {
	__class__: h3d_pass_PassObject
};
var h3d_pass_RenderMode = $hxEnums["h3d.pass.RenderMode"] = { __ename__:true,__constructs__:null
	,None: {_hx_name:"None",_hx_index:0,__enum__:"h3d.pass.RenderMode",toString:$estr}
	,Static: {_hx_name:"Static",_hx_index:1,__enum__:"h3d.pass.RenderMode",toString:$estr}
	,Dynamic: {_hx_name:"Dynamic",_hx_index:2,__enum__:"h3d.pass.RenderMode",toString:$estr}
	,Mixed: {_hx_name:"Mixed",_hx_index:3,__enum__:"h3d.pass.RenderMode",toString:$estr}
};
h3d_pass_RenderMode.__constructs__ = [h3d_pass_RenderMode.None,h3d_pass_RenderMode.Static,h3d_pass_RenderMode.Dynamic,h3d_pass_RenderMode.Mixed];
h3d_pass_RenderMode.__empty_constructs__ = [h3d_pass_RenderMode.None,h3d_pass_RenderMode.Static,h3d_pass_RenderMode.Dynamic,h3d_pass_RenderMode.Mixed];
var h3d_pass_ShadowSamplingKind = $hxEnums["h3d.pass.ShadowSamplingKind"] = { __ename__:true,__constructs__:null
	,None: {_hx_name:"None",_hx_index:0,__enum__:"h3d.pass.ShadowSamplingKind",toString:$estr}
	,PCF: {_hx_name:"PCF",_hx_index:1,__enum__:"h3d.pass.ShadowSamplingKind",toString:$estr}
	,ESM: {_hx_name:"ESM",_hx_index:2,__enum__:"h3d.pass.ShadowSamplingKind",toString:$estr}
};
h3d_pass_ShadowSamplingKind.__constructs__ = [h3d_pass_ShadowSamplingKind.None,h3d_pass_ShadowSamplingKind.PCF,h3d_pass_ShadowSamplingKind.ESM];
h3d_pass_ShadowSamplingKind.__empty_constructs__ = [h3d_pass_ShadowSamplingKind.None,h3d_pass_ShadowSamplingKind.PCF,h3d_pass_ShadowSamplingKind.ESM];
var h3d_pass_SortByMaterial = function() {
	this.textureCount = 1;
	this.shaderCount = 1;
	this.shaderIdMap = [];
	this.textureIdMap = [];
};
$hxClasses["h3d.pass.SortByMaterial"] = h3d_pass_SortByMaterial;
h3d_pass_SortByMaterial.__name__ = "h3d.pass.SortByMaterial";
h3d_pass_SortByMaterial.prototype = {
	sort: function(passes) {
		var _gthis = this;
		var shaderStart = this.shaderCount;
		var textureStart = this.textureCount;
		var _g_o = passes.current;
		while(_g_o != null) {
			var tmp = _g_o;
			_g_o = _g_o.next;
			var p = tmp;
			if(this.shaderIdMap[p.shader.id] < shaderStart || this.shaderIdMap[p.shader.id] == null) {
				this.shaderIdMap[p.shader.id] = this.shaderCount++;
			}
			if(this.textureIdMap[p.texture] < textureStart || this.textureIdMap[p.shader.id] == null) {
				this.textureIdMap[p.texture] = this.textureCount++;
			}
		}
		var list = passes.current;
		var tmp;
		if(list == null) {
			tmp = null;
		} else {
			var insize = 1;
			var nmerges;
			var psize = 0;
			var qsize = 0;
			var p;
			var q;
			var e;
			var tail;
			while(true) {
				p = list;
				list = null;
				tail = null;
				nmerges = 0;
				while(p != null) {
					++nmerges;
					q = p;
					psize = 0;
					var _g = 0;
					var _g1 = insize;
					while(_g < _g1) {
						var i = _g++;
						++psize;
						q = q.next;
						if(q == null) {
							break;
						}
					}
					qsize = insize;
					while(psize > 0 || qsize > 0 && q != null) {
						if(psize == 0) {
							e = q;
							q = q.next;
							--qsize;
						} else {
							var tmp1;
							if(!(qsize == 0 || q == null)) {
								var tmp2;
								if(p.pass.layer != q.pass.layer) {
									tmp2 = p.pass.layer - q.pass.layer;
								} else {
									var d = _gthis.shaderIdMap[p.shader.id] - _gthis.shaderIdMap[q.shader.id];
									tmp2 = d != 0 ? d : _gthis.textureIdMap[p.texture] - _gthis.textureIdMap[q.texture];
								}
								tmp1 = tmp2 <= 0;
							} else {
								tmp1 = true;
							}
							if(tmp1) {
								e = p;
								p = p.next;
								--psize;
							} else {
								e = q;
								q = q.next;
								--qsize;
							}
						}
						if(tail != null) {
							tail.next = e;
						} else {
							list = e;
						}
						tail = e;
					}
					p = q;
				}
				tail.next = null;
				if(nmerges <= 1) {
					break;
				}
				insize *= 2;
			}
			tmp = list;
		}
		passes.current = tmp;
	}
	,__class__: h3d_pass_SortByMaterial
};
var h3d_prim_BigPrimitive = function(format,alloc) {
	this.isStatic = true;
	this.hasTangents = false;
	this.startIndex = 0;
	this.idxPos = 0;
	this.bufPos = 0;
	h3d_prim_Primitive.call(this);
	this.format = format;
	this.buffers = [];
	this.allIndexes = [];
	this.bounds = new h3d_col_Bounds();
	this.allocator = alloc;
	if(format.stride < 3) {
		throw haxe_Exception.thrown("Minimum stride = 3");
	}
	this.allocPos = hxd_impl_AllocPos.make();
};
$hxClasses["h3d.prim.BigPrimitive"] = h3d_prim_BigPrimitive;
h3d_prim_BigPrimitive.__name__ = "h3d.prim.BigPrimitive";
h3d_prim_BigPrimitive.__super__ = h3d_prim_Primitive;
h3d_prim_BigPrimitive.prototype = $extend(h3d_prim_Primitive.prototype,{
	begin: function(vcount,icount) {
		this.startIndex = this.bufPos / this.format.stride | 0;
		if(this.startIndex + vcount >= 65535) {
			if(vcount >= 65535) {
				throw haxe_Exception.thrown("Too many vertices in begin()");
			}
			this.flush();
		}
		if(this.tmpBuf == null) {
			this.tmpBuf = h3d_prim_BigPrimitive.PREV_BUFFER;
			if(this.tmpBuf == null) {
				this.tmpBuf = hxd__$FloatBuffer_Float32Expand._new(0);
			} else {
				h3d_prim_BigPrimitive.PREV_BUFFER = null;
			}
			if(this.isStatic) {
				var this1 = this.tmpBuf;
				var _g = this1.pos;
				var _g1 = 65535 * this.format.stride;
				while(_g < _g1) {
					var i = _g++;
					if(this1.pos == this1.array.length) {
						var newSize = this1.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						var newArray = new Float32Array(newSize);
						newArray.set(this1.array);
						this1.array = newArray;
					}
					this1.array[this1.pos++] = 0.;
				}
			}
		}
		if(!this.isStatic) {
			var this1 = this.tmpBuf;
			var _g = this1.pos;
			var _g1 = vcount * this.format.stride + this.bufPos;
			while(_g < _g1) {
				var i = _g++;
				if(this1.pos == this1.array.length) {
					var newSize = this1.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					var newArray = new Float32Array(newSize);
					newArray.set(this1.array);
					this1.array = newArray;
				}
				this1.array[this1.pos++] = 0.;
			}
		}
		if(this.tmpIdx == null) {
			this.tmpIdx = h3d_prim_BigPrimitive.PREV_INDEX;
			if(this.tmpIdx == null) {
				this.tmpIdx = new Array(0);
			} else {
				h3d_prim_BigPrimitive.PREV_INDEX = null;
			}
		}
		if(this.idxPos + icount > this.tmpIdx.length) {
			var size = this.tmpIdx.length == 0 ? 1024 : this.tmpIdx.length;
			var req = this.idxPos + icount;
			while(size < req) size <<= 1;
			var this1 = this.tmpIdx;
			while(this1.length < size) this1.push(0);
		}
	}
	,addPoint: function(x,y,z) {
		this.tmpBuf.array[this.bufPos++] = x;
		this.tmpBuf.array[this.bufPos++] = y;
		this.tmpBuf.array[this.bufPos++] = z;
		var _this = this.bounds;
		if(x < _this.xMin) {
			_this.xMin = x;
		}
		if(x > _this.xMax) {
			_this.xMax = x;
		}
		if(y < _this.yMin) {
			_this.yMin = y;
		}
		if(y > _this.yMax) {
			_this.yMax = y;
		}
		if(z < _this.zMin) {
			_this.zMin = z;
		}
		if(z > _this.zMax) {
			_this.zMax = z;
		}
	}
	,addBounds: function(x,y,z) {
		var _this = this.bounds;
		if(x < _this.xMin) {
			_this.xMin = x;
		}
		if(x > _this.xMax) {
			_this.xMax = x;
		}
		if(y < _this.yMin) {
			_this.yMin = y;
		}
		if(y > _this.yMax) {
			_this.yMax = y;
		}
		if(z < _this.zMin) {
			_this.zMin = z;
		}
		if(z > _this.zMax) {
			_this.zMax = z;
		}
	}
	,addVertexValue: function(v) {
		this.tmpBuf.array[this.bufPos++] = v;
	}
	,addIndex: function(i) {
		this.tmpIdx[this.idxPos++] = i + this.startIndex;
	}
	,triCount: function() {
		var count = 0;
		var _g = 0;
		var _g1 = this.allIndexes;
		while(_g < _g1.length) {
			var i = _g1[_g];
			++_g;
			count += i.vertices;
		}
		count += this.idxPos;
		return count / 3 | 0;
	}
	,vertexCount: function() {
		var count = 0;
		var _g = 0;
		var _g1 = this.buffers;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			count += b.vertices;
		}
		count += this.bufPos / this.format.stride | 0;
		return count;
	}
	,flush: function() {
		if(this.tmpBuf != null) {
			if(this.bufPos > 0 && this.idxPos > 0) {
				this.flushing = true;
				var b;
				if(this.allocator != null) {
					b = this.allocator.ofSubFloats(this.tmpBuf,this.bufPos / this.format.stride | 0,this.format);
				} else {
					b = h3d_Buffer.ofSubFloats(this.tmpBuf,this.bufPos / this.format.stride | 0,this.format);
				}
				this.buffers.push(b);
				var idx = this.allocator != null ? this.allocator.ofIndexes(this.tmpIdx,this.idxPos) : h3d_Indexes.alloc(this.tmpIdx,0,this.idxPos);
				this.allIndexes.push(idx);
				this.flushing = false;
				b.allocPos = this.allocPos;
				var idx1 = idx;
				idx1.allocPos = this.allocPos;
			}
			if(h3d_prim_BigPrimitive.PREV_BUFFER == null || h3d_prim_BigPrimitive.PREV_BUFFER.pos < this.tmpBuf.pos) {
				h3d_prim_BigPrimitive.PREV_BUFFER = this.tmpBuf;
			}
			if(h3d_prim_BigPrimitive.PREV_INDEX == null || h3d_prim_BigPrimitive.PREV_INDEX.length < this.tmpIdx.length) {
				h3d_prim_BigPrimitive.PREV_INDEX = this.tmpIdx;
			}
			this.tmpBuf = null;
			this.tmpIdx = null;
			this.bufPos = 0;
			this.idxPos = 0;
			this.startIndex = 0;
		}
	}
	,render: function(engine) {
		if(this.tmpBuf != null) {
			this.flush();
		}
		var _g = 0;
		var _g1 = this.buffers.length;
		while(_g < _g1) {
			var i = _g++;
			engine.renderIndexed(this.buffers[i],this.allIndexes[i]);
		}
	}
	,getBounds: function() {
		return this.bounds;
	}
	,dispose: function() {
		this.clear();
	}
	,clear: function() {
		if(this.flushing) {
			throw haxe_Exception.thrown("Cannot clear() BigPrimitive while it's flushing");
		}
		var _this = this.bounds;
		_this.xMin = 1e20;
		_this.xMax = -1e20;
		_this.yMin = 1e20;
		_this.yMax = -1e20;
		_this.zMin = 1e20;
		_this.zMax = -1e20;
		var _g = 0;
		var _g1 = this.buffers;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			if(this.allocator != null) {
				this.allocator.disposeBuffer(b);
			} else {
				b.dispose();
			}
		}
		var _g = 0;
		var _g1 = this.allIndexes;
		while(_g < _g1.length) {
			var i = _g1[_g];
			++_g;
			if(this.allocator != null) {
				this.allocator.disposeIndexBuffer(i);
			} else {
				i.dispose();
			}
		}
		this.buffers = [];
		this.allIndexes = [];
		this.bufPos = 0;
		this.idxPos = 0;
		this.tmpBuf = null;
		this.tmpIdx = null;
	}
	,add: function(buf,idx,dx,dy,dz,rotation,scale,stride) {
		if(stride == null) {
			stride = -1;
		}
		if(scale == null) {
			scale = 1.;
		}
		if(rotation == null) {
			rotation = 0.;
		}
		if(dz == null) {
			dz = 0.;
		}
		if(dy == null) {
			dy = 0.;
		}
		if(dx == null) {
			dx = 0.;
		}
		this.addSub(buf,idx,0,0,buf.pos / (stride < 0 ? this.format.stride : stride) | 0,idx.length / 3 | 0,dx,dy,dz,rotation,scale,stride);
	}
	,addSub: function(buf,idx,startVert,startTri,nvert,triCount,dx,dy,dz,rotation,scale,stride,deltaU,deltaV,color,mat) {
		if(color == null) {
			color = 1.;
		}
		if(deltaV == null) {
			deltaV = 0.;
		}
		if(deltaU == null) {
			deltaU = 0.;
		}
		if(stride == null) {
			stride = -1;
		}
		if(scale == null) {
			scale = 1.;
		}
		if(rotation == null) {
			rotation = 0.;
		}
		if(dz == null) {
			dz = 0.;
		}
		if(dy == null) {
			dy = 0.;
		}
		if(dx == null) {
			dx = 0.;
		}
		if(stride < 0) {
			stride = this.format.stride;
		}
		if(stride < this.format.stride) {
			throw haxe_Exception.thrown("only stride >= " + this.format.stride + " allowed");
		}
		this.begin(nvert,triCount * 3);
		var start = this.startIndex;
		var cr = Math.cos(rotation);
		var sr = Math.sin(rotation);
		var pos = this.bufPos;
		var tmpBuf = this.tmpBuf;
		var _g = 0;
		var _g1 = nvert;
		while(_g < _g1) {
			var i = _g++;
			var p = (i + startVert) * stride;
			var x = buf.array[p++];
			var y = buf.array[p++];
			var z = buf.array[p++];
			if(mat != null) {
				var x1 = x;
				var y1 = y;
				var z1 = z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				var x2 = x1;
				var y2 = y1;
				var z2 = z1;
				if(z2 == null) {
					z2 = 0.;
				}
				if(y2 == null) {
					y2 = 0.;
				}
				if(x2 == null) {
					x2 = 0.;
				}
				var pt_x = x2;
				var pt_y = y2;
				var pt_z = z2;
				var px = pt_x * mat._11 + pt_y * mat._21 + pt_z * mat._31 + mat._41;
				var py = pt_x * mat._12 + pt_y * mat._22 + pt_z * mat._32 + mat._42;
				var pz = pt_x * mat._13 + pt_y * mat._23 + pt_z * mat._33 + mat._43;
				pt_x = px;
				pt_y = py;
				pt_z = pz;
				tmpBuf.array[pos++] = pt_x;
				tmpBuf.array[pos++] = pt_y;
				tmpBuf.array[pos++] = pt_z;
				var _this = this.bounds;
				if(pt_x < _this.xMin) {
					_this.xMin = pt_x;
				}
				if(pt_x > _this.xMax) {
					_this.xMax = pt_x;
				}
				if(pt_y < _this.yMin) {
					_this.yMin = pt_y;
				}
				if(pt_y > _this.yMax) {
					_this.yMax = pt_y;
				}
				if(pt_z < _this.zMin) {
					_this.zMin = pt_z;
				}
				if(pt_z > _this.zMax) {
					_this.zMax = pt_z;
				}
			} else {
				var tx = (x * cr - y * sr) * scale;
				var ty = (x * sr + y * cr) * scale;
				var vx = dx + tx;
				var vy = dy + ty;
				var vz = dz + z * scale;
				tmpBuf.array[pos++] = vx;
				tmpBuf.array[pos++] = vy;
				tmpBuf.array[pos++] = vz;
				var _this1 = this.bounds;
				if(vx < _this1.xMin) {
					_this1.xMin = vx;
				}
				if(vx > _this1.xMax) {
					_this1.xMax = vx;
				}
				if(vy < _this1.yMin) {
					_this1.yMin = vy;
				}
				if(vy > _this1.yMax) {
					_this1.yMax = vy;
				}
				if(vz < _this1.zMin) {
					_this1.zMin = vz;
				}
				if(vz > _this1.zMax) {
					_this1.zMax = vz;
				}
			}
			var stride1 = this.format.stride;
			if(stride1 >= 6) {
				var nx = buf.array[p++];
				var ny = buf.array[p++];
				var nz = buf.array[p++];
				if(mat != null) {
					var x3 = nx;
					var y3 = ny;
					var z3 = nz;
					if(z3 == null) {
						z3 = 0.;
					}
					if(y3 == null) {
						y3 = 0.;
					}
					if(x3 == null) {
						x3 = 0.;
					}
					var x4 = x3;
					var y4 = y3;
					var z4 = z3;
					if(z4 == null) {
						z4 = 0.;
					}
					if(y4 == null) {
						y4 = 0.;
					}
					if(x4 == null) {
						x4 = 0.;
					}
					var _this_x = x4;
					var _this_y = y4;
					var _this_z = z4;
					var px1 = _this_x * mat._11 + _this_y * mat._21 + _this_z * mat._31;
					var py1 = _this_x * mat._12 + _this_y * mat._22 + _this_z * mat._32;
					var pz1 = _this_x * mat._13 + _this_y * mat._23 + _this_z * mat._33;
					_this_x = px1;
					_this_y = py1;
					_this_z = pz1;
					var k = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
					if(k < 1e-20) {
						k = 0;
					} else {
						k = 1. / Math.sqrt(k);
					}
					_this_x *= k;
					_this_y *= k;
					_this_z *= k;
					tmpBuf.array[pos++] = _this_x;
					tmpBuf.array[pos++] = _this_y;
					tmpBuf.array[pos++] = _this_z;
				} else {
					var tnx = nx * cr - ny * sr;
					var tny = nx * sr + ny * cr;
					tmpBuf.array[pos++] = tnx;
					tmpBuf.array[pos++] = tny;
					tmpBuf.array[pos++] = nz;
				}
			}
			if(this.hasTangents) {
				var tx1 = buf.array[p++];
				var ty1 = buf.array[p++];
				var tz = buf.array[p++];
				if(mat != null) {
					var x5 = tx1;
					var y5 = ty1;
					var z5 = tz;
					if(z5 == null) {
						z5 = 0.;
					}
					if(y5 == null) {
						y5 = 0.;
					}
					if(x5 == null) {
						x5 = 0.;
					}
					var x6 = x5;
					var y6 = y5;
					var z6 = z5;
					if(z6 == null) {
						z6 = 0.;
					}
					if(y6 == null) {
						y6 = 0.;
					}
					if(x6 == null) {
						x6 = 0.;
					}
					var _this_x1 = x6;
					var _this_y1 = y6;
					var _this_z1 = z6;
					var len = _this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1;
					var px2 = _this_x1 * mat._11 + _this_y1 * mat._21 + _this_z1 * mat._31;
					var py2 = _this_x1 * mat._12 + _this_y1 * mat._22 + _this_z1 * mat._32;
					var pz2 = _this_x1 * mat._13 + _this_y1 * mat._23 + _this_z1 * mat._33;
					_this_x1 = px2;
					_this_y1 = py2;
					_this_z1 = pz2;
					var k1 = _this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1;
					if(k1 < 1e-20) {
						k1 = 0;
					} else {
						k1 = 1. / Math.sqrt(k1);
					}
					_this_x1 *= k1;
					_this_y1 *= k1;
					_this_z1 *= k1;
					if(len < 0.5) {
						_this_x1 *= 0.5;
						_this_y1 *= 0.5;
						_this_z1 *= 0.5;
					}
					tmpBuf.array[pos++] = _this_x1;
					tmpBuf.array[pos++] = _this_y1;
					tmpBuf.array[pos++] = _this_z1;
				} else {
					var tnx1 = tx1 * cr - ty1 * sr;
					var tny1 = tx1 * sr + ty1 * cr;
					tmpBuf.array[pos++] = tnx1;
					tmpBuf.array[pos++] = tny1;
					tmpBuf.array[pos++] = tz;
				}
				stride1 -= 3;
			}
			switch(stride1) {
			case 3:case 6:
				continue;
			case 4:case 7:
				tmpBuf.array[pos++] = buf.array[p++] + deltaU;
				break;
			case 5:case 8:case 9:case 10:
				tmpBuf.array[pos++] = buf.array[p++] + deltaU;
				tmpBuf.array[pos++] = buf.array[p++] + deltaV;
				var _g2 = 8;
				var _g3 = stride1;
				while(_g2 < _g3) {
					var i1 = _g2++;
					tmpBuf.array[pos++] = buf.array[p++];
				}
				break;
			default:
				tmpBuf.array[pos++] = buf.array[p++] + deltaU;
				tmpBuf.array[pos++] = buf.array[p++] + deltaV;
				tmpBuf.array[pos++] = buf.array[p++] * color;
				tmpBuf.array[pos++] = buf.array[p++] * color;
				tmpBuf.array[pos++] = buf.array[p++] * color;
				var _g4 = 11;
				var _g5 = stride1;
				while(_g4 < _g5) {
					var i2 = _g4++;
					tmpBuf.array[pos++] = buf.array[p++];
				}
			}
		}
		this.bufPos = pos;
		start -= startVert;
		var _g = 0;
		var _g1 = triCount * 3;
		while(_g < _g1) {
			var i = _g++;
			var tmp = idx[i + startTri * 3] + start;
			this.tmpIdx[this.idxPos++] = tmp;
		}
	}
	,__class__: h3d_prim_BigPrimitive
});
var h3d_prim_Blendshape = function(hmdModel) {
	this.shapesBytes = [];
	this.inputMapping = [];
	this.hmdModel = hmdModel;
	if(hmdModel.get_data().vertexFormat.hasLowPrecision) {
		throw haxe_Exception.thrown("Blend shape doesn't support low precision");
	}
	var is32 = hmdModel.get_data().vertexCount > 65536;
	var vertexFormat = hmdModel.get_data().vertexFormat;
	var size = hmdModel.get_data().vertexCount * vertexFormat.strideBytes;
	var geoId = 0;
	var _g_current = 0;
	var _g_array = hmdModel.lib.header.geometries;
	while(_g_current < _g_array.length) {
		var _g_value = _g_array[_g_current];
		var _g_key = _g_current++;
		var gIdx = _g_key;
		var g = _g_value;
		if(g == hmdModel.get_data()) {
			geoId = gIdx;
		}
	}
	var _g = [];
	var _g1 = 0;
	var _g2 = hmdModel.lib.header.shapes;
	while(_g1 < _g2.length) {
		var s = _g2[_g1];
		++_g1;
		if(s.geom == geoId) {
			_g.push(s);
		}
	}
	this.shapes = _g;
	this.weights = [];
	var _g = 0;
	var _g1 = this.shapes.length;
	while(_g < _g1) {
		var s = _g++;
		var s1 = this.shapes[s];
		var size = s1.vertexCount * s1.vertexFormat.strideBytes;
		var vertexBytes = new haxe_io_Bytes(new ArrayBuffer(size));
		hmdModel.lib.resource.entry.readBytes(vertexBytes,0,hmdModel.dataPosition + s1.vertexPosition,size);
		size = hmdModel.get_data().vertexCount << 2;
		var remapBytes = new haxe_io_Bytes(new ArrayBuffer(size));
		hmdModel.lib.resource.entry.readBytes(remapBytes,0,hmdModel.dataPosition + s1.remapPosition,size);
		this.shapesBytes.push({ vertexBytes : vertexBytes, remapBytes : remapBytes});
		this.inputMapping.push(new haxe_ds_StringMap());
		this.weights.push(0.0);
	}
	var _g_current = 0;
	var _g_array = vertexFormat.inputs;
	while(_g_current < _g_array.length) {
		var input = _g_array[_g_current++];
		var _g = 0;
		var _g1 = this.shapes.length;
		while(_g < _g1) {
			var s = _g++;
			var offset = 0;
			var _g_current1 = 0;
			var _g_array1 = this.shapes[s].vertexFormat.inputs;
			while(_g_current1 < _g_array1.length) {
				var i = _g_array1[_g_current1++];
				if(i.name == input.name) {
					this.inputMapping[s].h[i.name] = offset;
				}
				offset += i.type & 7;
			}
		}
	}
};
$hxClasses["h3d.prim.Blendshape"] = h3d_prim_Blendshape;
h3d_prim_Blendshape.__name__ = "h3d.prim.Blendshape";
h3d_prim_Blendshape.prototype = {
	setBlendshapeAmount: function(blendshapeIdx,amount) {
		if(blendshapeIdx >= this.weights.length) {
			throw haxe_Exception.thrown("Blendshape at index " + blendshapeIdx + " doesn't exist (there is only " + this.weights.length + " blendshapes).");
		}
		this.weights[blendshapeIdx] = amount;
		this.uploadBlendshapeBytes();
	}
	,getBlendshapeCount: function() {
		if(this.hmdModel.lib.header.shapes == null) {
			return 0;
		}
		return this.shapes.length;
	}
	,uploadBlendshapeBytes: function() {
		if(this.hmdModel.buffer == null || this.hmdModel.buffer.vbuf == null) {
			this.hmdModel.alloc(h3d_Engine.CURRENT);
		}
		var is32 = this.hmdModel.get_data().vertexCount > 65536;
		var vertexFormat = this.hmdModel.get_data().vertexFormat;
		var size = this.hmdModel.get_data().vertexCount * vertexFormat.strideBytes;
		var originalBytes = new haxe_io_Bytes(new ArrayBuffer(size));
		this.hmdModel.lib.resource.entry.readBytes(originalBytes,0,this.hmdModel.dataPosition + this.hmdModel.get_data().vertexPosition,size);
		var flagOffset = 31;
		var bytesOffset = new haxe_io_Bytes(new ArrayBuffer(originalBytes.length));
		bytesOffset.fill(0,originalBytes.length,0);
		var _g = 0;
		var _g1 = this.shapes.length;
		while(_g < _g1) {
			var sIdx = _g++;
			var sp = this.shapesBytes[sIdx];
			var offsetIdx = 0;
			var idx = 0;
			while(offsetIdx < this.shapes[sIdx].indexCount) {
				var affectedVId = sp.remapBytes.getInt32(idx << 2);
				var reachEnd = false;
				while(!reachEnd) {
					reachEnd = affectedVId >> flagOffset != 0;
					if(reachEnd) {
						affectedVId ^= 1 << flagOffset;
					}
					var inputIdx = 0;
					var offsetInput = 0;
					var _g_current = 0;
					var _g_array = this.shapes[sIdx].vertexFormat.inputs;
					while(_g_current < _g_array.length) {
						var input = _g_array[_g_current++];
						var _g2 = 0;
						var _g3 = input.type & 7;
						while(_g2 < _g3) {
							var sizeIdx = _g2++;
							var original = originalBytes.getFloat(affectedVId * vertexFormat.stride + this.inputMapping[sIdx].h[input.name] + sizeIdx << 2);
							var offset = sp.vertexBytes.getFloat(offsetIdx * this.shapes[sIdx].vertexFormat.stride + offsetInput + sizeIdx << 2);
							var res = original + this.weights[sIdx] * (original + offset - original) - original;
							var bytePos = affectedVId * vertexFormat.stride + this.inputMapping[sIdx].h[input.name] + sizeIdx << 2;
							bytesOffset.setFloat(bytePos,bytesOffset.getFloat(bytePos) + res);
						}
						offsetInput += input.type & 7;
						++inputIdx;
					}
					++idx;
					if(idx < this.hmdModel.get_data().vertexCount) {
						affectedVId = sp.remapBytes.getInt32(idx << 2);
					}
				}
				++offsetIdx;
			}
		}
		var bytes = new haxe_io_Bytes(new ArrayBuffer(originalBytes.length));
		bytes.blit(0,originalBytes,0,originalBytes.length);
		var _g = 0;
		var _g1 = bytesOffset.length / 4.0 | 0;
		while(_g < _g1) {
			var i = _g++;
			bytes.setFloat(i << 2,bytes.getFloat(i << 2) + bytesOffset.getFloat(i << 2));
		}
		this.hmdModel.buffer.uploadBytes(bytes,0,this.hmdModel.get_data().vertexCount);
		this.hmdModel.indexCount = 0;
		this.hmdModel.indexesTriPos = [];
		var _g = 0;
		var _g1 = this.hmdModel.get_data().indexCounts;
		while(_g < _g1.length) {
			var n = _g1[_g];
			++_g;
			this.hmdModel.indexesTriPos.push(this.hmdModel.indexCount / 3 | 0);
			this.hmdModel.indexCount += n;
		}
		var size = (is32 ? 4 : 2) * this.hmdModel.indexCount;
		var bytes = this.hmdModel.lib.resource.entry.fetchBytes(this.hmdModel.dataPosition + this.hmdModel.get_data().indexPosition,size);
		this.hmdModel.indexes.uploadBytes(bytes,0,this.hmdModel.indexCount);
	}
	,__class__: h3d_prim_Blendshape
};
var h3d_prim_Collider = function(hmdModel,data) {
	this.hmdModel = hmdModel;
	this.data = data;
};
$hxClasses["h3d.prim.Collider"] = h3d_prim_Collider;
h3d_prim_Collider.__name__ = "h3d.prim.Collider";
h3d_prim_Collider.fromHmd = function(hmdModel) {
	var header = hmdModel.lib.header;
	var _g = 0;
	var _g1 = header.models;
	while(_g < _g1.length) {
		var h = _g1[_g];
		++_g;
		if(header.geometries[h.geometry] == hmdModel.get_data()) {
			return new h3d_prim_Collider(hmdModel,header.colliders[h.collider]);
		}
	}
	return null;
};
h3d_prim_Collider.prototype = {
	getBuffers: function() {
		var vertexPosition = this.hmdModel.dataPosition + this.data.vertexPosition;
		var indexPosition = this.hmdModel.dataPosition + this.data.indexPosition;
		var buffers = [];
		var _g = 0;
		var _g1 = this.data.vertexCounts.length;
		while(_g < _g1) {
			var i = _g++;
			var vertexCount = this.data.vertexCounts[i];
			var indexCount = this.data.indexCounts[i];
			var is32 = vertexCount > 65536;
			var vSize = vertexCount * 3 * 4;
			var vertexBytes = new haxe_io_Bytes(new ArrayBuffer(vSize));
			this.hmdModel.lib.resource.entry.readBytes(vertexBytes,0,vertexPosition,vSize);
			var buf = new hxd_fmt_hmd_GeometryBuffer();
			buf.vertexes = new Array(3 * vertexCount);
			var _g2 = 0;
			var _g3 = 3 * vertexCount;
			while(_g2 < _g3) {
				var i1 = _g2++;
				buf.vertexes[i1] = vertexBytes.getFloat(i1 * 4);
			}
			var iSize = indexCount * (is32 ? 4 : 2);
			var indexBytes = new haxe_io_Bytes(new ArrayBuffer(iSize));
			this.hmdModel.lib.resource.entry.readBytes(indexBytes,0,indexPosition,iSize);
			buf.indexes = new Array(indexCount);
			var stride = is32 ? 4 : 2;
			if(is32) {
				var _g4 = 0;
				var _g5 = indexCount;
				while(_g4 < _g5) {
					var i2 = _g4++;
					buf.indexes[i2] = indexBytes.getInt32(i2 * stride);
				}
			} else {
				var _g6 = 0;
				var _g7 = indexCount;
				while(_g6 < _g7) {
					var i3 = _g6++;
					buf.indexes[i3] = indexBytes.getUInt16(i3 * stride);
				}
			}
			buffers.push(buf);
			vertexPosition += vSize;
			indexPosition += iSize;
		}
		return buffers;
	}
	,__class__: h3d_prim_Collider
};
var h3d_prim_MeshPrimitive = function() {
	h3d_prim_Primitive.call(this);
};
$hxClasses["h3d.prim.MeshPrimitive"] = h3d_prim_MeshPrimitive;
h3d_prim_MeshPrimitive.__name__ = "h3d.prim.MeshPrimitive";
h3d_prim_MeshPrimitive.__super__ = h3d_prim_Primitive;
h3d_prim_MeshPrimitive.prototype = $extend(h3d_prim_Primitive.prototype,{
	hasInput: function(name) {
		return this.resolveBuffer(name) != null;
	}
	,resolveBuffer: function(name) {
		if(this.buffers != null) {
			var _g = 0;
			var _g1 = this.buffers;
			while(_g < _g1.length) {
				var b = _g1[_g];
				++_g;
				if(b.format.hasInput(name)) {
					return b;
				}
			}
			return null;
		}
		if(this.buffer != null && this.buffer.format.hasInput(name)) {
			return this.buffer;
		}
		return null;
	}
	,removeBuffer: function(buf) {
		if(this.buffers != null) {
			HxOverrides.remove(this.buffers,buf);
			if(buf == this.buffer) {
				this.buffer = this.buffers[this.buffers.length - 1];
			}
			if(this.buffers.length == 1) {
				this.buffers = null;
				this.formats = null;
			}
		} else if(this.buffer == buf) {
			this.buffer = null;
		}
	}
	,addBuffer: function(buf) {
		if(this.buffer == null) {
			this.buffer = buf;
		} else {
			if(this.buffers == null) {
				if(buf == this.buffer) {
					throw haxe_Exception.thrown("Duplicate addBuffer()");
				}
				this.buffers = [this.buffer];
			} else if(this.buffers.indexOf(buf) >= 0) {
				throw haxe_Exception.thrown("Duplicate addBuffer()");
			}
			this.buffers.unshift(buf);
			var _g = [];
			var _g1 = 0;
			var _g2 = this.buffers;
			while(_g1 < _g2.length) {
				var b = _g2[_g1];
				++_g1;
				_g.push(b.format);
			}
			this.formats = hxd_MultiFormat.make(_g);
		}
	}
	,dispose: function() {
		h3d_prim_Primitive.prototype.dispose.call(this);
		if(this.buffers != null) {
			var _g = 0;
			var _g1 = this.buffers;
			while(_g < _g1.length) {
				var b = _g1[_g];
				++_g;
				b.dispose();
			}
			this.buffers = null;
			this.formats = null;
		}
	}
	,render: function(engine) {
		if(this.indexes == null || this.indexes.vbuf == null || this.buffer == null || this.buffer.vbuf == null) {
			this.alloc(engine);
		}
		if(this.buffers != null) {
			engine.renderMultiBuffers(this.formats,this.buffers,this.indexes);
		} else {
			engine.renderIndexed(this.buffer,this.indexes);
		}
	}
	,__class__: h3d_prim_MeshPrimitive
});
var h3d_prim_Polygon = function(points,idx) {
	this.translatedZ = 0.;
	this.translatedY = 0.;
	this.translatedX = 0.;
	this.scaled = 1.;
	h3d_prim_MeshPrimitive.call(this);
	this.points = points;
	this.idx = idx;
};
$hxClasses["h3d.prim.Polygon"] = h3d_prim_Polygon;
h3d_prim_Polygon.__name__ = "h3d.prim.Polygon";
h3d_prim_Polygon.__super__ = h3d_prim_MeshPrimitive;
h3d_prim_Polygon.prototype = $extend(h3d_prim_MeshPrimitive.prototype,{
	getBounds: function() {
		var b = new h3d_col_Bounds();
		var _g = 0;
		var _g1 = this.points;
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			if(p.x < b.xMin) {
				b.xMin = p.x;
			}
			if(p.x > b.xMax) {
				b.xMax = p.x;
			}
			if(p.y < b.yMin) {
				b.yMin = p.y;
			}
			if(p.y > b.yMax) {
				b.yMax = p.y;
			}
			if(p.z < b.zMin) {
				b.zMin = p.z;
			}
			if(p.z > b.zMax) {
				b.zMax = p.z;
			}
		}
		return b;
	}
	,alloc: function(engine) {
		this.dispose();
		var format = hxd_BufferFormat.get_POS3D();
		if(this.normals != null) {
			format = format.append("normal",3);
		}
		if(this.tangents != null) {
			format = format.append("tangent",3);
		}
		if(this.uvs != null) {
			format = format.append("uv",2);
		}
		if(this.colors != null) {
			format = format.append("color",3);
		}
		var buf = hxd__$FloatBuffer_Float32Expand._new(0);
		var _g = 0;
		var _g1 = this.points.length;
		while(_g < _g1) {
			var k = _g++;
			var p = this.points[k];
			var v = p.x;
			if(buf.pos == buf.array.length) {
				var newSize = buf.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(buf.array);
				buf.array = newArray;
			}
			buf.array[buf.pos++] = v;
			var v1 = p.y;
			if(buf.pos == buf.array.length) {
				var newSize1 = buf.array.length << 1;
				if(newSize1 < 128) {
					newSize1 = 128;
				}
				var newArray1 = new Float32Array(newSize1);
				newArray1.set(buf.array);
				buf.array = newArray1;
			}
			buf.array[buf.pos++] = v1;
			var v2 = p.z;
			if(buf.pos == buf.array.length) {
				var newSize2 = buf.array.length << 1;
				if(newSize2 < 128) {
					newSize2 = 128;
				}
				var newArray2 = new Float32Array(newSize2);
				newArray2.set(buf.array);
				buf.array = newArray2;
			}
			buf.array[buf.pos++] = v2;
			if(this.normals != null) {
				var n = this.normals[k];
				var v3 = n.x;
				if(buf.pos == buf.array.length) {
					var newSize3 = buf.array.length << 1;
					if(newSize3 < 128) {
						newSize3 = 128;
					}
					var newArray3 = new Float32Array(newSize3);
					newArray3.set(buf.array);
					buf.array = newArray3;
				}
				buf.array[buf.pos++] = v3;
				var v4 = n.y;
				if(buf.pos == buf.array.length) {
					var newSize4 = buf.array.length << 1;
					if(newSize4 < 128) {
						newSize4 = 128;
					}
					var newArray4 = new Float32Array(newSize4);
					newArray4.set(buf.array);
					buf.array = newArray4;
				}
				buf.array[buf.pos++] = v4;
				var v5 = n.z;
				if(buf.pos == buf.array.length) {
					var newSize5 = buf.array.length << 1;
					if(newSize5 < 128) {
						newSize5 = 128;
					}
					var newArray5 = new Float32Array(newSize5);
					newArray5.set(buf.array);
					buf.array = newArray5;
				}
				buf.array[buf.pos++] = v5;
			}
			if(this.tangents != null) {
				var t = this.tangents[k];
				var v6 = t.x;
				if(buf.pos == buf.array.length) {
					var newSize6 = buf.array.length << 1;
					if(newSize6 < 128) {
						newSize6 = 128;
					}
					var newArray6 = new Float32Array(newSize6);
					newArray6.set(buf.array);
					buf.array = newArray6;
				}
				buf.array[buf.pos++] = v6;
				var v7 = t.y;
				if(buf.pos == buf.array.length) {
					var newSize7 = buf.array.length << 1;
					if(newSize7 < 128) {
						newSize7 = 128;
					}
					var newArray7 = new Float32Array(newSize7);
					newArray7.set(buf.array);
					buf.array = newArray7;
				}
				buf.array[buf.pos++] = v7;
				var v8 = t.z;
				if(buf.pos == buf.array.length) {
					var newSize8 = buf.array.length << 1;
					if(newSize8 < 128) {
						newSize8 = 128;
					}
					var newArray8 = new Float32Array(newSize8);
					newArray8.set(buf.array);
					buf.array = newArray8;
				}
				buf.array[buf.pos++] = v8;
			}
			if(this.uvs != null) {
				var t1 = this.uvs[k];
				var v9 = t1.u;
				if(buf.pos == buf.array.length) {
					var newSize9 = buf.array.length << 1;
					if(newSize9 < 128) {
						newSize9 = 128;
					}
					var newArray9 = new Float32Array(newSize9);
					newArray9.set(buf.array);
					buf.array = newArray9;
				}
				buf.array[buf.pos++] = v9;
				var v10 = t1.v;
				if(buf.pos == buf.array.length) {
					var newSize10 = buf.array.length << 1;
					if(newSize10 < 128) {
						newSize10 = 128;
					}
					var newArray10 = new Float32Array(newSize10);
					newArray10.set(buf.array);
					buf.array = newArray10;
				}
				buf.array[buf.pos++] = v10;
			}
			if(this.colors != null) {
				var c = this.colors[k];
				var v11 = c.x;
				if(buf.pos == buf.array.length) {
					var newSize11 = buf.array.length << 1;
					if(newSize11 < 128) {
						newSize11 = 128;
					}
					var newArray11 = new Float32Array(newSize11);
					newArray11.set(buf.array);
					buf.array = newArray11;
				}
				buf.array[buf.pos++] = v11;
				var v12 = c.y;
				if(buf.pos == buf.array.length) {
					var newSize12 = buf.array.length << 1;
					if(newSize12 < 128) {
						newSize12 = 128;
					}
					var newArray12 = new Float32Array(newSize12);
					newArray12.set(buf.array);
					buf.array = newArray12;
				}
				buf.array[buf.pos++] = v12;
				var v13 = c.z;
				if(buf.pos == buf.array.length) {
					var newSize13 = buf.array.length << 1;
					if(newSize13 < 128) {
						newSize13 = 128;
					}
					var newArray13 = new Float32Array(newSize13);
					newArray13.set(buf.array);
					buf.array = newArray13;
				}
				buf.array[buf.pos++] = v13;
			}
		}
		this.buffer = h3d_Buffer.ofFloats(buf,format);
		if(this.idx != null) {
			this.indexes = h3d_Indexes.alloc(this.idx);
		}
	}
	,unindex: function() {
		if(this.idx != null && this.points.length != this.idx.length) {
			var p = [];
			var _g = 0;
			var _g1 = this.idx.length;
			while(_g < _g1) {
				var i = _g++;
				var _this = this.points[this.idx[i]];
				var x = _this.x;
				var y = _this.y;
				var z = _this.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				p.push(new h3d_VectorImpl(x,y,z));
			}
			if(this.normals != null) {
				var n = [];
				var _g = 0;
				var _g1 = this.idx.length;
				while(_g < _g1) {
					var i = _g++;
					var _this = this.normals[this.idx[i]];
					var x = _this.x;
					var y = _this.y;
					var z = _this.z;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					n.push(new h3d_VectorImpl(x,y,z));
				}
				this.normals = n;
			}
			if(this.tangents != null) {
				var t = [];
				var _g = 0;
				var _g1 = this.idx.length;
				while(_g < _g1) {
					var i = _g++;
					var _this = this.tangents[this.idx[i]];
					var x = _this.x;
					var y = _this.y;
					var z = _this.z;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					t.push(new h3d_VectorImpl(x,y,z));
				}
				this.tangents = t;
			}
			if(this.colors != null) {
				var n = [];
				var _g = 0;
				var _g1 = this.idx.length;
				while(_g < _g1) {
					var i = _g++;
					var _this = this.colors[this.idx[i]];
					var x = _this.x;
					var y = _this.y;
					var z = _this.z;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					n.push(new h3d_VectorImpl(x,y,z));
				}
				this.colors = n;
			}
			if(this.uvs != null) {
				var t = [];
				var _g = 0;
				var _g1 = this.idx.length;
				while(_g < _g1) {
					var i = _g++;
					t.push(this.uvs[this.idx[i]].clone());
				}
				this.uvs = t;
			}
			this.points = p;
			this.idx = null;
		}
	}
	,translate: function(dx,dy,dz) {
		this.translatedX += dx;
		this.translatedY += dy;
		this.translatedZ += dz;
		var _g = 0;
		var _g1 = this.points;
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			p.x += dx;
			p.y += dy;
			p.z += dz;
		}
	}
	,scale: function(s) {
		this.scaled *= s;
		var _g = 0;
		var _g1 = this.points;
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			p.x *= s;
			p.y *= s;
			p.z *= s;
		}
	}
	,addNormals: function() {
		this.normals = [];
		var _g = 0;
		var _g1 = this.points.length;
		while(_g < _g1) {
			var i = _g++;
			this.normals[i] = new h3d_VectorImpl(0.,0.,0.);
		}
		var pos = 0;
		var _g = 0;
		var _g1 = this.triCount();
		while(_g < _g1) {
			var i = _g++;
			var i0;
			var i1;
			var i2;
			if(this.idx == null) {
				++pos;
				i0 = pos - 1;
				++pos;
				i1 = pos - 1;
				++pos;
				i2 = pos - 1;
			} else {
				i0 = this.idx[pos++];
				i1 = this.idx[pos++];
				i2 = this.idx[pos++];
			}
			var p0 = this.points[i0];
			var p1 = this.points[i1];
			var p2 = this.points[i2];
			var x = p1.x - p0.x;
			var y = p1.y - p0.y;
			var z = p1.z - p0.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var _this_x = x1;
			var _this_y = y1;
			var _this_z = z1;
			var x2 = p2.x - p0.x;
			var y2 = p2.y - p0.y;
			var z2 = p2.z - p0.z;
			if(z2 == null) {
				z2 = 0.;
			}
			if(y2 == null) {
				y2 = 0.;
			}
			if(x2 == null) {
				x2 = 0.;
			}
			var x3 = x2;
			var y3 = y2;
			var z3 = z2;
			if(z3 == null) {
				z3 = 0.;
			}
			if(y3 == null) {
				y3 = 0.;
			}
			if(x3 == null) {
				x3 = 0.;
			}
			var v_x = x3;
			var v_y = y3;
			var v_z = z3;
			var x4 = _this_y * v_z - _this_z * v_y;
			var y4 = _this_z * v_x - _this_x * v_z;
			var z4 = _this_x * v_y - _this_y * v_x;
			if(z4 == null) {
				z4 = 0.;
			}
			if(y4 == null) {
				y4 = 0.;
			}
			if(x4 == null) {
				x4 = 0.;
			}
			var x5 = x4;
			var y5 = y4;
			var z5 = z4;
			if(z5 == null) {
				z5 = 0.;
			}
			if(y5 == null) {
				y5 = 0.;
			}
			if(x5 == null) {
				x5 = 0.;
			}
			var n_x = x5;
			var n_y = y5;
			var n_z = z5;
			this.normals[i0].x += n_x;
			this.normals[i0].y += n_y;
			this.normals[i0].z += n_z;
			this.normals[i1].x += n_x;
			this.normals[i1].y += n_y;
			this.normals[i1].z += n_z;
			this.normals[i2].x += n_x;
			this.normals[i2].y += n_y;
			this.normals[i2].z += n_z;
		}
		var _g = 0;
		var _g1 = this.normals;
		while(_g < _g1.length) {
			var n = _g1[_g];
			++_g;
			var _this = n;
			var k = _this.x * _this.x + _this.y * _this.y + _this.z * _this.z;
			if(k < 1e-20) {
				k = 0;
			} else {
				k = 1. / Math.sqrt(k);
			}
			_this.x *= k;
			_this.y *= k;
			_this.z *= k;
		}
	}
	,addTangents: function() {
		if(this.normals == null) {
			this.addNormals();
		}
		if(this.uvs == null) {
			this.addUVs();
		}
		this.tangents = [];
		var _g = 0;
		var _g1 = this.points.length;
		while(_g < _g1) {
			var i = _g++;
			this.tangents[i] = new h3d_VectorImpl(0.,0.,0.);
		}
		var pos = 0;
		var _g = 0;
		var _g1 = this.triCount();
		while(_g < _g1) {
			var i = _g++;
			var i0;
			var i1;
			var i2;
			if(this.idx == null) {
				++pos;
				i0 = pos - 1;
				++pos;
				i1 = pos - 1;
				++pos;
				i2 = pos - 1;
			} else {
				i0 = this.idx[pos++];
				i1 = this.idx[pos++];
				i2 = this.idx[pos++];
			}
			var p0 = this.points[i0];
			var p1 = this.points[i1];
			var p2 = this.points[i2];
			var uv0 = this.uvs[i0];
			var uv1 = this.uvs[i1];
			var uv2 = this.uvs[i2];
			var n = this.normals[i0];
			var x = p1.x - p0.x;
			var y = p1.y - p0.y;
			var z = p1.z - p0.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var k0_x = x1;
			var k0_y = y1;
			var k0_z = z1;
			var x2 = p2.x - p0.x;
			var y2 = p2.y - p0.y;
			var z2 = p2.z - p0.z;
			if(z2 == null) {
				z2 = 0.;
			}
			if(y2 == null) {
				y2 = 0.;
			}
			if(x2 == null) {
				x2 = 0.;
			}
			var x3 = x2;
			var y3 = y2;
			var z3 = z2;
			if(z3 == null) {
				z3 = 0.;
			}
			if(y3 == null) {
				y3 = 0.;
			}
			if(x3 == null) {
				x3 = 0.;
			}
			var k1_x = x3;
			var k1_y = y3;
			var k1_z = z3;
			var v = uv2.v - uv0.v;
			k0_x *= v;
			k0_y *= v;
			k0_z *= v;
			var v1 = uv1.v - uv0.v;
			k1_x *= v1;
			k1_y *= v1;
			k1_z *= v1;
			var x4 = k0_x - k1_x;
			var y4 = k0_y - k1_y;
			var z4 = k0_z - k1_z;
			if(z4 == null) {
				z4 = 0.;
			}
			if(y4 == null) {
				y4 = 0.;
			}
			if(x4 == null) {
				x4 = 0.;
			}
			var t = new h3d_VectorImpl(x4,y4,z4);
			var _this = n;
			var x5 = _this.y * t.z - _this.z * t.y;
			var y5 = _this.z * t.x - _this.x * t.z;
			var z5 = _this.x * t.y - _this.y * t.x;
			if(z5 == null) {
				z5 = 0.;
			}
			if(y5 == null) {
				y5 = 0.;
			}
			if(x5 == null) {
				x5 = 0.;
			}
			var x6 = x5;
			var y6 = y5;
			var z6 = z5;
			if(z6 == null) {
				z6 = 0.;
			}
			if(y6 == null) {
				y6 = 0.;
			}
			if(x6 == null) {
				x6 = 0.;
			}
			var _this_x = x6;
			var _this_y = y6;
			var _this_z = z6;
			var k = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
			if(k < 1e-20) {
				k = 0;
			} else {
				k = 1. / Math.sqrt(k);
			}
			_this_x *= k;
			_this_y *= k;
			_this_z *= k;
			var x7 = _this_y * n.z - _this_z * n.y;
			var y7 = _this_z * n.x - _this_x * n.z;
			var z7 = _this_x * n.y - _this_y * n.x;
			if(z7 == null) {
				z7 = 0.;
			}
			if(y7 == null) {
				y7 = 0.;
			}
			if(x7 == null) {
				x7 = 0.;
			}
			t = new h3d_VectorImpl(x7,y7,z7);
			var _this1 = t;
			var k1 = _this1.x * _this1.x + _this1.y * _this1.y + _this1.z * _this1.z;
			if(k1 < 1e-20) {
				k1 = 0;
			} else {
				k1 = 1. / Math.sqrt(k1);
			}
			_this1.x *= k1;
			_this1.y *= k1;
			_this1.z *= k1;
			this.tangents[i0].x += t.x;
			this.tangents[i0].y += t.y;
			this.tangents[i0].z += t.z;
			this.tangents[i1].x += t.x;
			this.tangents[i1].y += t.y;
			this.tangents[i1].z += t.z;
			this.tangents[i2].x += t.x;
			this.tangents[i2].y += t.y;
			this.tangents[i2].z += t.z;
		}
		var _g = 0;
		var _g1 = this.tangents;
		while(_g < _g1.length) {
			var t = _g1[_g];
			++_g;
			var _this = t;
			var k = _this.x * _this.x + _this.y * _this.y + _this.z * _this.z;
			if(k < 1e-20) {
				k = 0;
			} else {
				k = 1. / Math.sqrt(k);
			}
			_this.x *= k;
			_this.y *= k;
			_this.z *= k;
		}
	}
	,addUVs: function() {
		this.uvs = [];
		var _g = 0;
		var _g1 = this.points.length;
		while(_g < _g1) {
			var i = _g++;
			this.uvs[i] = new h3d_prim_UV(this.points[i].x,this.points[i].y);
		}
	}
	,uvScale: function(su,sv) {
		if(this.uvs == null) {
			throw haxe_Exception.thrown("Missing UVs");
		}
		var m = new haxe_ds_ObjectMap();
		var _g = 0;
		var _g1 = this.uvs;
		while(_g < _g1.length) {
			var t = _g1[_g];
			++_g;
			if(m.h.__keys__[t.__id__] != null) {
				continue;
			}
			m.set(t,true);
			t.u *= su;
			t.v *= sv;
		}
	}
	,triCount: function() {
		var n = h3d_prim_MeshPrimitive.prototype.triCount.call(this);
		if(n != 0) {
			return n;
		}
		return (this.idx == null ? this.points.length : this.idx.length) / 3 | 0;
	}
	,vertexCount: function() {
		return this.points.length;
	}
	,getCollider: function() {
		var vertexes = new Array(this.points.length * 3);
		var indexes = new Array(this.idx.length);
		var vid = 0;
		var _g = 0;
		var _g1 = this.points;
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			vertexes[vid++] = p.x;
			vertexes[vid++] = p.y;
			vertexes[vid++] = p.z;
		}
		var _g = 0;
		var _g1 = this.idx.length;
		while(_g < _g1) {
			var i = _g++;
			indexes[i] = this.idx[i];
		}
		var poly = new h3d_col_Polygon();
		poly.addBuffers(vertexes,indexes);
		return poly;
	}
	,render: function(engine) {
		if(this.buffer == null || this.buffer.vbuf == null) {
			this.alloc(engine);
		}
		var indexes = this.indexes;
		var count = this.triCount();
		if(indexes == null) {
			indexes = engine.mem.getTriIndexes(count * 3);
		}
		if(this.buffers != null) {
			engine.renderMultiBuffers(this.formats,this.buffers,indexes,0,count);
		} else {
			engine.renderIndexed(this.buffer,indexes,0,count);
		}
	}
	,__class__: h3d_prim_Polygon
});
var h3d_prim_Cube = function(x,y,z,centered) {
	if(centered == null) {
		centered = false;
	}
	if(z == null) {
		z = 1.;
	}
	if(y == null) {
		y = 1.;
	}
	if(x == null) {
		x = 1.;
	}
	this.sizeX = x;
	this.sizeY = y;
	this.sizeZ = z;
	var x1 = 0;
	var y1 = 0;
	var z1 = 0;
	if(z1 == null) {
		z1 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	var this1 = new h3d_VectorImpl(x1,y1,z1);
	var x1 = x;
	var y1 = 0;
	var z1 = 0;
	if(z1 == null) {
		z1 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	var this2 = new h3d_VectorImpl(x1,y1,z1);
	var x1 = 0;
	var y1 = y;
	var z1 = 0;
	if(z1 == null) {
		z1 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	var this3 = new h3d_VectorImpl(x1,y1,z1);
	var x1 = 0;
	var y1 = 0;
	var z1 = z;
	if(z1 == null) {
		z1 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	var this4 = new h3d_VectorImpl(x1,y1,z1);
	var x1 = x;
	var y1 = y;
	var z1 = 0;
	if(z1 == null) {
		z1 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	var this5 = new h3d_VectorImpl(x1,y1,z1);
	var x1 = x;
	var y1 = 0;
	var z1 = z;
	if(z1 == null) {
		z1 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	var this6 = new h3d_VectorImpl(x1,y1,z1);
	var x1 = 0;
	var y1 = y;
	var z1 = z;
	if(z1 == null) {
		z1 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	var this7 = new h3d_VectorImpl(x1,y1,z1);
	var x1 = x;
	var y1 = y;
	var z1 = z;
	if(z1 == null) {
		z1 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	var p = [this1,this2,this3,this4,this5,this6,this7,new h3d_VectorImpl(x1,y1,z1)];
	var idx = new Array(0);
	idx.push(0);
	idx.push(1);
	idx.push(5);
	idx.push(0);
	idx.push(5);
	idx.push(3);
	idx.push(1);
	idx.push(4);
	idx.push(7);
	idx.push(1);
	idx.push(7);
	idx.push(5);
	idx.push(3);
	idx.push(5);
	idx.push(7);
	idx.push(3);
	idx.push(7);
	idx.push(6);
	idx.push(0);
	idx.push(6);
	idx.push(2);
	idx.push(0);
	idx.push(3);
	idx.push(6);
	idx.push(2);
	idx.push(7);
	idx.push(4);
	idx.push(2);
	idx.push(6);
	idx.push(7);
	idx.push(0);
	idx.push(4);
	idx.push(1);
	idx.push(0);
	idx.push(2);
	idx.push(4);
	h3d_prim_Polygon.call(this,p,idx);
	if(centered) {
		this.translate(-x * 0.5,-y * 0.5,-z * 0.5);
	}
};
$hxClasses["h3d.prim.Cube"] = h3d_prim_Cube;
h3d_prim_Cube.__name__ = "h3d.prim.Cube";
h3d_prim_Cube.defaultUnitCube = function() {
	var engine = h3d_Engine.CURRENT;
	var c = engine.resCache.h[h3d_prim_Cube.__id__];
	if(c != null) {
		return c;
	}
	c = new h3d_prim_Cube(1,1,1);
	c.translate(-0.5,-0.5,-0.5);
	c.unindex();
	c.addNormals();
	c.addUniformUVs(1.0);
	c.addTangents();
	engine.resCache.set(h3d_prim_Cube,c);
	return c;
};
h3d_prim_Cube.__super__ = h3d_prim_Polygon;
h3d_prim_Cube.prototype = $extend(h3d_prim_Polygon.prototype,{
	addUVs: function() {
		this.unindex();
		var z = new h3d_prim_UV(0,1);
		var x = new h3d_prim_UV(1,1);
		var y = new h3d_prim_UV(0,0);
		var o = new h3d_prim_UV(1,0);
		this.uvs = [x,z,y,x,y,o,x,z,y,x,y,o,x,z,y,x,y,o,z,o,x,z,y,o,z,o,x,z,y,o,z,o,x,z,y,o];
	}
	,addUniformUVs: function(scale) {
		if(scale == null) {
			scale = 1.;
		}
		this.unindex();
		var v = scale;
		this.uvs = [new h3d_prim_UV(v * this.sizeX,v * this.sizeZ),new h3d_prim_UV(0,v * this.sizeZ),new h3d_prim_UV(0,0),new h3d_prim_UV(v * this.sizeX,v * this.sizeZ),new h3d_prim_UV(0,0),new h3d_prim_UV(v * this.sizeX,0),new h3d_prim_UV(v * this.sizeY,v * this.sizeZ),new h3d_prim_UV(0,v * this.sizeZ),new h3d_prim_UV(0,0),new h3d_prim_UV(v * this.sizeY,v * this.sizeZ),new h3d_prim_UV(0,0),new h3d_prim_UV(v * this.sizeY,0),new h3d_prim_UV(v * this.sizeX,v * this.sizeY),new h3d_prim_UV(0,v * this.sizeY),new h3d_prim_UV(0,0),new h3d_prim_UV(v * this.sizeX,v * this.sizeY),new h3d_prim_UV(0,0),new h3d_prim_UV(v * this.sizeX,0),new h3d_prim_UV(0,v * this.sizeZ),new h3d_prim_UV(v * this.sizeY,0),new h3d_prim_UV(v * this.sizeY,v * this.sizeZ),new h3d_prim_UV(0,v * this.sizeZ),new h3d_prim_UV(0,0),new h3d_prim_UV(v * this.sizeY,0),new h3d_prim_UV(0,v * this.sizeZ),new h3d_prim_UV(v * this.sizeX,0),new h3d_prim_UV(v * this.sizeX,v * this.sizeZ),new h3d_prim_UV(0,v * this.sizeZ),new h3d_prim_UV(0,0),new h3d_prim_UV(v * this.sizeX,0),new h3d_prim_UV(0,v * this.sizeY),new h3d_prim_UV(v * this.sizeX,0),new h3d_prim_UV(v * this.sizeX,v * this.sizeY),new h3d_prim_UV(0,v * this.sizeY),new h3d_prim_UV(0,0),new h3d_prim_UV(v * this.sizeX,0)];
	}
	,getCollider: function() {
		var x = this.translatedX;
		var y = this.translatedY;
		var z = this.translatedZ;
		var dx = this.sizeX * this.scaled;
		var dy = this.sizeY * this.scaled;
		var dz = this.sizeZ * this.scaled;
		var b = new h3d_col_Bounds();
		b.xMin = x;
		b.yMin = y;
		b.zMin = z;
		b.xMax = x + dx;
		b.yMax = y + dy;
		b.zMax = z + dz;
		return b;
	}
	,__class__: h3d_prim_Cube
});
var h3d_prim_HMDModel = function(data,dataPos,lib,lods) {
	this.lodConfig = null;
	h3d_prim_MeshPrimitive.call(this);
	this.lods = [data];
	if(lods != null) {
		var _g = 0;
		while(_g < lods.length) {
			var lod = lods[_g];
			++_g;
			this.lods.push(lib.header.geometries[lod.geometry]);
		}
	}
	this.dataPosition = dataPos;
	this.lib = lib;
	if(lib.header.shapes != null && lib.header.shapes.length > 0) {
		this.blendshape = new h3d_prim_Blendshape(this);
	}
	if(lib.header.colliders != null && lib.header.colliders.length > 0) {
		this.colliderData = h3d_prim_Collider.fromHmd(this);
	}
};
$hxClasses["h3d.prim.HMDModel"] = h3d_prim_HMDModel;
h3d_prim_HMDModel.__name__ = "h3d.prim.HMDModel";
h3d_prim_HMDModel.__super__ = h3d_prim_MeshPrimitive;
h3d_prim_HMDModel.prototype = $extend(h3d_prim_MeshPrimitive.prototype,{
	get_data: function() {
		return this.lods[0];
	}
	,hasInput: function(name) {
		if(!h3d_prim_MeshPrimitive.prototype.hasInput.call(this,name)) {
			return this.get_data().vertexFormat.hasInput(name);
		} else {
			return true;
		}
	}
	,triCount: function() {
		return this.get_data().get_indexCount() / 3 | 0;
	}
	,vertexCount: function() {
		return this.get_data().vertexCount;
	}
	,getBounds: function() {
		return this.get_data().bounds;
	}
	,selectMaterial: function(material,lod) {
		this.curMaterial = material + lod * this.get_data().indexCounts.length;
	}
	,getMaterialIndexStart: function(material,lod) {
		if(lod == null) {
			lod = 0;
		}
		return this.indexesTriPos[material + lod * this.get_data().indexCounts.length] * 3;
	}
	,getMaterialIndexCount: function(material,lod) {
		if(lod == null) {
			lod = 0;
		}
		return this.lods[lod].indexCounts[material];
	}
	,getDataBuffers: function(fmt,defaults,material) {
		return this.lib.getBuffers(this.get_data(),fmt,defaults,material);
	}
	,loadSkin: function(skin) {
		this.lib.loadSkin(this.get_data(),skin);
	}
	,alloc: function(engine) {
		this.dispose();
		var vertexCount = 0;
		var vertexFormat = this.get_data().vertexFormat;
		this.indexCount = 0;
		this.indexesTriPos = [];
		var _g = 0;
		var _g1 = this.lods;
		while(_g < _g1.length) {
			var lod = _g1[_g];
			++_g;
			vertexCount += lod.vertexCount;
			var _g2 = 0;
			var _g3 = lod.indexCounts;
			while(_g2 < _g3.length) {
				var n = _g3[_g2];
				++_g2;
				this.indexesTriPos.push(this.indexCount / 3 | 0);
				this.indexCount += n;
			}
		}
		this.buffer = new h3d_Buffer(vertexCount,vertexFormat);
		var is32 = vertexCount > 65536;
		this.indexes = h3d_Indexes._new(this.indexCount,is32);
		var indexStride = is32 ? 4 : 2;
		var entry = this.lib.resource.entry;
		var curVertexCount = 0;
		var curIndexCount = 0;
		var _g_current = 0;
		var _g_array = this.lods;
		while(_g_current < _g_array.length) {
			var _g_value = _g_array[_g_current];
			var _g_key = _g_current++;
			var i = _g_key;
			var lod = _g_value;
			if(lod.vertexFormat != vertexFormat) {
				var error = "LOD" + i + " has a different vertex format, has ";
				var _g_current1 = 0;
				var _g_array1 = lod.vertexFormat.inputs;
				while(_g_current1 < _g_array1.length) {
					var input = _g_array1[_g_current1++];
					error += input.name + " ";
				}
				error += ", wants ";
				var _g_current2 = 0;
				var _g_array2 = vertexFormat.inputs;
				while(_g_current2 < _g_array2.length) {
					var input1 = _g_array2[_g_current2++];
					error += input1.name + " ";
				}
				throw haxe_Exception.thrown(error);
			}
			var size = lod.vertexCount * vertexFormat.strideBytes;
			var bytes = entry.fetchBytes(this.dataPosition + lod.vertexPosition,size);
			engine.driver.uploadBufferBytes(this.buffer,curVertexCount,lod.vertexCount,bytes,0);
			var indexCount = lod.get_indexCount();
			var lodIs32 = lod.vertexCount > 65536;
			size = (lodIs32 ? 4 : 2) * indexCount;
			var inBytes = entry.fetchBytes(this.dataPosition + lod.indexPosition,size);
			var outBytes = is32 != lodIs32 ? new haxe_io_Bytes(new ArrayBuffer(indexCount * indexStride)) : inBytes;
			if(is32) {
				var _g = 0;
				var _g1 = indexCount;
				while(_g < _g1) {
					var i1 = _g++;
					if(lodIs32) {
						outBytes.setInt32(i1 << 2,inBytes.getInt32(i1 << 2) + curVertexCount);
					} else {
						outBytes.setInt32(i1 << 2,inBytes.getUInt16(i1 << 1) + curVertexCount);
					}
				}
			} else {
				var _g2 = 0;
				var _g3 = indexCount;
				while(_g2 < _g3) {
					var i2 = _g2++;
					if(lodIs32) {
						outBytes.setUInt16(i2 << 1,inBytes.getInt32(i2 << 2) + curVertexCount);
					} else {
						outBytes.setUInt16(i2 << 1,inBytes.getUInt16(i2 << 1) + curVertexCount);
					}
				}
			}
			engine.driver.uploadBufferBytes(this.indexes,curIndexCount,indexCount,outBytes,0);
			curVertexCount += lod.vertexCount;
			curIndexCount += indexCount;
		}
		if(this.normalsRecomputed != null) {
			var name = this.normalsRecomputed;
			this.normalsRecomputed = null;
			this.recomputeNormals(name);
		}
	}
	,recomputeNormals: function(name) {
		if(this.normalsRecomputed != null) {
			return;
		}
		if(name != null && this.get_data().vertexFormat.hasInput(name)) {
			return;
		}
		if(name == null) {
			name = "normal";
		}
		var v = hxd__$FloatBuffer_Float32Expand._new(0);
		var _g = 0;
		var _g1 = this.lods;
		while(_g < _g1.length) {
			var lod = _g1[_g];
			++_g;
			var pos = this.lib.getBuffers(lod,hxd_BufferFormat.get_POS3D());
			var ids = [];
			var pts = [];
			var mpts_h = { };
			var _g2 = 0;
			var _g3 = lod.vertexCount;
			while(_g2 < _g3) {
				var i = _g2++;
				var added = false;
				var px = pos.vertexes[i * 3];
				var py = pos.vertexes[i * 3 + 1];
				var pz = pos.vertexes[i * 3 + 2];
				var pid = (px + py + pz) * 10.01 | 0;
				var arr = mpts_h[pid];
				if(arr == null) {
					arr = [];
					mpts_h[pid] = arr;
				} else {
					var _g4 = 0;
					while(_g4 < arr.length) {
						var idx = arr[_g4];
						++_g4;
						var p = pts[idx];
						if(p.x == px && p.y == py && p.z == pz) {
							ids.push(idx);
							added = true;
							break;
						}
					}
				}
				if(!added) {
					ids.push(pts.length);
					arr.push(pts.length);
					var x = px;
					var y = py;
					var z = pz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					pts.push(new h3d_VectorImpl(x,y,z));
				}
			}
			var idx1 = new Array(0);
			var _g5 = 0;
			var _g6 = pos.indexes;
			while(_g5 < _g6.length) {
				var i1 = _g6[_g5];
				++_g5;
				idx1.push(ids[i1]);
			}
			var pol = new h3d_prim_Polygon(pts,idx1);
			pol.addNormals();
			var startOffset = v.pos;
			var _g7 = v.pos;
			var _g8 = lod.vertexCount * 3;
			while(_g7 < _g8) {
				var i2 = _g7++;
				if(v.pos == v.array.length) {
					var newSize = v.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					var newArray = new Float32Array(newSize);
					newArray.set(v.array);
					v.array = newArray;
				}
				v.array[v.pos++] = 0.;
			}
			var k = 0;
			var _g9 = 0;
			var _g10 = lod.vertexCount;
			while(_g9 < _g10) {
				var i3 = _g9++;
				var n = pol.normals[ids[i3]];
				v.array[startOffset + k++] = n.x;
				v.array[startOffset + k++] = n.y;
				v.array[startOffset + k++] = n.z;
			}
		}
		var buf = h3d_Buffer.ofFloats(v,hxd_BufferFormat.make([new hxd_BufferInput(name,3,0)]));
		this.addBuffer(buf);
		this.normalsRecomputed = name;
	}
	,addTangents: function() {
		if(this.hasInput("tangent")) {
			return;
		}
		var v = hxd__$FloatBuffer_Float32Expand._new(0);
		var _g = 0;
		var _g1 = this.lods;
		while(_g < _g1.length) {
			var lod = _g1[_g];
			++_g;
			var pos = this.lib.getBuffers(lod,hxd_BufferFormat.get_POS3D());
			var ids = [];
			var pts = [];
			var _g2 = 0;
			var _g3 = lod.vertexCount;
			while(_g2 < _g3) {
				var i = _g2++;
				var added = false;
				var px = pos.vertexes[i * 3];
				var py = pos.vertexes[i * 3 + 1];
				var pz = pos.vertexes[i * 3 + 2];
				var _g4 = 0;
				var _g5 = pts.length;
				while(_g4 < _g5) {
					var i1 = _g4++;
					var p = pts[i1];
					if(p.x == px && p.y == py && p.z == pz) {
						ids.push(i1);
						added = true;
						break;
					}
				}
				if(!added) {
					ids.push(pts.length);
					var x = px;
					var y = py;
					var z = pz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					pts.push(new h3d_VectorImpl(x,y,z));
				}
			}
			var idx = new Array(0);
			var _g6 = 0;
			var _g7 = pos.indexes;
			while(_g6 < _g7.length) {
				var i2 = _g7[_g6];
				++_g6;
				idx.push(ids[i2]);
			}
			var pol = new h3d_prim_Polygon(pts,idx);
			pol.addNormals();
			pol.addTangents();
			var startOffset = v.pos;
			var _g8 = v.pos;
			var _g9 = lod.vertexCount * 3;
			while(_g8 < _g9) {
				var i3 = _g8++;
				if(v.pos == v.array.length) {
					var newSize = v.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					var newArray = new Float32Array(newSize);
					newArray.set(v.array);
					v.array = newArray;
				}
				v.array[v.pos++] = 0.;
			}
			var k = 0;
			var _g10 = 0;
			var _g11 = lod.vertexCount;
			while(_g10 < _g11) {
				var i4 = _g10++;
				var t = pol.tangents[ids[i4]];
				v.array[startOffset + k++] = t.x;
				v.array[startOffset + k++] = t.y;
				v.array[startOffset + k++] = t.z;
			}
		}
		var buf = h3d_Buffer.ofFloats(v,hxd_BufferFormat.make([new hxd_BufferInput("tangent",3,0)]));
		this.addBuffer(buf);
	}
	,render: function(engine) {
		if(this.curMaterial < 0) {
			h3d_prim_MeshPrimitive.prototype.render.call(this,engine);
			return;
		}
		var materialCount = this.get_data().indexCounts.length;
		var lodLevel = this.curMaterial / this.get_data().indexCounts.length | 0;
		if(this.indexes == null || this.indexes.vbuf == null) {
			this.alloc(engine);
		}
		if(this.buffers == null) {
			engine.renderIndexed(this.buffer,this.indexes,this.indexesTriPos[this.curMaterial],this.lods[lodLevel].indexCounts[this.curMaterial % materialCount] / 3 | 0);
		} else {
			engine.renderMultiBuffers(this.formats,this.buffers,this.indexes,this.indexesTriPos[this.curMaterial],this.lods[lodLevel].indexCounts[this.curMaterial % materialCount] / 3 | 0);
		}
		this.curMaterial = -1;
	}
	,initCollider: function(poly) {
		var _this = this.get_data().bounds;
		var dx = _this.xMax - _this.xMin;
		var dy = _this.yMax - _this.yMin;
		var dz = _this.zMax - _this.zMin;
		var sphere = new h3d_col_Sphere((_this.xMin + _this.xMax) * 0.5,(_this.yMin + _this.yMax) * 0.5,(_this.zMin + _this.zMax) * 0.5,Math.sqrt(dx * dx + dy * dy + dz * dz) * 0.5);
		if(this.colliderData == null) {
			var buf = this.lib.getBuffers(this.get_data(),hxd_BufferFormat.get_POS3D());
			poly.setData(buf.vertexes,buf.indexes);
			if(this.collider == null) {
				this.collider = new h3d_col_OptimizedCollider(sphere,poly);
			}
		} else {
			var buffers = this.colliderData.getBuffers();
			var hulls = [];
			hulls.length = buffers.length;
			var _g_current = 0;
			var _g_array = buffers;
			while(_g_current < _g_array.length) {
				var _g_value = _g_array[_g_current];
				var _g_key = _g_current++;
				var i = _g_key;
				var buf = _g_value;
				var p = new h3d_col_PolygonBuffer();
				p.source = poly.source;
				p.setData(buf.vertexes,buf.indexes);
				hulls[i] = p;
			}
			var convexHulls = new h3d_col_GroupCollider(hulls);
			this.collider = new h3d_col_OptimizedCollider(sphere,convexHulls);
		}
	}
	,getCollider: function() {
		if(this.collider != null) {
			return this.collider;
		}
		var poly = new h3d_col_PolygonBuffer();
		poly.source = { entry : this.lib.resource.entry, geometryName : null};
		var _g = 0;
		var _g1 = this.lib.header.models;
		while(_g < _g1.length) {
			var h = _g1[_g];
			++_g;
			if(this.lib.header.geometries[h.geometry] == this.get_data()) {
				poly.source.geometryName = h.name;
				break;
			}
		}
		this.initCollider(poly);
		return this.collider;
	}
	,lodCount: function() {
		return this.lods.length;
	}
	,screenRatioToLod: function(screenRatio) {
		var lodCount = this.lodCount();
		if(this.forcedLod >= 0) {
			var a = this.forcedLod;
			if(a > lodCount) {
				return lodCount;
			} else {
				return a;
			}
		}
		if(lodCount == 1) {
			return 0;
		}
		var lodConfig = this.getLodConfig();
		if(lodConfig != null) {
			var lodConfigHasCulling = lodConfig.length > lodCount - 1;
			if(lodConfigHasCulling && screenRatio < lodConfig[lodConfig.length - 1]) {
				return lodCount;
			}
			var lodLevel = 0;
			var maxIter = lodConfigHasCulling ? lodCount - 1 : lodConfig.length;
			var _g = 0;
			var _g1 = maxIter;
			while(_g < _g1) {
				var i = _g++;
				if(lodConfig[i] == 0.0) {
					return lodLevel;
				}
				if(lodConfig[i] > screenRatio) {
					++lodLevel;
				} else {
					break;
				}
			}
			return lodLevel;
		}
		return 0;
	}
	,getLodConfig: function() {
		if(this.lodConfig != null) {
			return this.lodConfig;
		}
		var d = this.lib.resource.entry.get_directory();
		if(d.indexOf("res/") < 0) {
			d = "res/" + d;
		}
		this.lodConfig = h3d_prim_ModelDatabase.current.getDefaultLodConfig(d);
		return this.lodConfig;
	}
	,__class__: h3d_prim_HMDModel
});
var h3d_prim_Instanced = function() {
	h3d_prim_Primitive.call(this);
	this.bounds = new h3d_col_Bounds();
	var _this = this.bounds;
	if(0 < _this.xMin) {
		_this.xMin = 0;
	}
	if(0 > _this.xMax) {
		_this.xMax = 0;
	}
	if(0 < _this.yMin) {
		_this.yMin = 0;
	}
	if(0 > _this.yMax) {
		_this.yMax = 0;
	}
	if(0 < _this.zMin) {
		_this.zMin = 0;
	}
	if(0 > _this.zMax) {
		_this.zMax = 0;
	}
	this.tmpBounds = new h3d_col_Bounds();
};
$hxClasses["h3d.prim.Instanced"] = h3d_prim_Instanced;
h3d_prim_Instanced.__name__ = "h3d.prim.Instanced";
h3d_prim_Instanced.__super__ = h3d_prim_Primitive;
h3d_prim_Instanced.prototype = $extend(h3d_prim_Primitive.prototype,{
	setMesh: function(m) {
		if(this.refCount > 0) {
			if(this.primitive != null) {
				this.primitive.decref();
			}
			m.incref();
		}
		this.primitive = m;
		this.baseBounds = m.getBounds();
		if(m.buffer == null || m.indexes == null) {
			m.alloc(h3d_Engine.CURRENT);
		}
	}
	,initBounds: function() {
		var _this = this.bounds;
		_this.xMin = 1e20;
		_this.xMax = -1e20;
		_this.yMin = 1e20;
		_this.yMax = -1e20;
		_this.zMin = 1e20;
		_this.zMax = -1e20;
	}
	,addInstanceBounds: function(absPos) {
		this.tmpBounds.load(this.baseBounds);
		this.tmpBounds.transform(absPos);
		var _this = this.bounds;
		var b = this.tmpBounds;
		if(b.xMin < _this.xMin) {
			_this.xMin = b.xMin;
		}
		if(b.xMax > _this.xMax) {
			_this.xMax = b.xMax;
		}
		if(b.yMin < _this.yMin) {
			_this.yMin = b.yMin;
		}
		if(b.yMax > _this.yMax) {
			_this.yMax = b.yMax;
		}
		if(b.zMin < _this.zMin) {
			_this.zMin = b.zMin;
		}
		if(b.zMax > _this.zMax) {
			_this.zMax = b.zMax;
		}
	}
	,dispose: function() {
	}
	,incref: function() {
		if(this.refCount == 0 && this.primitive != null) {
			this.primitive.incref();
		}
		h3d_prim_Primitive.prototype.incref.call(this);
	}
	,decref: function() {
		h3d_prim_Primitive.prototype.decref.call(this);
		if(this.refCount == 0 && this.primitive != null) {
			this.primitive.decref();
		}
	}
	,getBounds: function() {
		return this.bounds;
	}
	,screenRatioToLod: function(screenRatio) {
		return this.primitive.screenRatioToLod(screenRatio);
	}
	,setCommand: function(material,lod,count) {
		if(lod > this.primitive.lodCount() - 1) {
			this.commands.setCommand(0,0,0);
			return;
		}
		this.commands.setCommand(count,this.primitive.getMaterialIndexCount(material,lod),this.primitive.getMaterialIndexStart(material,lod));
	}
	,render: function(engine) {
		if(this.primitive.buffer == null || this.primitive.buffer.vbuf == null) {
			this.primitive.alloc(engine);
		}
		if(engine.needFlushTarget) {
			engine.doFlushTarget();
		}
		if(this.primitive.buffers == null) {
			engine.driver.selectBuffer(this.primitive.buffer);
		} else {
			engine.driver.selectMultiBuffers(this.primitive.formats,this.primitive.buffers);
		}
		var indexes = this.primitive.indexes;
		if(indexes == null) {
			indexes = engine.mem.getTriIndexes(this.triCount() * 3);
		}
		engine.renderInstanced(indexes,this.commands);
	}
	,__class__: h3d_prim_Instanced
});
var h3d_prim_ModelDatabase = function() {
};
$hxClasses["h3d.prim.ModelDatabase"] = h3d_prim_ModelDatabase;
h3d_prim_ModelDatabase.__name__ = "h3d.prim.ModelDatabase";
h3d_prim_ModelDatabase.prototype = {
	get_baseDir: function() {
		return "";
	}
	,getFilePath: function(directory) {
		if(directory == null || directory == "") {
			return h3d_prim_ModelDatabase.FILE_NAME;
		} else {
			return directory + "/" + h3d_prim_ModelDatabase.FILE_NAME;
		}
	}
	,getRootData: function(directory) {
		if(directory == null) {
			return null;
		}
		var cached = h3d_prim_ModelDatabase.db.h[directory];
		if(cached != null) {
			return cached;
		}
		var file = this.getFilePath(directory);
		var value;
		try {
			value = JSON.parse(hxd_res_Loader.currentInstance.load(file).toText());
		} catch( _g ) {
			if(((haxe_Exception.caught(_g).unwrap()) instanceof hxd_fs_NotFound)) {
				value = { };
			} else {
				throw _g;
			}
		}
		h3d_prim_ModelDatabase.db.h[directory] = value;
		return value;
	}
	,getModelData: function(directory,resourceName,modelName) {
		var key = resourceName + "/" + modelName;
		var rootData = this.getRootData(directory);
		this.cleanOldModelData(rootData,key);
		return Reflect.field(rootData,key);
	}
	,saveModelData: function(directory,resourceName,modelName,data) {
		var file = this.getFilePath(directory);
		var rootData = this.getRootData(directory);
		var key = resourceName + "/" + modelName;
		if(data == null || Reflect.fields(data).length == 0) {
			Reflect.deleteField(rootData,key);
		} else {
			rootData[key] = data;
		}
		throw haxe_Exception.thrown("Can't save model props database " + file);
	}
	,getDefaultLodConfig: function(dir) {
		var value = hxd_res_Loader.currentInstance.fs;
		var fs = ((value) instanceof hxd_fs_LocalFileSystem) ? value : null;
		if(fs == null) {
			return h3d_prim_ModelDatabase.baseLodConfig;
		}
		return h3d_prim_ModelDatabase.baseLodConfig;
	}
	,cleanOldModelData: function(rootData,key) {
		var oldLodConfig = Reflect.field(rootData,h3d_prim_ModelDatabase.LOD_CONFIG);
		if(oldLodConfig != null) {
			var _g = 0;
			var _g1 = Reflect.fields(oldLodConfig);
			while(_g < _g1.length) {
				var f = _g1[_g];
				++_g;
				if(key.indexOf(f) < 0) {
					continue;
				}
				var c = Reflect.field(oldLodConfig,f);
				var newData = { "lodConfig" : c};
				rootData[key] = newData;
				Reflect.deleteField(oldLodConfig,f);
				rootData[h3d_prim_ModelDatabase.LOD_CONFIG] = oldLodConfig;
			}
			if(oldLodConfig == null || Reflect.fields(oldLodConfig).length == 0) {
				Reflect.deleteField(rootData,h3d_prim_ModelDatabase.LOD_CONFIG);
			}
		}
	}
	,loadLodConfig: function(input,data) {
		var c = Reflect.field(data,h3d_prim_ModelDatabase.LOD_CONFIG);
		if(c == null || input.hmd == null) {
			return;
		}
		input.hmd.lodConfig = c;
	}
	,loadDynamicBonesConfig: function(input,data) {
		var c = Reflect.field(data,h3d_prim_ModelDatabase.DYN_BONES_CONFIG);
		if(c == null || input.skin == null) {
			return;
		}
		var getJointConf = function(j) {
			var _g = 0;
			while(_g < c.length) {
				var jConf = c[_g];
				++_g;
				if(jConf.name == j.name) {
					return jConf;
				}
			}
			return null;
		};
		var skinData = input.skin.getSkinData();
		var _g = 0;
		var _g1 = skinData.allJoints;
		while(_g < _g1.length) {
			var j = _g1[_g];
			++_g;
			var jConf = getJointConf(j);
			if(jConf == null) {
				continue;
			}
			var newJ = new h3d_anim_DynamicJoint();
			newJ.index = j.index;
			newJ.name = j.name;
			newJ.bindIndex = j.bindIndex;
			newJ.splitIndex = j.splitIndex;
			newJ.defMat = j.defMat;
			newJ.transPos = j.transPos;
			newJ.parent = j.parent;
			newJ.follow = j.follow;
			newJ.subs = j.subs;
			newJ.offsets = j.offsets;
			newJ.offsetRay = j.offsetRay;
			newJ.retargetAnim = j.retargetAnim;
			newJ.damping = jConf.damping;
			newJ.resistance = jConf.resistance;
			newJ.slackness = jConf.slackness;
			newJ.stiffness = jConf.stiffness;
			newJ.additive = jConf.additive;
			var tmp;
			if(jConf.lockAxis == null) {
				var x = 0;
				var y = 0;
				var z = 0;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				tmp = new h3d_VectorImpl(x,y,z);
			} else {
				var tmp1 = jConf.lockAxis;
				var x1 = tmp1 != null ? tmp1.x : null;
				var tmp2 = jConf.lockAxis;
				var y1 = tmp2 != null ? tmp2.y : null;
				var tmp3 = jConf.lockAxis;
				var z1 = tmp3 != null ? tmp3.z : null;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				tmp = new h3d_VectorImpl(x1,y1,z1);
			}
			newJ.lockAxis = tmp;
			var x2 = jConf.globalForce.x;
			var y2 = jConf.globalForce.y;
			var z2 = jConf.globalForce.z;
			if(z2 == null) {
				z2 = 0.;
			}
			if(y2 == null) {
				y2 = 0.;
			}
			if(x2 == null) {
				x2 = 0.;
			}
			newJ.globalForce = new h3d_VectorImpl(x2,y2,z2);
			skinData.allJoints[j.index] = newJ;
			var tmp4 = j.parent;
			if(tmp4 != null) {
				tmp4.subs.push(newJ);
			}
			var tmp5 = j.parent;
			if(tmp5 != null) {
				HxOverrides.remove(tmp5.subs,j);
			}
			if(newJ.subs != null) {
				var _g2 = 0;
				var _g3 = newJ.subs;
				while(_g2 < _g3.length) {
					var s = _g3[_g2];
					++_g2;
					s.parent = newJ;
				}
			}
		}
		input.skin.setSkinData(skinData);
	}
	,saveLodConfig: function(input,data) {
		var isDefaultConfig = true;
		var defaultConfig = this.getDefaultLodConfig(input.resourceDirectory);
		if(input.hmd.lodConfig != null) {
			if(defaultConfig.length != input.hmd.lodConfig.length) {
				isDefaultConfig = false;
			}
			var _g = 0;
			var _g1 = input.hmd.lodConfig.length;
			while(_g < _g1) {
				var idx = _g++;
				if(defaultConfig[idx] != input.hmd.lodConfig[idx]) {
					isDefaultConfig = false;
					break;
				}
			}
		}
		if(!isDefaultConfig) {
			var c = [];
			var _g = 0;
			var _g1 = input.hmd.lodCount();
			while(_g < _g1) {
				var idx = _g++;
				if(idx >= input.hmd.lodConfig.length) {
					c[idx] = 0.;
				} else {
					c[idx] = input.hmd.lodConfig[idx];
				}
			}
			data[h3d_prim_ModelDatabase.LOD_CONFIG] = c;
		} else {
			Reflect.deleteField(data,h3d_prim_ModelDatabase.LOD_CONFIG);
		}
	}
	,saveDynamicBonesConfig: function(input,data) {
		if(input.skin == null) {
			return;
		}
		var dynamicJoints = [];
		var _g = 0;
		var _g1 = input.skin.getSkinData().allJoints;
		while(_g < _g1.length) {
			var j = _g1[_g];
			++_g;
			var dynJ = ((j) instanceof h3d_anim_DynamicJoint) ? j : null;
			if(dynJ == null) {
				continue;
			}
			dynamicJoints.push({ name : dynJ.name, slackness : dynJ.slackness, stiffness : dynJ.stiffness, resistance : dynJ.resistance, damping : dynJ.damping, additive : dynJ.additive, globalForce : dynJ.globalForce, lockAxis : dynJ.lockAxis});
		}
		if(dynamicJoints.length == 0) {
			Reflect.deleteField(data,h3d_prim_ModelDatabase.DYN_BONES_CONFIG);
			return;
		}
		data[h3d_prim_ModelDatabase.DYN_BONES_CONFIG] = dynamicJoints;
	}
	,loadModelProps: function(input) {
		var data = this.getModelData(input.resourceDirectory,input.resourceName,input.objectName);
		if(data == null) {
			return;
		}
		this.loadLodConfig(input,data);
		this.loadDynamicBonesConfig(input,data);
	}
	,saveModelProps: function(input) {
		var data = this.getModelData(input.resourceDirectory,input.resourceName,input.objectName);
		if(data == null) {
			data = { };
		}
		this.saveLodConfig(input,data);
		this.saveDynamicBonesConfig(input,data);
		this.saveModelData(input.resourceDirectory,input.resourceName,input.objectName,data);
	}
	,__class__: h3d_prim_ModelDatabase
};
var h3d_prim_Plane2D = function() {
	h3d_prim_Primitive.call(this);
};
$hxClasses["h3d.prim.Plane2D"] = h3d_prim_Plane2D;
h3d_prim_Plane2D.__name__ = "h3d.prim.Plane2D";
h3d_prim_Plane2D.get = function() {
	var engine = h3d_Engine.CURRENT;
	var inst = engine.resCache.h[h3d_prim_Plane2D.__id__];
	if(inst == null) {
		inst = new h3d_prim_Plane2D();
		engine.resCache.set(h3d_prim_Plane2D,inst);
	}
	return inst;
};
h3d_prim_Plane2D.__super__ = h3d_prim_Primitive;
h3d_prim_Plane2D.prototype = $extend(h3d_prim_Primitive.prototype,{
	triCount: function() {
		return 2;
	}
	,vertexCount: function() {
		return 4;
	}
	,alloc: function(engine) {
		var v = hxd__$FloatBuffer_Float32Expand._new(0);
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = -1;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = -1;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 0;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 1;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = -1;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 1;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 0;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 0;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 1;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = -1;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 1;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 1;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 1;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 1;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 1;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 0;
		this.buffer = h3d_Buffer.ofFloats(v,hxd_BufferFormat.get_XY_UV());
	}
	,render: function(engine) {
		if(this.buffer == null || this.buffer.vbuf == null) {
			this.alloc(engine);
		}
		var b = this.buffer;
		engine.renderBuffer(b,engine.mem.getQuadIndexes(b.vertices),2,0,-1);
	}
	,__class__: h3d_prim_Plane2D
});
var h3d_prim_RawPrimitive = function(inf,persist) {
	if(persist == null) {
		persist = false;
	}
	h3d_prim_Primitive.call(this);
	this.onContextLost = function() {
		return inf;
	};
	this.bounds = inf.bounds;
	this.alloc(null);
	if(!persist) {
		this.onContextLost = null;
	}
};
$hxClasses["h3d.prim.RawPrimitive"] = h3d_prim_RawPrimitive;
h3d_prim_RawPrimitive.__name__ = "h3d.prim.RawPrimitive";
h3d_prim_RawPrimitive.__super__ = h3d_prim_Primitive;
h3d_prim_RawPrimitive.prototype = $extend(h3d_prim_Primitive.prototype,{
	alloc: function(engine) {
		if(this.onContextLost == null) {
			throw haxe_Exception.thrown("Cannot realloc " + Std.string(this));
		}
		var inf = this.onContextLost();
		this.buffer = h3d_Buffer.ofFloats(inf.vbuf,inf.format);
		this.vcount = this.buffer.vertices;
		this.tcount = inf.ibuf != null ? inf.ibuf.length / 3 | 0 : this.vcount / 3 | 0;
		if(inf.ibuf != null) {
			this.indexes = h3d_Indexes.alloc(inf.ibuf);
		} else if(this.indexes != null) {
			this.indexes.dispose();
			this.indexes = null;
		}
	}
	,getBounds: function() {
		if(this.bounds == null) {
			throw haxe_Exception.thrown("Bounds not defined for " + Std.string(this));
		}
		return this.bounds;
	}
	,triCount: function() {
		return this.tcount;
	}
	,vertexCount: function() {
		return this.vcount;
	}
	,__class__: h3d_prim_RawPrimitive
});
var h3d_prim_Sphere = function(ray,segsW,segsH,portion) {
	if(portion == null) {
		portion = 1.;
	}
	if(segsH == null) {
		segsH = 6;
	}
	if(segsW == null) {
		segsW = 8;
	}
	if(ray == null) {
		ray = 1.;
	}
	this.ray = ray;
	this.segsH = segsH;
	this.segsW = segsW;
	this.portion = portion;
	var dp = Math.PI * 2 / segsW;
	var pts = [];
	var idx = new Array(0);
	var _g = 0;
	var _g1 = segsH + 1;
	while(_g < _g1) {
		var y = _g++;
		var t = y / segsH * Math.PI * portion;
		var st = Math.sin(t);
		var pz = Math.cos(t);
		var p = 0.;
		var _g2 = 0;
		var _g3 = segsW + 1;
		while(_g2 < _g3) {
			var x = _g2++;
			var px = st * Math.cos(p);
			var py = st * Math.sin(p);
			var x1 = px * ray;
			var y1 = py * ray;
			var z = pz * ray;
			if(z == null) {
				z = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			pts.push(new h3d_VectorImpl(x1,y1,z));
			p += dp;
		}
	}
	var _g = 0;
	var _g1 = segsH;
	while(_g < _g1) {
		var y = _g++;
		var _g2 = 0;
		var _g3 = segsW;
		while(_g2 < _g3) {
			var x = _g2++;
			var v1 = x + 1 + y * (segsW + 1);
			var v2 = x + y * (segsW + 1);
			var v3 = x + (y + 1) * (segsW + 1);
			var v4 = x + 1 + (y + 1) * (segsW + 1);
			if(y != 0) {
				idx.push(v1);
				idx.push(v2);
				idx.push(v4);
			}
			if(y != segsH - 1 || portion != 1.) {
				idx.push(v2);
				idx.push(v3);
				idx.push(v4);
			}
		}
	}
	h3d_prim_Polygon.call(this,pts,idx);
};
$hxClasses["h3d.prim.Sphere"] = h3d_prim_Sphere;
h3d_prim_Sphere.__name__ = "h3d.prim.Sphere";
h3d_prim_Sphere.defaultUnitSphere = function() {
	var engine = h3d_Engine.CURRENT;
	var s = engine.resCache.h[h3d_prim_Sphere.__id__];
	if(s != null) {
		return s;
	}
	s = new h3d_prim_Sphere(1,16,16);
	s.addNormals();
	s.addUVs();
	engine.resCache.set(h3d_prim_Sphere,s);
	return s;
};
h3d_prim_Sphere.__super__ = h3d_prim_Polygon;
h3d_prim_Sphere.prototype = $extend(h3d_prim_Polygon.prototype,{
	getCollider: function() {
		return new h3d_col_Sphere(this.translatedX,this.translatedY,this.translatedZ,this.ray * this.scaled);
	}
	,addNormals: function() {
		this.normals = this.points;
	}
	,addUVs: function() {
		this.uvs = [];
		var _g = 0;
		var _g1 = this.segsH + 1;
		while(_g < _g1) {
			var y = _g++;
			var _g2 = 0;
			var _g3 = this.segsW + 1;
			while(_g2 < _g3) {
				var x = _g2++;
				this.uvs.push(new h3d_prim_UV(1 - x / this.segsW,y / this.segsH));
			}
		}
	}
	,__class__: h3d_prim_Sphere
});
var h3d_prim_UV = function(u,v) {
	this.u = u;
	this.v = v;
};
$hxClasses["h3d.prim.UV"] = h3d_prim_UV;
h3d_prim_UV.__name__ = "h3d.prim.UV";
h3d_prim_UV.prototype = {
	clone: function() {
		return new h3d_prim_UV(this.u,this.v);
	}
	,toString: function() {
		return "{" + hxd_Math.fmt(this.u) + "," + hxd_Math.fmt(this.v) + "}";
	}
	,__class__: h3d_prim_UV
};
var h3d_scene_Mesh = function(primitive,material,parent) {
	this.curScreenRatio = 1.0;
	this.inheritLod = false;
	h3d_scene_Object.call(this,parent);
	this.set_primitive(primitive);
	if(material == null) {
		material = h3d_mat_MaterialSetup.current.createMaterial();
		material.set_props(material.getDefaultProps());
	}
	this.material = material;
};
$hxClasses["h3d.scene.Mesh"] = h3d_scene_Mesh;
h3d_scene_Mesh.__name__ = "h3d.scene.Mesh";
h3d_scene_Mesh.__super__ = h3d_scene_Object;
h3d_scene_Mesh.prototype = $extend(h3d_scene_Object.prototype,{
	getMeshMaterials: function() {
		return [this.material];
	}
	,addBoundsRec: function(b,relativeTo) {
		h3d_scene_Object.prototype.addBoundsRec.call(this,b,relativeTo);
		if(this.primitive == null || (this.flags & 512) != 0) {
			return;
		}
		var bounds = this.primitive.getBounds();
		if(relativeTo == null) {
			var m = this.absPos;
			var b1 = new h3d_col_Bounds();
			b1.xMin = bounds.xMin;
			b1.xMax = bounds.xMax;
			b1.yMin = bounds.yMin;
			b1.yMax = bounds.yMax;
			b1.zMin = bounds.zMin;
			b1.zMax = bounds.zMax;
			var tmp = b1;
			tmp.transform(m);
			if(tmp.xMin < b.xMin) {
				b.xMin = tmp.xMin;
			}
			if(tmp.xMax > b.xMax) {
				b.xMax = tmp.xMax;
			}
			if(tmp.yMin < b.yMin) {
				b.yMin = tmp.yMin;
			}
			if(tmp.yMax > b.yMax) {
				b.yMax = tmp.yMax;
			}
			if(tmp.zMin < b.zMin) {
				b.zMin = tmp.zMin;
			}
			if(tmp.zMax > b.zMax) {
				b.zMax = tmp.zMax;
			}
		} else {
			h3d_scene_Mesh.tmpMat.multiply(this.absPos,relativeTo);
			var m = h3d_scene_Mesh.tmpMat;
			var b1 = new h3d_col_Bounds();
			b1.xMin = bounds.xMin;
			b1.xMax = bounds.xMax;
			b1.yMin = bounds.yMin;
			b1.yMax = bounds.yMax;
			b1.zMin = bounds.zMin;
			b1.zMax = bounds.zMax;
			var tmp = b1;
			tmp.transform(m);
			if(tmp.xMin < b.xMin) {
				b.xMin = tmp.xMin;
			}
			if(tmp.xMax > b.xMax) {
				b.xMax = tmp.xMax;
			}
			if(tmp.yMin < b.yMin) {
				b.yMin = tmp.yMin;
			}
			if(tmp.yMax > b.yMax) {
				b.yMax = tmp.yMax;
			}
			if(tmp.zMin < b.zMin) {
				b.zMin = tmp.zMin;
			}
			if(tmp.zMax > b.zMax) {
				b.zMax = tmp.zMax;
			}
		}
	}
	,clone: function(o) {
		var m = o == null ? new h3d_scene_Mesh(null,this.material) : o;
		m.set_primitive(this.primitive);
		m.material = this.material.clone();
		h3d_scene_Object.prototype.clone.call(this,m);
		return m;
	}
	,getLocalCollider: function() {
		return this.primitive.getCollider();
	}
	,draw: function(ctx) {
		this.primitive.selectMaterial(0,this.primitive.screenRatioToLod(this.curScreenRatio));
		this.primitive.render(ctx.engine);
	}
	,calcScreenRatio: function(ctx) {
		if(this.primitive == null || this.primitive.lodCount() == 1) {
			return;
		}
		if(ctx.forcedScreenRatio >= 0.0) {
			this.curScreenRatio = ctx.forcedScreenRatio;
			return;
		}
		var bounds = this.primitive.getBounds();
		if(bounds == null) {
			this.curScreenRatio = 1.0;
			return;
		}
		var absPos = this.getAbsPos();
		var _this = absPos;
		var x = 0.;
		var y = 0.;
		var z = 0.;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var worldCenter_x = x;
		var worldCenter_y = y;
		var worldCenter_z = z;
		var x = _this._41;
		var y = _this._42;
		var z = _this._43;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		worldCenter_x = x;
		worldCenter_y = y;
		worldCenter_z = z;
		var _this = absPos;
		var x = 0.;
		var y = 0.;
		var z = 0.;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var worldScale_x = x;
		var worldScale_y = y;
		var worldScale_z = z;
		worldScale_x = Math.sqrt(_this._11 * _this._11 + _this._12 * _this._12 + _this._13 * _this._13);
		worldScale_y = Math.sqrt(_this._21 * _this._21 + _this._22 * _this._22 + _this._23 * _this._23);
		worldScale_z = Math.sqrt(_this._31 * _this._31 + _this._32 * _this._32 + _this._33 * _this._33);
		if(_this._11 * (_this._22 * _this._33 - _this._23 * _this._32) + _this._12 * (_this._23 * _this._31 - _this._21 * _this._33) + _this._13 * (_this._21 * _this._32 - _this._22 * _this._31) < 0) {
			worldScale_x *= -1;
			worldScale_y *= -1;
			worldScale_z *= -1;
		}
		var a = bounds.xMax - bounds.xMin;
		var a1 = bounds.yMax - bounds.yMin;
		var b = bounds.zMax - bounds.zMin;
		var b1 = a1 < b ? b : a1;
		var a1 = worldScale_x;
		var a2 = worldScale_y;
		var b = worldScale_z;
		var b2 = a2 < b ? b : a2;
		var worldRadius = (a < b1 ? b1 : a) * (a1 < b2 ? b2 : a1) / 2.0;
		var _this = ctx.camera;
		var x = 0.;
		var y = 0.;
		var z = 0.;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var cameraRight_x = x;
		var cameraRight_y = y;
		var cameraRight_z = z;
		if(_this.directions == null) {
			_this.directions = new h3d_MatrixImpl();
			_this.directions._44 = 0;
		}
		if(_this.directions._44 == 0) {
			_this.calcDirections();
		}
		cameraRight_x = _this.directions._21;
		cameraRight_y = _this.directions._22;
		cameraRight_z = _this.directions._23;
		var _this = ctx.camera;
		var x = 0.;
		var y = 0.;
		var z = 0.;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var cameraUp_x = x;
		var cameraUp_y = y;
		var cameraUp_z = z;
		if(_this.directions == null) {
			_this.directions = new h3d_MatrixImpl();
			_this.directions._44 = 0;
		}
		if(_this.directions._44 == 0) {
			_this.calcDirections();
		}
		cameraUp_x = _this.directions._31;
		cameraUp_y = _this.directions._32;
		cameraUp_z = _this.directions._33;
		var x = cameraUp_x - cameraRight_x;
		var y = cameraUp_y - cameraRight_y;
		var z = cameraUp_z - cameraRight_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var k = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		var x = _this_x * k;
		var y = _this_y * k;
		var z = _this_z * k;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var cameraTopLeft_x = x1;
		var cameraTopLeft_y = y1;
		var cameraTopLeft_z = z1;
		var x = cameraTopLeft_x * worldRadius;
		var y = cameraTopLeft_y * worldRadius;
		var z = cameraTopLeft_z * worldRadius;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var x = worldCenter_x + v_x;
		var y = worldCenter_y + v_y;
		var z = worldCenter_z + v_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var worldTopLeft_x = x1;
		var worldTopLeft_y = y1;
		var worldTopLeft_z = z1;
		var x = cameraTopLeft_x * worldRadius;
		var y = cameraTopLeft_y * worldRadius;
		var z = cameraTopLeft_z * worldRadius;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var x = worldCenter_x - v_x;
		var y = worldCenter_y - v_y;
		var z = worldCenter_z - v_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var worldBottomRight_x = x1;
		var worldBottomRight_y = y1;
		var worldBottomRight_z = z1;
		var snapToPixel = false;
		if(snapToPixel == null) {
			snapToPixel = true;
		}
		var x = 0.;
		var y = 0.;
		var z = 0.;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var screenTopLeft_x = x;
		var screenTopLeft_y = y;
		var screenTopLeft_z = z;
		var x = worldTopLeft_x;
		var y = worldTopLeft_y;
		var z = worldTopLeft_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		screenTopLeft_x = x;
		screenTopLeft_y = y;
		screenTopLeft_z = z;
		var m = ctx.camera.m;
		var px = screenTopLeft_x * m._11 + screenTopLeft_y * m._21 + screenTopLeft_z * m._31 + m._41;
		var py = screenTopLeft_x * m._12 + screenTopLeft_y * m._22 + screenTopLeft_z * m._32 + m._42;
		var pz = screenTopLeft_x * m._13 + screenTopLeft_y * m._23 + screenTopLeft_z * m._33 + m._43;
		var iw = 1 / (screenTopLeft_x * m._14 + screenTopLeft_y * m._24 + screenTopLeft_z * m._34 + m._44);
		screenTopLeft_x = px * iw;
		screenTopLeft_y = py * iw;
		screenTopLeft_z = pz * iw;
		screenTopLeft_x = (screenTopLeft_x + 1) * 0.5;
		screenTopLeft_y = (-screenTopLeft_y + 1) * 0.5;
		if(snapToPixel) {
			screenTopLeft_x = Math.round(screenTopLeft_x);
			screenTopLeft_y = Math.round(screenTopLeft_y);
		}
		var snapToPixel = false;
		if(snapToPixel == null) {
			snapToPixel = true;
		}
		var x = 0.;
		var y = 0.;
		var z = 0.;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var screenBottomRight_x = x;
		var screenBottomRight_y = y;
		var screenBottomRight_z = z;
		var x = worldBottomRight_x;
		var y = worldBottomRight_y;
		var z = worldBottomRight_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		screenBottomRight_x = x;
		screenBottomRight_y = y;
		screenBottomRight_z = z;
		var m = ctx.camera.m;
		var px = screenBottomRight_x * m._11 + screenBottomRight_y * m._21 + screenBottomRight_z * m._31 + m._41;
		var py = screenBottomRight_x * m._12 + screenBottomRight_y * m._22 + screenBottomRight_z * m._32 + m._42;
		var pz = screenBottomRight_x * m._13 + screenBottomRight_y * m._23 + screenBottomRight_z * m._33 + m._43;
		var iw = 1 / (screenBottomRight_x * m._14 + screenBottomRight_y * m._24 + screenBottomRight_z * m._34 + m._44);
		screenBottomRight_x = px * iw;
		screenBottomRight_y = py * iw;
		screenBottomRight_z = pz * iw;
		screenBottomRight_x = (screenBottomRight_x + 1) * 0.5;
		screenBottomRight_y = (-screenBottomRight_y + 1) * 0.5;
		if(snapToPixel) {
			screenBottomRight_x = Math.round(screenBottomRight_x);
			screenBottomRight_y = Math.round(screenBottomRight_y);
		}
		var a = screenBottomRight_x - screenTopLeft_x;
		var b = screenBottomRight_y - screenTopLeft_y;
		var screenArea = a < b ? b : a;
		this.curScreenRatio = screenArea * screenArea;
		if(this.inheritLod) {
			ctx.forcedScreenRatio = this.curScreenRatio;
		}
	}
	,emit: function(ctx) {
		this.calcScreenRatio(ctx);
		if(this.primitive.screenRatioToLod(this.curScreenRatio) >= this.primitive.lodCount()) {
			return;
		}
		var p = this.material.passes;
		while(p != null) {
			if(!p.culled) {
				ctx.emitPass(p,this).index = 0;
			}
			p = p.nextPass;
		}
	}
	,getMaterialByName: function(name) {
		if(this.material != null && this.material.name == name) {
			return this.material;
		}
		return h3d_scene_Object.prototype.getMaterialByName.call(this,name);
	}
	,getMaterials: function(a,recursive) {
		if(recursive == null) {
			recursive = true;
		}
		if(a == null) {
			a = [];
		}
		if(this.material != null && a.indexOf(this.material) < 0) {
			a.push(this.material);
		}
		return h3d_scene_Object.prototype.getMaterials.call(this,a,recursive);
	}
	,onAdd: function() {
		h3d_scene_Object.prototype.onAdd.call(this);
		if(this.primitive != null) {
			this.primitive.incref();
		}
	}
	,onRemove: function() {
		if(this.primitive != null) {
			this.primitive.decref();
		}
		h3d_scene_Object.prototype.onRemove.call(this);
	}
	,set_primitive: function(prim) {
		if(prim != this.primitive && (this.flags & 32) != 0) {
			if(this.primitive != null) {
				this.primitive.decref();
			}
			if(prim != null) {
				prim.incref();
			}
		}
		return this.primitive = prim;
	}
	,__class__: h3d_scene_Mesh
});
var h3d_scene_Graphics = function(parent) {
	this.lineSize = 0.;
	this.curR = 0.;
	this.curZ = 0.;
	this.curY = 0.;
	this.curX = 0.;
	this.bprim = new h3d_prim_BigPrimitive(hxd_BufferFormat.get_POS3D_NORMAL_UV_RGBA());
	this.bprim.isStatic = false;
	h3d_scene_Mesh.call(this,this.bprim,null,parent);
	this.tmpPoints = [];
	this.lineShader = new h3d_shader_LineShader();
	this.lineShader.setPriority(-100);
	var _this = this.material;
	_this.set_castShadows(false);
	_this.set_receiveShadows(false);
	this.material.passes.set_enableLights(false);
	this.material.passes.addShader(this.lineShader);
	var vcolor = new h3d_shader_VertexColorAlpha();
	vcolor.setPriority(-100);
	this.material.passes.addShader(vcolor);
	this.material.passes.set_culling(h3d_mat_Face.None);
};
$hxClasses["h3d.scene.Graphics"] = h3d_scene_Graphics;
h3d_scene_Graphics.__name__ = "h3d.scene.Graphics";
h3d_scene_Graphics.__super__ = h3d_scene_Mesh;
h3d_scene_Graphics.prototype = $extend(h3d_scene_Mesh.prototype,{
	onRemove: function() {
		h3d_scene_Mesh.prototype.onRemove.call(this);
		this.bprim.clear();
	}
	,set_is3D: function(v) {
		if(this.is3D == v) {
			return v;
		}
		if(v) {
			this.material.set_texture(h3d_mat_Texture.fromColor(-1));
			this.material.passes.removeShader(this.lineShader);
		} else {
			this.material.set_texture(null);
			this.material.passes.addShader(this.lineShader);
		}
		this.bprim.clear();
		this.tmpPoints = [];
		return this.is3D = v;
	}
	,flushLine: function() {
		var _gthis = this;
		var pts = this.tmpPoints;
		var last = pts.length - 1;
		var prev = pts[last];
		var p = pts[0];
		var closed = p.x == prev.x && p.y == prev.y && p.z == prev.z;
		var count = pts.length;
		if(!closed) {
			var prevLast = pts[last - 1];
			if(prevLast == null) {
				prevLast = p;
			}
			pts.push(new h3d_scene__$Graphics_GPoint(prev.x * 2 - prevLast.x,prev.y * 2 - prevLast.y,prev.z * 2 - prevLast.z,0,0,0,0));
			var pNext = pts[1];
			if(pNext == null) {
				pNext = p;
			}
			prev = new h3d_scene__$Graphics_GPoint(p.x * 2 - pNext.x,p.y * 2 - pNext.y,p.z * 2 - pNext.z,0,0,0,0);
		} else if(p != prev) {
			--count;
			--last;
			prev = pts[last];
		}
		var start = this.bprim.vertexCount();
		var pindex = start;
		var v = 0.;
		var _g = 0;
		var _g1 = count;
		while(_g < _g1) {
			var i = _g++;
			var next = pts[(i + 1) % pts.length];
			var nx1 = prev.y - p.y;
			var ny1 = p.x - prev.x;
			var ns1 = 1. / Math.sqrt(nx1 * nx1 + ny1 * ny1);
			var nx2 = p.y - next.y;
			var ny2 = next.x - p.x;
			var ns2 = 1. / Math.sqrt(nx2 * nx2 + ny2 * ny2);
			var nx = nx1 * ns1 + nx2 * ns2;
			var ny = ny1 * ns1 + ny2 * ns2;
			var ns = 1. / Math.sqrt(nx * nx + ny * ny);
			nx *= ns;
			ny *= ns;
			var size = nx * nx1 * ns1 + ny * ny1 * ns1;
			var d = this.lineSize * 0.5 / size;
			nx *= d;
			ny *= d;
			var hasIndex = i < count - 1 || closed;
			this.bprim.begin(2,hasIndex ? 6 : 0);
			var _this = _gthis.bprim;
			_this.tmpBuf.array[_this.bufPos++] = p.x + nx;
			var _this1 = _gthis.bprim;
			_this1.tmpBuf.array[_this1.bufPos++] = p.y + ny;
			var _this2 = _gthis.bprim;
			_this2.tmpBuf.array[_this2.bufPos++] = p.z;
			var _this3 = _gthis.bprim;
			_this3.tmpBuf.array[_this3.bufPos++] = 0;
			var _this4 = _gthis.bprim;
			_this4.tmpBuf.array[_this4.bufPos++] = 0;
			var _this5 = _gthis.bprim;
			_this5.tmpBuf.array[_this5.bufPos++] = 1;
			var _this6 = _gthis.bprim;
			_this6.tmpBuf.array[_this6.bufPos++] = 0;
			var _this7 = _gthis.bprim;
			_this7.tmpBuf.array[_this7.bufPos++] = v;
			var _this8 = _gthis.bprim;
			_this8.tmpBuf.array[_this8.bufPos++] = p.r;
			var _this9 = _gthis.bprim;
			_this9.tmpBuf.array[_this9.bufPos++] = p.g;
			var _this10 = _gthis.bprim;
			_this10.tmpBuf.array[_this10.bufPos++] = p.b;
			var _this11 = _gthis.bprim;
			_this11.tmpBuf.array[_this11.bufPos++] = p.a;
			var _this12 = _gthis.bprim;
			_this12.tmpBuf.array[_this12.bufPos++] = p.x - nx;
			var _this13 = _gthis.bprim;
			_this13.tmpBuf.array[_this13.bufPos++] = p.y - ny;
			var _this14 = _gthis.bprim;
			_this14.tmpBuf.array[_this14.bufPos++] = p.z;
			var _this15 = _gthis.bprim;
			_this15.tmpBuf.array[_this15.bufPos++] = 0;
			var _this16 = _gthis.bprim;
			_this16.tmpBuf.array[_this16.bufPos++] = 0;
			var _this17 = _gthis.bprim;
			_this17.tmpBuf.array[_this17.bufPos++] = 1;
			var _this18 = _gthis.bprim;
			_this18.tmpBuf.array[_this18.bufPos++] = 1;
			var _this19 = _gthis.bprim;
			_this19.tmpBuf.array[_this19.bufPos++] = v;
			var _this20 = _gthis.bprim;
			_this20.tmpBuf.array[_this20.bufPos++] = p.r;
			var _this21 = _gthis.bprim;
			_this21.tmpBuf.array[_this21.bufPos++] = p.g;
			var _this22 = _gthis.bprim;
			_this22.tmpBuf.array[_this22.bufPos++] = p.b;
			var _this23 = _gthis.bprim;
			_this23.tmpBuf.array[_this23.bufPos++] = p.a;
			v = 1 - v;
			if(hasIndex) {
				var pnext = i == last ? start - pindex : 2;
				var _this24 = this.bprim;
				_this24.tmpIdx[_this24.idxPos++] = _this24.startIndex;
				var _this25 = this.bprim;
				_this25.tmpIdx[_this25.idxPos++] = 1 + _this25.startIndex;
				var _this26 = this.bprim;
				_this26.tmpIdx[_this26.idxPos++] = pnext + _this26.startIndex;
				var _this27 = this.bprim;
				_this27.tmpIdx[_this27.idxPos++] = pnext + _this27.startIndex;
				var _this28 = this.bprim;
				_this28.tmpIdx[_this28.idxPos++] = 1 + _this28.startIndex;
				var _this29 = this.bprim;
				_this29.tmpIdx[_this29.idxPos++] = pnext + 1 + _this29.startIndex;
			}
			pindex += 2;
			prev = p;
			p = next;
		}
	}
	,flush: function() {
		if(this.tmpPoints.length == 0) {
			return;
		}
		if(this.is3D) {
			this.flushLine();
			this.tmpPoints = [];
		}
	}
	,sync: function(ctx) {
		h3d_scene_Mesh.prototype.sync.call(this,ctx);
		this.flush();
		this.bprim.flush();
	}
	,draw: function(ctx) {
		this.flush();
		this.bprim.flush();
		h3d_scene_Mesh.prototype.draw.call(this,ctx);
	}
	,clear: function() {
		this.flush();
		this.bprim.clear();
	}
	,lineStyle: function(size,color,alpha) {
		if(alpha == null) {
			alpha = 1.;
		}
		if(color == null) {
			color = 0;
		}
		if(size == null) {
			size = 0.;
		}
		this.flush();
		if(size > 0 && this.lineSize != size) {
			this.lineSize = size;
			if(!this.is3D) {
				this.lineShader.width__ = this.lineSize;
			}
		}
		this.setColor(color,alpha);
	}
	,setColorF: function(r,g,b,a) {
		if(a == null) {
			a = 1.;
		}
		this.curA = a;
		this.curR = r;
		this.curG = g;
		this.curB = b;
	}
	,setColor: function(color,alpha) {
		if(alpha == null) {
			alpha = 1.;
		}
		this.curA = alpha;
		this.curR = (color >> 16 & 255) / 255.;
		this.curG = (color >> 8 & 255) / 255.;
		this.curB = (color & 255) / 255.;
	}
	,drawLine: function(p1,p2) {
		this.moveTo(p1.x,p1.y,p1.z);
		this.lineTo(p2.x,p2.y,p2.z);
	}
	,moveTo: function(x,y,z) {
		if(this.is3D) {
			this.flush();
			this.lineTo(x,y,z);
		} else {
			this.curX = x;
			this.curY = y;
			this.curZ = z;
		}
	}
	,addVertex: function(x,y,z,r,g,b,a) {
		this.tmpPoints.push(new h3d_scene__$Graphics_GPoint(x,y,z,r,g,b,a));
	}
	,lineTo: function(x,y,z) {
		var _gthis = this;
		if(this.is3D) {
			var x1 = this.curX;
			var y1 = this.curY;
			var z1 = this.curZ;
			var _this = this.bprim.bounds;
			if(x1 < _this.xMin) {
				_this.xMin = x1;
			}
			if(x1 > _this.xMax) {
				_this.xMax = x1;
			}
			if(y1 < _this.yMin) {
				_this.yMin = y1;
			}
			if(y1 > _this.yMax) {
				_this.yMax = y1;
			}
			if(z1 < _this.zMin) {
				_this.zMin = z1;
			}
			if(z1 > _this.zMax) {
				_this.zMax = z1;
			}
			var _this = this.bprim.bounds;
			if(x < _this.xMin) {
				_this.xMin = x;
			}
			if(x > _this.xMax) {
				_this.xMax = x;
			}
			if(y < _this.yMin) {
				_this.yMin = y;
			}
			if(y > _this.yMax) {
				_this.yMax = y;
			}
			if(z < _this.zMin) {
				_this.zMin = z;
			}
			if(z > _this.zMax) {
				_this.zMax = z;
			}
			this.tmpPoints.push(new h3d_scene__$Graphics_GPoint(x,y,z,this.curR,this.curG,this.curB,this.curA));
			return;
		}
		this.bprim.begin(4,6);
		var nx = x - this.curX;
		var ny = y - this.curY;
		var nz = z - this.curZ;
		var x1 = this.curX;
		var y1 = this.curY;
		var z1 = this.curZ;
		var _this = this.bprim.bounds;
		if(x1 < _this.xMin) {
			_this.xMin = x1;
		}
		if(x1 > _this.xMax) {
			_this.xMax = x1;
		}
		if(y1 < _this.yMin) {
			_this.yMin = y1;
		}
		if(y1 > _this.yMax) {
			_this.yMax = y1;
		}
		if(z1 < _this.zMin) {
			_this.zMin = z1;
		}
		if(z1 > _this.zMax) {
			_this.zMax = z1;
		}
		var _this = this.bprim.bounds;
		if(x < _this.xMin) {
			_this.xMin = x;
		}
		if(x > _this.xMax) {
			_this.xMax = x;
		}
		if(y < _this.yMin) {
			_this.yMin = y;
		}
		if(y > _this.yMax) {
			_this.yMax = y;
		}
		if(z < _this.zMin) {
			_this.zMin = z;
		}
		if(z > _this.zMax) {
			_this.zMax = z;
		}
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curX;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curY;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curZ;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = nx;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = ny;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = nz;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = 0;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = 0;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curR;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curG;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curB;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curA;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curX;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curY;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curZ;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = nx;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = ny;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = nz;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = 0;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = 1;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curR;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curG;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curB;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curA;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curX;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curY;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curZ;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = nx;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = ny;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = nz;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = 1;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = 0;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curR;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curG;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curB;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curA;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curX;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curY;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curZ;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = nx;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = ny;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = nz;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = 1;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = 1;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curR;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curG;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curB;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curA;
		var _this = this.bprim;
		_this.tmpIdx[_this.idxPos++] = _this.startIndex;
		var _this = this.bprim;
		_this.tmpIdx[_this.idxPos++] = 1 + _this.startIndex;
		var _this = this.bprim;
		_this.tmpIdx[_this.idxPos++] = 2 + _this.startIndex;
		var _this = this.bprim;
		_this.tmpIdx[_this.idxPos++] = 2 + _this.startIndex;
		var _this = this.bprim;
		_this.tmpIdx[_this.idxPos++] = 3 + _this.startIndex;
		var _this = this.bprim;
		_this.tmpIdx[_this.idxPos++] = 1 + _this.startIndex;
		this.curX = x;
		this.curY = y;
		this.curZ = z;
	}
	,__class__: h3d_scene_Graphics
});
var h3d_scene_Box = function(color,bounds,depth,parent) {
	if(depth == null) {
		depth = true;
	}
	if(color == null) {
		color = -65536;
	}
	this.prevZMax = -1e9;
	this.prevYMax = -1e9;
	this.prevXMax = -1e9;
	this.prevZMin = 1e9;
	this.prevYMin = 1e9;
	this.prevXMin = 1e9;
	this.thickness = 1.0;
	h3d_scene_Graphics.call(this,parent);
	this.color = color;
	this.bounds = bounds;
	if(!depth) {
		this.material.passes.depth(true,h3d_mat_Compare.Always);
	}
};
$hxClasses["h3d.scene.Box"] = h3d_scene_Box;
h3d_scene_Box.__name__ = "h3d.scene.Box";
h3d_scene_Box.__super__ = h3d_scene_Graphics;
h3d_scene_Box.prototype = $extend(h3d_scene_Graphics.prototype,{
	clone: function(o) {
		var b;
		if(o == null) {
			var b1 = this.color;
			var _this = this.bounds;
			var b2 = new h3d_col_Bounds();
			b2.xMin = _this.xMin;
			b2.xMax = _this.xMax;
			b2.yMin = _this.yMin;
			b2.yMax = _this.yMax;
			b2.zMin = _this.zMin;
			b2.zMax = _this.zMax;
			b = new h3d_scene_Box(b1,b2,this.material.passes.depthWrite,null);
		} else {
			b = o;
		}
		h3d_scene_Graphics.prototype.clone.call(this,b);
		var _this = this.bounds;
		var b1 = new h3d_col_Bounds();
		b1.xMin = _this.xMin;
		b1.xMax = _this.xMax;
		b1.yMin = _this.yMin;
		b1.yMax = _this.yMax;
		b1.zMin = _this.zMin;
		b1.zMax = _this.zMax;
		b.bounds = b1;
		b.prevXMin = this.prevXMin;
		b.prevYMin = this.prevYMin;
		b.prevZMin = this.prevZMin;
		b.prevXMax = this.prevXMax;
		b.prevYMax = this.prevYMax;
		b.prevZMax = this.prevZMax;
		return b;
	}
	,getLocalCollider: function() {
		return null;
	}
	,sync: function(ctx) {
		if(this.bounds == null) {
			if(this.prevXMin == -0.5 && this.prevYMin == -0.5 && this.prevZMin == -0.5 && this.prevXMax == 0.5 && this.prevYMax == 0.5 && this.prevZMax == 0.5) {
				return;
			}
			this.prevXMin = -0.5;
			this.prevYMin = -0.5;
			this.prevZMin = -0.5;
			this.prevXMax = 0.5;
			this.prevYMax = 0.5;
			this.prevZMax = 0.5;
		} else {
			if(this.prevXMin == this.bounds.xMin && this.prevYMin == this.bounds.yMin && this.prevZMin == this.bounds.zMin && this.prevXMax == this.bounds.xMax && this.prevYMax == this.bounds.yMax && this.prevZMax == this.bounds.zMax) {
				return;
			}
			this.prevXMin = this.bounds.xMin;
			this.prevYMin = this.bounds.yMin;
			this.prevZMin = this.bounds.zMin;
			this.prevXMax = this.bounds.xMax;
			this.prevYMax = this.bounds.yMax;
			this.prevZMax = this.bounds.zMax;
		}
		this.clear();
		this.lineStyle(this.thickness,this.color);
		this.moveTo(this.prevXMin,this.prevYMin,this.prevZMin);
		this.lineTo(this.prevXMax,this.prevYMin,this.prevZMin);
		this.lineTo(this.prevXMax,this.prevYMax,this.prevZMin);
		this.lineTo(this.prevXMin,this.prevYMax,this.prevZMin);
		this.lineTo(this.prevXMin,this.prevYMin,this.prevZMin);
		this.lineTo(this.prevXMin,this.prevYMin,this.prevZMax);
		this.lineTo(this.prevXMax,this.prevYMin,this.prevZMax);
		this.lineTo(this.prevXMax,this.prevYMax,this.prevZMax);
		this.lineTo(this.prevXMin,this.prevYMax,this.prevZMax);
		this.lineTo(this.prevXMin,this.prevYMin,this.prevZMax);
		this.moveTo(this.prevXMax,this.prevYMin,this.prevZMin);
		this.lineTo(this.prevXMax,this.prevYMin,this.prevZMax);
		this.moveTo(this.prevXMin,this.prevYMax,this.prevZMin);
		this.lineTo(this.prevXMin,this.prevYMax,this.prevZMax);
		this.moveTo(this.prevXMax,this.prevYMax,this.prevZMin);
		this.lineTo(this.prevXMax,this.prevYMax,this.prevZMax);
		h3d_scene_Graphics.prototype.sync.call(this,ctx);
	}
	,__class__: h3d_scene_Box
});
var h3d_scene__$Graphics_GPoint = function(x,y,z,r,g,b,a) {
	this.x = x;
	this.y = y;
	this.z = z;
	this.r = r;
	this.g = g;
	this.b = b;
	this.a = a;
};
$hxClasses["h3d.scene._Graphics.GPoint"] = h3d_scene__$Graphics_GPoint;
h3d_scene__$Graphics_GPoint.__name__ = "h3d.scene._Graphics.GPoint";
h3d_scene__$Graphics_GPoint.prototype = {
	__class__: h3d_scene__$Graphics_GPoint
};
var h3d_scene_Interactive = function(shape,parent) {
	this.hitPoint = new h3d_Vector4Impl(0.,0.,0.,1.);
	this.lastClickFrame = -1;
	this.mouseDownButton = -1;
	this.emittedLastFrame = false;
	this.isAbsoluteShape = false;
	this.allowMultiClick = false;
	this.enableRightButton = false;
	this.propagateEvents = false;
	this.cancelEvents = false;
	h3d_scene_Object.call(this,parent);
	this.shape = shape;
	this.set_cursor(hxd_Cursor.Button);
};
$hxClasses["h3d.scene.Interactive"] = h3d_scene_Interactive;
h3d_scene_Interactive.__name__ = "h3d.scene.Interactive";
h3d_scene_Interactive.__interfaces__ = [hxd_Interactive];
h3d_scene_Interactive.setupDebugMaterial = function(debugObj) {
	var materials = debugObj.getMaterials();
	var _g = 0;
	while(_g < materials.length) {
		var m = materials[_g];
		++_g;
		var engine = h3d_Engine.CURRENT;
		if(engine.driver.hasFeature(h3d_impl_Feature.Wireframe)) {
			m.passes.set_wireframe(true);
		}
		m.set_castShadows(false);
		m.set_receiveShadows(false);
		m.mshader.color__.w = 0.7;
		m.set_blendMode(h2d_BlendMode.Alpha);
	}
};
h3d_scene_Interactive.__super__ = h3d_scene_Object;
h3d_scene_Interactive.prototype = $extend(h3d_scene_Object.prototype,{
	getPoint: function(ray,bestMatch) {
		var rold_px = ray.px;
		var rold_py = ray.py;
		var rold_pz = ray.pz;
		var rold_lx = ray.lx;
		var rold_ly = ray.ly;
		var rold_lz = ray.lz;
		var m = this.getInvPos();
		var x = ray.px;
		var y = ray.py;
		var z = ray.pz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var p_x = x1;
		var p_y = y1;
		var p_z = z1;
		var px = p_x * m._11 + p_y * m._21 + p_z * m._31 + m._41;
		var py = p_x * m._12 + p_y * m._22 + p_z * m._32 + m._42;
		var pz = p_x * m._13 + p_y * m._23 + p_z * m._33 + m._43;
		p_x = px;
		p_y = py;
		p_z = pz;
		ray.px = p_x;
		ray.py = p_y;
		ray.pz = p_z;
		var x = ray.lx;
		var y = ray.ly;
		var z = ray.lz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		ray.lx = _this_x;
		ray.ly = _this_y;
		ray.lz = _this_z;
		ray.normalize();
		var d = this.shape.rayIntersection(ray,bestMatch);
		if(d < 0) {
			ray.px = rold_px;
			ray.py = rold_py;
			ray.pz = rold_pz;
			ray.lx = rold_lx;
			ray.ly = rold_ly;
			ray.lz = rold_lz;
			return null;
		}
		var x = ray.px + d * ray.lx;
		var y = ray.py + d * ray.ly;
		var z = ray.pz + d * ray.lz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var pt = new h3d_VectorImpl(x,y,z);
		var m = this.getAbsPos();
		var px = pt.x * m._11 + pt.y * m._21 + pt.z * m._31 + m._41;
		var py = pt.x * m._12 + pt.y * m._22 + pt.z * m._32 + m._42;
		var pz = pt.x * m._13 + pt.y * m._23 + pt.z * m._33 + m._43;
		pt.x = px;
		pt.y = py;
		pt.z = pz;
		ray.px = rold_px;
		ray.py = rold_py;
		ray.pz = rold_pz;
		ray.lx = rold_lx;
		ray.ly = rold_ly;
		ray.lz = rold_lz;
		return pt;
	}
	,get_showDebug: function() {
		return this.debugObj != null;
	}
	,set_showDebug: function(val) {
		if(!val) {
			if(this.debugObj != null) {
				var _this = this.debugObj;
				if(_this != null && _this.parent != null) {
					_this.parent.removeChild(_this);
				}
			}
			this.debugObj = null;
			return false;
		}
		if(this.debugObj != null) {
			return true;
		}
		this.debugObj = this.shape.makeDebugObj();
		if(this.debugObj != null) {
			h3d_scene_Interactive.setupDebugMaterial(this.debugObj);
			var _this = this.debugObj;
			var b = this.isAbsoluteShape;
			if(b != ((_this.flags & 2048) != 0)) {
				var f = 1;
				var b1 = true;
				if(b1) {
					_this.flags |= f;
				} else {
					_this.flags &= ~f;
				}
				var c = b1;
				if(c && (_this.flags & 131072) != 0) {
					var f = 262144;
					_this.flags |= f;
				}
			}
			var f = 2048;
			if(b) {
				_this.flags |= f;
			} else {
				_this.flags &= ~f;
			}
			this.addChild(this.debugObj);
		}
		return this.debugObj != null;
	}
	,onAdd: function() {
		this.scene = this.getScene();
		if(this.scene != null) {
			this.scene.addEventTarget(this);
		}
		h3d_scene_Object.prototype.onAdd.call(this);
	}
	,onRemove: function() {
		if(this.scene != null) {
			this.scene.removeEventTarget(this);
			this.scene = null;
		}
		h3d_scene_Object.prototype.onRemove.call(this);
	}
	,sync: function(ctx) {
		h3d_scene_Object.prototype.sync.call(this,ctx);
		this.emittedLastFrame = false;
	}
	,emit: function(ctx) {
		h3d_scene_Object.prototype.emit.call(this,ctx);
		this.emittedLastFrame = true;
	}
	,preventClick: function() {
		this.mouseDownButton = -1;
	}
	,getInteractiveScene: function() {
		return this.scene;
	}
	,handleEvent: function(e) {
		if(this.propagateEvents) {
			e.propagate = true;
		}
		if(this.cancelEvents) {
			e.cancel = true;
		}
		switch(e.kind._hx_index) {
		case 0:
			if(this.enableRightButton || e.button == 0) {
				this.mouseDownButton = e.button;
				this.onPush(e);
				if(e.cancel) {
					this.mouseDownButton = -1;
				}
			}
			break;
		case 1:
			if(this.enableRightButton || e.button == 0) {
				this.onRelease(e);
				var frame = hxd_Timer.frameCount;
				if(this.mouseDownButton == e.button && (this.lastClickFrame != frame || this.allowMultiClick)) {
					this.onClick(e);
					this.lastClickFrame = frame;
				}
			}
			this.mouseDownButton = -1;
			break;
		case 2:
			this.onMove(e);
			break;
		case 3:
			this.onOver(e);
			break;
		case 4:
			this.onOut(e);
			break;
		case 5:
			this.onWheel(e);
			break;
		case 6:
			this.onFocus(e);
			break;
		case 7:
			this.onFocusLost(e);
			break;
		case 8:
			this.onKeyDown(e);
			break;
		case 9:
			this.onKeyUp(e);
			break;
		case 10:
			if(this.enableRightButton || e.button == 0) {
				this.onRelease(e);
				if(this.mouseDownButton == e.button) {
					this.onReleaseOutside(e);
				}
			}
			this.mouseDownButton = -1;
			break;
		case 11:
			this.onTextInput(e);
			break;
		case 12:
			this.onCheck(e);
			break;
		}
	}
	,set_cursor: function(c) {
		this.cursor = c;
		if(this.scene != null && this.scene.events != null) {
			this.scene.events.updateCursor(this);
		}
		return c;
	}
	,focus: function() {
		if(this.scene == null || this.scene.events == null) {
			return;
		}
		this.scene.events.focus(this);
	}
	,blur: function() {
		if(this.hasFocus()) {
			this.scene.events.blur();
		}
	}
	,isOver: function() {
		if(this.scene != null && this.scene.events != null) {
			return this.scene.events.overList.indexOf(this) != -1;
		} else {
			return false;
		}
	}
	,hasFocus: function() {
		if(this.scene != null && this.scene.events != null) {
			return this.scene.events.currentFocus == this;
		} else {
			return false;
		}
	}
	,onOver: function(e) {
	}
	,onOut: function(e) {
	}
	,onPush: function(e) {
	}
	,onRelease: function(e) {
	}
	,onReleaseOutside: function(e) {
	}
	,onClick: function(e) {
	}
	,onMove: function(e) {
	}
	,onWheel: function(e) {
	}
	,onFocus: function(e) {
	}
	,onFocusLost: function(e) {
	}
	,onKeyUp: function(e) {
	}
	,onKeyDown: function(e) {
	}
	,onCheck: function(e) {
	}
	,onTextInput: function(e) {
	}
	,__class__: h3d_scene_Interactive
});
var h3d_scene_Light = function(shader,parent) {
	h3d_scene_Object.call(this,parent);
	this.shader = shader;
};
$hxClasses["h3d.scene.Light"] = h3d_scene_Light;
h3d_scene_Light.__name__ = "h3d.scene.Light";
h3d_scene_Light.__super__ = h3d_scene_Object;
h3d_scene_Light.prototype = $extend(h3d_scene_Object.prototype,{
	get_color: function() {
		return new h3d_VectorImpl(0.,0.,0.);
	}
	,set_color: function(v) {
		return v;
	}
	,emit: function(ctx) {
		ctx.emitLight(this);
	}
	,getShadowDirection: function() {
		return null;
	}
	,__class__: h3d_scene_Light
});
var h3d_scene_LightSystem = function() {
	this.drawPasses = 0;
};
$hxClasses["h3d.scene.LightSystem"] = h3d_scene_LightSystem;
h3d_scene_LightSystem.__name__ = "h3d.scene.LightSystem";
h3d_scene_LightSystem.prototype = {
	initGlobals: function(globals) {
	}
	,initLights: function(ctx) {
		this.ctx = ctx;
		if(this.shadowLight == null || (this.shadowLight.flags & 32) == 0) {
			var l = ctx.lights;
			while(l != null) {
				var dir = l.getShadowDirection();
				if(dir != null) {
					this.shadowLight = l;
					break;
				}
				l = l.next;
			}
		}
	}
	,computeLight: function(obj,shaders) {
		return shaders;
	}
	,dispose: function() {
	}
	,__class__: h3d_scene_LightSystem
};
var h3d_scene_MultiMaterial = function(prim,mats,parent) {
	h3d_scene_Mesh.call(this,prim,mats == null ? null : mats[0],parent);
	this.materials = mats == null ? [this.material] : mats;
};
$hxClasses["h3d.scene.MultiMaterial"] = h3d_scene_MultiMaterial;
h3d_scene_MultiMaterial.__name__ = "h3d.scene.MultiMaterial";
h3d_scene_MultiMaterial.__super__ = h3d_scene_Mesh;
h3d_scene_MultiMaterial.prototype = $extend(h3d_scene_Mesh.prototype,{
	getMeshMaterials: function() {
		return this.materials.slice();
	}
	,clone: function(o) {
		var m = o == null ? new h3d_scene_MultiMaterial(null,this.materials) : o;
		m.materials = [];
		var _g = 0;
		var _g1 = this.materials;
		while(_g < _g1.length) {
			var mat = _g1[_g];
			++_g;
			m.materials.push(mat == null ? null : mat.clone());
		}
		h3d_scene_Mesh.prototype.clone.call(this,m);
		m.material = m.materials[0];
		return m;
	}
	,emit: function(ctx) {
		this.calcScreenRatio(ctx);
		if(this.primitive.screenRatioToLod(this.curScreenRatio) >= this.primitive.lodCount()) {
			return;
		}
		var _g = 0;
		var _g1 = this.materials.length;
		while(_g < _g1) {
			var i = _g++;
			var m = this.materials[i];
			if(m != null) {
				var index = i;
				if(index == null) {
					index = 0;
				}
				var p = m.passes;
				while(p != null) {
					if(!p.culled) {
						ctx.emitPass(p,this).index = index;
					}
					p = p.nextPass;
				}
			}
		}
	}
	,getMaterialByName: function(name) {
		var _g = 0;
		var _g1 = this.materials;
		while(_g < _g1.length) {
			var m = _g1[_g];
			++_g;
			if(m != null && m.name == name) {
				return m;
			}
		}
		return h3d_scene_Mesh.prototype.getMaterialByName.call(this,name);
	}
	,getMaterials: function(a,recursive) {
		if(recursive == null) {
			recursive = true;
		}
		if(a == null) {
			a = [];
		}
		var _g = 0;
		var _g1 = this.materials;
		while(_g < _g1.length) {
			var m = _g1[_g];
			++_g;
			if(m != null && a.indexOf(m) < 0) {
				a.push(m);
			}
		}
		if(recursive) {
			var _g = 0;
			var _g1 = this.children;
			while(_g < _g1.length) {
				var o = _g1[_g];
				++_g;
				o.getMaterials(a);
			}
		}
		return a;
	}
	,draw: function(ctx) {
		if(this.materials.length > 1) {
			this.primitive.selectMaterial(ctx.drawPass.index,this.primitive.screenRatioToLod(this.curScreenRatio));
		}
		this.primitive.render(ctx.engine);
	}
	,__class__: h3d_scene_MultiMaterial
});
var h3d_scene_ObjectFlags = {};
h3d_scene_ObjectFlags._new = function(value) {
	return value;
};
h3d_scene_ObjectFlags.toInt = function(this1) {
	return this1;
};
h3d_scene_ObjectFlags.has = function(this1,f) {
	return (this1 & f) != 0;
};
h3d_scene_ObjectFlags.set = function(this1,f,b) {
	if(b) {
		this1 |= f;
	} else {
		this1 &= ~f;
	}
	return b;
};
var h3d_scene__$RenderContext_SharedGlobal = function(gid,value) {
	this.gid = gid;
	this.value = value;
};
$hxClasses["h3d.scene._RenderContext.SharedGlobal"] = h3d_scene__$RenderContext_SharedGlobal;
h3d_scene__$RenderContext_SharedGlobal.__name__ = "h3d.scene._RenderContext.SharedGlobal";
h3d_scene__$RenderContext_SharedGlobal.prototype = {
	__class__: h3d_scene__$RenderContext_SharedGlobal
};
var h3d_scene_RenderContext = function(scene) {
	this.cameraFrustumUploaded = false;
	this.cameraFrustumBuffer = null;
	this.tmpComputeLink = new hxsl_ShaderList(null,null);
	this.forcedScreenRatio = -1;
	h3d_impl_RenderContext.call(this);
	this.scene = scene;
	this.cachedShaderList = [];
	this.cachedPassObjects = [];
	this.initGlobals();
};
$hxClasses["h3d.scene.RenderContext"] = h3d_scene_RenderContext;
h3d_scene_RenderContext.__name__ = "h3d.scene.RenderContext";
h3d_scene_RenderContext.__super__ = h3d_impl_RenderContext;
h3d_scene_RenderContext.prototype = $extend(h3d_impl_RenderContext.prototype,{
	setCamera: function(cam) {
		this.camera = cam;
		var v = cam.mcam;
		this.globals.map.h[this.cameraView_id] = v;
		var v = cam.zNear;
		this.globals.map.h[this.cameraNear_id] = v;
		var v = cam.zFar;
		this.globals.map.h[this.cameraFar_id] = v;
		var v = cam.mproj;
		this.globals.map.h[this.cameraProj_id] = v;
		var v = cam.pos;
		this.globals.map.h[this.cameraPos_id] = v;
		var x = cam.mproj._11;
		var y = cam.mproj._22;
		var z = cam.mproj._33;
		var w = cam.mproj._44;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var v = new h3d_Vector4Impl(x,y,z,w);
		this.globals.map.h[this.cameraProjDiag_id] = v;
		if(this.globals.map.h[this.cameraPreviousViewProj_id] == null) {
			var v = cam.m.clone();
			this.globals.map.h[this.cameraPreviousViewProj_id] = v;
		}
		if(this.globals.map.h[this.cameraJitterOffsets_id] == null) {
			var x = 0.0;
			var y = 0.0;
			var z = 0.0;
			var w = 0.0;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var v = new h3d_Vector4Impl(x,y,z,w);
			this.globals.map.h[this.cameraJitterOffsets_id] = v;
		}
		var v = cam.m;
		this.globals.map.h[this.cameraViewProj_id] = v;
		var v = this.camera.getInverseViewProj();
		this.globals.map.h[this.cameraInverseViewProj_id] = v;
	}
	,setupTarget: function() {
		var v = this.engine.driver.hasFeature(h3d_impl_Feature.BottomLeftCoords) && this.engine.getCurrentTarget() != null ? -1 : 1;
		this.globals.map.h[this.cameraProjFlip_id] = v;
	}
	,getCurrentPixelSize: function() {
		var t = this.engine.getCurrentTarget();
		var x = 2 / (t == null ? this.engine.width : t.width);
		var y = 2 / (t == null ? this.engine.height : t.height);
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,0.);
	}
	,emit: function(mat,obj,index) {
		if(index == null) {
			index = 0;
		}
		var p = mat.passes;
		while(p != null) {
			if(!p.culled) {
				this.emitPass(p,obj).index = index;
			}
			p = p.nextPass;
		}
	}
	,start: function() {
		this.lights = null;
		this.drawPass = null;
		this.passes = [];
		this.lights = null;
		this.cachedPos = 0;
		this.visibleFlag = true;
		this.forcedScreenRatio = -1;
		this.time += this.elapsedTime;
		this.frame++;
		this.setCurrent();
		this.engine = h3d_Engine.CURRENT;
		var v = this.time;
		this.globals.map.h[this.globalTime_id] = v;
		var v = this.getCurrentPixelSize();
		this.globals.map.h[this.pixelSize_id] = v;
		this.setCamera(this.scene.camera);
	}
	,nextPass: function() {
		this.cachedPos = 0;
		this.drawPass = null;
	}
	,getGlobal: function(name) {
		return this.globals.get(name);
	}
	,setGlobal: function(name,v) {
		this.globals.set(name,v);
	}
	,emitPass: function(pass,obj) {
		if((pass.rendererFlags & 1) == 0) {
			this.scene.renderer.setPassFlags(pass);
		}
		var o = this.allocPool;
		if(o == null) {
			o = new h3d_pass_PassObject();
			o.nextAlloc = this.allocFirst;
			this.allocFirst = o;
		} else {
			this.allocPool = o.nextAlloc;
		}
		o.pass = pass;
		o.obj = obj;
		if(this.passes.length <= pass.passId) {
			this.passes.length = pass.passId;
		}
		o.next = this.passes[pass.passId];
		this.passes[pass.passId] = o;
		return o;
	}
	,allocShaderList: function(s,next) {
		var sl = this.cachedShaderList[this.cachedPos++];
		if(sl == null) {
			sl = new hxsl_ShaderList(null);
			this.cachedShaderList[this.cachedPos - 1] = sl;
		}
		sl.s = s;
		sl.next = next;
		return sl;
	}
	,computeList: function(list) {
		if(this.computeLink != null) {
			throw haxe_Exception.thrown("Use computeDispatch to dispatch computeList");
		}
		this.computeLink = list;
	}
	,computeDispatch: function(shader,x,y,z) {
		if(z == null) {
			z = 1;
		}
		if(y == null) {
			y = 1;
		}
		if(x == null) {
			x = 1;
		}
		if(x <= 0 || y <= 0 || z <= 0) {
			throw haxe_Exception.thrown("Can't use zero or negative work groups count");
		}
		var prev = h3d_impl_RenderContext.get();
		if(prev != this) {
			this.start();
		}
		this.globals.maxChannels = 0;
		if(shader != null) {
			this.tmpComputeLink.s = shader;
			this.computeLink = this.tmpComputeLink;
		}
		var _g_l = this.computeLink;
		var _g_last = null;
		while(_g_l != _g_last) {
			var s = _g_l.s;
			_g_l = _g_l.next;
			var s1 = s;
			s1.updateConstants(this.globals);
		}
		var rt = hxsl_Cache.get().link(this.computeLink,hxsl_LinkMode.Compute);
		this.engine.driver.selectShader(rt);
		var buf = this.shaderBuffers;
		buf.vertex.grow(rt.vertex);
		if(rt.fragment != null) {
			buf.fragment.grow(rt.fragment);
		}
		this.fillGlobals(buf,rt);
		this.engine.uploadShaderBuffers(buf,0);
		this.fillParams(buf,rt,this.computeLink,true);
		this.engine.uploadShaderBuffers(buf,1);
		this.engine.uploadShaderBuffers(buf,2);
		this.engine.uploadShaderBuffers(buf,3);
		this.engine.driver.computeDispatch(x,y,z);
		this.engine.dispatches++;
		if(this.computeLink == this.tmpComputeLink) {
			this.tmpComputeLink.s = null;
		}
		this.computeLink = null;
		if(prev != this) {
			this.done();
			if(prev != null) {
				prev.setCurrent();
			}
		}
	}
	,emitLight: function(l) {
		l.next = this.lights;
		this.lights = l;
	}
	,getCameraFrustumBuffer: function() {
		if(this.cameraFrustumBuffer == null) {
			this.cameraFrustumBuffer = hxd_impl_Allocator.get().allocBuffer(6,hxd_BufferFormat.get_VEC4_DATA(),2);
		}
		if(!this.cameraFrustumUploaded) {
			var tmp = new haxe_io_Bytes(new ArrayBuffer(96));
			var frustum = this.camera.frustum;
			var plane = frustum.pleft;
			tmp.setFloat(0,plane.nx);
			tmp.setFloat(4,plane.ny);
			tmp.setFloat(8,plane.nz);
			tmp.setFloat(12,plane.d);
			var plane = frustum.pright;
			tmp.setFloat(16,plane.nx);
			tmp.setFloat(20,plane.ny);
			tmp.setFloat(24,plane.nz);
			tmp.setFloat(28,plane.d);
			var plane = frustum.ptop;
			tmp.setFloat(32,plane.nx);
			tmp.setFloat(36,plane.ny);
			tmp.setFloat(40,plane.nz);
			tmp.setFloat(44,plane.d);
			var plane = frustum.pbottom;
			tmp.setFloat(48,plane.nx);
			tmp.setFloat(52,plane.ny);
			tmp.setFloat(56,plane.nz);
			tmp.setFloat(60,plane.d);
			var plane = frustum.pfar;
			tmp.setFloat(64,plane.nx);
			tmp.setFloat(68,plane.ny);
			tmp.setFloat(72,plane.nz);
			tmp.setFloat(76,plane.d);
			var plane = frustum.pnear;
			tmp.setFloat(80,plane.nx);
			tmp.setFloat(84,plane.ny);
			tmp.setFloat(88,plane.nz);
			tmp.setFloat(92,plane.d);
			this.cameraFrustumBuffer.uploadBytes(tmp,0,6);
			this.cameraFrustumUploaded = true;
		}
		return this.cameraFrustumBuffer;
	}
	,uploadParams: function() {
		this.fillParams(this.shaderBuffers,this.drawPass.shader,this.drawPass.shaders);
		this.engine.uploadShaderBuffers(this.shaderBuffers,1);
		this.engine.uploadShaderBuffers(this.shaderBuffers,2);
		this.engine.uploadShaderBuffers(this.shaderBuffers,3);
	}
	,done: function() {
		this.drawPass = null;
		var p = this.allocFirst;
		while(p != null && p != this.allocPool) {
			p.obj = null;
			p.pass = null;
			p.shader = null;
			p.shaders = null;
			p.next = null;
			p.index = 0;
			p.texture = 0;
			p = p.nextAlloc;
		}
		if(this.allocPool != null) {
			this.allocFirst = this.allocFirst.nextAlloc;
		}
		this.allocPool = this.allocFirst;
		var _g = 0;
		var _g1 = this.cachedShaderList;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			c.s = null;
			c.next = null;
		}
		this.passes = [];
		this.lights = null;
		this.cameraFrustumUploaded = false;
		this.globals.map.h[this.cameraPreviousViewProj_id].load(this.globals.map.h[this.cameraViewProj_id]);
		this.computeVelocity = false;
		this.clearCurrent();
	}
	,dispose: function() {
		h3d_impl_RenderContext.prototype.dispose.call(this);
		if(this.cameraFrustumBuffer != null) {
			hxd_impl_Allocator.get().disposeBuffer(this.cameraFrustumBuffer);
		}
	}
	,get_cameraView: function() {
		return this.globals.map.h[this.cameraView_id];
	}
	,set_cameraView: function(v) {
		this.globals.map.h[this.cameraView_id] = v;
		return v;
	}
	,get_cameraNear: function() {
		return this.globals.map.h[this.cameraNear_id];
	}
	,set_cameraNear: function(v) {
		this.globals.map.h[this.cameraNear_id] = v;
		return v;
	}
	,get_cameraFar: function() {
		return this.globals.map.h[this.cameraFar_id];
	}
	,set_cameraFar: function(v) {
		this.globals.map.h[this.cameraFar_id] = v;
		return v;
	}
	,get_cameraProj: function() {
		return this.globals.map.h[this.cameraProj_id];
	}
	,set_cameraProj: function(v) {
		this.globals.map.h[this.cameraProj_id] = v;
		return v;
	}
	,get_cameraPos: function() {
		return this.globals.map.h[this.cameraPos_id];
	}
	,set_cameraPos: function(v) {
		this.globals.map.h[this.cameraPos_id] = v;
		return v;
	}
	,get_cameraProjDiag: function() {
		return this.globals.map.h[this.cameraProjDiag_id];
	}
	,set_cameraProjDiag: function(v) {
		this.globals.map.h[this.cameraProjDiag_id] = v;
		return v;
	}
	,get_cameraProjFlip: function() {
		return this.globals.map.h[this.cameraProjFlip_id];
	}
	,set_cameraProjFlip: function(v) {
		this.globals.map.h[this.cameraProjFlip_id] = v;
		return v;
	}
	,get_cameraViewProj: function() {
		return this.globals.map.h[this.cameraViewProj_id];
	}
	,set_cameraViewProj: function(v) {
		this.globals.map.h[this.cameraViewProj_id] = v;
		return v;
	}
	,get_cameraInverseViewProj: function() {
		return this.globals.map.h[this.cameraInverseViewProj_id];
	}
	,set_cameraInverseViewProj: function(v) {
		this.globals.map.h[this.cameraInverseViewProj_id] = v;
		return v;
	}
	,get_cameraPreviousViewProj: function() {
		return this.globals.map.h[this.cameraPreviousViewProj_id];
	}
	,set_cameraPreviousViewProj: function(v) {
		this.globals.map.h[this.cameraPreviousViewProj_id] = v;
		return v;
	}
	,get_cameraJitterOffsets: function() {
		return this.globals.map.h[this.cameraJitterOffsets_id];
	}
	,set_cameraJitterOffsets: function(v) {
		this.globals.map.h[this.cameraJitterOffsets_id] = v;
		return v;
	}
	,get_globalTime: function() {
		return this.globals.map.h[this.globalTime_id];
	}
	,set_globalTime: function(v) {
		this.globals.map.h[this.globalTime_id] = v;
		return v;
	}
	,get_pixelSize: function() {
		return this.globals.map.h[this.pixelSize_id];
	}
	,set_pixelSize: function(v) {
		this.globals.map.h[this.pixelSize_id] = v;
		return v;
	}
	,get_globalModelView: function() {
		return this.globals.map.h[this.globalModelView_id];
	}
	,set_globalModelView: function(v) {
		this.globals.map.h[this.globalModelView_id] = v;
		return v;
	}
	,get_globalModelViewInverse: function() {
		return this.globals.map.h[this.globalModelViewInverse_id];
	}
	,set_globalModelViewInverse: function(v) {
		this.globals.map.h[this.globalModelViewInverse_id] = v;
		return v;
	}
	,get_globalPreviousModelView: function() {
		return this.globals.map.h[this.globalPreviousModelView_id];
	}
	,set_globalPreviousModelView: function(v) {
		this.globals.map.h[this.globalPreviousModelView_id] = v;
		return v;
	}
	,initGlobals: function() {
		this.cameraView_id = hxsl_Globals.allocID("camera.view");
		this.cameraNear_id = hxsl_Globals.allocID("camera.zNear");
		this.cameraFar_id = hxsl_Globals.allocID("camera.zFar");
		this.cameraProj_id = hxsl_Globals.allocID("camera.proj");
		this.cameraPos_id = hxsl_Globals.allocID("camera.position");
		this.cameraProjDiag_id = hxsl_Globals.allocID("camera.projDiag");
		this.cameraProjFlip_id = hxsl_Globals.allocID("camera.projFlip");
		this.cameraViewProj_id = hxsl_Globals.allocID("camera.viewProj");
		this.cameraInverseViewProj_id = hxsl_Globals.allocID("camera.inverseViewProj");
		this.cameraPreviousViewProj_id = hxsl_Globals.allocID("camera.previousViewProj");
		this.cameraJitterOffsets_id = hxsl_Globals.allocID("camera.jitterOffsets");
		this.globalTime_id = hxsl_Globals.allocID("global.time");
		this.pixelSize_id = hxsl_Globals.allocID("global.pixelSize");
		this.globalModelView_id = hxsl_Globals.allocID("global.modelView");
		this.globalModelViewInverse_id = hxsl_Globals.allocID("global.modelViewInverse");
		this.globalPreviousModelView_id = hxsl_Globals.allocID("global.previousModelView");
	}
	,__class__: h3d_scene_RenderContext
});
var h3d_scene_PassObjects = function() {
	this.passes = new h3d_pass_PassList();
};
$hxClasses["h3d.scene.PassObjects"] = h3d_scene_PassObjects;
h3d_scene_PassObjects.__name__ = "h3d.scene.PassObjects";
h3d_scene_PassObjects.prototype = {
	__class__: h3d_scene_PassObjects
};
var h3d_scene_RenderMode = $hxEnums["h3d.scene.RenderMode"] = { __ename__:true,__constructs__:null
	,Default: {_hx_name:"Default",_hx_index:0,__enum__:"h3d.scene.RenderMode",toString:$estr}
	,LightProbe: {_hx_name:"LightProbe",_hx_index:1,__enum__:"h3d.scene.RenderMode",toString:$estr}
};
h3d_scene_RenderMode.__constructs__ = [h3d_scene_RenderMode.Default,h3d_scene_RenderMode.LightProbe];
h3d_scene_RenderMode.__empty_constructs__ = [h3d_scene_RenderMode.Default,h3d_scene_RenderMode.LightProbe];
var h3d_scene_Renderer = function() {
	this.shadows = true;
	this.renderMode = h3d_scene_RenderMode.Default;
	this.effects = [];
	this.debugging = false;
	this.hasSetTarget = false;
	this.emptyPasses = new h3d_pass_PassList();
	this.allPasses = [];
	this.passObjects = new haxe_ds_StringMap();
	this.set_props(this.getDefaultProps());
	var _g = this;
	var frontToBack = true;
	this.frontToBack = function(passes) {
		_g.depthSort(frontToBack,passes);
	};
	var _g1 = this;
	var frontToBack1 = false;
	this.backToFront = function(passes) {
		_g1.depthSort(frontToBack1,passes);
	};
};
$hxClasses["h3d.scene.Renderer"] = h3d_scene_Renderer;
h3d_scene_Renderer.__name__ = "h3d.scene.Renderer";
h3d_scene_Renderer.__super__ = hxd_impl_AnyProps;
h3d_scene_Renderer.prototype = $extend(hxd_impl_AnyProps.prototype,{
	getEffect: function(cl) {
		var _g = 0;
		var _g1 = this.effects;
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			var f1 = js_Boot.__downcastCheck(f,cl) ? f : null;
			if(f1 != null) {
				return f1;
			}
		}
		return null;
	}
	,dispose: function() {
		var _g = 0;
		var _g1 = this.allPasses;
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			p.dispose();
		}
		var _g = 0;
		var _g1 = this.effects;
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			f.dispose();
		}
		if(this.ctx.lightSystem != null) {
			this.ctx.lightSystem.dispose();
		}
		this.passObjects = new haxe_ds_StringMap();
	}
	,mark: function(id) {
	}
	,addShader: function(s) {
	}
	,getPass: function(c) {
		var _g = 0;
		var _g1 = this.allPasses;
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			if(js_Boot.__instanceof(p,c)) {
				return p;
			}
		}
		return null;
	}
	,getPassByName: function(name) {
		var _g = 0;
		var _g1 = this.allPasses;
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			if(p.name == name) {
				return p;
			}
		}
		return null;
	}
	,hasFeature: function(f) {
		return h3d_Engine.CURRENT.driver.hasFeature(f);
	}
	,getLightSystem: function() {
		return this.ctx.scene.lightSystem;
	}
	,depthSort: function(frontToBack,passes) {
		var cam = this.ctx.camera.m;
		var _g_o = passes.current;
		while(_g_o != null) {
			var tmp = _g_o;
			_g_o = _g_o.next;
			var p = tmp;
			var z = p.obj.absPos._41 * cam._13 + p.obj.absPos._42 * cam._23 + p.obj.absPos._43 * cam._33 + cam._43;
			var w = p.obj.absPos._41 * cam._14 + p.obj.absPos._42 * cam._24 + p.obj.absPos._43 * cam._34 + cam._44;
			p.depth = w > 0.0 ? z / w : -z / w;
		}
		if(frontToBack) {
			var list = passes.current;
			var tmp;
			if(list == null) {
				tmp = null;
			} else {
				var insize = 1;
				var nmerges;
				var psize = 0;
				var qsize = 0;
				var p;
				var q;
				var e;
				var tail;
				while(true) {
					p = list;
					list = null;
					tail = null;
					nmerges = 0;
					while(p != null) {
						++nmerges;
						q = p;
						psize = 0;
						var _g = 0;
						var _g1 = insize;
						while(_g < _g1) {
							var i = _g++;
							++psize;
							q = q.next;
							if(q == null) {
								break;
							}
						}
						qsize = insize;
						while(psize > 0 || qsize > 0 && q != null) {
							if(psize == 0) {
								e = q;
								q = q.next;
								--qsize;
							} else if(qsize == 0 || q == null || (p.pass.layer != q.pass.layer ? p.pass.layer - q.pass.layer : p.depth == q.depth ? 0 : p.depth > q.depth ? 1 : -1) <= 0) {
								e = p;
								p = p.next;
								--psize;
							} else {
								e = q;
								q = q.next;
								--qsize;
							}
							if(tail != null) {
								tail.next = e;
							} else {
								list = e;
							}
							tail = e;
						}
						p = q;
					}
					tail.next = null;
					if(nmerges <= 1) {
						break;
					}
					insize *= 2;
				}
				tmp = list;
			}
			passes.current = tmp;
		} else {
			var list = passes.current;
			var tmp;
			if(list == null) {
				tmp = null;
			} else {
				var insize = 1;
				var nmerges;
				var psize = 0;
				var qsize = 0;
				var p;
				var q;
				var e;
				var tail;
				while(true) {
					p = list;
					list = null;
					tail = null;
					nmerges = 0;
					while(p != null) {
						++nmerges;
						q = p;
						psize = 0;
						var _g = 0;
						var _g1 = insize;
						while(_g < _g1) {
							var i = _g++;
							++psize;
							q = q.next;
							if(q == null) {
								break;
							}
						}
						qsize = insize;
						while(psize > 0 || qsize > 0 && q != null) {
							if(psize == 0) {
								e = q;
								q = q.next;
								--qsize;
							} else if(qsize == 0 || q == null || (p.pass.layer != q.pass.layer ? p.pass.layer - q.pass.layer : p.depth == q.depth ? 0 : p.depth < q.depth ? 1 : -1) <= 0) {
								e = p;
								p = p.next;
								--psize;
							} else {
								e = q;
								q = q.next;
								--qsize;
							}
							if(tail != null) {
								tail.next = e;
							} else {
								list = e;
							}
							tail = e;
						}
						p = q;
					}
					tail.next = null;
					if(nmerges <= 1) {
						break;
					}
					insize *= 2;
				}
				tmp = list;
			}
			passes.current = tmp;
		}
	}
	,clear: function(color,depth,stencil) {
		this.ctx.engine.clear(color,depth,stencil);
	}
	,allocTarget: function(name,depth,size,format) {
		if(size == null) {
			size = 1.;
		}
		if(depth == null) {
			depth = true;
		}
		return this.ctx.textures.allocTarget(name,Math.round(this.ctx.engine.width * size),Math.round(this.ctx.engine.height * size),depth,format);
	}
	,copy: function(from,to,blend) {
		h3d_pass_Copy.run(from,to,blend);
	}
	,setTarget: function(tex,depthBinding) {
		if(depthBinding == null) {
			depthBinding = h3d_DepthBinding.ReadWrite;
		}
		if(this.hasSetTarget) {
			this.ctx.engine.popTarget();
		}
		this.ctx.engine.pushTarget(tex,null,null,depthBinding);
		this.hasSetTarget = true;
	}
	,setTargets: function(textures,depthBinding) {
		if(depthBinding == null) {
			depthBinding = h3d_DepthBinding.ReadWrite;
		}
		if(this.hasSetTarget) {
			this.ctx.engine.popTarget();
		}
		this.ctx.engine.pushTargets(textures,depthBinding);
		this.hasSetTarget = true;
	}
	,setDepth: function(depthBuffer) {
		if(this.hasSetTarget) {
			this.ctx.engine.popTarget();
		}
		this.ctx.engine.pushDepth(depthBuffer);
		this.hasSetTarget = true;
	}
	,resetTarget: function() {
		if(this.hasSetTarget) {
			this.ctx.engine.popTarget();
			this.hasSetTarget = false;
		}
	}
	,has: function(name) {
		return this.passObjects.h[name] != null;
	}
	,setPassFlags: function(pass) {
		pass.rendererFlags |= 1;
	}
	,get: function(name) {
		var p = this.passObjects.h[name];
		if(p == null) {
			return this.emptyPasses;
		}
		p.rendered = true;
		return p.passes;
	}
	,draw: function(name) {
		this.defaultPass.draw(this.get(name));
	}
	,render: function() {
		throw haxe_Exception.thrown("Not implemented");
	}
	,computeStatic: function() {
		throw haxe_Exception.thrown("Not implemented");
	}
	,start: function() {
	}
	,startEffects: function() {
		var _g = 0;
		var _g1 = this.effects;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			if(e.enabled) {
				e.start(this);
			}
		}
	}
	,process: function(passes) {
		this.hasSetTarget = false;
		var _g = 0;
		var _g1 = this.allPasses;
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			p.setContext(this.ctx);
		}
		var _g = 0;
		while(_g < passes.length) {
			var p = passes[_g];
			++_g;
			this.passObjects.h[p.name] = p;
		}
		this.ctx.textures.begin();
		if(this.ctx.computingStatic) {
			this.computeStatic();
		} else {
			this.render();
		}
		this.resetTarget();
		var _g = 0;
		while(_g < passes.length) {
			var p = passes[_g];
			++_g;
			this.passObjects.h[p.name] = null;
		}
	}
	,computeDispatch: function(shader,x,y,z) {
		if(z == null) {
			z = 1;
		}
		if(y == null) {
			y = 1;
		}
		if(x == null) {
			x = 1;
		}
		this.ctx.computeDispatch(shader,x,y,z);
	}
	,__class__: h3d_scene_Renderer
});
var h3d_scene_Scene = function(createRenderer,createLightSystem) {
	if(createLightSystem == null) {
		createLightSystem = true;
	}
	if(createRenderer == null) {
		createRenderer = true;
	}
	this.prevEngine = null;
	this.checkPasses = true;
	this.interactiveOffset = 0;
	this.ratioY = 1;
	this.ratioX = 1;
	this.offsetY = 0;
	this.offsetX = 0;
	h3d_scene_Object.call(this,null);
	this.window = hxd_Window.getInstance();
	this.eventListeners = [];
	this.hitInteractives = [];
	this.interactives = [];
	this.camera = new h3d_Camera();
	var engine = h3d_Engine.CURRENT;
	if(engine != null) {
		this.camera.screenRatio = engine.width / engine.height;
	}
	this.ctx = new h3d_scene_RenderContext(this);
	if(createRenderer) {
		this.set_renderer(h3d_mat_MaterialSetup.current.createRenderer());
	}
	if(createLightSystem) {
		this.lightSystem = h3d_mat_MaterialSetup.current.createLightSystem();
	}
};
$hxClasses["h3d.scene.Scene"] = h3d_scene_Scene;
h3d_scene_Scene.__name__ = "h3d.scene.Scene";
h3d_scene_Scene.__interfaces__ = [hxd_InteractiveScene,h3d_IDrawable];
h3d_scene_Scene.__super__ = h3d_scene_Object;
h3d_scene_Scene.prototype = $extend(h3d_scene_Object.prototype,{
	setEvents: function(events) {
		this.events = events;
	}
	,addEventListener: function(f) {
		this.eventListeners.push(f);
	}
	,removeEventListener: function(f) {
		var _g = 0;
		var _g1 = this.eventListeners;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			if(e == f) {
				HxOverrides.remove(this.eventListeners,e);
				return true;
			}
		}
		return false;
	}
	,dispatchListeners: function(event) {
		var _g = 0;
		var _g1 = this.eventListeners;
		while(_g < _g1.length) {
			var l = _g1[_g];
			++_g;
			l(event);
			if(!event.propagate) {
				break;
			}
		}
	}
	,set_renderer: function(r) {
		this.renderer = r;
		if(r != null) {
			r.ctx = this.ctx;
		}
		return r;
	}
	,sortHitPointByCameraDistance: function(i1,i2) {
		var z1 = i1.hitPoint.w;
		var z2 = i2.hitPoint.w;
		if(z1 > z2) {
			return -1;
		}
		return 1;
	}
	,dispatchEvent: function(event,to) {
		var i = to;
		i.handleEvent(event);
	}
	,isInteractiveVisible: function(i) {
		var o = i;
		while(o != this) {
			if(o == null || (o.flags & 2) == 0) {
				return false;
			}
			o = o.parent;
		}
		return true;
	}
	,handleEvent: function(event,last) {
		if(this.interactives.length == 0) {
			return null;
		}
		if(this.hitInteractives.length == 0) {
			var x = event.relX - this.offsetX;
			var y = event.relY - this.offsetY;
			var width = this.ratioX * this.window.get_width();
			var height = this.ratioY * this.window.get_height();
			var screenX = (x / width - 0.5) * 2;
			var screenY = -(y / height - 0.5) * 2;
			var p0 = this.camera.unproject(screenX,screenY,0);
			var p1 = this.camera.unproject(screenX,screenY,1);
			var x = p0.x;
			var y = p0.y;
			var z = p0.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var p1_x = x1;
			var p1_y = y1;
			var p1_z = z1;
			var x = p1.x;
			var y = p1.y;
			var z = p1.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var p2_x = x1;
			var p2_y = y1;
			var p2_z = z1;
			var r = new h3d_col_Ray();
			r.px = p1_x;
			r.py = p1_y;
			r.pz = p1_z;
			r.lx = p2_x - p1_x;
			r.ly = p2_y - p1_y;
			r.lz = p2_z - p1_z;
			r.normalize();
			var r1 = r;
			if(this.interactiveOffset != 0) {
				r1.px += r1.lx * this.interactiveOffset;
				r1.py += r1.ly * this.interactiveOffset;
				r1.pz += r1.lz * this.interactiveOffset;
			}
			var saveR_px = r1.px;
			var saveR_py = r1.py;
			var saveR_pz = r1.pz;
			var saveR_lx = r1.lx;
			var saveR_ly = r1.ly;
			var saveR_lz = r1.lz;
			var priority = -2147483648;
			var _g = 0;
			var _g1 = this.interactives;
			while(_g < _g1.length) {
				var i = _g1[_g];
				++_g;
				if(i.priority < priority) {
					continue;
				}
				var p = i;
				while(p != null && (p.flags & 2) != 0) p = p.parent;
				if(p != null) {
					continue;
				}
				if(!i.isAbsoluteShape) {
					var minv = i.getInvPos();
					var x = r1.px;
					var y = r1.py;
					var z = r1.pz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var p_x = x1;
					var p_y = y1;
					var p_z = z1;
					var px = p_x * minv._11 + p_y * minv._21 + p_z * minv._31 + minv._41;
					var py = p_x * minv._12 + p_y * minv._22 + p_z * minv._32 + minv._42;
					var pz = p_x * minv._13 + p_y * minv._23 + p_z * minv._33 + minv._43;
					p_x = px;
					p_y = py;
					p_z = pz;
					r1.px = p_x;
					r1.py = p_y;
					r1.pz = p_z;
					var x2 = r1.lx;
					var y2 = r1.ly;
					var z2 = r1.lz;
					if(z2 == null) {
						z2 = 0.;
					}
					if(y2 == null) {
						y2 = 0.;
					}
					if(x2 == null) {
						x2 = 0.;
					}
					var x3 = x2;
					var y3 = y2;
					var z3 = z2;
					if(z3 == null) {
						z3 = 0.;
					}
					if(y3 == null) {
						y3 = 0.;
					}
					if(x3 == null) {
						x3 = 0.;
					}
					var _this_x = x3;
					var _this_y = y3;
					var _this_z = z3;
					var px1 = _this_x * minv._11 + _this_y * minv._21 + _this_z * minv._31;
					var py1 = _this_x * minv._12 + _this_y * minv._22 + _this_z * minv._32;
					var pz1 = _this_x * minv._13 + _this_y * minv._23 + _this_z * minv._33;
					_this_x = px1;
					_this_y = py1;
					_this_z = pz1;
					r1.lx = _this_x;
					r1.ly = _this_y;
					r1.lz = _this_z;
					r1.normalize();
				}
				if(r1.lx != r1.lx) {
					r1.px = saveR_px;
					r1.py = saveR_py;
					r1.pz = saveR_pz;
					r1.lx = saveR_lx;
					r1.ly = saveR_ly;
					r1.lz = saveR_lz;
					continue;
				}
				var hit = i.shape.rayIntersection(r1,i.bestMatch);
				if(hit < 0) {
					r1.px = saveR_px;
					r1.py = saveR_py;
					r1.pz = saveR_pz;
					r1.lx = saveR_lx;
					r1.ly = saveR_ly;
					r1.lz = saveR_lz;
					continue;
				}
				var x4 = r1.px + hit * r1.lx;
				var y4 = r1.py + hit * r1.ly;
				var z4 = r1.pz + hit * r1.lz;
				if(z4 == null) {
					z4 = 0.;
				}
				if(y4 == null) {
					y4 = 0.;
				}
				if(x4 == null) {
					x4 = 0.;
				}
				var x5 = x4;
				var y5 = y4;
				var z5 = z4;
				if(z5 == null) {
					z5 = 0.;
				}
				if(y5 == null) {
					y5 = 0.;
				}
				if(x5 == null) {
					x5 = 0.;
				}
				var hitPoint_x = x5;
				var hitPoint_y = y5;
				var hitPoint_z = z5;
				r1.px = saveR_px;
				r1.py = saveR_py;
				r1.pz = saveR_pz;
				r1.lx = saveR_lx;
				r1.ly = saveR_ly;
				r1.lz = saveR_lz;
				i.hitPoint.x = hitPoint_x;
				i.hitPoint.y = hitPoint_y;
				i.hitPoint.z = hitPoint_z;
				if(i.priority > priority) {
					while(this.hitInteractives.length > 0) this.hitInteractives.pop();
					priority = i.priority;
				}
				this.hitInteractives.push(i);
			}
			if(this.hitInteractives.length == 0) {
				return null;
			}
			if(this.hitInteractives.length > 1) {
				var _g = 0;
				var _g1 = this.hitInteractives;
				while(_g < _g1.length) {
					var i = _g1[_g];
					++_g;
					var m = i.invPos;
					var wfactor = 0.;
					if(i.preciseShape != null || !i.bestMatch) {
						if(!i.isAbsoluteShape) {
							var x = r1.px;
							var y = r1.py;
							var z = r1.pz;
							if(z == null) {
								z = 0.;
							}
							if(y == null) {
								y = 0.;
							}
							if(x == null) {
								x = 0.;
							}
							var x1 = x;
							var y1 = y;
							var z1 = z;
							if(z1 == null) {
								z1 = 0.;
							}
							if(y1 == null) {
								y1 = 0.;
							}
							if(x1 == null) {
								x1 = 0.;
							}
							var p_x = x1;
							var p_y = y1;
							var p_z = z1;
							var px = p_x * m._11 + p_y * m._21 + p_z * m._31 + m._41;
							var py = p_x * m._12 + p_y * m._22 + p_z * m._32 + m._42;
							var pz = p_x * m._13 + p_y * m._23 + p_z * m._33 + m._43;
							p_x = px;
							p_y = py;
							p_z = pz;
							r1.px = p_x;
							r1.py = p_y;
							r1.pz = p_z;
							var x2 = r1.lx;
							var y2 = r1.ly;
							var z2 = r1.lz;
							if(z2 == null) {
								z2 = 0.;
							}
							if(y2 == null) {
								y2 = 0.;
							}
							if(x2 == null) {
								x2 = 0.;
							}
							var x3 = x2;
							var y3 = y2;
							var z3 = z2;
							if(z3 == null) {
								z3 = 0.;
							}
							if(y3 == null) {
								y3 = 0.;
							}
							if(x3 == null) {
								x3 = 0.;
							}
							var _this_x = x3;
							var _this_y = y3;
							var _this_z = z3;
							var px1 = _this_x * m._11 + _this_y * m._21 + _this_z * m._31;
							var py1 = _this_x * m._12 + _this_y * m._22 + _this_z * m._32;
							var pz1 = _this_x * m._13 + _this_y * m._23 + _this_z * m._33;
							_this_x = px1;
							_this_y = py1;
							_this_z = pz1;
							r1.lx = _this_x;
							r1.ly = _this_y;
							r1.lz = _this_z;
							r1.normalize();
						}
						var tmp = i.preciseShape;
						var hit = (tmp != null ? tmp : i.shape).rayIntersection(r1,true);
						if(hit > 0) {
							var x4 = r1.px + hit * r1.lx;
							var y4 = r1.py + hit * r1.ly;
							var z4 = r1.pz + hit * r1.lz;
							if(z4 == null) {
								z4 = 0.;
							}
							if(y4 == null) {
								y4 = 0.;
							}
							if(x4 == null) {
								x4 = 0.;
							}
							var x5 = x4;
							var y5 = y4;
							var z5 = z4;
							if(z5 == null) {
								z5 = 0.;
							}
							if(y5 == null) {
								y5 = 0.;
							}
							if(x5 == null) {
								x5 = 0.;
							}
							var hitPoint_x = x5;
							var hitPoint_y = y5;
							var hitPoint_z = z5;
							i.hitPoint.x = hitPoint_x;
							i.hitPoint.y = hitPoint_y;
							i.hitPoint.z = hitPoint_z;
						} else {
							wfactor = 1.;
						}
						r1.px = saveR_px;
						r1.py = saveR_py;
						r1.pz = saveR_pz;
						r1.lx = saveR_lx;
						r1.ly = saveR_ly;
						r1.lz = saveR_lz;
					}
					var _this = i.hitPoint;
					var x6 = _this.x;
					var y6 = _this.y;
					var z6 = _this.z;
					var w = _this.w;
					if(w == null) {
						w = 1.;
					}
					if(z6 == null) {
						z6 = 0.;
					}
					if(y6 == null) {
						y6 = 0.;
					}
					if(x6 == null) {
						x6 = 0.;
					}
					var x7 = x6;
					var y7 = y6;
					var z7 = z6;
					var w1 = w;
					if(w1 == null) {
						w1 = 1.;
					}
					if(z7 == null) {
						z7 = 0.;
					}
					if(y7 == null) {
						y7 = 0.;
					}
					if(x7 == null) {
						x7 = 0.;
					}
					var _this_x1 = x7;
					var _this_y1 = y7;
					var _this_z1 = z7;
					var _this_w = w1;
					_this_w = 1;
					if(!i.isAbsoluteShape) {
						var m1 = i.absPos;
						var px2 = _this_x1 * m1._11 + _this_y1 * m1._21 + _this_z1 * m1._31 + _this_w * m1._41;
						var py2 = _this_x1 * m1._12 + _this_y1 * m1._22 + _this_z1 * m1._32 + _this_w * m1._42;
						var pz2 = _this_x1 * m1._13 + _this_y1 * m1._23 + _this_z1 * m1._33 + _this_w * m1._43;
						_this_x1 = px2;
						_this_y1 = py2;
						_this_z1 = pz2;
					}
					var m2 = this.camera.m;
					var px3 = _this_x1 * m2._11 + _this_y1 * m2._21 + _this_z1 * m2._31 + _this_w * m2._41;
					var py3 = _this_x1 * m2._12 + _this_y1 * m2._22 + _this_z1 * m2._32 + _this_w * m2._42;
					var pz3 = _this_x1 * m2._13 + _this_y1 * m2._23 + _this_z1 * m2._33 + _this_w * m2._43;
					var iw = 1 / (_this_x1 * m2._14 + _this_y1 * m2._24 + _this_z1 * m2._34 + _this_w * m2._44);
					_this_x1 = px3 * iw;
					_this_y1 = py3 * iw;
					_this_z1 = pz3 * iw;
					_this_w = 1;
					i.hitPoint.w = _this_z1 + wfactor;
				}
				this.hitInteractives.sort($bind(this,this.sortHitPointByCameraDistance));
			}
			this.hitInteractives.unshift(null);
		}
		while(this.hitInteractives.length > 0) {
			var i = this.hitInteractives.pop();
			if(i == null) {
				return null;
			}
			event.relX = i.hitPoint.x;
			event.relY = i.hitPoint.y;
			event.relZ = i.hitPoint.z;
			i.handleEvent(event);
			if(event.cancel) {
				event.cancel = false;
				event.propagate = false;
				continue;
			}
			if(!event.propagate) {
				while(this.hitInteractives.length > 0) this.hitInteractives.pop();
			}
			return i;
		}
		return null;
	}
	,clone: function(o) {
		var s = o == null ? new h3d_scene_Scene() : o;
		s.camera = this.camera.clone();
		h3d_scene_Object.prototype.clone.call(this,s);
		return s;
	}
	,dispose: function() {
		if((this.flags & 32) != 0) {
			this.onRemove();
		}
		this.ctx.dispose();
		if(this.renderer != null) {
			this.renderer.dispose();
			this.set_renderer(new h3d_scene_Renderer());
		}
	}
	,addEventTarget: function(i) {
		if(this.interactives.indexOf(i) >= 0) {
			throw haxe_Exception.thrown("assert");
		}
		this.interactives.push(i);
	}
	,removeEventTarget: function(i) {
		if(HxOverrides.remove(this.interactives,i)) {
			if(this.events != null) {
				this.events.onRemove(i);
			}
			HxOverrides.remove(this.hitInteractives,i);
		}
	}
	,setElapsedTime: function(elapsedTime) {
		this.ctx.elapsedTime = elapsedTime;
	}
	,syncOnly: function(et) {
		var engine = h3d_Engine.CURRENT;
		this.setElapsedTime(et);
		var t = engine.getCurrentTarget();
		if(t == null) {
			this.camera.screenRatio = engine.width / engine.height;
		} else {
			this.camera.screenRatio = t.width / t.height;
		}
		this.camera.update();
		this.ctx.start();
		this.syncRec(this.ctx);
		this.ctx.done();
	}
	,computeStatic: function() {
		var old = this.ctx.elapsedTime;
		this.ctx.elapsedTime = 0;
		this.ctx.computingStatic = true;
		this.render(h3d_Engine.CURRENT);
		this.ctx.computingStatic = false;
		this.ctx.elapsedTime = old;
	}
	,onContextLost: function() {
		this.ctx.wasContextLost = true;
	}
	,render: function(engine) {
		if((this.flags & 32) == 0) {
			this.onAdd();
		}
		var t = engine.getCurrentTarget();
		if(t == null) {
			this.camera.screenRatio = engine.width / engine.height;
		} else {
			this.camera.screenRatio = t.width / t.height;
		}
		this.camera.update();
		if(this.camera.rightHanded) {
			engine.driver.setRenderFlag(h3d_impl_RenderFlag.CameraHandness,1);
		}
		this.ctx.start();
		this.renderer.start();
		this.renderer.startEffects();
		this.mark("sync");
		this.syncRec(this.ctx);
		this.mark("emit");
		this.emitRec(this.ctx);
		var passes = [];
		var passIndex = -1;
		var _g = 0;
		var _g1 = this.ctx.passes.length;
		while(_g < _g1) {
			var passId = _g++;
			var curPass = this.ctx.passes[passId];
			if(curPass == null) {
				continue;
			}
			var pobjs = this.ctx.cachedPassObjects[++passIndex];
			if(pobjs == null) {
				pobjs = new h3d_scene_PassObjects();
				this.ctx.cachedPassObjects[passIndex] = pobjs;
			}
			pobjs.name = curPass.pass.name;
			var _this = pobjs.passes;
			_this.current = curPass;
			_this.discarded = _this.lastDisc = null;
			passes.push(pobjs);
		}
		if(this.lightSystem != null) {
			this.ctx.lightSystem = this.lightSystem;
			this.lightSystem.initLights(this.ctx);
		}
		this.renderer.process(passes);
		if(!this.ctx.computingStatic && this.checkPasses) {
			var _g = 0;
			while(_g < passes.length) {
				var p = passes[_g];
				++_g;
				if(!p.rendered) {
					haxe_Log.trace("Pass " + p.name + " has not been rendered : don't know how to handle.",{ fileName : "h3d/scene/Scene.hx", lineNumber : 397, className : "h3d.scene.Scene", methodName : "render"});
				}
			}
		}
		if(this.camera.rightHanded) {
			engine.driver.setRenderFlag(h3d_impl_RenderFlag.CameraHandness,0);
		}
		this.ctx.done();
		this.ctx.wasContextLost = false;
		var _g = 0;
		var _g1 = passIndex;
		while(_g < _g1) {
			var i = _g++;
			var p = this.ctx.cachedPassObjects[i];
			p.name = null;
			var _this = p.passes;
			_this.current = null;
			_this.discarded = _this.lastDisc = null;
		}
	}
	,mark: function(name) {
		this.renderer.mark(name);
	}
	,setOutputTarget: function(engine,tex) {
		if(tex != null) {
			if(this.prevDB != null) {
				throw haxe_Exception.thrown("missing setOutputTarget()");
			}
			engine.pushTarget(tex);
			engine.width = tex.width;
			engine.height = tex.height;
			this.prevDB = this.ctx.textures.defaultDepthBuffer;
			this.prevEngine = engine;
			this.ctx.textures.defaultDepthBuffer = tex.depthBuffer;
		} else {
			this.prevEngine.popTarget();
			this.prevEngine.width = this.prevDB.width;
			this.prevEngine.height = this.prevDB.height;
			this.ctx.textures.defaultDepthBuffer = this.prevDB;
			this.prevDB = null;
			this.prevEngine = null;
		}
	}
	,__class__: h3d_scene_Scene
});
var h3d_scene_Joint = function(skin,j) {
	h3d_scene_Object.call(this,null);
	this.name = j.name;
	this.skin = skin;
	this.lastFrame = -2;
	this.parent = skin;
	this.index = j.index;
};
$hxClasses["h3d.scene.Joint"] = h3d_scene_Joint;
h3d_scene_Joint.__name__ = "h3d.scene.Joint";
h3d_scene_Joint.__super__ = h3d_scene_Object;
h3d_scene_Joint.prototype = $extend(h3d_scene_Object.prototype,{
	getObjectByName: function(name) {
		var sk = this.skin.getSkinData();
		var j = sk.namedJoints.h[name];
		if(j == null) {
			return null;
		}
		var cur = sk.allJoints[this.index];
		if(cur.index != this.index) {
			throw haxe_Exception.thrown("assert");
		}
		var jp = j.parent;
		while(jp != null) {
			if(jp == cur) {
				var jo = new h3d_scene_Joint(this.skin,j);
				jo.parent = this;
				return jo;
			}
			jp = jp.parent;
		}
		return null;
	}
	,syncPos: function() {
		var p = this.skin;
		while(p != null) {
			if((p.flags & 1) != 0) {
				this.update();
				break;
			}
			p = p.parent;
		}
		if(this.lastFrame != this.skin.lastFrame) {
			this.lastFrame = this.skin.lastFrame;
			this.absPos.load(this.skin.jointsData[this.index].currentAbsPose);
		}
	}
	,update: function() {
		this.skin.getAbsPos();
		this.skin.syncJoints();
		this.lastFrame = -1;
	}
	,__class__: h3d_scene_Joint
});
var h3d_scene_JointData = function() {
	this.currentAbsPose = h3d_Matrix.I();
};
$hxClasses["h3d.scene.JointData"] = h3d_scene_JointData;
h3d_scene_JointData.__name__ = "h3d.scene.JointData";
h3d_scene_JointData.prototype = {
	sync: function(skin,j) {
		if(j.follow != null) {
			return;
		}
		var m = this.currentAbsPose;
		var r = this.currentRelPose;
		var bid = j.bindIndex;
		if(r == null) {
			r = j.defMat;
		} else if(j.retargetAnim && skin.enableRetargeting) {
			h3d_scene_Skin.TMP_MAT.load(r);
			r = h3d_scene_Skin.TMP_MAT;
			r._41 = j.defMat._41;
			r._42 = j.defMat._42;
			r._43 = j.defMat._43;
		}
		if(j.parent == null) {
			var _this = m;
			var b = skin.absPos;
			var m11 = r._11;
			var m12 = r._12;
			var m13 = r._13;
			var m21 = r._21;
			var m22 = r._22;
			var m23 = r._23;
			var a31 = r._31;
			var a32 = r._32;
			var a33 = r._33;
			var a41 = r._41;
			var a42 = r._42;
			var a43 = r._43;
			var b11 = b._11;
			var b12 = b._12;
			var b13 = b._13;
			var b21 = b._21;
			var b22 = b._22;
			var b23 = b._23;
			var b31 = b._31;
			var b32 = b._32;
			var b33 = b._33;
			var b41 = b._41;
			var b42 = b._42;
			var b43 = b._43;
			_this._11 = m11 * b11 + m12 * b21 + m13 * b31;
			_this._12 = m11 * b12 + m12 * b22 + m13 * b32;
			_this._13 = m11 * b13 + m12 * b23 + m13 * b33;
			_this._14 = 0;
			_this._21 = m21 * b11 + m22 * b21 + m23 * b31;
			_this._22 = m21 * b12 + m22 * b22 + m23 * b32;
			_this._23 = m21 * b13 + m22 * b23 + m23 * b33;
			_this._24 = 0;
			_this._31 = a31 * b11 + a32 * b21 + a33 * b31;
			_this._32 = a31 * b12 + a32 * b22 + a33 * b32;
			_this._33 = a31 * b13 + a32 * b23 + a33 * b33;
			_this._34 = 0;
			_this._41 = a41 * b11 + a42 * b21 + a43 * b31 + b41;
			_this._42 = a41 * b12 + a42 * b22 + a43 * b32 + b42;
			_this._43 = a41 * b13 + a42 * b23 + a43 * b33 + b43;
			_this._44 = 1;
		} else {
			var _this = m;
			var b = skin.jointsData[j.parent.index].currentAbsPose;
			var m11 = r._11;
			var m12 = r._12;
			var m13 = r._13;
			var m21 = r._21;
			var m22 = r._22;
			var m23 = r._23;
			var a31 = r._31;
			var a32 = r._32;
			var a33 = r._33;
			var a41 = r._41;
			var a42 = r._42;
			var a43 = r._43;
			var b11 = b._11;
			var b12 = b._12;
			var b13 = b._13;
			var b21 = b._21;
			var b22 = b._22;
			var b23 = b._23;
			var b31 = b._31;
			var b32 = b._32;
			var b33 = b._33;
			var b41 = b._41;
			var b42 = b._42;
			var b43 = b._43;
			_this._11 = m11 * b11 + m12 * b21 + m13 * b31;
			_this._12 = m11 * b12 + m12 * b22 + m13 * b32;
			_this._13 = m11 * b13 + m12 * b23 + m13 * b33;
			_this._14 = 0;
			_this._21 = m21 * b11 + m22 * b21 + m23 * b31;
			_this._22 = m21 * b12 + m22 * b22 + m23 * b32;
			_this._23 = m21 * b13 + m22 * b23 + m23 * b33;
			_this._24 = 0;
			_this._31 = a31 * b11 + a32 * b21 + a33 * b31;
			_this._32 = a31 * b12 + a32 * b22 + a33 * b32;
			_this._33 = a31 * b13 + a32 * b23 + a33 * b33;
			_this._34 = 0;
			_this._41 = a41 * b11 + a42 * b21 + a43 * b31 + b41;
			_this._42 = a41 * b12 + a42 * b22 + a43 * b32 + b42;
			_this._43 = a41 * b13 + a42 * b23 + a43 * b33 + b43;
			_this._44 = 1;
		}
		if(this.additivePose != null) {
			var _this = m;
			var a = this.additivePose;
			var m11 = a._11;
			var m12 = a._12;
			var m13 = a._13;
			var m21 = a._21;
			var m22 = a._22;
			var m23 = a._23;
			var a31 = a._31;
			var a32 = a._32;
			var a33 = a._33;
			var a41 = a._41;
			var a42 = a._42;
			var a43 = a._43;
			var b11 = m._11;
			var b12 = m._12;
			var b13 = m._13;
			var b21 = m._21;
			var b22 = m._22;
			var b23 = m._23;
			var b31 = m._31;
			var b32 = m._32;
			var b33 = m._33;
			var b41 = m._41;
			var b42 = m._42;
			var b43 = m._43;
			_this._11 = m11 * b11 + m12 * b21 + m13 * b31;
			_this._12 = m11 * b12 + m12 * b22 + m13 * b32;
			_this._13 = m11 * b13 + m12 * b23 + m13 * b33;
			_this._14 = 0;
			_this._21 = m21 * b11 + m22 * b21 + m23 * b31;
			_this._22 = m21 * b12 + m22 * b22 + m23 * b32;
			_this._23 = m21 * b13 + m22 * b23 + m23 * b33;
			_this._24 = 0;
			_this._31 = a31 * b11 + a32 * b21 + a33 * b31;
			_this._32 = a31 * b12 + a32 * b22 + a33 * b32;
			_this._33 = a31 * b13 + a32 * b23 + a33 * b33;
			_this._34 = 0;
			_this._41 = a41 * b11 + a42 * b21 + a43 * b31 + b41;
			_this._42 = a41 * b12 + a42 * b22 + a43 * b32 + b42;
			_this._43 = a41 * b13 + a42 * b23 + a43 * b33 + b43;
			_this._44 = 1;
		}
		if(bid >= 0) {
			var _this = skin.currentPalette[bid];
			var a = j.transPos;
			var m11 = a._11;
			var m12 = a._12;
			var m13 = a._13;
			var m21 = a._21;
			var m22 = a._22;
			var m23 = a._23;
			var a31 = a._31;
			var a32 = a._32;
			var a33 = a._33;
			var a41 = a._41;
			var a42 = a._42;
			var a43 = a._43;
			var b11 = m._11;
			var b12 = m._12;
			var b13 = m._13;
			var b21 = m._21;
			var b22 = m._22;
			var b23 = m._23;
			var b31 = m._31;
			var b32 = m._32;
			var b33 = m._33;
			var b41 = m._41;
			var b42 = m._42;
			var b43 = m._43;
			_this._11 = m11 * b11 + m12 * b21 + m13 * b31;
			_this._12 = m11 * b12 + m12 * b22 + m13 * b32;
			_this._13 = m11 * b13 + m12 * b23 + m13 * b33;
			_this._14 = 0;
			_this._21 = m21 * b11 + m22 * b21 + m23 * b31;
			_this._22 = m21 * b12 + m22 * b22 + m23 * b32;
			_this._23 = m21 * b13 + m22 * b23 + m23 * b33;
			_this._24 = 0;
			_this._31 = a31 * b11 + a32 * b21 + a33 * b31;
			_this._32 = a31 * b12 + a32 * b22 + a33 * b32;
			_this._33 = a31 * b13 + a32 * b23 + a33 * b33;
			_this._34 = 0;
			_this._41 = a41 * b11 + a42 * b21 + a43 * b31 + b41;
			_this._42 = a41 * b12 + a42 * b22 + a43 * b32 + b42;
			_this._43 = a41 * b13 + a42 * b23 + a43 * b33 + b43;
			_this._44 = 1;
		}
	}
	,__class__: h3d_scene_JointData
};
var h3d_scene_DynamicJointData = function() {
	this.f = -1;
	h3d_scene_JointData.call(this);
	var x = 0;
	var y = 0;
	var z = 0;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.speed = new h3d_VectorImpl(x,y,z);
};
$hxClasses["h3d.scene.DynamicJointData"] = h3d_scene_DynamicJointData;
h3d_scene_DynamicJointData.__name__ = "h3d.scene.DynamicJointData";
h3d_scene_DynamicJointData.__super__ = h3d_scene_JointData;
h3d_scene_DynamicJointData.prototype = $extend(h3d_scene_JointData.prototype,{
	load: function(data) {
		if(data.currentRelPose != null) {
			if(this.currentRelPose == null) {
				this.currentRelPose = new h3d_MatrixImpl();
			}
			this.currentRelPose.load(data.currentRelPose);
		}
		if(data.currentAbsPose != null) {
			if(this.currentAbsPose == null) {
				this.currentAbsPose = new h3d_MatrixImpl();
			}
			this.currentAbsPose.load(data.currentAbsPose);
		}
		if(data.additivePose != null) {
			if(this.additivePose == null) {
				this.additivePose = new h3d_MatrixImpl();
			}
			this.additivePose.load(data.additivePose);
		}
		if(data.absPos != null) {
			if(this.absPos == null) {
				this.absPos = new h3d_MatrixImpl();
			}
			this.absPos.load(data.absPos);
		}
		var _this = this.speed;
		var v = data.speed;
		_this.x = v.x;
		_this.y = v.y;
		_this.z = v.z;
	}
	,sync: function(skin,j) {
		h3d_scene_JointData.prototype.sync.call(this,skin,j);
		if(this.f != hxd_Timer.frameCount) {
			this.f = hxd_Timer.frameCount;
			if(this.initialState == null) {
				this.initialState = new h3d_scene_DynamicJointData();
			}
			this.initialState.load(this);
		} else {
			this.load(this.initialState);
		}
		this.computeDyn(skin,j);
		this.computeRotationDyn(skin,j.parent);
	}
	,computeDyn: function(skin,j) {
		var j1 = j;
		var value = skin.jointsData[j1.index];
		var jData = ((value) instanceof h3d_scene_DynamicJointData) ? value : null;
		var absPos = jData.absPos == null ? jData.currentAbsPose : jData.absPos;
		var relPos = j1.defMat;
		var _this = h3d_scene_DynamicJointData.newWorldPos;
		var _this1 = absPos;
		var x = 0.;
		var y = 0.;
		var z = 0.;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var v_x = x;
		var v_y = y;
		var v_z = z;
		var x = _this1._41;
		var y = _this1._42;
		var z = _this1._43;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		v_x = x;
		v_y = y;
		v_z = z;
		_this.x = v_x;
		_this.y = v_y;
		_this.z = v_z;
		var _this = h3d_scene_DynamicJointData.expectedPos;
		var _this1 = absPos;
		var x = 0.;
		var y = 0.;
		var z = 0.;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var v_x = x;
		var v_y = y;
		var v_z = z;
		var x = _this1._41;
		var y = _this1._42;
		var z = _this1._43;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		v_x = x;
		v_y = y;
		v_z = z;
		_this.x = v_x;
		_this.y = v_y;
		_this.z = v_z;
		var globalForce = j1.globalForce;
		var _this = this.speed;
		var this1 = this.speed;
		var v = 1.0 - j1.resistance;
		var x = globalForce.x * v;
		var y = globalForce.y * v;
		var z = globalForce.z * v;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var x = this1.x + v_x;
		var y = this1.y + v_y;
		var z = this1.z + v_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		_this.x = v_x;
		_this.y = v_y;
		_this.z = v_z;
		var this1 = jData.speed;
		var v = 1.0 - j1.damping;
		this1.x *= v;
		this1.y *= v;
		this1.z *= v;
		var _this = jData.speed;
		if(_this.x * _this.x + _this.y * _this.y + _this.z * _this.z > h3d_anim_DynamicJoint.SLEEP_THRESHOLD) {
			var _this = h3d_scene_DynamicJointData.newWorldPos;
			var this1 = h3d_scene_DynamicJointData.newWorldPos;
			var this2 = jData.speed;
			var f = hxd_Timer.dt;
			var min = 0;
			var max = hxd_Timer.maxDeltaTime;
			if(max == null) {
				max = 1.;
			}
			if(min == null) {
				min = 0.;
			}
			var v = f < min ? min : f > max ? max : f;
			var x = this2.x * v;
			var y = this2.y * v;
			var z = this2.z * v;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var v_x = x1;
			var v_y = y1;
			var v_z = z1;
			var x = this1.x + v_x;
			var y = this1.y + v_y;
			var z = this1.z + v_z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var v_x = x1;
			var v_y = y1;
			var v_z = z1;
			_this.x = v_x;
			_this.y = v_y;
			_this.z = v_z;
		}
		var _this = jData.speed;
		if(_this.x * _this.x + _this.y * _this.y + _this.z * _this.z > h3d_anim_DynamicJoint.MAX_THRESHOLD) {
			var _this = h3d_scene_DynamicJointData.newWorldPos;
			var _this1 = jData.currentAbsPose;
			var x = 0.;
			var y = 0.;
			var z = 0.;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var v_x = x;
			var v_y = y;
			var v_z = z;
			var x = _this1._41;
			var y = _this1._42;
			var z = _this1._43;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			v_x = x;
			v_y = y;
			v_z = z;
			_this.x = v_x;
			_this.y = v_y;
			_this.z = v_z;
			absPos.load(jData.currentAbsPose);
			var _this = jData.speed;
			var x = 0;
			var y = 0;
			var z = 0;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
		}
		h3d_scene_Skin.TMP_MAT.multiply(relPos,skin.jointsData[j1.parent.index].currentAbsPose);
		var _this = h3d_scene_DynamicJointData.expectedPos;
		var _this1 = h3d_scene_Skin.TMP_MAT;
		var x = 0.;
		var y = 0.;
		var z = 0.;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var v_x = x;
		var v_y = y;
		var v_z = z;
		var x = _this1._41;
		var y = _this1._42;
		var z = _this1._43;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		v_x = x;
		v_y = y;
		v_z = z;
		_this.x = v_x;
		_this.y = v_y;
		_this.z = v_z;
		var _this = h3d_scene_DynamicJointData.newWorldPos;
		var v1 = h3d_scene_DynamicJointData.newWorldPos;
		var v2 = h3d_scene_DynamicJointData.expectedPos;
		var k = j1.stiffness;
		var a = v1.x;
		_this.x = a + k * (v2.x - a);
		var a = v1.y;
		_this.y = a + k * (v2.y - a);
		var a = v1.z;
		_this.z = a + k * (v2.z - a);
		var this1 = h3d_scene_DynamicJointData.newWorldPos;
		var _this = skin.jointsData[j1.parent.index].currentAbsPose;
		var x = 0.;
		var y = 0.;
		var z = 0.;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var v_x = x;
		var v_y = y;
		var v_z = z;
		var x = _this._41;
		var y = _this._42;
		var z = _this._43;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		v_x = x;
		v_y = y;
		v_z = z;
		var x = this1.x - v_x;
		var y = this1.y - v_y;
		var z = this1.z - v_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var k = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		var x = _this_x * k;
		var y = _this_y * k;
		var z = _this_z * k;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var dirToParent_x = x1;
		var dirToParent_y = y1;
		var dirToParent_z = z1;
		var _this = relPos;
		var x = 0.;
		var y = 0.;
		var z = 0.;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var _this_x = x;
		var _this_y = y;
		var _this_z = z;
		var x = _this._41;
		var y = _this._42;
		var z = _this._43;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this_x = x;
		_this_y = y;
		_this_z = z;
		var lengthToParent = Math.sqrt(_this_x * _this_x + _this_y * _this_y + _this_z * _this_z);
		var _this = h3d_scene_DynamicJointData.expectedPos;
		var _this1 = skin.jointsData[j1.parent.index].currentAbsPose;
		var x = 0.;
		var y = 0.;
		var z = 0.;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var _this_x = x;
		var _this_y = y;
		var _this_z = z;
		var x = _this1._41;
		var y = _this1._42;
		var z = _this1._43;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this_x = x;
		_this_y = y;
		_this_z = z;
		var x = dirToParent_x * lengthToParent;
		var y = dirToParent_y * lengthToParent;
		var z = dirToParent_z * lengthToParent;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var x = _this_x + v_x;
		var y = _this_y + v_y;
		var z = _this_z + v_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		_this.x = v_x;
		_this.y = v_y;
		_this.z = v_z;
		var _this = h3d_scene_DynamicJointData.newWorldPos;
		var v1 = h3d_scene_DynamicJointData.expectedPos;
		var v2 = h3d_scene_DynamicJointData.newWorldPos;
		var k = j1.slackness;
		var a = v1.x;
		_this.x = a + k * (v2.x - a);
		var a = v1.y;
		_this.y = a + k * (v2.y - a);
		var a = v1.z;
		_this.z = a + k * (v2.z - a);
		skin.jointsData[j1.parent.index].currentAbsPose.getInverse(h3d_scene_Skin.TMP_MAT);
		var _this = h3d_scene_DynamicJointData.tmpVec;
		var v = h3d_scene_DynamicJointData.newWorldPos;
		_this.x = v.x;
		_this.y = v.y;
		_this.z = v.z;
		var this1 = h3d_scene_DynamicJointData.tmpVec;
		var m = h3d_scene_Skin.TMP_MAT;
		var px = this1.x * m._11 + this1.y * m._21 + this1.z * m._31 + m._41;
		var py = this1.x * m._12 + this1.y * m._22 + this1.z * m._32 + m._42;
		var pz = this1.x * m._13 + this1.y * m._23 + this1.z * m._33 + m._43;
		this1.x = px;
		this1.y = py;
		this1.z = pz;
		var _this = h3d_scene_DynamicJointData.tmpVec2;
		var _this1 = jData.currentAbsPose;
		var x = 0.;
		var y = 0.;
		var z = 0.;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var v_x = x;
		var v_y = y;
		var v_z = z;
		var x = _this1._41;
		var y = _this1._42;
		var z = _this1._43;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		v_x = x;
		v_y = y;
		v_z = z;
		_this.x = v_x;
		_this.y = v_y;
		_this.z = v_z;
		var this1 = h3d_scene_DynamicJointData.tmpVec2;
		var m = h3d_scene_Skin.TMP_MAT;
		var px = this1.x * m._11 + this1.y * m._21 + this1.z * m._31 + m._41;
		var py = this1.x * m._12 + this1.y * m._22 + this1.z * m._32 + m._42;
		var pz = this1.x * m._13 + this1.y * m._23 + this1.z * m._33 + m._43;
		this1.x = px;
		this1.y = py;
		this1.z = pz;
		if(j1.lockAxis.x > 0.0) {
			h3d_scene_DynamicJointData.tmpVec.x = h3d_scene_DynamicJointData.tmpVec2.x;
		}
		if(j1.lockAxis.y > 0.0) {
			h3d_scene_DynamicJointData.tmpVec.y = h3d_scene_DynamicJointData.tmpVec2.y;
		}
		if(j1.lockAxis.z > 0.0) {
			h3d_scene_DynamicJointData.tmpVec.z = h3d_scene_DynamicJointData.tmpVec2.z;
		}
		var this1 = h3d_scene_DynamicJointData.tmpVec;
		var m = skin.jointsData[j1.parent.index].currentAbsPose;
		var px = this1.x * m._11 + this1.y * m._21 + this1.z * m._31 + m._41;
		var py = this1.x * m._12 + this1.y * m._22 + this1.z * m._32 + m._42;
		var pz = this1.x * m._13 + this1.y * m._23 + this1.z * m._33 + m._43;
		this1.x = px;
		this1.y = py;
		this1.z = pz;
		var _this = h3d_scene_DynamicJointData.newWorldPos;
		var v = h3d_scene_DynamicJointData.tmpVec;
		_this.x = v.x;
		_this.y = v.y;
		_this.z = v.z;
		var _this = jData.speed;
		var this1 = jData.speed;
		var this2 = h3d_scene_DynamicJointData.newWorldPos;
		var _this1 = absPos;
		var x = 0.;
		var y = 0.;
		var z = 0.;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var v_x = x;
		var v_y = y;
		var v_z = z;
		var x = _this1._41;
		var y = _this1._42;
		var z = _this1._43;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		v_x = x;
		v_y = y;
		v_z = z;
		var x = this2.x - v_x;
		var y = this2.y - v_y;
		var z = this2.z - v_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var this_x = x1;
		var this_y = y1;
		var this_z = z1;
		var v = 1.0 / hxd_Timer.dt;
		var x = this_x * v;
		var y = this_y * v;
		var z = this_z * v;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var x = this1.x + v_x;
		var y = this1.y + v_y;
		var z = this1.z + v_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var this_x = x1;
		var this_y = y1;
		var this_z = z1;
		var x = this_x * 0.5;
		var y = this_y * 0.5;
		var z = this_z * 0.5;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		_this.x = v_x;
		_this.y = v_y;
		_this.z = v_z;
		var _this = jData.currentAbsPose;
		var v = h3d_scene_DynamicJointData.newWorldPos;
		_this._41 = v.x;
		_this._42 = v.y;
		_this._43 = v.z;
		if(jData.absPos == null) {
			jData.absPos = new h3d_MatrixImpl();
		}
		jData.absPos.load(jData.currentAbsPose);
		if(jData.relPos == null) {
			jData.relPos = new h3d_MatrixImpl();
		}
		skin.jointsData[j1.parent.index].currentAbsPose.getInverse(h3d_scene_Skin.TMP_MAT);
		jData.relPos.multiply(jData.absPos,h3d_scene_Skin.TMP_MAT);
		if(j1.bindIndex >= 0) {
			var _this = skin.currentPalette[j1.bindIndex];
			var a = j1.transPos;
			var b = jData.currentAbsPose;
			var m11 = a._11;
			var m12 = a._12;
			var m13 = a._13;
			var m21 = a._21;
			var m22 = a._22;
			var m23 = a._23;
			var a31 = a._31;
			var a32 = a._32;
			var a33 = a._33;
			var a41 = a._41;
			var a42 = a._42;
			var a43 = a._43;
			var b11 = b._11;
			var b12 = b._12;
			var b13 = b._13;
			var b21 = b._21;
			var b22 = b._22;
			var b23 = b._23;
			var b31 = b._31;
			var b32 = b._32;
			var b33 = b._33;
			var b41 = b._41;
			var b42 = b._42;
			var b43 = b._43;
			_this._11 = m11 * b11 + m12 * b21 + m13 * b31;
			_this._12 = m11 * b12 + m12 * b22 + m13 * b32;
			_this._13 = m11 * b13 + m12 * b23 + m13 * b33;
			_this._14 = 0;
			_this._21 = m21 * b11 + m22 * b21 + m23 * b31;
			_this._22 = m21 * b12 + m22 * b22 + m23 * b32;
			_this._23 = m21 * b13 + m22 * b23 + m23 * b33;
			_this._24 = 0;
			_this._31 = a31 * b11 + a32 * b21 + a33 * b31;
			_this._32 = a31 * b12 + a32 * b22 + a33 * b32;
			_this._33 = a31 * b13 + a32 * b23 + a33 * b33;
			_this._34 = 0;
			_this._41 = a41 * b11 + a42 * b21 + a43 * b31 + b41;
			_this._42 = a41 * b12 + a42 * b22 + a43 * b32 + b42;
			_this._43 = a41 * b13 + a42 * b23 + a43 * b33 + b43;
			_this._44 = 1;
		}
		var _this = jData.speed;
		if(Math.sqrt(_this.x * _this.x + _this.y * _this.y + _this.z * _this.z) != 0.) {
			skin.forceJointsUpdateOnFrame = hxd_Timer.frameCount + 1;
		}
	}
	,computeRotationDyn: function(skin,j) {
		if(j.follow != null) {
			return;
		}
		var jData = skin.jointsData[j.index];
		var value = skin.jointsData[j.index];
		var jDynData = ((value) instanceof h3d_scene_DynamicJointData) ? value : null;
		var dynJoint = ((j) instanceof h3d_anim_DynamicJoint) ? j : null;
		if(j.subs.length == 1) {
			var value = j.subs[0];
			var child = ((value) instanceof h3d_anim_DynamicJoint) ? value : null;
			if(child == null) {
				return;
			}
			var value = skin.jointsData[child.index];
			var childData = ((value) instanceof h3d_scene_DynamicJointData) ? value : null;
			var _this = h3d_scene_DynamicJointData.tmpVec;
			var _this1 = child.defMat;
			var x = 0.;
			var y = 0.;
			var z = 0.;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var _this_x = x;
			var _this_y = y;
			var _this_z = z;
			var x = _this1._41;
			var y = _this1._42;
			var z = _this1._43;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this_x = x;
			_this_y = y;
			_this_z = z;
			var k = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
			if(k < 1e-20) {
				k = 0;
			} else {
				k = 1. / Math.sqrt(k);
			}
			var x = _this_x * k;
			var y = _this_y * k;
			var z = _this_z * k;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var v_x = x1;
			var v_y = y1;
			var v_z = z1;
			_this.x = v_x;
			_this.y = v_y;
			_this.z = v_z;
			var _this = h3d_scene_DynamicJointData.tmpVec2;
			var _this1 = childData.relPos;
			var x = 0.;
			var y = 0.;
			var z = 0.;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var _this_x = x;
			var _this_y = y;
			var _this_z = z;
			var x = _this1._41;
			var y = _this1._42;
			var z = _this1._43;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this_x = x;
			_this_y = y;
			_this_z = z;
			var k = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
			if(k < 1e-20) {
				k = 0;
			} else {
				k = 1. / Math.sqrt(k);
			}
			var x = _this_x * k;
			var y = _this_y * k;
			var z = _this_z * k;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var v_x = x1;
			var v_y = y1;
			var v_z = z1;
			_this.x = v_x;
			_this.y = v_y;
			_this.z = v_z;
			h3d_scene_DynamicJointData.tmpQ.initMoveTo(h3d_scene_DynamicJointData.tmpVec,h3d_scene_DynamicJointData.tmpVec2);
			h3d_scene_DynamicJointData.tmpQ.toMatrix(h3d_scene_Skin.TMP_MAT);
			jData.currentAbsPose.multiply(h3d_scene_Skin.TMP_MAT,jData.currentAbsPose);
		}
		if(j.bindIndex >= 0) {
			var _this = skin.currentPalette[j.bindIndex];
			var a = j.transPos;
			var b = jData.currentAbsPose;
			var m11 = a._11;
			var m12 = a._12;
			var m13 = a._13;
			var m21 = a._21;
			var m22 = a._22;
			var m23 = a._23;
			var a31 = a._31;
			var a32 = a._32;
			var a33 = a._33;
			var a41 = a._41;
			var a42 = a._42;
			var a43 = a._43;
			var b11 = b._11;
			var b12 = b._12;
			var b13 = b._13;
			var b21 = b._21;
			var b22 = b._22;
			var b23 = b._23;
			var b31 = b._31;
			var b32 = b._32;
			var b33 = b._33;
			var b41 = b._41;
			var b42 = b._42;
			var b43 = b._43;
			_this._11 = m11 * b11 + m12 * b21 + m13 * b31;
			_this._12 = m11 * b12 + m12 * b22 + m13 * b32;
			_this._13 = m11 * b13 + m12 * b23 + m13 * b33;
			_this._14 = 0;
			_this._21 = m21 * b11 + m22 * b21 + m23 * b31;
			_this._22 = m21 * b12 + m22 * b22 + m23 * b32;
			_this._23 = m21 * b13 + m22 * b23 + m23 * b33;
			_this._24 = 0;
			_this._31 = a31 * b11 + a32 * b21 + a33 * b31;
			_this._32 = a31 * b12 + a32 * b22 + a33 * b32;
			_this._33 = a31 * b13 + a32 * b23 + a33 * b33;
			_this._34 = 0;
			_this._41 = a41 * b11 + a42 * b21 + a43 * b31 + b41;
			_this._42 = a41 * b12 + a42 * b22 + a43 * b32 + b42;
			_this._43 = a41 * b13 + a42 * b23 + a43 * b33 + b43;
			_this._44 = 1;
		}
		if(jDynData != null) {
			jDynData.absPos.load(jDynData.currentAbsPose);
		}
	}
	,__class__: h3d_scene_DynamicJointData
});
var h3d_scene_Skin = function(s,mat,parent) {
	this.prevEnableRetargeting = true;
	this.enableRetargeting = true;
	this.forceJointsUpdateOnFrame = -1;
	h3d_scene_MultiMaterial.call(this,null,mat,parent);
	if(s != null) {
		this.setSkinData(s);
	}
};
$hxClasses["h3d.scene.Skin"] = h3d_scene_Skin;
h3d_scene_Skin.__name__ = "h3d.scene.Skin";
h3d_scene_Skin.__super__ = h3d_scene_MultiMaterial;
h3d_scene_Skin.prototype = $extend(h3d_scene_MultiMaterial.prototype,{
	clone: function(o) {
		var s = o == null ? new h3d_scene_Skin(null,this.materials.slice()) : o;
		h3d_scene_MultiMaterial.prototype.clone.call(this,s);
		s.setSkinData(this.skinData);
		s.jointsData = [];
		var _g = 0;
		var _g1 = this.jointsData;
		while(_g < _g1.length) {
			var jData = _g1[_g];
			++_g;
			s.jointsData.push(Reflect.copy(jData));
		}
		return s;
	}
	,addBoundsRec: function(b,relativeTo) {
		var old = this.primitive;
		this.set_primitive(null);
		h3d_scene_MultiMaterial.prototype.addBoundsRec.call(this,b,relativeTo);
		this.set_primitive(old);
		if((this.flags & 512) != 0) {
			return;
		}
		this.syncJoints();
		if(this.skinData.vertexWeights == null) {
			(js_Boot.__cast(this.primitive , h3d_prim_HMDModel)).loadSkin(this.skinData);
		}
		var _this = this.getAbsPos();
		var x = 0.;
		var y = 0.;
		var z = 0.;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var absScale_x = x;
		var absScale_y = y;
		var absScale_z = z;
		absScale_x = Math.sqrt(_this._11 * _this._11 + _this._12 * _this._12 + _this._13 * _this._13);
		absScale_y = Math.sqrt(_this._21 * _this._21 + _this._22 * _this._22 + _this._23 * _this._23);
		absScale_z = Math.sqrt(_this._31 * _this._31 + _this._32 * _this._32 + _this._33 * _this._33);
		if(_this._11 * (_this._22 * _this._33 - _this._23 * _this._32) + _this._12 * (_this._23 * _this._31 - _this._21 * _this._33) + _this._13 * (_this._21 * _this._32 - _this._22 * _this._31) < 0) {
			absScale_x *= -1;
			absScale_y *= -1;
			absScale_z *= -1;
		}
		var scale = Math.max(Math.max(absScale_x,absScale_y),absScale_z);
		var _g = 0;
		var _g1 = this.skinData.allJoints;
		while(_g < _g1.length) {
			var j = _g1[_g];
			++_g;
			if(j.offsetRay < 0) {
				continue;
			}
			var m = this.currentPalette[j.bindIndex];
			var _this = j.offsets;
			var x = _this.xMin;
			var y = _this.yMin;
			var z = _this.zMin;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var pt_x = x1;
			var pt_y = y1;
			var pt_z = z1;
			if(m != null) {
				var px = pt_x * m._11 + pt_y * m._21 + pt_z * m._31 + m._41;
				var py = pt_x * m._12 + pt_y * m._22 + pt_z * m._32 + m._42;
				var pz = pt_x * m._13 + pt_y * m._23 + pt_z * m._33 + m._43;
				pt_x = px;
				pt_y = py;
				pt_z = pz;
				if(relativeTo != null) {
					var px1 = pt_x * relativeTo._11 + pt_y * relativeTo._21 + pt_z * relativeTo._31 + relativeTo._41;
					var py1 = pt_x * relativeTo._12 + pt_y * relativeTo._22 + pt_z * relativeTo._32 + relativeTo._42;
					var pz1 = pt_x * relativeTo._13 + pt_y * relativeTo._23 + pt_z * relativeTo._33 + relativeTo._43;
					pt_x = px1;
					pt_y = py1;
					pt_z = pz1;
				}
				var x2 = pt_x;
				var y2 = pt_y;
				var z2 = pt_z;
				var r = j.offsetRay * scale;
				if(x2 - r < b.xMin) {
					b.xMin = x2 - r;
				}
				if(x2 + r > b.xMax) {
					b.xMax = x2 + r;
				}
				if(y2 - r < b.yMin) {
					b.yMin = y2 - r;
				}
				if(y2 + r > b.yMax) {
					b.yMax = y2 + r;
				}
				if(z2 - r < b.zMin) {
					b.zMin = z2 - r;
				}
				if(z2 + r > b.zMax) {
					b.zMax = z2 + r;
				}
				var _this1 = j.offsets;
				var x3 = _this1.xMax;
				var y3 = _this1.yMax;
				var z3 = _this1.zMax;
				if(z3 == null) {
					z3 = 0.;
				}
				if(y3 == null) {
					y3 = 0.;
				}
				if(x3 == null) {
					x3 = 0.;
				}
				var x4 = x3;
				var y4 = y3;
				var z4 = z3;
				if(z4 == null) {
					z4 = 0.;
				}
				if(y4 == null) {
					y4 = 0.;
				}
				if(x4 == null) {
					x4 = 0.;
				}
				var pt_x1 = x4;
				var pt_y1 = y4;
				var pt_z1 = z4;
				var px2 = pt_x1 * m._11 + pt_y1 * m._21 + pt_z1 * m._31 + m._41;
				var py2 = pt_x1 * m._12 + pt_y1 * m._22 + pt_z1 * m._32 + m._42;
				var pz2 = pt_x1 * m._13 + pt_y1 * m._23 + pt_z1 * m._33 + m._43;
				pt_x1 = px2;
				pt_y1 = py2;
				pt_z1 = pz2;
				if(relativeTo != null) {
					var px3 = pt_x1 * relativeTo._11 + pt_y1 * relativeTo._21 + pt_z1 * relativeTo._31 + relativeTo._41;
					var py3 = pt_x1 * relativeTo._12 + pt_y1 * relativeTo._22 + pt_z1 * relativeTo._32 + relativeTo._42;
					var pz3 = pt_x1 * relativeTo._13 + pt_y1 * relativeTo._23 + pt_z1 * relativeTo._33 + relativeTo._43;
					pt_x1 = px3;
					pt_y1 = py3;
					pt_z1 = pz3;
				}
				var x5 = pt_x1;
				var y5 = pt_y1;
				var z5 = pt_z1;
				var r1 = j.offsetRay * scale;
				if(x5 - r1 < b.xMin) {
					b.xMin = x5 - r1;
				}
				if(x5 + r1 > b.xMax) {
					b.xMax = x5 + r1;
				}
				if(y5 - r1 < b.yMin) {
					b.yMin = y5 - r1;
				}
				if(y5 + r1 > b.yMax) {
					b.yMax = y5 + r1;
				}
				if(z5 - r1 < b.zMin) {
					b.zMin = z5 - r1;
				}
				if(z5 + r1 > b.zMax) {
					b.zMax = z5 + r1;
				}
			}
		}
	}
	,getCurrentSkeletonBounds: function() {
		this.syncJoints();
		var b = new h3d_col_Bounds();
		var _g = 0;
		var _g1 = this.skinData.allJoints;
		while(_g < _g1.length) {
			var j = _g1[_g];
			++_g;
			if(j.bindIndex < 0) {
				continue;
			}
			var r = this.jointsData[j.index].currentAbsPose;
			var x = r._41;
			var y = r._42;
			var z = r._43;
			if(x < b.xMin) {
				b.xMin = x;
			}
			if(x > b.xMax) {
				b.xMax = x;
			}
			if(y < b.yMin) {
				b.yMin = y;
			}
			if(y > b.yMax) {
				b.yMax = y;
			}
			if(z < b.zMin) {
				b.zMin = z;
			}
			if(z > b.zMax) {
				b.zMax = z;
			}
		}
		return b;
	}
	,getObjectByName: function(name) {
		if(this.skinData != null && this.skinData.name == name) {
			return this;
		}
		var o = h3d_scene_MultiMaterial.prototype.getObjectByName.call(this,name);
		if(o != null) {
			return o;
		}
		if(this.skinData != null) {
			var j = this.skinData.namedJoints.h[name];
			if(j != null) {
				return new h3d_scene_Joint(this,j);
			}
		}
		return null;
	}
	,getLocalCollider: function() {
		throw haxe_Exception.thrown("Not implemented");
	}
	,getGlobalCollider: function() {
		var col = js_Boot.__cast(this.primitive.getCollider() , h3d_col_OptimizedCollider);
		(js_Boot.__cast(this.primitive , h3d_prim_HMDModel)).loadSkin(this.skinData);
		return new h3d_col_SkinCollider(this,js_Boot.__cast(col.b , h3d_col_PolygonBuffer));
	}
	,calcAbsPos: function() {
		h3d_scene_MultiMaterial.prototype.calcAbsPos.call(this);
		this.jointsUpdated = true;
	}
	,getSkinData: function() {
		return this.skinData;
	}
	,getJointRelPosition: function(name,additive) {
		if(additive == null) {
			additive = false;
		}
		var j = this.skinData.namedJoints.h[name];
		if(j == null) {
			return null;
		}
		if(additive) {
			return this.jointsData[j.index].additivePose;
		}
		var tmp = this.jointsData[j.index].currentRelPose;
		if(tmp != null) {
			return tmp;
		} else {
			return j.defMat;
		}
	}
	,setJointRelPosition: function(name,pos,additive) {
		if(additive == null) {
			additive = false;
		}
		var j = this.skinData.namedJoints.h[name];
		if(j == null) {
			return;
		}
		if(additive) {
			this.jointsData[j.index].additivePose = pos;
		} else {
			this.jointsData[j.index].currentRelPose = pos;
		}
		this.jointsUpdated = true;
	}
	,setSkinData: function(s,shaderInit) {
		if(shaderInit == null) {
			shaderInit = true;
		}
		this.skinData = s;
		this.jointsUpdated = true;
		this.set_primitive(s.primitive);
		if(shaderInit) {
			var hasNormalMap = false;
			var _g = 0;
			var _g1 = this.materials;
			while(_g < _g1.length) {
				var m = _g1[_g];
				++_g;
				if(m != null && m.get_normalMap() != null) {
					hasNormalMap = true;
					break;
				}
			}
			this.skinShader = hasNormalMap ? new h3d_shader_SkinTangent() : new h3d_shader_Skin();
			var _this = this.skinShader;
			_this.constModified = true;
			_this.fourBonesByVertex__ = this.skinData.bonesPerVertex == 4;
			var maxBones = 0;
			if(this.skinData.splitJoints != null) {
				var _g = 0;
				var _g1 = this.skinData.splitJoints;
				while(_g < _g1.length) {
					var s = _g1[_g];
					++_g;
					if(s.joints.length > maxBones) {
						maxBones = s.joints.length;
					}
				}
			} else {
				maxBones = this.skinData.boundJoints.length;
			}
			if(this.skinShader.MaxBones__ < maxBones) {
				var _this = this.skinShader;
				_this.constModified = true;
				_this.MaxBones__ = maxBones;
			}
			var _g = 0;
			var _g1 = this.materials;
			while(_g < _g1.length) {
				var m = _g1[_g];
				++_g;
				if(m != null) {
					var s = m.passes.getShader(h3d_shader_SkinTangent);
					if(s != null) {
						m.passes.removeShader(s);
					}
					if(m.get_normalMap() != null) {
						m.passes.addShaderAtIndex(this.skinShader,m.passes.getShaderIndex(m.normalShader) + 1);
					} else {
						m.passes.addShader(this.skinShader);
					}
					if(this.skinData.splitJoints != null) {
						m.passes.set_dynamicParameters(true);
					}
				}
			}
		}
		this.jointsData = [];
		this.currentPalette = [];
		this.paletteChanged = true;
		this.makeJointsData();
		var _g = 0;
		var _g1 = this.skinData.boundJoints.length;
		while(_g < _g1) {
			var i = _g++;
			this.currentPalette.push(h3d_Matrix.I());
		}
		if(this.skinData.splitJoints != null) {
			this.splitPalette = [];
			var _g = 0;
			var _g1 = this.skinData.splitJoints;
			while(_g < _g1.length) {
				var a = _g1[_g];
				++_g;
				var tmp = this.splitPalette;
				var _g2 = [];
				var _g3 = 0;
				var _g4 = a.joints;
				while(_g3 < _g4.length) {
					var j = _g4[_g3];
					++_g3;
					_g2.push(this.currentPalette[j.bindIndex]);
				}
				tmp.push(_g2);
			}
		} else {
			this.splitPalette = null;
		}
	}
	,makeJointsData: function() {
		var _g = 0;
		var _g1 = this.skinData.allJoints;
		while(_g < _g1.length) {
			var j = _g1[_g];
			++_g;
			this.jointsData[j.index] = j.makeRuntimeData();
		}
	}
	,sync: function(ctx) {
		if(!ctx.visibleFlag && (this.flags & 64) == 0) {
			return;
		}
		this.syncJoints();
	}
	,syncJoints: function() {
		if(!this.jointsUpdated && this.forceJointsUpdateOnFrame != hxd_Timer.frameCount) {
			return;
		}
		var _g = 0;
		var _g1 = this.skinData.allJoints;
		while(_g < _g1.length) {
			var j = _g1[_g];
			++_g;
			this.jointsData[j.index].sync(this,j);
		}
		this.skinShader.bonesMatrixes__ = this.currentPalette;
		this.jointsUpdated = false;
		this.prevEnableRetargeting = this.enableRetargeting;
	}
	,emit: function(ctx) {
		this.calcScreenRatio(ctx);
		this.syncJoints();
		if(this.splitPalette == null) {
			h3d_scene_MultiMaterial.prototype.emit.call(this,ctx);
		} else {
			var _g = 0;
			var _g1 = this.splitPalette.length;
			while(_g < _g1) {
				var i = _g++;
				var m = this.materials[this.skinData.splitJoints[i].material];
				if(m != null) {
					var index = i;
					if(index == null) {
						index = 0;
					}
					var p = m.passes;
					while(p != null) {
						if(!p.culled) {
							ctx.emitPass(p,this).index = index;
						}
						p = p.nextPass;
					}
				}
			}
		}
		if(this.showJoints) {
			if(this.jointsGraphics == null) {
				this.jointsGraphics = new h3d_scene_Graphics(this);
				this.jointsGraphics.material.passes.depth(false,h3d_mat_Compare.Always);
				this.jointsGraphics.material.passes.setPassName("alpha");
			}
			var topParent = this;
			while(topParent.parent != null) topParent = topParent.parent;
			this.jointsGraphics.set_follow(topParent);
			var g = this.jointsGraphics;
			g.clear();
			var _g = 0;
			var _g1 = this.skinData.allJoints;
			while(_g < _g1.length) {
				var j = _g1[_g];
				++_g;
				var m = this.jointsData[j.index].currentAbsPose;
				var mp = j.parent == null ? this.absPos : this.jointsData[j.parent.index].currentAbsPose;
				g.lineStyle(1,j.parent == null ? -16776961 : -256);
				g.moveTo(mp._41,mp._42,mp._43);
				g.lineTo(m._41,m._42,m._43);
			}
		} else if(this.jointsGraphics != null) {
			var _this = this.jointsGraphics;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
			this.jointsGraphics = null;
		}
	}
	,draw: function(ctx) {
		if(this.splitPalette == null) {
			h3d_scene_MultiMaterial.prototype.draw.call(this,ctx);
		} else {
			var i = ctx.drawPass.index;
			this.skinShader.bonesMatrixes__ = this.splitPalette[i];
			this.primitive.selectMaterial(i,this.primitive.screenRatioToLod(this.curScreenRatio));
			ctx.uploadParams();
			this.primitive.render(ctx.engine);
		}
	}
	,__class__: h3d_scene_Skin
});
var h3d_scene_fwd_Light = function(shader,parent) {
	this.priority = 0;
	this.cullingDistance = -1;
	h3d_scene_Light.call(this,shader,parent);
};
$hxClasses["h3d.scene.fwd.Light"] = h3d_scene_fwd_Light;
h3d_scene_fwd_Light.__name__ = "h3d.scene.fwd.Light";
h3d_scene_fwd_Light.__super__ = h3d_scene_Light;
h3d_scene_fwd_Light.prototype = $extend(h3d_scene_Light.prototype,{
	get_enableSpecular: function() {
		return false;
	}
	,set_enableSpecular: function(b) {
		if(b) {
			throw haxe_Exception.thrown("Not implemented for this light");
		}
		return false;
	}
	,__class__: h3d_scene_fwd_Light
});
var h3d_scene_fwd_LightSystem = function() {
	this.perPixelLighting = true;
	this.maxLightsPerObject = 6;
	h3d_scene_LightSystem.call(this);
	var x = 0.5;
	var y = 0.5;
	var z = 0.5;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.ambientLight = new h3d_VectorImpl(x,y,z);
	this.ambientShader = new h3d_shader_AmbientLight();
	this.set_additiveLighting(true);
};
$hxClasses["h3d.scene.fwd.LightSystem"] = h3d_scene_fwd_LightSystem;
h3d_scene_fwd_LightSystem.__name__ = "h3d.scene.fwd.LightSystem";
h3d_scene_fwd_LightSystem.__super__ = h3d_scene_LightSystem;
h3d_scene_fwd_LightSystem.prototype = $extend(h3d_scene_LightSystem.prototype,{
	get_additiveLighting: function() {
		var value = this.ambientShader;
		return (((value) instanceof h3d_shader_AmbientLight) ? value : null).additive__;
	}
	,set_additiveLighting: function(b) {
		var value = this.ambientShader;
		var _this = ((value) instanceof h3d_shader_AmbientLight) ? value : null;
		_this.constModified = true;
		return _this.additive__ = b;
	}
	,initLights: function(ctx) {
		this.lightCount = 0;
		this.ctx = ctx;
		this.cullLights();
		h3d_scene_LightSystem.prototype.initLights.call(this,ctx);
		if(this.lightCount <= this.maxLightsPerObject) {
			var list = ctx.lights;
			var cmp = $bind(this,this.sortLight);
			var tmp;
			if(list == null) {
				tmp = null;
			} else {
				var insize = 1;
				var nmerges;
				var psize = 0;
				var qsize = 0;
				var p;
				var q;
				var e;
				var tail;
				while(true) {
					p = list;
					list = null;
					tail = null;
					nmerges = 0;
					while(p != null) {
						++nmerges;
						q = p;
						psize = 0;
						var _g = 0;
						var _g1 = insize;
						while(_g < _g1) {
							var i = _g++;
							++psize;
							q = q.next;
							if(q == null) {
								break;
							}
						}
						qsize = insize;
						while(psize > 0 || qsize > 0 && q != null) {
							if(psize == 0) {
								e = q;
								q = q.next;
								--qsize;
							} else if(qsize == 0 || q == null || cmp(p,q) <= 0) {
								e = p;
								p = p.next;
								--psize;
							} else {
								e = q;
								q = q.next;
								--qsize;
							}
							if(tail != null) {
								tail.next = e;
							} else {
								list = e;
							}
							tail = e;
						}
						p = q;
					}
					tail.next = null;
					if(nmerges <= 1) {
						break;
					}
					insize *= 2;
				}
				tmp = list;
			}
			ctx.lights = tmp;
		}
	}
	,initGlobals: function(globals) {
		globals.set("global.ambientLight",this.ambientLight);
		globals.set("global.perPixelLighting",this.perPixelLighting);
	}
	,cullLights: function() {
		var ll = this.ctx.lights;
		var prev = null;
		var s = new h3d_col_Sphere();
		while(ll != null) {
			var l = ((ll) instanceof h3d_scene_fwd_Light) ? ll : null;
			if(l != null) {
				s.x = l.absPos._41;
				s.y = l.absPos._42;
				s.z = l.absPos._43;
				s.r = l.cullingDistance;
			}
			if(l == null || l.cullingDistance > 0 && !this.ctx.computingStatic && !this.ctx.camera.frustum.hasSphere(s)) {
				if(prev == null) {
					this.ctx.lights = ll.next;
				} else {
					prev.next = ll.next;
				}
				ll = ll.next;
				continue;
			}
			this.lightCount++;
			l.objectDistance = 0.;
			prev = ll;
			ll = ll.next;
		}
	}
	,sortLight: function(l1,l2) {
		var p = l1.priority - l2.priority;
		if(p != 0) {
			return -p;
		}
		if(l1.objectDistance < l2.objectDistance) {
			return -1;
		} else {
			return 1;
		}
	}
	,computeLight: function(obj,shaders) {
		var _gthis = this;
		if(this.lightCount > this.maxLightsPerObject) {
			var ll = this.ctx.lights;
			while(ll != null) {
				var l = ((ll) instanceof h3d_scene_fwd_Light) ? ll : null;
				if((obj.flags & 16) != 0) {
					var dx = l.absPos._41 - this.ctx.camera.target.x;
					var dy = l.absPos._42 - this.ctx.camera.target.y;
					var dz = l.absPos._43 - this.ctx.camera.target.z;
					if(dz == null) {
						dz = 0.;
					}
					l.objectDistance = dx * dx + dy * dy + dz * dz;
				} else {
					var dx1 = l.absPos._41 - obj.absPos._41;
					var dy1 = l.absPos._42 - obj.absPos._42;
					var dz1 = l.absPos._43 - obj.absPos._43;
					if(dz1 == null) {
						dz1 = 0.;
					}
					l.objectDistance = dx1 * dx1 + dy1 * dy1 + dz1 * dz1;
				}
				ll = ll.next;
			}
			var list = this.ctx.lights;
			var cmp = $bind(this,this.sortLight);
			var tmp;
			if(list == null) {
				tmp = null;
			} else {
				var insize = 1;
				var nmerges;
				var psize = 0;
				var qsize = 0;
				var p;
				var q;
				var e;
				var tail;
				while(true) {
					p = list;
					list = null;
					tail = null;
					nmerges = 0;
					while(p != null) {
						++nmerges;
						q = p;
						psize = 0;
						var _g = 0;
						var _g1 = insize;
						while(_g < _g1) {
							var i = _g++;
							++psize;
							q = q.next;
							if(q == null) {
								break;
							}
						}
						qsize = insize;
						while(psize > 0 || qsize > 0 && q != null) {
							if(psize == 0) {
								e = q;
								q = q.next;
								--qsize;
							} else if(qsize == 0 || q == null || cmp(p,q) <= 0) {
								e = p;
								p = p.next;
								--psize;
							} else {
								e = q;
								q = q.next;
								--qsize;
							}
							if(tail != null) {
								tail.next = e;
							} else {
								list = e;
							}
							tail = e;
						}
						p = q;
					}
					tail.next = null;
					if(nmerges <= 1) {
						break;
					}
					insize *= 2;
				}
				tmp = list;
			}
			this.ctx.lights = tmp;
		}
		shaders = _gthis.ctx.allocShaderList(this.ambientShader,shaders);
		var l = this.ctx.lights;
		var i = 0;
		while(l != null) {
			if(i++ == this.maxLightsPerObject) {
				break;
			}
			shaders = _gthis.ctx.allocShaderList(l.shader,shaders);
			l = l.next;
		}
		return shaders;
	}
	,__class__: h3d_scene_fwd_LightSystem
});
var h3d_scene_fwd_DepthPass = function() {
	this.enableSky = false;
	h3d_pass_Output.call(this,"depth",[hxsl_Output.PackFloat(hxsl_Output.Value("output.depth"))]);
	this.depthMapId = hxsl_Globals.allocID("depthMap");
};
$hxClasses["h3d.scene.fwd.DepthPass"] = h3d_scene_fwd_DepthPass;
h3d_scene_fwd_DepthPass.__name__ = "h3d.scene.fwd.DepthPass";
h3d_scene_fwd_DepthPass.__super__ = h3d_pass_Output;
h3d_scene_fwd_DepthPass.prototype = $extend(h3d_pass_Output.prototype,{
	draw: function(passes,sort) {
		var texture = this.ctx.textures.allocTarget("depthMap",this.ctx.engine.width,this.ctx.engine.height,true);
		this.ctx.engine.pushTarget(texture);
		this.ctx.engine.clear(this.enableSky ? 0 : 16711680,1);
		h3d_pass_Output.prototype.draw.call(this,passes,sort);
		this.ctx.engine.popTarget();
		this.ctx.globals.map.h[this.depthMapId] = { texture : texture};
	}
	,__class__: h3d_scene_fwd_DepthPass
});
var h3d_scene_fwd_NormalPass = function() {
	h3d_pass_Output.call(this,"normal",[hxsl_Output.PackNormal(hxsl_Output.Value("output.normal"))]);
	this.normalMapId = hxsl_Globals.allocID("normalMap");
};
$hxClasses["h3d.scene.fwd.NormalPass"] = h3d_scene_fwd_NormalPass;
h3d_scene_fwd_NormalPass.__name__ = "h3d.scene.fwd.NormalPass";
h3d_scene_fwd_NormalPass.__super__ = h3d_pass_Output;
h3d_scene_fwd_NormalPass.prototype = $extend(h3d_pass_Output.prototype,{
	draw: function(passes,sort) {
		var texture = this.ctx.textures.allocTarget("normalMap",this.ctx.engine.width,this.ctx.engine.height);
		this.ctx.engine.pushTarget(texture);
		this.ctx.engine.clear(8421504,1);
		h3d_pass_Output.prototype.draw.call(this,passes,sort);
		this.ctx.engine.popTarget();
		this.ctx.globals.map.h[this.normalMapId] = texture;
	}
	,__class__: h3d_scene_fwd_NormalPass
});
var h3d_scene_fwd_Renderer = function() {
	this.shadow = new h3d_pass_DefaultShadowMap(1024);
	this.normal = new h3d_scene_fwd_NormalPass();
	this.depth = new h3d_scene_fwd_DepthPass();
	h3d_scene_Renderer.call(this);
	this.defaultPass = new h3d_pass_Output("default");
	this.allPasses = [this.defaultPass,this.depth,this.normal,this.shadow];
};
$hxClasses["h3d.scene.fwd.Renderer"] = h3d_scene_fwd_Renderer;
h3d_scene_fwd_Renderer.__name__ = "h3d.scene.fwd.Renderer";
h3d_scene_fwd_Renderer.__super__ = h3d_scene_Renderer;
h3d_scene_fwd_Renderer.prototype = $extend(h3d_scene_Renderer.prototype,{
	get_def: function() {
		return this.defaultPass;
	}
	,renderPass: function(p,passes,sort) {
		p.draw(passes,sort);
	}
	,getPassByName: function(name) {
		if(name == "alpha" || name == "additive") {
			return this.defaultPass;
		}
		return h3d_scene_Renderer.prototype.getPassByName.call(this,name);
	}
	,render: function() {
		if(this.has("shadow")) {
			this.renderPass(this.shadow,this.get("shadow"));
		}
		if(this.has("depth")) {
			this.renderPass(this.depth,this.get("depth"));
		}
		if(this.has("normal")) {
			this.renderPass(this.normal,this.get("normal"));
		}
		this.renderPass(this.defaultPass,this.get("default"));
		this.renderPass(this.defaultPass,this.get("alpha"),this.backToFront);
		this.renderPass(this.defaultPass,this.get("additive"));
	}
	,__class__: h3d_scene_fwd_Renderer
});
var h3d_shader_AmbientLight = function() {
	hxsl_Shader.call(this);
};
$hxClasses["h3d.shader.AmbientLight"] = h3d_shader_AmbientLight;
h3d_shader_AmbientLight.__name__ = "h3d.shader.AmbientLight";
h3d_shader_AmbientLight.__super__ = hxsl_Shader;
h3d_shader_AmbientLight.prototype = $extend(hxsl_Shader.prototype,{
	get_additive: function() {
		return this.additive__;
	}
	,set_additive: function(_v) {
		this.constModified = true;
		return this.additive__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		if(this.additive__) {
			this.constBits |= 2;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		if(index == 0) {
			return this.additive__;
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
		if(index == 0) {
			this.additive__ = val;
		}
	}
	,setParamIndexFloatValue: function(index,val) {
	}
	,clone: function() {
		var s = Object.create(h3d_shader_AmbientLight.prototype);
		s.shader = this.shader;
		s.additive__ = this.additive__;
		return s;
	}
	,__class__: h3d_shader_AmbientLight
});
var h3d_shader_Base2d = function() {
	this.viewportB__ = new h3d_VectorImpl(0.,0.,0.);
	this.viewportA__ = new h3d_VectorImpl(0.,0.,0.);
	this.halfPixelInverse__ = new h3d_VectorImpl(0.,0.,0.);
	this.uvPos__ = new h3d_Vector4Impl(0.,0.,0.,1.);
	this.filterMatrixB__ = new h3d_VectorImpl(0.,0.,0.);
	this.filterMatrixA__ = new h3d_VectorImpl(0.,0.,0.);
	this.absoluteMatrixB__ = new h3d_VectorImpl(0.,0.,0.);
	this.absoluteMatrixA__ = new h3d_VectorImpl(0.,0.,0.);
	this.color__ = new h3d_Vector4Impl(0.,0.,0.,1.);
	this.zValue__ = 0;
	hxsl_Shader.call(this);
};
$hxClasses["h3d.shader.Base2d"] = h3d_shader_Base2d;
h3d_shader_Base2d.__name__ = "h3d.shader.Base2d";
h3d_shader_Base2d.__super__ = hxsl_Shader;
h3d_shader_Base2d.prototype = $extend(hxsl_Shader.prototype,{
	get_zValue: function() {
		return this.zValue__;
	}
	,set_zValue: function(_v) {
		return this.zValue__ = _v;
	}
	,get_texture: function() {
		return this.texture__;
	}
	,set_texture: function(_v) {
		return this.texture__ = _v;
	}
	,get_isRelative: function() {
		return this.isRelative__;
	}
	,set_isRelative: function(_v) {
		this.constModified = true;
		return this.isRelative__ = _v;
	}
	,get_color: function() {
		return this.color__;
	}
	,set_color: function(_v) {
		return this.color__ = _v;
	}
	,get_absoluteMatrixA: function() {
		return this.absoluteMatrixA__;
	}
	,set_absoluteMatrixA: function(_v) {
		return this.absoluteMatrixA__ = _v;
	}
	,get_absoluteMatrixB: function() {
		return this.absoluteMatrixB__;
	}
	,set_absoluteMatrixB: function(_v) {
		return this.absoluteMatrixB__ = _v;
	}
	,get_filterMatrixA: function() {
		return this.filterMatrixA__;
	}
	,set_filterMatrixA: function(_v) {
		return this.filterMatrixA__ = _v;
	}
	,get_filterMatrixB: function() {
		return this.filterMatrixB__;
	}
	,set_filterMatrixB: function(_v) {
		return this.filterMatrixB__ = _v;
	}
	,get_hasUVPos: function() {
		return this.hasUVPos__;
	}
	,set_hasUVPos: function(_v) {
		this.constModified = true;
		return this.hasUVPos__ = _v;
	}
	,get_uvPos: function() {
		return this.uvPos__;
	}
	,set_uvPos: function(_v) {
		return this.uvPos__ = _v;
	}
	,get_killAlpha: function() {
		return this.killAlpha__;
	}
	,set_killAlpha: function(_v) {
		this.constModified = true;
		return this.killAlpha__ = _v;
	}
	,get_pixelAlign: function() {
		return this.pixelAlign__;
	}
	,set_pixelAlign: function(_v) {
		this.constModified = true;
		return this.pixelAlign__ = _v;
	}
	,get_halfPixelInverse: function() {
		return this.halfPixelInverse__;
	}
	,set_halfPixelInverse: function(_v) {
		return this.halfPixelInverse__ = _v;
	}
	,get_viewportA: function() {
		return this.viewportA__;
	}
	,set_viewportA: function(_v) {
		return this.viewportA__ = _v;
	}
	,get_viewportB: function() {
		return this.viewportB__;
	}
	,set_viewportB: function(_v) {
		return this.viewportB__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		if(this.isRelative__) {
			this.constBits |= 1;
		}
		if(this.hasUVPos__) {
			this.constBits |= 2;
		}
		if(this.killAlpha__) {
			this.constBits |= 4;
		}
		if(this.pixelAlign__) {
			this.constBits |= 8;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.zValue__;
		case 1:
			return this.texture__;
		case 2:
			return this.isRelative__;
		case 3:
			return this.color__;
		case 4:
			return this.absoluteMatrixA__;
		case 5:
			return this.absoluteMatrixB__;
		case 6:
			return this.filterMatrixA__;
		case 7:
			return this.filterMatrixB__;
		case 8:
			return this.hasUVPos__;
		case 9:
			return this.uvPos__;
		case 10:
			return this.killAlpha__;
		case 11:
			return this.pixelAlign__;
		case 12:
			return this.halfPixelInverse__;
		case 13:
			return this.viewportA__;
		case 14:
			return this.viewportB__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		if(index == 0) {
			return this.zValue__;
		}
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
		switch(index) {
		case 0:
			this.zValue__ = val;
			break;
		case 1:
			this.texture__ = val;
			break;
		case 2:
			this.isRelative__ = val;
			break;
		case 3:
			this.color__ = val;
			break;
		case 4:
			this.absoluteMatrixA__ = val;
			break;
		case 5:
			this.absoluteMatrixB__ = val;
			break;
		case 6:
			this.filterMatrixA__ = val;
			break;
		case 7:
			this.filterMatrixB__ = val;
			break;
		case 8:
			this.hasUVPos__ = val;
			break;
		case 9:
			this.uvPos__ = val;
			break;
		case 10:
			this.killAlpha__ = val;
			break;
		case 11:
			this.pixelAlign__ = val;
			break;
		case 12:
			this.halfPixelInverse__ = val;
			break;
		case 13:
			this.viewportA__ = val;
			break;
		case 14:
			this.viewportB__ = val;
			break;
		default:
		}
	}
	,setParamIndexFloatValue: function(index,val) {
		if(index == 0) {
			this.zValue__ = val;
		}
	}
	,clone: function() {
		var s = Object.create(h3d_shader_Base2d.prototype);
		s.shader = this.shader;
		s.zValue__ = this.zValue__;
		s.texture__ = this.texture__;
		s.isRelative__ = this.isRelative__;
		s.color__ = this.color__;
		s.absoluteMatrixA__ = this.absoluteMatrixA__;
		s.absoluteMatrixB__ = this.absoluteMatrixB__;
		s.filterMatrixA__ = this.filterMatrixA__;
		s.filterMatrixB__ = this.filterMatrixB__;
		s.hasUVPos__ = this.hasUVPos__;
		s.uvPos__ = this.uvPos__;
		s.killAlpha__ = this.killAlpha__;
		s.pixelAlign__ = this.pixelAlign__;
		s.halfPixelInverse__ = this.halfPixelInverse__;
		s.viewportA__ = this.viewportA__;
		s.viewportB__ = this.viewportB__;
		return s;
	}
	,__class__: h3d_shader_Base2d
});
var h3d_shader_BaseMesh = function() {
	this.specularColor__ = new h3d_VectorImpl(0.,0.,0.);
	this.specularAmount__ = 0;
	this.specularPower__ = 0;
	this.color__ = new h3d_Vector4Impl(0.,0.,0.,1.);
	hxsl_Shader.call(this);
	var _this = this.color__;
	var x = 1;
	var y = 1;
	var z = 1;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	_this.x = x;
	_this.y = y;
	_this.z = z;
	_this.w = 1.;
	var _this = this.specularColor__;
	var x = 1;
	var y = 1;
	var z = 1;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	_this.x = x;
	_this.y = y;
	_this.z = z;
	this.specularPower__ = 50;
	this.specularAmount__ = 1;
};
$hxClasses["h3d.shader.BaseMesh"] = h3d_shader_BaseMesh;
h3d_shader_BaseMesh.__name__ = "h3d.shader.BaseMesh";
h3d_shader_BaseMesh.__super__ = hxsl_Shader;
h3d_shader_BaseMesh.prototype = $extend(hxsl_Shader.prototype,{
	get_color: function() {
		return this.color__;
	}
	,set_color: function(_v) {
		return this.color__ = _v;
	}
	,get_specularPower: function() {
		return this.specularPower__;
	}
	,set_specularPower: function(_v) {
		return this.specularPower__ = _v;
	}
	,get_specularAmount: function() {
		return this.specularAmount__;
	}
	,set_specularAmount: function(_v) {
		return this.specularAmount__ = _v;
	}
	,get_specularColor: function() {
		return this.specularColor__;
	}
	,set_specularColor: function(_v) {
		return this.specularColor__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.color__;
		case 1:
			return this.specularPower__;
		case 2:
			return this.specularAmount__;
		case 3:
			return this.specularColor__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		switch(index) {
		case 1:
			return this.specularPower__;
		case 2:
			return this.specularAmount__;
		default:
		}
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
		switch(index) {
		case 0:
			this.color__ = val;
			break;
		case 1:
			this.specularPower__ = val;
			break;
		case 2:
			this.specularAmount__ = val;
			break;
		case 3:
			this.specularColor__ = val;
			break;
		default:
		}
	}
	,setParamIndexFloatValue: function(index,val) {
		switch(index) {
		case 1:
			this.specularPower__ = val;
			break;
		case 2:
			this.specularAmount__ = val;
			break;
		default:
		}
	}
	,clone: function() {
		var s = Object.create(h3d_shader_BaseMesh.prototype);
		s.shader = this.shader;
		s.color__ = this.color__;
		s.specularPower__ = this.specularPower__;
		s.specularAmount__ = this.specularAmount__;
		s.specularColor__ = this.specularColor__;
		return s;
	}
	,__class__: h3d_shader_BaseMesh
});
var h3d_shader_Blur = function() {
	this.cubeDir__ = new h3d_MatrixImpl();
	this.depthThresholdMaxDist__ = 0;
	this.depthThreshold__ = 1;
	this.fixedColor__ = new h3d_Vector4Impl(0.,0.,0.,1.);
	this.pixel__ = new h3d_VectorImpl(0.,0.,0.);
	this.offsets__ = [];
	this.values__ = [];
	this.Quality__ = 0;
	this.inverseProj__ = new h3d_MatrixImpl();
	h3d_shader_ScreenShader.call(this);
};
$hxClasses["h3d.shader.Blur"] = h3d_shader_Blur;
h3d_shader_Blur.__name__ = "h3d.shader.Blur";
h3d_shader_Blur.__super__ = h3d_shader_ScreenShader;
h3d_shader_Blur.prototype = $extend(h3d_shader_ScreenShader.prototype,{
	get_inverseProj: function() {
		return this.inverseProj__;
	}
	,set_inverseProj: function(_v) {
		return this.inverseProj__ = _v;
	}
	,get_texture: function() {
		return this.texture__;
	}
	,set_texture: function(_v) {
		return this.texture__ = _v;
	}
	,get_depthTexture: function() {
		return this.depthTexture__;
	}
	,set_depthTexture: function(_v) {
		return this.depthTexture__ = _v;
	}
	,get_Quality: function() {
		return this.Quality__;
	}
	,set_Quality: function(_v) {
		this.constModified = true;
		return this.Quality__ = _v;
	}
	,get_isDepth: function() {
		return this.isDepth__;
	}
	,set_isDepth: function(_v) {
		this.constModified = true;
		return this.isDepth__ = _v;
	}
	,get_values: function() {
		return this.values__;
	}
	,set_values: function(_v) {
		return this.values__ = _v;
	}
	,get_offsets: function() {
		return this.offsets__;
	}
	,set_offsets: function(_v) {
		return this.offsets__ = _v;
	}
	,get_pixel: function() {
		return this.pixel__;
	}
	,set_pixel: function(_v) {
		return this.pixel__ = _v;
	}
	,get_hasFixedColor: function() {
		return this.hasFixedColor__;
	}
	,set_hasFixedColor: function(_v) {
		this.constModified = true;
		return this.hasFixedColor__ = _v;
	}
	,get_smoothFixedColor: function() {
		return this.smoothFixedColor__;
	}
	,set_smoothFixedColor: function(_v) {
		this.constModified = true;
		return this.smoothFixedColor__ = _v;
	}
	,get_fixedColor: function() {
		return this.fixedColor__;
	}
	,set_fixedColor: function(_v) {
		return this.fixedColor__ = _v;
	}
	,get_isDepthDependant: function() {
		return this.isDepthDependant__;
	}
	,set_isDepthDependant: function(_v) {
		this.constModified = true;
		return this.isDepthDependant__ = _v;
	}
	,get_depthThreshold: function() {
		return this.depthThreshold__;
	}
	,set_depthThreshold: function(_v) {
		return this.depthThreshold__ = _v;
	}
	,get_depthThresholdMaxDist: function() {
		return this.depthThresholdMaxDist__;
	}
	,set_depthThresholdMaxDist: function(_v) {
		return this.depthThresholdMaxDist__ = _v;
	}
	,get_isCube: function() {
		return this.isCube__;
	}
	,set_isCube: function(_v) {
		this.constModified = true;
		return this.isCube__ = _v;
	}
	,get_cubeTexture: function() {
		return this.cubeTexture__;
	}
	,set_cubeTexture: function(_v) {
		return this.cubeTexture__ = _v;
	}
	,get_cubeDir: function() {
		return this.cubeDir__;
	}
	,set_cubeDir: function(_v) {
		return this.cubeDir__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		var v = this.Quality__;
		if(v >>> 8 != 0) {
			throw haxe_Exception.thrown("Quality" + " is out of range " + v + ">" + 255 + ", consider using @const(MAX_VALUE)");
		}
		this.constBits |= v;
		if(this.isDepth__) {
			this.constBits |= 256;
		}
		if(this.hasFixedColor__) {
			this.constBits |= 512;
		}
		if(this.smoothFixedColor__) {
			this.constBits |= 1024;
		}
		if(this.isDepthDependant__) {
			this.constBits |= 2048;
		}
		if(this.isCube__) {
			this.constBits |= 4096;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.inverseProj__;
		case 2:
			return this.texture__;
		case 3:
			return this.depthTexture__;
		case 4:
			return this.Quality__;
		case 5:
			return this.isDepth__;
		case 6:
			return this.values__;
		case 7:
			return this.offsets__;
		case 8:
			return this.pixel__;
		case 9:
			return this.hasFixedColor__;
		case 10:
			return this.smoothFixedColor__;
		case 11:
			return this.fixedColor__;
		case 12:
			return this.isDepthDependant__;
		case 13:
			return this.depthThreshold__;
		case 14:
			return this.depthThresholdMaxDist__;
		case 15:
			return this.isCube__;
		case 16:
			return this.cubeTexture__;
		case 17:
			return this.cubeDir__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 4:
			return this.Quality__;
		case 13:
			return this.depthThreshold__;
		case 14:
			return this.depthThresholdMaxDist__;
		default:
		}
		return 0.;
	}
	,clone: function() {
		var s = Object.create(h3d_shader_Blur.prototype);
		s.shader = this.shader;
		s.flipY__ = this.flipY__;
		s.inverseProj__ = this.inverseProj__;
		s.texture__ = this.texture__;
		s.depthTexture__ = this.depthTexture__;
		s.Quality__ = this.Quality__;
		s.isDepth__ = this.isDepth__;
		s.values__ = this.values__;
		s.offsets__ = this.offsets__;
		s.pixel__ = this.pixel__;
		s.hasFixedColor__ = this.hasFixedColor__;
		s.smoothFixedColor__ = this.smoothFixedColor__;
		s.fixedColor__ = this.fixedColor__;
		s.isDepthDependant__ = this.isDepthDependant__;
		s.depthThreshold__ = this.depthThreshold__;
		s.depthThresholdMaxDist__ = this.depthThresholdMaxDist__;
		s.isCube__ = this.isCube__;
		s.cubeTexture__ = this.cubeTexture__;
		s.cubeDir__ = this.cubeDir__;
		return s;
	}
	,__class__: h3d_shader_Blur
});
var h3d_shader_ShaderBuffers = function() {
	this.globals = new Float32Array(0);
	this.params = new Float32Array(0);
	this.tex = new Array(0);
};
$hxClasses["h3d.shader.ShaderBuffers"] = h3d_shader_ShaderBuffers;
h3d_shader_ShaderBuffers.__name__ = "h3d.shader.ShaderBuffers";
h3d_shader_ShaderBuffers.prototype = {
	grow: function(s) {
		var ng = s.globalsSize << 2;
		var np = s.paramsSize << 2;
		var nt = s.texturesCount;
		var nb = s.bufferCount;
		if(this.globals.length < ng) {
			this.globals = new Float32Array(ng);
		}
		if(this.params.length < np) {
			this.params = new Float32Array(np);
		}
		if(this.tex.length < nt) {
			this.tex = new Array(nt);
		}
		if(nb > 0 && (this.buffers == null || this.buffers.length < nb)) {
			this.buffers = new Array(nb);
		}
	}
	,__class__: h3d_shader_ShaderBuffers
};
var h3d_shader_Buffers = function() {
	this.vertex = new h3d_shader_ShaderBuffers();
	this.fragment = new h3d_shader_ShaderBuffers();
};
$hxClasses["h3d.shader.Buffers"] = h3d_shader_Buffers;
h3d_shader_Buffers.__name__ = "h3d.shader.Buffers";
h3d_shader_Buffers.prototype = {
	grow: function(s) {
		this.vertex.grow(s.vertex);
		if(s.fragment != null) {
			this.fragment.grow(s.fragment);
		}
	}
	,__class__: h3d_shader_Buffers
};
var h3d_shader_ColorAdd = function(color) {
	if(color == null) {
		color = 0;
	}
	this.color__ = new h3d_VectorImpl(0.,0.,0.);
	hxsl_Shader.call(this);
	var _this = this.color__;
	_this.x = (color >> 16 & 255) / 255;
	_this.y = (color >> 8 & 255) / 255;
	_this.z = (color & 255) / 255;
};
$hxClasses["h3d.shader.ColorAdd"] = h3d_shader_ColorAdd;
h3d_shader_ColorAdd.__name__ = "h3d.shader.ColorAdd";
h3d_shader_ColorAdd.__super__ = hxsl_Shader;
h3d_shader_ColorAdd.prototype = $extend(hxsl_Shader.prototype,{
	get_color: function() {
		return this.color__;
	}
	,set_color: function(_v) {
		return this.color__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		if(index == 0) {
			return this.color__;
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
		if(index == 0) {
			this.color__ = val;
		}
	}
	,setParamIndexFloatValue: function(index,val) {
	}
	,clone: function() {
		var s = Object.create(h3d_shader_ColorAdd.prototype);
		s.shader = this.shader;
		s.color__ = this.color__;
		return s;
	}
	,__class__: h3d_shader_ColorAdd
});
var h3d_shader_ColorKey = function(v) {
	if(v == null) {
		v = 0;
	}
	this.colorKey__ = new h3d_Vector4Impl(0.,0.,0.,1.);
	hxsl_Shader.call(this);
	var _this = this.colorKey__;
	_this.x = (v >> 16 & 255) / 255;
	_this.y = (v >> 8 & 255) / 255;
	_this.z = (v & 255) / 255;
	_this.w = (v >>> 24) / 255;
};
$hxClasses["h3d.shader.ColorKey"] = h3d_shader_ColorKey;
h3d_shader_ColorKey.__name__ = "h3d.shader.ColorKey";
h3d_shader_ColorKey.__super__ = hxsl_Shader;
h3d_shader_ColorKey.prototype = $extend(hxsl_Shader.prototype,{
	get_colorKey: function() {
		return this.colorKey__;
	}
	,set_colorKey: function(_v) {
		return this.colorKey__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		if(index == 0) {
			return this.colorKey__;
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
		if(index == 0) {
			this.colorKey__ = val;
		}
	}
	,setParamIndexFloatValue: function(index,val) {
	}
	,clone: function() {
		var s = Object.create(h3d_shader_ColorKey.prototype);
		s.shader = this.shader;
		s.colorKey__ = this.colorKey__;
		return s;
	}
	,__class__: h3d_shader_ColorKey
});
var h3d_shader_ColorMatrix = function(m) {
	this.enabled__ = true;
	this.matrix__ = new h3d_MatrixImpl();
	hxsl_Shader.call(this);
	if(m != null) {
		this.matrix__.loadValues(m);
	} else {
		this.matrix__.identity();
	}
};
$hxClasses["h3d.shader.ColorMatrix"] = h3d_shader_ColorMatrix;
h3d_shader_ColorMatrix.__name__ = "h3d.shader.ColorMatrix";
h3d_shader_ColorMatrix.__super__ = hxsl_Shader;
h3d_shader_ColorMatrix.prototype = $extend(hxsl_Shader.prototype,{
	get_matrix: function() {
		return this.matrix__;
	}
	,set_matrix: function(_v) {
		return this.matrix__ = _v;
	}
	,get_enabled: function() {
		return this.enabled__;
	}
	,set_enabled: function(_v) {
		this.constModified = true;
		return this.enabled__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		if(this.enabled__) {
			this.constBits |= 1;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.matrix__;
		case 1:
			return this.enabled__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
		switch(index) {
		case 0:
			this.matrix__ = val;
			break;
		case 1:
			this.enabled__ = val;
			break;
		default:
		}
	}
	,setParamIndexFloatValue: function(index,val) {
	}
	,clone: function() {
		var s = Object.create(h3d_shader_ColorMatrix.prototype);
		s.shader = this.shader;
		s.matrix__ = this.matrix__;
		s.enabled__ = this.enabled__;
		return s;
	}
	,__class__: h3d_shader_ColorMatrix
});
var h3d_shader_DirShadow = function() {
	this.poissonDisk__ = [];
	this.shadowBias__ = 0;
	this.shadowProj__ = new h3d_MatrixImpl();
	this.shadowMapChannel__ = hxsl_Channel.Unknown;
	this.shadowRes__ = new h3d_VectorImpl(0.,0.,0.);
	this.pcfScale__ = 0;
	this.PCF_SAMPLES__ = 0;
	this.shadowPower__ = 0;
	hxsl_Shader.call(this);
	this.set_pcfQuality(1);
};
$hxClasses["h3d.shader.DirShadow"] = h3d_shader_DirShadow;
h3d_shader_DirShadow.__name__ = "h3d.shader.DirShadow";
h3d_shader_DirShadow.__super__ = hxsl_Shader;
h3d_shader_DirShadow.prototype = $extend(hxsl_Shader.prototype,{
	set_pcfQuality: function(q) {
		var _v;
		switch(q) {
		case 2:
			var x = -0.326;
			var y = -0.406;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this1 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.840;
			var y = -0.074;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this2 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.696;
			var y = 0.457;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this3 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.203;
			var y = 0.621;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this4 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.962;
			var y = -0.195;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this5 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.473;
			var y = -0.480;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this6 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.519;
			var y = 0.767;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this7 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.185;
			var y = -0.893;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this8 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.507;
			var y = 0.064;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this9 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.896;
			var y = 0.412;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this10 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.322;
			var y = -0.933;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this11 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.792;
			var y = -0.598;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_v = [this1,this2,this3,this4,this5,this6,this7,this8,this9,this10,this11,new h3d_Vector4Impl(x,y,0.,1.)];
			break;
		case 3:
			var x = -0.613392;
			var y = 0.617481;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this1 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.170019;
			var y = -0.040254;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this2 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.299417;
			var y = 0.791925;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this3 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.645680;
			var y = 0.493210;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this4 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.651784;
			var y = 0.717887;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this5 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.421003;
			var y = 0.027070;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this6 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.817194;
			var y = -0.271096;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this7 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.705374;
			var y = -0.668203;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this8 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.977050;
			var y = -0.108615;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this9 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.063326;
			var y = 0.142369;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this10 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.203528;
			var y = 0.214331;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this11 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.667531;
			var y = 0.326090;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this12 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.098422;
			var y = -0.295755;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this13 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.885922;
			var y = 0.215369;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this14 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.566637;
			var y = 0.605213;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this15 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.039766;
			var y = -0.396100;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this16 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.751946;
			var y = 0.453352;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this17 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.078707;
			var y = -0.715323;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this18 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.075838;
			var y = -0.529344;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this19 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.724479;
			var y = -0.580798;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this20 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.222999;
			var y = -0.215125;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this21 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.467574;
			var y = -0.405438;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this22 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.248268;
			var y = -0.814753;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this23 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.354411;
			var y = -0.887570;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this24 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.175817;
			var y = 0.382366;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this25 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.487472;
			var y = -0.063082;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this26 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.084078;
			var y = 0.898312;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this27 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.488876;
			var y = -0.783441;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this28 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.470016;
			var y = 0.217933;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this29 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.696890;
			var y = -0.549791;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this30 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.149693;
			var y = 0.605762;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this31 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.034211;
			var y = 0.979980;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this32 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.503098;
			var y = -0.308878;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this33 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.016205;
			var y = -0.872921;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this34 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.385784;
			var y = -0.393902;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this35 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.146886;
			var y = -0.859249;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this36 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.643361;
			var y = 0.164098;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this37 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.634388;
			var y = -0.049471;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this38 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.688894;
			var y = 0.007843;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this39 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.464034;
			var y = -0.188818;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this40 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.440840;
			var y = 0.137486;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this41 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.364483;
			var y = 0.511704;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this42 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.034028;
			var y = 0.325968;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this43 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.099094;
			var y = -0.308023;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this44 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.693960;
			var y = -0.366253;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this45 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.678884;
			var y = -0.204688;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this46 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.001801;
			var y = 0.780328;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this47 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.145177;
			var y = -0.898984;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this48 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.062655;
			var y = -0.611866;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this49 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.315226;
			var y = -0.604297;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this50 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.780145;
			var y = 0.486251;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this51 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.371868;
			var y = 0.882138;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this52 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.200476;
			var y = 0.494430;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this53 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.494552;
			var y = -0.711051;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this54 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.612476;
			var y = 0.705252;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this55 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.578845;
			var y = -0.768792;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this56 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.772454;
			var y = -0.090976;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this57 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.504440;
			var y = 0.372295;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this58 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.155736;
			var y = 0.065157;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this59 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.391522;
			var y = 0.849605;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this60 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.620106;
			var y = -0.328104;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this61 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.789239;
			var y = -0.419965;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this62 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.545396;
			var y = 0.538133;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this63 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.178564;
			var y = -0.596057;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_v = [this1,this2,this3,this4,this5,this6,this7,this8,this9,this10,this11,this12,this13,this14,this15,this16,this17,this18,this19,this20,this21,this22,this23,this24,this25,this26,this27,this28,this29,this30,this31,this32,this33,this34,this35,this36,this37,this38,this39,this40,this41,this42,this43,this44,this45,this46,this47,this48,this49,this50,this51,this52,this53,this54,this55,this56,this57,this58,this59,this60,this61,this62,this63,new h3d_Vector4Impl(x,y,0.,1.)];
			break;
		default:
			var x = -0.942;
			var y = -0.399;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this1 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.945;
			var y = -0.768;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this2 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.094;
			var y = -0.929;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this3 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.344;
			var y = 0.293;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_v = [this1,this2,this3,new h3d_Vector4Impl(x,y,0.,1.)];
		}
		this.poissonDisk__ = _v;
		this.constModified = true;
		this.PCF_SAMPLES__ = this.poissonDisk__.length;
		return q;
	}
	,get_enable: function() {
		return this.enable__;
	}
	,set_enable: function(_v) {
		this.constModified = true;
		return this.enable__ = _v;
	}
	,get_USE_ESM: function() {
		return this.USE_ESM__;
	}
	,set_USE_ESM: function(_v) {
		this.constModified = true;
		return this.USE_ESM__ = _v;
	}
	,get_shadowPower: function() {
		return this.shadowPower__;
	}
	,set_shadowPower: function(_v) {
		return this.shadowPower__ = _v;
	}
	,get_USE_PCF: function() {
		return this.USE_PCF__;
	}
	,set_USE_PCF: function(_v) {
		this.constModified = true;
		return this.USE_PCF__ = _v;
	}
	,get_PCF_SAMPLES: function() {
		return this.PCF_SAMPLES__;
	}
	,set_PCF_SAMPLES: function(_v) {
		this.constModified = true;
		return this.PCF_SAMPLES__ = _v;
	}
	,get_pcfScale: function() {
		return this.pcfScale__;
	}
	,set_pcfScale: function(_v) {
		return this.pcfScale__ = _v;
	}
	,get_shadowRes: function() {
		return this.shadowRes__;
	}
	,set_shadowRes: function(_v) {
		return this.shadowRes__ = _v;
	}
	,get_shadowMap: function() {
		return this.shadowMap__;
	}
	,set_shadowMap: function(_v) {
		this.constModified = true;
		return this.shadowMap__ = _v;
	}
	,get_shadowMapChannel: function() {
		return this.shadowMapChannel__;
	}
	,set_shadowMapChannel: function(v) {
		this.constModified = true;
		return this.shadowMapChannel__ = v;
	}
	,get_shadowProj: function() {
		return this.shadowProj__;
	}
	,set_shadowProj: function(_v) {
		return this.shadowProj__ = _v;
	}
	,get_shadowBias: function() {
		return this.shadowBias__;
	}
	,set_shadowBias: function(_v) {
		return this.shadowBias__ = _v;
	}
	,get_poissonDisk: function() {
		return this.poissonDisk__;
	}
	,set_poissonDisk: function(_v) {
		return this.poissonDisk__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		if(this.enable__) {
			this.constBits |= 1;
		}
		if(this.USE_ESM__) {
			this.constBits |= 2;
		}
		if(this.USE_PCF__) {
			this.constBits |= 4;
		}
		var v = this.PCF_SAMPLES__;
		if(v >>> 8 != 0) {
			throw haxe_Exception.thrown("PCF_SAMPLES" + " is out of range " + v + ">" + 255 + ", consider using @const(MAX_VALUE)");
		}
		this.constBits |= v << 3;
		if(this.shadowMap__ == null) {
			this.shadowMapChannel__ = hxsl_Channel.Unknown;
		} else if(this.shadowMapChannel__ == hxsl_Channel.Unknown) {
			if(this.shadowMap__.format == h3d_mat_Texture.nativeFormat) {
				this.shadowMapChannel__ = hxsl_Channel.PackedFloat;
			} else {
				throw haxe_Exception.thrown("shadowMap" + "Channel is not set");
			}
		}
		this.constBits |= (globals.allocChannelID(this.shadowMap__) << 3 | this.shadowMapChannel__._hx_index) << 11;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.enable__;
		case 1:
			return this.USE_ESM__;
		case 2:
			return this.shadowPower__;
		case 3:
			return this.USE_PCF__;
		case 4:
			return this.PCF_SAMPLES__;
		case 5:
			return this.pcfScale__;
		case 6:
			return this.shadowRes__;
		case 7:
			return this.shadowMap__;
		case 8:
			return this.shadowProj__;
		case 9:
			return this.shadowBias__;
		case 10:
			return this.poissonDisk__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		switch(index) {
		case 2:
			return this.shadowPower__;
		case 4:
			return this.PCF_SAMPLES__;
		case 5:
			return this.pcfScale__;
		case 9:
			return this.shadowBias__;
		default:
		}
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
		switch(index) {
		case 0:
			this.enable__ = val;
			break;
		case 1:
			this.USE_ESM__ = val;
			break;
		case 2:
			this.shadowPower__ = val;
			break;
		case 3:
			this.USE_PCF__ = val;
			break;
		case 4:
			this.PCF_SAMPLES__ = val;
			break;
		case 5:
			this.pcfScale__ = val;
			break;
		case 6:
			this.shadowRes__ = val;
			break;
		case 7:
			this.shadowMap__ = val;
			break;
		case 8:
			this.shadowProj__ = val;
			break;
		case 9:
			this.shadowBias__ = val;
			break;
		case 10:
			this.poissonDisk__ = val;
			break;
		default:
		}
	}
	,setParamIndexFloatValue: function(index,val) {
		switch(index) {
		case 2:
			this.shadowPower__ = val;
			break;
		case 5:
			this.pcfScale__ = val;
			break;
		case 9:
			this.shadowBias__ = val;
			break;
		default:
		}
	}
	,clone: function() {
		var s = Object.create(h3d_shader_DirShadow.prototype);
		s.shader = this.shader;
		s.enable__ = this.enable__;
		s.USE_ESM__ = this.USE_ESM__;
		s.shadowPower__ = this.shadowPower__;
		s.USE_PCF__ = this.USE_PCF__;
		s.PCF_SAMPLES__ = this.PCF_SAMPLES__;
		s.pcfScale__ = this.pcfScale__;
		s.shadowRes__ = this.shadowRes__;
		s.shadowMap__ = this.shadowMap__;
		s.shadowProj__ = this.shadowProj__;
		s.shadowBias__ = this.shadowBias__;
		s.poissonDisk__ = this.poissonDisk__;
		return s;
	}
	,__class__: h3d_shader_DirShadow
});
var h3d_shader_GenTexture = function() {
	this.color__ = new h3d_Vector4Impl(0.,0.,0.,1.);
	this.mode__ = 0;
	h3d_shader_ScreenShader.call(this);
};
$hxClasses["h3d.shader.GenTexture"] = h3d_shader_GenTexture;
h3d_shader_GenTexture.__name__ = "h3d.shader.GenTexture";
h3d_shader_GenTexture.__super__ = h3d_shader_ScreenShader;
h3d_shader_GenTexture.prototype = $extend(h3d_shader_ScreenShader.prototype,{
	get_mode: function() {
		return this.mode__;
	}
	,set_mode: function(_v) {
		this.constModified = true;
		return this.mode__ = _v;
	}
	,get_color: function() {
		return this.color__;
	}
	,set_color: function(_v) {
		return this.color__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		var v = this.mode__;
		if(v >>> 8 != 0) {
			throw haxe_Exception.thrown("mode" + " is out of range " + v + ">" + 255 + ", consider using @const(MAX_VALUE)");
		}
		this.constBits |= v;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.mode__;
		case 2:
			return this.color__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.mode__;
		default:
		}
		return 0.;
	}
	,clone: function() {
		var s = Object.create(h3d_shader_GenTexture.prototype);
		s.shader = this.shader;
		s.flipY__ = this.flipY__;
		s.mode__ = this.mode__;
		s.color__ = this.color__;
		return s;
	}
	,__class__: h3d_shader_GenTexture
});
var h3d_shader_LineShader = function(width,lengthScale) {
	if(lengthScale == null) {
		lengthScale = 1.;
	}
	if(width == null) {
		width = 1.5;
	}
	this.width__ = 0;
	this.lengthScale__ = 0;
	hxsl_Shader.call(this);
	this.width__ = width;
	this.lengthScale__ = lengthScale;
};
$hxClasses["h3d.shader.LineShader"] = h3d_shader_LineShader;
h3d_shader_LineShader.__name__ = "h3d.shader.LineShader";
h3d_shader_LineShader.__super__ = hxsl_Shader;
h3d_shader_LineShader.prototype = $extend(hxsl_Shader.prototype,{
	get_lengthScale: function() {
		return this.lengthScale__;
	}
	,set_lengthScale: function(_v) {
		return this.lengthScale__ = _v;
	}
	,get_width: function() {
		return this.width__;
	}
	,set_width: function(_v) {
		return this.width__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.lengthScale__;
		case 1:
			return this.width__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		switch(index) {
		case 0:
			return this.lengthScale__;
		case 1:
			return this.width__;
		default:
		}
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
		switch(index) {
		case 0:
			this.lengthScale__ = val;
			break;
		case 1:
			this.width__ = val;
			break;
		default:
		}
	}
	,setParamIndexFloatValue: function(index,val) {
		switch(index) {
		case 0:
			this.lengthScale__ = val;
			break;
		case 1:
			this.width__ = val;
			break;
		default:
		}
	}
	,clone: function() {
		var s = Object.create(h3d_shader_LineShader.prototype);
		s.shader = this.shader;
		s.lengthScale__ = this.lengthScale__;
		s.width__ = this.width__;
		return s;
	}
	,__class__: h3d_shader_LineShader
});
var h3d_shader_MinMaxShader = function() {
	h3d_shader_ScreenShader.call(this);
};
$hxClasses["h3d.shader.MinMaxShader"] = h3d_shader_MinMaxShader;
h3d_shader_MinMaxShader.__name__ = "h3d.shader.MinMaxShader";
h3d_shader_MinMaxShader.__super__ = h3d_shader_ScreenShader;
h3d_shader_MinMaxShader.prototype = $extend(h3d_shader_ScreenShader.prototype,{
	get_texA: function() {
		return this.texA__;
	}
	,set_texA: function(_v) {
		return this.texA__ = _v;
	}
	,get_texB: function() {
		return this.texB__;
	}
	,set_texB: function(_v) {
		return this.texB__ = _v;
	}
	,get_isMax: function() {
		return this.isMax__;
	}
	,set_isMax: function(_v) {
		this.constModified = true;
		return this.isMax__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		if(this.isMax__) {
			this.constBits |= 1;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.texA__;
		case 2:
			return this.texB__;
		case 3:
			return this.isMax__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return 0.;
	}
	,clone: function() {
		var s = Object.create(h3d_shader_MinMaxShader.prototype);
		s.shader = this.shader;
		s.flipY__ = this.flipY__;
		s.texA__ = this.texA__;
		s.texB__ = this.texB__;
		s.isMax__ = this.isMax__;
		return s;
	}
	,__class__: h3d_shader_MinMaxShader
});
var h3d_shader_CubeMinMaxShader = function() {
	this.mat__ = new h3d_MatrixImpl();
	h3d_shader_ScreenShader.call(this);
};
$hxClasses["h3d.shader.CubeMinMaxShader"] = h3d_shader_CubeMinMaxShader;
h3d_shader_CubeMinMaxShader.__name__ = "h3d.shader.CubeMinMaxShader";
h3d_shader_CubeMinMaxShader.__super__ = h3d_shader_ScreenShader;
h3d_shader_CubeMinMaxShader.prototype = $extend(h3d_shader_ScreenShader.prototype,{
	get_texA: function() {
		return this.texA__;
	}
	,set_texA: function(_v) {
		return this.texA__ = _v;
	}
	,get_texB: function() {
		return this.texB__;
	}
	,set_texB: function(_v) {
		return this.texB__ = _v;
	}
	,get_isMax: function() {
		return this.isMax__;
	}
	,set_isMax: function(_v) {
		this.constModified = true;
		return this.isMax__ = _v;
	}
	,get_mat: function() {
		return this.mat__;
	}
	,set_mat: function(_v) {
		return this.mat__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		if(this.isMax__) {
			this.constBits |= 1;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.texA__;
		case 2:
			return this.texB__;
		case 3:
			return this.isMax__;
		case 4:
			return this.mat__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return 0.;
	}
	,clone: function() {
		var s = Object.create(h3d_shader_CubeMinMaxShader.prototype);
		s.shader = this.shader;
		s.flipY__ = this.flipY__;
		s.texA__ = this.texA__;
		s.texB__ = this.texB__;
		s.isMax__ = this.isMax__;
		s.mat__ = this.mat__;
		return s;
	}
	,__class__: h3d_shader_CubeMinMaxShader
});
var h3d_shader_NormalMap = function(texture) {
	hxsl_Shader.call(this);
	this.texture__ = texture;
};
$hxClasses["h3d.shader.NormalMap"] = h3d_shader_NormalMap;
h3d_shader_NormalMap.__name__ = "h3d.shader.NormalMap";
h3d_shader_NormalMap.__super__ = hxsl_Shader;
h3d_shader_NormalMap.prototype = $extend(hxsl_Shader.prototype,{
	get_texture: function() {
		return this.texture__;
	}
	,set_texture: function(_v) {
		return this.texture__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		if(index == 0) {
			return this.texture__;
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
		if(index == 0) {
			this.texture__ = val;
		}
	}
	,setParamIndexFloatValue: function(index,val) {
	}
	,clone: function() {
		var s = Object.create(h3d_shader_NormalMap.prototype);
		s.shader = this.shader;
		s.texture__ = this.texture__;
		return s;
	}
	,__class__: h3d_shader_NormalMap
});
var h3d_shader_Shadow = function() {
	hxsl_Shader.call(this);
};
$hxClasses["h3d.shader.Shadow"] = h3d_shader_Shadow;
h3d_shader_Shadow.__name__ = "h3d.shader.Shadow";
h3d_shader_Shadow.__super__ = hxsl_Shader;
h3d_shader_Shadow.prototype = $extend(hxsl_Shader.prototype,{
	updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
	}
	,setParamIndexFloatValue: function(index,val) {
	}
	,__class__: h3d_shader_Shadow
});
var h3d_shader_SignedDistanceField = function() {
	this.smoothing__ = 0.041666666666666664;
	this.alphaCutoff__ = 0.5;
	this.autoSmoothing__ = false;
	this.channel__ = 0;
	hxsl_Shader.call(this);
};
$hxClasses["h3d.shader.SignedDistanceField"] = h3d_shader_SignedDistanceField;
h3d_shader_SignedDistanceField.__name__ = "h3d.shader.SignedDistanceField";
h3d_shader_SignedDistanceField.__super__ = hxsl_Shader;
h3d_shader_SignedDistanceField.prototype = $extend(hxsl_Shader.prototype,{
	get_channel: function() {
		return this.channel__;
	}
	,set_channel: function(_v) {
		this.constModified = true;
		return this.channel__ = _v;
	}
	,get_autoSmoothing: function() {
		return this.autoSmoothing__;
	}
	,set_autoSmoothing: function(_v) {
		this.constModified = true;
		return this.autoSmoothing__ = _v;
	}
	,get_alphaCutoff: function() {
		return this.alphaCutoff__;
	}
	,set_alphaCutoff: function(_v) {
		return this.alphaCutoff__ = _v;
	}
	,get_smoothing: function() {
		return this.smoothing__;
	}
	,set_smoothing: function(_v) {
		return this.smoothing__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		var v = this.channel__;
		if(v >>> 8 != 0) {
			throw haxe_Exception.thrown("channel" + " is out of range " + v + ">" + 255 + ", consider using @const(MAX_VALUE)");
		}
		this.constBits |= v;
		if(this.autoSmoothing__) {
			this.constBits |= 256;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.channel__;
		case 1:
			return this.autoSmoothing__;
		case 2:
			return this.alphaCutoff__;
		case 3:
			return this.smoothing__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		switch(index) {
		case 0:
			return this.channel__;
		case 2:
			return this.alphaCutoff__;
		case 3:
			return this.smoothing__;
		default:
		}
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
		switch(index) {
		case 0:
			this.channel__ = val;
			break;
		case 1:
			this.autoSmoothing__ = val;
			break;
		case 2:
			this.alphaCutoff__ = val;
			break;
		case 3:
			this.smoothing__ = val;
			break;
		default:
		}
	}
	,setParamIndexFloatValue: function(index,val) {
		switch(index) {
		case 2:
			this.alphaCutoff__ = val;
			break;
		case 3:
			this.smoothing__ = val;
			break;
		default:
		}
	}
	,clone: function() {
		var s = Object.create(h3d_shader_SignedDistanceField.prototype);
		s.shader = this.shader;
		s.channel__ = this.channel__;
		s.autoSmoothing__ = this.autoSmoothing__;
		s.alphaCutoff__ = this.alphaCutoff__;
		s.smoothing__ = this.smoothing__;
		return s;
	}
	,__class__: h3d_shader_SignedDistanceField
});
var h3d_shader_Utils = function() {
	hxsl_Shader.call(this);
};
$hxClasses["h3d.shader.Utils"] = h3d_shader_Utils;
h3d_shader_Utils.__name__ = "h3d.shader.Utils";
h3d_shader_Utils.__super__ = hxsl_Shader;
h3d_shader_Utils.prototype = $extend(hxsl_Shader.prototype,{
	updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
	}
	,setParamIndexFloatValue: function(index,val) {
	}
	,__class__: h3d_shader_Utils
});
var h3d_shader_SkinBase = function() {
	this.bonesMatrixes__ = [];
	this.fourBonesByVertex__ = false;
	this.MaxBones__ = 0;
	hxsl_Shader.call(this);
	this.constModified = true;
	this.MaxBones__ = 34;
};
$hxClasses["h3d.shader.SkinBase"] = h3d_shader_SkinBase;
h3d_shader_SkinBase.__name__ = "h3d.shader.SkinBase";
h3d_shader_SkinBase.__super__ = hxsl_Shader;
h3d_shader_SkinBase.prototype = $extend(hxsl_Shader.prototype,{
	get_MaxBones: function() {
		return this.MaxBones__;
	}
	,set_MaxBones: function(_v) {
		this.constModified = true;
		return this.MaxBones__ = _v;
	}
	,get_fourBonesByVertex: function() {
		return this.fourBonesByVertex__;
	}
	,set_fourBonesByVertex: function(_v) {
		this.constModified = true;
		return this.fourBonesByVertex__ = _v;
	}
	,get_bonesMatrixes: function() {
		return this.bonesMatrixes__;
	}
	,set_bonesMatrixes: function(_v) {
		return this.bonesMatrixes__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		var v = this.MaxBones__;
		if(v >>> 8 != 0) {
			throw haxe_Exception.thrown("MaxBones" + " is out of range " + v + ">" + 255 + ", consider using @const(MAX_VALUE)");
		}
		this.constBits |= v;
		if(this.fourBonesByVertex__) {
			this.constBits |= 256;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.MaxBones__;
		case 1:
			return this.fourBonesByVertex__;
		case 2:
			return this.bonesMatrixes__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		if(index == 0) {
			return this.MaxBones__;
		}
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
		switch(index) {
		case 0:
			this.MaxBones__ = val;
			break;
		case 1:
			this.fourBonesByVertex__ = val;
			break;
		case 2:
			this.bonesMatrixes__ = val;
			break;
		default:
		}
	}
	,setParamIndexFloatValue: function(index,val) {
	}
	,clone: function() {
		var s = Object.create(h3d_shader_SkinBase.prototype);
		s.shader = this.shader;
		s.MaxBones__ = this.MaxBones__;
		s.fourBonesByVertex__ = this.fourBonesByVertex__;
		s.bonesMatrixes__ = this.bonesMatrixes__;
		return s;
	}
	,__class__: h3d_shader_SkinBase
});
var h3d_shader_Skin = function() {
	h3d_shader_SkinBase.call(this);
};
$hxClasses["h3d.shader.Skin"] = h3d_shader_Skin;
h3d_shader_Skin.__name__ = "h3d.shader.Skin";
h3d_shader_Skin.__super__ = h3d_shader_SkinBase;
h3d_shader_Skin.prototype = $extend(h3d_shader_SkinBase.prototype,{
	updateConstants: function(globals) {
		this.constBits = 0;
		var v = this.MaxBones__;
		if(v >>> 8 != 0) {
			throw haxe_Exception.thrown("MaxBones" + " is out of range " + v + ">" + 255 + ", consider using @const(MAX_VALUE)");
		}
		this.constBits |= v;
		if(this.fourBonesByVertex__) {
			this.constBits |= 256;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.MaxBones__;
		case 1:
			return this.fourBonesByVertex__;
		case 2:
			return this.bonesMatrixes__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		if(index == 0) {
			return this.MaxBones__;
		}
		return 0.;
	}
	,clone: function() {
		var s = Object.create(h3d_shader_Skin.prototype);
		s.shader = this.shader;
		s.MaxBones__ = this.MaxBones__;
		s.fourBonesByVertex__ = this.fourBonesByVertex__;
		s.bonesMatrixes__ = this.bonesMatrixes__;
		return s;
	}
	,__class__: h3d_shader_Skin
});
var h3d_shader_SkinTangent = function() {
	h3d_shader_SkinBase.call(this);
};
$hxClasses["h3d.shader.SkinTangent"] = h3d_shader_SkinTangent;
h3d_shader_SkinTangent.__name__ = "h3d.shader.SkinTangent";
h3d_shader_SkinTangent.__super__ = h3d_shader_SkinBase;
h3d_shader_SkinTangent.prototype = $extend(h3d_shader_SkinBase.prototype,{
	updateConstants: function(globals) {
		this.constBits = 0;
		var v = this.MaxBones__;
		if(v >>> 8 != 0) {
			throw haxe_Exception.thrown("MaxBones" + " is out of range " + v + ">" + 255 + ", consider using @const(MAX_VALUE)");
		}
		this.constBits |= v;
		if(this.fourBonesByVertex__) {
			this.constBits |= 256;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.MaxBones__;
		case 1:
			return this.fourBonesByVertex__;
		case 2:
			return this.bonesMatrixes__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		if(index == 0) {
			return this.MaxBones__;
		}
		return 0.;
	}
	,clone: function() {
		var s = Object.create(h3d_shader_SkinTangent.prototype);
		s.shader = this.shader;
		s.MaxBones__ = this.MaxBones__;
		s.fourBonesByVertex__ = this.fourBonesByVertex__;
		s.bonesMatrixes__ = this.bonesMatrixes__;
		return s;
	}
	,__class__: h3d_shader_SkinTangent
});
var h3d_shader_SpecularTexture = function(tex) {
	hxsl_Shader.call(this);
	this.texture__ = tex;
};
$hxClasses["h3d.shader.SpecularTexture"] = h3d_shader_SpecularTexture;
h3d_shader_SpecularTexture.__name__ = "h3d.shader.SpecularTexture";
h3d_shader_SpecularTexture.__super__ = hxsl_Shader;
h3d_shader_SpecularTexture.prototype = $extend(hxsl_Shader.prototype,{
	get_texture: function() {
		return this.texture__;
	}
	,set_texture: function(_v) {
		return this.texture__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		if(index == 0) {
			return this.texture__;
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
		if(index == 0) {
			this.texture__ = val;
		}
	}
	,setParamIndexFloatValue: function(index,val) {
	}
	,clone: function() {
		var s = Object.create(h3d_shader_SpecularTexture.prototype);
		s.shader = this.shader;
		s.texture__ = this.texture__;
		return s;
	}
	,__class__: h3d_shader_SpecularTexture
});
var h3d_shader_Texture = function(tex) {
	this.killAlphaThreshold__ = 0;
	hxsl_Shader.call(this);
	this.texture__ = tex;
	this.killAlphaThreshold__ = h3d_mat_Defaults.defaultKillAlphaThreshold;
};
$hxClasses["h3d.shader.Texture"] = h3d_shader_Texture;
h3d_shader_Texture.__name__ = "h3d.shader.Texture";
h3d_shader_Texture.__super__ = hxsl_Shader;
h3d_shader_Texture.prototype = $extend(hxsl_Shader.prototype,{
	get_additive: function() {
		return this.additive__;
	}
	,set_additive: function(_v) {
		this.constModified = true;
		return this.additive__ = _v;
	}
	,get_killAlpha: function() {
		return this.killAlpha__;
	}
	,set_killAlpha: function(_v) {
		this.constModified = true;
		return this.killAlpha__ = _v;
	}
	,get_specularAlpha: function() {
		return this.specularAlpha__;
	}
	,set_specularAlpha: function(_v) {
		this.constModified = true;
		return this.specularAlpha__ = _v;
	}
	,get_killAlphaThreshold: function() {
		return this.killAlphaThreshold__;
	}
	,set_killAlphaThreshold: function(_v) {
		return this.killAlphaThreshold__ = _v;
	}
	,get_texture: function() {
		return this.texture__;
	}
	,set_texture: function(_v) {
		return this.texture__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		if(this.additive__) {
			this.constBits |= 1;
		}
		if(this.killAlpha__) {
			this.constBits |= 2;
		}
		if(this.specularAlpha__) {
			this.constBits |= 4;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.additive__;
		case 1:
			return this.killAlpha__;
		case 2:
			return this.specularAlpha__;
		case 3:
			return this.killAlphaThreshold__;
		case 4:
			return this.texture__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		if(index == 3) {
			return this.killAlphaThreshold__;
		}
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
		switch(index) {
		case 0:
			this.additive__ = val;
			break;
		case 1:
			this.killAlpha__ = val;
			break;
		case 2:
			this.specularAlpha__ = val;
			break;
		case 3:
			this.killAlphaThreshold__ = val;
			break;
		case 4:
			this.texture__ = val;
			break;
		default:
		}
	}
	,setParamIndexFloatValue: function(index,val) {
		if(index == 3) {
			this.killAlphaThreshold__ = val;
		}
	}
	,clone: function() {
		var s = Object.create(h3d_shader_Texture.prototype);
		s.shader = this.shader;
		s.additive__ = this.additive__;
		s.killAlpha__ = this.killAlpha__;
		s.specularAlpha__ = this.specularAlpha__;
		s.killAlphaThreshold__ = this.killAlphaThreshold__;
		s.texture__ = this.texture__;
		return s;
	}
	,__class__: h3d_shader_Texture
});
var h3d_shader_UVDelta = function(dx,dy,sx,sy) {
	if(sy == null) {
		sy = 1.;
	}
	if(sx == null) {
		sx = 1.;
	}
	if(dy == null) {
		dy = 0.;
	}
	if(dx == null) {
		dx = 0.;
	}
	this.uvScale__ = new h3d_VectorImpl(0.,0.,0.);
	this.uvDelta__ = new h3d_VectorImpl(0.,0.,0.);
	hxsl_Shader.call(this);
	var _this = this.uvDelta__;
	var x = dx;
	var y = dy;
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	_this.x = x;
	_this.y = y;
	_this.z = 0.;
	var _this = this.uvScale__;
	var x = sx;
	var y = sy;
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	_this.x = x;
	_this.y = y;
	_this.z = 0.;
};
$hxClasses["h3d.shader.UVDelta"] = h3d_shader_UVDelta;
h3d_shader_UVDelta.__name__ = "h3d.shader.UVDelta";
h3d_shader_UVDelta.__super__ = hxsl_Shader;
h3d_shader_UVDelta.prototype = $extend(hxsl_Shader.prototype,{
	get_uvDelta: function() {
		return this.uvDelta__;
	}
	,set_uvDelta: function(_v) {
		return this.uvDelta__ = _v;
	}
	,get_uvScale: function() {
		return this.uvScale__;
	}
	,set_uvScale: function(_v) {
		return this.uvScale__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.uvDelta__;
		case 1:
			return this.uvScale__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
		switch(index) {
		case 0:
			this.uvDelta__ = val;
			break;
		case 1:
			this.uvScale__ = val;
			break;
		default:
		}
	}
	,setParamIndexFloatValue: function(index,val) {
	}
	,clone: function() {
		var s = Object.create(h3d_shader_UVDelta.prototype);
		s.shader = this.shader;
		s.uvDelta__ = this.uvDelta__;
		s.uvScale__ = this.uvScale__;
		return s;
	}
	,__class__: h3d_shader_UVDelta
});
var h3d_shader_VertexColorAlpha = function() {
	hxsl_Shader.call(this);
};
$hxClasses["h3d.shader.VertexColorAlpha"] = h3d_shader_VertexColorAlpha;
h3d_shader_VertexColorAlpha.__name__ = "h3d.shader.VertexColorAlpha";
h3d_shader_VertexColorAlpha.__super__ = hxsl_Shader;
h3d_shader_VertexColorAlpha.prototype = $extend(hxsl_Shader.prototype,{
	get_additive: function() {
		return this.additive__;
	}
	,set_additive: function(_v) {
		this.constModified = true;
		return this.additive__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		if(this.additive__) {
			this.constBits |= 1;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		if(index == 0) {
			return this.additive__;
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
		if(index == 0) {
			this.additive__ = val;
		}
	}
	,setParamIndexFloatValue: function(index,val) {
	}
	,clone: function() {
		var s = Object.create(h3d_shader_VertexColorAlpha.prototype);
		s.shader = this.shader;
		s.additive__ = this.additive__;
		return s;
	}
	,__class__: h3d_shader_VertexColorAlpha
});
var h3d_shader_VolumeDecal = function(objectWidth,objectHeight) {
	this.isCentered__ = true;
	this.tangent__ = new h3d_VectorImpl(0.,0.,0.);
	this.normal__ = new h3d_VectorImpl(0.,0.,0.);
	this.scale__ = new h3d_VectorImpl(0.,0.,0.);
	hxsl_Shader.call(this);
	var _this = this.normal__;
	var x = 0;
	var y = 0;
	var z = 1;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	_this.x = x;
	_this.y = y;
	_this.z = z;
	var _this = this.tangent__;
	var x = 1;
	var y = 0;
	var z = 0;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	_this.x = x;
	_this.y = y;
	_this.z = z;
	var _this = this.scale__;
	var x = 1 / objectWidth;
	var y = 1 / objectHeight;
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	_this.x = x;
	_this.y = y;
	_this.z = 0.;
};
$hxClasses["h3d.shader.VolumeDecal"] = h3d_shader_VolumeDecal;
h3d_shader_VolumeDecal.__name__ = "h3d.shader.VolumeDecal";
h3d_shader_VolumeDecal.__super__ = hxsl_Shader;
h3d_shader_VolumeDecal.prototype = $extend(hxsl_Shader.prototype,{
	get_scale: function() {
		return this.scale__;
	}
	,set_scale: function(_v) {
		return this.scale__ = _v;
	}
	,get_normal: function() {
		return this.normal__;
	}
	,set_normal: function(_v) {
		return this.normal__ = _v;
	}
	,get_tangent: function() {
		return this.tangent__;
	}
	,set_tangent: function(_v) {
		return this.tangent__ = _v;
	}
	,get_isCentered: function() {
		return this.isCentered__;
	}
	,set_isCentered: function(_v) {
		this.constModified = true;
		return this.isCentered__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		if(this.isCentered__) {
			this.constBits |= 64;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.scale__;
		case 1:
			return this.normal__;
		case 2:
			return this.tangent__;
		case 3:
			return this.isCentered__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
		switch(index) {
		case 0:
			this.scale__ = val;
			break;
		case 1:
			this.normal__ = val;
			break;
		case 2:
			this.tangent__ = val;
			break;
		case 3:
			this.isCentered__ = val;
			break;
		default:
		}
	}
	,setParamIndexFloatValue: function(index,val) {
	}
	,clone: function() {
		var s = Object.create(h3d_shader_VolumeDecal.prototype);
		s.shader = this.shader;
		s.scale__ = this.scale__;
		s.normal__ = this.normal__;
		s.tangent__ = this.tangent__;
		s.isCentered__ = this.isCentered__;
		return s;
	}
	,__class__: h3d_shader_VolumeDecal
});
var haxe_StackItem = $hxEnums["haxe.StackItem"] = { __ename__:true,__constructs__:null
	,CFunction: {_hx_name:"CFunction",_hx_index:0,__enum__:"haxe.StackItem",toString:$estr}
	,Module: ($_=function(m) { return {_hx_index:1,m:m,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="Module",$_.__params__ = ["m"],$_)
	,FilePos: ($_=function(s,file,line,column) { return {_hx_index:2,s:s,file:file,line:line,column:column,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="FilePos",$_.__params__ = ["s","file","line","column"],$_)
	,Method: ($_=function(classname,method) { return {_hx_index:3,classname:classname,method:method,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="Method",$_.__params__ = ["classname","method"],$_)
	,LocalFunction: ($_=function(v) { return {_hx_index:4,v:v,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="LocalFunction",$_.__params__ = ["v"],$_)
};
haxe_StackItem.__constructs__ = [haxe_StackItem.CFunction,haxe_StackItem.Module,haxe_StackItem.FilePos,haxe_StackItem.Method,haxe_StackItem.LocalFunction];
haxe_StackItem.__empty_constructs__ = [haxe_StackItem.CFunction];
var haxe_CallStack = {};
haxe_CallStack.callStack = function() {
	return haxe_NativeStackTrace.toHaxe(haxe_NativeStackTrace.callStack());
};
var haxe_EntryPoint = function() { };
$hxClasses["haxe.EntryPoint"] = haxe_EntryPoint;
haxe_EntryPoint.__name__ = "haxe.EntryPoint";
haxe_EntryPoint.processEvents = function() {
	while(true) {
		var f = haxe_EntryPoint.pending.shift();
		if(f == null) {
			break;
		}
		f();
	}
	var time = haxe_MainLoop.tick();
	if(!haxe_MainLoop.hasEvents() && haxe_EntryPoint.threadCount == 0) {
		return -1;
	}
	return time;
};
haxe_EntryPoint.run = function() {
	var nextTick = haxe_EntryPoint.processEvents();
	if(typeof(window) != "undefined") {
		var $window = window;
		var rqf = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame || $window.mozRequestAnimationFrame;
		if(rqf != null) {
			rqf(haxe_EntryPoint.run);
		} else if(nextTick >= 0) {
			setTimeout(haxe_EntryPoint.run,nextTick * 1000);
		}
	} else if(nextTick >= 0) {
		setTimeout(haxe_EntryPoint.run,nextTick * 1000);
	}
};
var haxe_EnumFlags = {};
haxe_EnumFlags.from = function(e) {
	var i = 1 << e._hx_index;
	if(i == null) {
		i = 0;
	}
	return i;
};
var haxe_Exception = function(message,previous,native) {
	Error.call(this,message);
	this.message = message;
	this.__previousException = previous;
	this.__nativeException = native != null ? native : this;
};
$hxClasses["haxe.Exception"] = haxe_Exception;
haxe_Exception.__name__ = "haxe.Exception";
haxe_Exception.caught = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value;
	} else if(((value) instanceof Error)) {
		return new haxe_Exception(value.message,null,value);
	} else {
		return new haxe_ValueException(value,null,value);
	}
};
haxe_Exception.thrown = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value.get_native();
	} else if(((value) instanceof Error)) {
		return value;
	} else {
		var e = new haxe_ValueException(value);
		return e;
	}
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
	unwrap: function() {
		return this.__nativeException;
	}
	,toString: function() {
		return this.get_message();
	}
	,get_message: function() {
		return this.message;
	}
	,get_native: function() {
		return this.__nativeException;
	}
	,__class__: haxe_Exception
});
var haxe_Log = function() { };
$hxClasses["haxe.Log"] = haxe_Log;
haxe_Log.__name__ = "haxe.Log";
haxe_Log.formatOutput = function(v,infos) {
	var str = Std.string(v);
	if(infos == null) {
		return str;
	}
	var pstr = infos.fileName + ":" + infos.lineNumber;
	if(infos.customParams != null) {
		var _g = 0;
		var _g1 = infos.customParams;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			str += ", " + Std.string(v);
		}
	}
	return pstr + ": " + str;
};
haxe_Log.trace = function(v,infos) {
	var str = haxe_Log.formatOutput(v,infos);
	if(typeof(console) != "undefined" && console.log != null) {
		console.log(str);
	}
};
var haxe_MainEvent = function(f,p) {
	this.isBlocking = true;
	this.f = f;
	this.priority = p;
	this.nextRun = -Infinity;
};
$hxClasses["haxe.MainEvent"] = haxe_MainEvent;
haxe_MainEvent.__name__ = "haxe.MainEvent";
haxe_MainEvent.prototype = {
	stop: function() {
		if(this.f == null) {
			return;
		}
		this.f = null;
		this.nextRun = -Infinity;
		if(this.prev == null) {
			haxe_MainLoop.pending = this.next;
		} else {
			this.prev.next = this.next;
		}
		if(this.next != null) {
			this.next.prev = this.prev;
		}
	}
	,__class__: haxe_MainEvent
};
var haxe_MainLoop = function() { };
$hxClasses["haxe.MainLoop"] = haxe_MainLoop;
haxe_MainLoop.__name__ = "haxe.MainLoop";
haxe_MainLoop.hasEvents = function() {
	var p = haxe_MainLoop.pending;
	while(p != null) {
		if(p.isBlocking) {
			return true;
		}
		p = p.next;
	}
	return false;
};
haxe_MainLoop.add = function(f,priority) {
	if(priority == null) {
		priority = 0;
	}
	if(f == null) {
		throw haxe_Exception.thrown("Event function is null");
	}
	var e = new haxe_MainEvent(f,priority);
	var head = haxe_MainLoop.pending;
	if(head != null) {
		head.prev = e;
	}
	e.next = head;
	haxe_MainLoop.pending = e;
	return e;
};
haxe_MainLoop.sortEvents = function() {
	var list = haxe_MainLoop.pending;
	if(list == null) {
		return;
	}
	var insize = 1;
	var nmerges;
	var psize = 0;
	var qsize = 0;
	var p;
	var q;
	var e;
	var tail;
	while(true) {
		p = list;
		list = null;
		tail = null;
		nmerges = 0;
		while(p != null) {
			++nmerges;
			q = p;
			psize = 0;
			var _g = 0;
			var _g1 = insize;
			while(_g < _g1) {
				var i = _g++;
				++psize;
				q = q.next;
				if(q == null) {
					break;
				}
			}
			qsize = insize;
			while(psize > 0 || qsize > 0 && q != null) {
				if(psize == 0) {
					e = q;
					q = q.next;
					--qsize;
				} else if(qsize == 0 || q == null || (p.priority > q.priority || p.priority == q.priority && p.nextRun <= q.nextRun)) {
					e = p;
					p = p.next;
					--psize;
				} else {
					e = q;
					q = q.next;
					--qsize;
				}
				if(tail != null) {
					tail.next = e;
				} else {
					list = e;
				}
				e.prev = tail;
				tail = e;
			}
			p = q;
		}
		tail.next = null;
		if(nmerges <= 1) {
			break;
		}
		insize *= 2;
	}
	list.prev = null;
	haxe_MainLoop.pending = list;
};
haxe_MainLoop.tick = function() {
	haxe_MainLoop.sortEvents();
	var e = haxe_MainLoop.pending;
	var now = HxOverrides.now() / 1000;
	var wait = 1e9;
	while(e != null) {
		var next = e.next;
		var wt = e.nextRun - now;
		if(wt <= 0) {
			wait = 0;
			if(e.f != null) {
				e.f();
			}
		} else if(wait > wt) {
			wait = wt;
		}
		e = next;
	}
	return wait;
};
var haxe_NativeStackTrace = function() { };
$hxClasses["haxe.NativeStackTrace"] = haxe_NativeStackTrace;
haxe_NativeStackTrace.__name__ = "haxe.NativeStackTrace";
haxe_NativeStackTrace.callStack = function() {
	var e = new Error("");
	var stack = haxe_NativeStackTrace.tryHaxeStack(e);
	if(typeof(stack) == "undefined") {
		try {
			throw e;
		} catch( _g ) {
		}
		stack = e.stack;
	}
	return haxe_NativeStackTrace.normalize(stack,2);
};
haxe_NativeStackTrace.toHaxe = function(s,skip) {
	if(skip == null) {
		skip = 0;
	}
	if(s == null) {
		return [];
	} else if(typeof(s) == "string") {
		var stack = s.split("\n");
		if(stack[0] == "Error") {
			stack.shift();
		}
		var m = [];
		var _g = 0;
		var _g1 = stack.length;
		while(_g < _g1) {
			var i = _g++;
			if(skip > i) {
				continue;
			}
			var line = stack[i];
			var matched = line.match(/^    at ([$A-Za-z0-9_. ]+) \(([^)]+):([0-9]+):([0-9]+)\)$/);
			if(matched != null) {
				var path = matched[1].split(".");
				if(path[0] == "$hxClasses") {
					path.shift();
				}
				var meth = path.pop();
				var file = matched[2];
				var line1 = Std.parseInt(matched[3]);
				var column = Std.parseInt(matched[4]);
				m.push(haxe_StackItem.FilePos(meth == "Anonymous function" ? haxe_StackItem.LocalFunction() : meth == "Global code" ? null : haxe_StackItem.Method(path.join("."),meth),file,line1,column));
			} else {
				m.push(haxe_StackItem.Module(StringTools.trim(line)));
			}
		}
		return m;
	} else if(skip > 0 && Array.isArray(s)) {
		return s.slice(skip);
	} else {
		return s;
	}
};
haxe_NativeStackTrace.tryHaxeStack = function(e) {
	if(e == null) {
		return [];
	}
	var oldValue = Error.prepareStackTrace;
	Error.prepareStackTrace = haxe_NativeStackTrace.prepareHxStackTrace;
	var stack = e.stack;
	Error.prepareStackTrace = oldValue;
	return stack;
};
haxe_NativeStackTrace.prepareHxStackTrace = function(e,callsites) {
	var stack = [];
	var _g = 0;
	while(_g < callsites.length) {
		var site = callsites[_g];
		++_g;
		if(haxe_NativeStackTrace.wrapCallSite != null) {
			site = haxe_NativeStackTrace.wrapCallSite(site);
		}
		var method = null;
		var fullName = site.getFunctionName();
		if(fullName != null) {
			var idx = fullName.lastIndexOf(".");
			if(idx >= 0) {
				var className = fullName.substring(0,idx);
				var methodName = fullName.substring(idx + 1);
				method = haxe_StackItem.Method(className,methodName);
			} else {
				method = haxe_StackItem.Method(null,fullName);
			}
		}
		var fileName = site.getFileName();
		var fileAddr = fileName == null ? -1 : fileName.indexOf("file:");
		if(haxe_NativeStackTrace.wrapCallSite != null && fileAddr > 0) {
			fileName = fileName.substring(fileAddr + 6);
		}
		stack.push(haxe_StackItem.FilePos(method,fileName,site.getLineNumber(),site.getColumnNumber()));
	}
	return stack;
};
haxe_NativeStackTrace.normalize = function(stack,skipItems) {
	if(skipItems == null) {
		skipItems = 0;
	}
	if(Array.isArray(stack) && skipItems > 0) {
		return stack.slice(skipItems);
	} else if(typeof(stack) == "string") {
		switch(stack.substring(0,6)) {
		case "Error\n":case "Error:":
			++skipItems;
			break;
		default:
		}
		return haxe_NativeStackTrace.skipLines(stack,skipItems);
	} else {
		return stack;
	}
};
haxe_NativeStackTrace.skipLines = function(stack,skip,pos) {
	if(pos == null) {
		pos = 0;
	}
	if(skip > 0) {
		pos = stack.indexOf("\n",pos);
		if(pos < 0) {
			return "";
		} else {
			return haxe_NativeStackTrace.skipLines(stack,--skip,pos + 1);
		}
	} else {
		return stack.substring(pos);
	}
};
var haxe_Resource = function() { };
$hxClasses["haxe.Resource"] = haxe_Resource;
haxe_Resource.__name__ = "haxe.Resource";
haxe_Resource.getBytes = function(name) {
	var _g = 0;
	var _g1 = haxe_Resource.content;
	while(_g < _g1.length) {
		var x = _g1[_g];
		++_g;
		if(x.name == name) {
			if(x.str != null) {
				return haxe_io_Bytes.ofString(x.str);
			}
			return haxe_crypto_Base64.decode(x.data);
		}
	}
	return null;
};
var haxe_Timer = function(time_ms) {
	var me = this;
	this.id = setInterval(function() {
		me.run();
	},time_ms);
};
$hxClasses["haxe.Timer"] = haxe_Timer;
haxe_Timer.__name__ = "haxe.Timer";
haxe_Timer.delay = function(f,time_ms) {
	var t = new haxe_Timer(time_ms);
	t.run = function() {
		t.stop();
		f();
	};
	return t;
};
haxe_Timer.prototype = {
	stop: function() {
		if(this.id == null) {
			return;
		}
		clearInterval(this.id);
		this.id = null;
	}
	,run: function() {
	}
	,__class__: haxe_Timer
};
var haxe__$Unserializer_DefaultResolver = function() {
};
$hxClasses["haxe._Unserializer.DefaultResolver"] = haxe__$Unserializer_DefaultResolver;
haxe__$Unserializer_DefaultResolver.__name__ = "haxe._Unserializer.DefaultResolver";
haxe__$Unserializer_DefaultResolver.prototype = {
	resolveClass: function(name) {
		return $hxClasses[name];
	}
	,resolveEnum: function(name) {
		return $hxEnums[name];
	}
	,__class__: haxe__$Unserializer_DefaultResolver
};
var haxe_Unserializer = function(buf) {
	this.buf = buf;
	this.length = this.buf.length;
	this.pos = 0;
	this.scache = [];
	this.cache = [];
	var r = haxe_Unserializer.DEFAULT_RESOLVER;
	if(r == null) {
		r = new haxe__$Unserializer_DefaultResolver();
		haxe_Unserializer.DEFAULT_RESOLVER = r;
	}
	this.resolver = r;
};
$hxClasses["haxe.Unserializer"] = haxe_Unserializer;
haxe_Unserializer.__name__ = "haxe.Unserializer";
haxe_Unserializer.initCodes = function() {
	var codes = [];
	var _g = 0;
	var _g1 = haxe_Unserializer.BASE64.length;
	while(_g < _g1) {
		var i = _g++;
		codes[haxe_Unserializer.BASE64.charCodeAt(i)] = i;
	}
	return codes;
};
haxe_Unserializer.run = function(v) {
	return new haxe_Unserializer(v).unserialize();
};
haxe_Unserializer.prototype = {
	readDigits: function() {
		var k = 0;
		var s = false;
		var fpos = this.pos;
		while(true) {
			var c = this.buf.charCodeAt(this.pos);
			if(c != c) {
				break;
			}
			if(c == 45) {
				if(this.pos != fpos) {
					break;
				}
				s = true;
				this.pos++;
				continue;
			}
			if(c < 48 || c > 57) {
				break;
			}
			k = k * 10 + (c - 48);
			this.pos++;
		}
		if(s) {
			k *= -1;
		}
		return k;
	}
	,readFloat: function() {
		var p1 = this.pos;
		while(true) {
			var c = this.buf.charCodeAt(this.pos);
			if(c != c) {
				break;
			}
			if(c >= 43 && c < 58 || c == 101 || c == 69) {
				this.pos++;
			} else {
				break;
			}
		}
		return parseFloat(HxOverrides.substr(this.buf,p1,this.pos - p1));
	}
	,unserializeObject: function(o) {
		while(true) {
			if(this.pos >= this.length) {
				throw haxe_Exception.thrown("Invalid object");
			}
			if(this.buf.charCodeAt(this.pos) == 103) {
				break;
			}
			var k = this.unserialize();
			if(typeof(k) != "string") {
				throw haxe_Exception.thrown("Invalid object key");
			}
			var v = this.unserialize();
			o[k] = v;
		}
		this.pos++;
	}
	,unserializeEnum: function(edecl,tag) {
		if(this.buf.charCodeAt(this.pos++) != 58) {
			throw haxe_Exception.thrown("Invalid enum format");
		}
		var nargs = this.readDigits();
		if(nargs == 0) {
			return Type.createEnum(edecl,tag);
		}
		var args = [];
		while(nargs-- > 0) args.push(this.unserialize());
		return Type.createEnum(edecl,tag,args);
	}
	,unserialize: function() {
		switch(this.buf.charCodeAt(this.pos++)) {
		case 65:
			var name = this.unserialize();
			var cl = this.resolver.resolveClass(name);
			if(cl == null) {
				throw haxe_Exception.thrown("Class not found " + name);
			}
			return cl;
		case 66:
			var name = this.unserialize();
			var e = this.resolver.resolveEnum(name);
			if(e == null) {
				throw haxe_Exception.thrown("Enum not found " + name);
			}
			return e;
		case 67:
			var name = this.unserialize();
			var cl = this.resolver.resolveClass(name);
			if(cl == null) {
				throw haxe_Exception.thrown("Class not found " + name);
			}
			var o = Object.create(cl.prototype);
			this.cache.push(o);
			o.hxUnserialize(this);
			if(this.buf.charCodeAt(this.pos++) != 103) {
				throw haxe_Exception.thrown("Invalid custom data");
			}
			return o;
		case 77:
			var h = new haxe_ds_ObjectMap();
			this.cache.push(h);
			var buf = this.buf;
			while(this.buf.charCodeAt(this.pos) != 104) {
				var s = this.unserialize();
				h.set(s,this.unserialize());
			}
			this.pos++;
			return h;
		case 82:
			var n = this.readDigits();
			if(n < 0 || n >= this.scache.length) {
				throw haxe_Exception.thrown("Invalid string reference");
			}
			return this.scache[n];
		case 97:
			var buf = this.buf;
			var a = [];
			this.cache.push(a);
			while(true) {
				var c = this.buf.charCodeAt(this.pos);
				if(c == 104) {
					this.pos++;
					break;
				}
				if(c == 117) {
					this.pos++;
					var n = this.readDigits();
					a[a.length + n - 1] = null;
				} else {
					a.push(this.unserialize());
				}
			}
			return a;
		case 98:
			var h = new haxe_ds_StringMap();
			this.cache.push(h);
			var buf = this.buf;
			while(this.buf.charCodeAt(this.pos) != 104) {
				var s = this.unserialize();
				var value = this.unserialize();
				h.h[s] = value;
			}
			this.pos++;
			return h;
		case 99:
			var name = this.unserialize();
			var cl = this.resolver.resolveClass(name);
			if(cl == null) {
				throw haxe_Exception.thrown("Class not found " + name);
			}
			var o = Object.create(cl.prototype);
			this.cache.push(o);
			this.unserializeObject(o);
			return o;
		case 100:
			return this.readFloat();
		case 102:
			return false;
		case 105:
			return this.readDigits();
		case 106:
			var name = this.unserialize();
			var edecl = this.resolver.resolveEnum(name);
			if(edecl == null) {
				throw haxe_Exception.thrown("Enum not found " + name);
			}
			this.pos++;
			var index = this.readDigits();
			var _this = edecl.__constructs__;
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = _this[i]._hx_name;
			}
			var tag = result[index];
			if(tag == null) {
				throw haxe_Exception.thrown("Unknown enum index " + name + "@" + index);
			}
			var e = this.unserializeEnum(edecl,tag);
			this.cache.push(e);
			return e;
		case 107:
			return NaN;
		case 108:
			var l = new haxe_ds_List();
			this.cache.push(l);
			var buf = this.buf;
			while(this.buf.charCodeAt(this.pos) != 104) l.add(this.unserialize());
			this.pos++;
			return l;
		case 109:
			return -Infinity;
		case 110:
			return null;
		case 111:
			var o = { };
			this.cache.push(o);
			this.unserializeObject(o);
			return o;
		case 112:
			return Infinity;
		case 113:
			var h = new haxe_ds_IntMap();
			this.cache.push(h);
			var buf = this.buf;
			var c = this.buf.charCodeAt(this.pos++);
			while(c == 58) {
				var i = this.readDigits();
				var value = this.unserialize();
				h.h[i] = value;
				c = this.buf.charCodeAt(this.pos++);
			}
			if(c != 104) {
				throw haxe_Exception.thrown("Invalid IntMap format");
			}
			return h;
		case 114:
			var n = this.readDigits();
			if(n < 0 || n >= this.cache.length) {
				throw haxe_Exception.thrown("Invalid reference");
			}
			return this.cache[n];
		case 115:
			var len = this.readDigits();
			var buf = this.buf;
			if(this.buf.charCodeAt(this.pos++) != 58 || this.length - this.pos < len) {
				throw haxe_Exception.thrown("Invalid bytes length");
			}
			var codes = haxe_Unserializer.CODES;
			if(codes == null) {
				codes = haxe_Unserializer.initCodes();
				haxe_Unserializer.CODES = codes;
			}
			var i = this.pos;
			var rest = len & 3;
			var size = (len >> 2) * 3 + (rest >= 2 ? rest - 1 : 0);
			var max = i + (len - rest);
			var bytes = new haxe_io_Bytes(new ArrayBuffer(size));
			var bpos = 0;
			while(i < max) {
				var c1 = codes[buf.charCodeAt(i++)];
				var c2 = codes[buf.charCodeAt(i++)];
				bytes.b[bpos++] = c1 << 2 | c2 >> 4;
				var c3 = codes[buf.charCodeAt(i++)];
				bytes.b[bpos++] = c2 << 4 | c3 >> 2;
				var c4 = codes[buf.charCodeAt(i++)];
				bytes.b[bpos++] = c3 << 6 | c4;
			}
			if(rest >= 2) {
				var c1 = codes[buf.charCodeAt(i++)];
				var c2 = codes[buf.charCodeAt(i++)];
				bytes.b[bpos++] = c1 << 2 | c2 >> 4;
				if(rest == 3) {
					var c3 = codes[buf.charCodeAt(i++)];
					bytes.b[bpos++] = c2 << 4 | c3 >> 2;
				}
			}
			this.pos += len;
			this.cache.push(bytes);
			return bytes;
		case 116:
			return true;
		case 118:
			var d;
			if(this.buf.charCodeAt(this.pos) >= 48 && this.buf.charCodeAt(this.pos) <= 57 && this.buf.charCodeAt(this.pos + 1) >= 48 && this.buf.charCodeAt(this.pos + 1) <= 57 && this.buf.charCodeAt(this.pos + 2) >= 48 && this.buf.charCodeAt(this.pos + 2) <= 57 && this.buf.charCodeAt(this.pos + 3) >= 48 && this.buf.charCodeAt(this.pos + 3) <= 57 && this.buf.charCodeAt(this.pos + 4) == 45) {
				d = HxOverrides.strDate(HxOverrides.substr(this.buf,this.pos,19));
				this.pos += 19;
			} else {
				d = new Date(this.readFloat());
			}
			this.cache.push(d);
			return d;
		case 119:
			var name = this.unserialize();
			var edecl = this.resolver.resolveEnum(name);
			if(edecl == null) {
				throw haxe_Exception.thrown("Enum not found " + name);
			}
			var e = this.unserializeEnum(edecl,this.unserialize());
			this.cache.push(e);
			return e;
		case 120:
			throw haxe_Exception.thrown(this.unserialize());
		case 121:
			var len = this.readDigits();
			if(this.buf.charCodeAt(this.pos++) != 58 || this.length - this.pos < len) {
				throw haxe_Exception.thrown("Invalid string length");
			}
			var s = HxOverrides.substr(this.buf,this.pos,len);
			this.pos += len;
			s = decodeURIComponent(s.split("+").join(" "));
			this.scache.push(s);
			return s;
		case 122:
			return 0;
		default:
		}
		this.pos--;
		throw haxe_Exception.thrown("Invalid char " + this.buf.charAt(this.pos) + " at position " + this.pos);
	}
	,__class__: haxe_Unserializer
};
var haxe_ValueException = function(value,previous,native) {
	haxe_Exception.call(this,String(value),previous,native);
	this.value = value;
};
$hxClasses["haxe.ValueException"] = haxe_ValueException;
haxe_ValueException.__name__ = "haxe.ValueException";
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
	unwrap: function() {
		return this.value;
	}
	,__class__: haxe_ValueException
});
var haxe_crypto_Adler32 = function() {
	this.a1 = 1;
	this.a2 = 0;
};
$hxClasses["haxe.crypto.Adler32"] = haxe_crypto_Adler32;
haxe_crypto_Adler32.__name__ = "haxe.crypto.Adler32";
haxe_crypto_Adler32.read = function(i) {
	var a = new haxe_crypto_Adler32();
	var a2a = i.readByte();
	var a2b = i.readByte();
	var a1a = i.readByte();
	var a1b = i.readByte();
	a.a1 = a1a << 8 | a1b;
	a.a2 = a2a << 8 | a2b;
	return a;
};
haxe_crypto_Adler32.prototype = {
	update: function(b,pos,len) {
		var a1 = this.a1;
		var a2 = this.a2;
		var _g = pos;
		var _g1 = pos + len;
		while(_g < _g1) {
			var p = _g++;
			var c = b.b[p];
			a1 = (a1 + c) % 65521;
			a2 = (a2 + a1) % 65521;
		}
		this.a1 = a1;
		this.a2 = a2;
	}
	,equals: function(a) {
		if(a.a1 == this.a1) {
			return a.a2 == this.a2;
		} else {
			return false;
		}
	}
	,__class__: haxe_crypto_Adler32
};
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
$hxClasses["haxe.io.Bytes"] = haxe_io_Bytes;
haxe_io_Bytes.__name__ = "haxe.io.Bytes";
haxe_io_Bytes.ofString = function(s,encoding) {
	if(encoding == haxe_io_Encoding.RawNative) {
		var buf = new Uint8Array(s.length << 1);
		var _g = 0;
		var _g1 = s.length;
		while(_g < _g1) {
			var i = _g++;
			var c = s.charCodeAt(i);
			buf[i << 1] = c & 255;
			buf[i << 1 | 1] = c >> 8;
		}
		return new haxe_io_Bytes(buf.buffer);
	}
	var a = [];
	var i = 0;
	while(i < s.length) {
		var c = s.charCodeAt(i++);
		if(55296 <= c && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(i++) & 1023;
		}
		if(c <= 127) {
			a.push(c);
		} else if(c <= 2047) {
			a.push(192 | c >> 6);
			a.push(128 | c & 63);
		} else if(c <= 65535) {
			a.push(224 | c >> 12);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		} else {
			a.push(240 | c >> 18);
			a.push(128 | c >> 12 & 63);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		}
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
haxe_io_Bytes.ofData = function(b) {
	var hb = b.hxBytes;
	if(hb != null) {
		return hb;
	}
	return new haxe_io_Bytes(b);
};
haxe_io_Bytes.prototype = {
	blit: function(pos,src,srcpos,len) {
		if(pos < 0 || srcpos < 0 || len < 0 || pos + len > this.length || srcpos + len > src.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(srcpos == 0 && len == src.b.byteLength) {
			this.b.set(src.b,pos);
		} else {
			this.b.set(src.b.subarray(srcpos,srcpos + len),pos);
		}
	}
	,fill: function(pos,len,value) {
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			this.b[pos++] = value;
		}
	}
	,sub: function(pos,len) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		return new haxe_io_Bytes(this.b.buffer.slice(pos + this.b.byteOffset,pos + this.b.byteOffset + len));
	}
	,getFloat: function(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getFloat32(pos,true);
	}
	,setFloat: function(pos,v) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		this.data.setFloat32(pos,v,true);
	}
	,getUInt16: function(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getUint16(pos,true);
	}
	,setUInt16: function(pos,v) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		this.data.setUint16(pos,v,true);
	}
	,getInt32: function(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getInt32(pos,true);
	}
	,setInt32: function(pos,v) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		this.data.setInt32(pos,v,true);
	}
	,getString: function(pos,len,encoding) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(encoding == null) {
			encoding = haxe_io_Encoding.UTF8;
		}
		var s = "";
		var b = this.b;
		var i = pos;
		var max = pos + len;
		switch(encoding._hx_index) {
		case 0:
			var debug = pos > 0;
			while(i < max) {
				var c = b[i++];
				if(c < 128) {
					if(c == 0) {
						break;
					}
					s += String.fromCodePoint(c);
				} else if(c < 224) {
					var code = (c & 63) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code);
				} else if(c < 240) {
					var c2 = b[i++];
					var code1 = (c & 31) << 12 | (c2 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code1);
				} else {
					var c21 = b[i++];
					var c3 = b[i++];
					var u = (c & 15) << 18 | (c21 & 127) << 12 | (c3 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(u);
				}
			}
			break;
		case 1:
			while(i < max) {
				var c = b[i++] | b[i++] << 8;
				s += String.fromCodePoint(c);
			}
			break;
		}
		return s;
	}
	,toString: function() {
		return this.getString(0,this.length);
	}
	,__class__: haxe_io_Bytes
};
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__:true,__constructs__:null
	,UTF8: {_hx_name:"UTF8",_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_name:"RawNative",_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
haxe_io_Encoding.__constructs__ = [haxe_io_Encoding.UTF8,haxe_io_Encoding.RawNative];
haxe_io_Encoding.__empty_constructs__ = [haxe_io_Encoding.UTF8,haxe_io_Encoding.RawNative];
var haxe_crypto_Base64 = function() { };
$hxClasses["haxe.crypto.Base64"] = haxe_crypto_Base64;
haxe_crypto_Base64.__name__ = "haxe.crypto.Base64";
haxe_crypto_Base64.encode = function(bytes,complement) {
	if(complement == null) {
		complement = true;
	}
	var str = new haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).encodeBytes(bytes).toString();
	if(complement) {
		switch(bytes.length % 3) {
		case 1:
			str += "==";
			break;
		case 2:
			str += "=";
			break;
		default:
		}
	}
	return str;
};
haxe_crypto_Base64.decode = function(str,complement) {
	if(complement == null) {
		complement = true;
	}
	if(complement) {
		while(HxOverrides.cca(str,str.length - 1) == 61) str = HxOverrides.substr(str,0,-1);
	}
	return new haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).decodeBytes(haxe_io_Bytes.ofString(str));
};
var haxe_crypto_BaseCode = function(base) {
	var len = base.length;
	var nbits = 1;
	while(len > 1 << nbits) ++nbits;
	if(nbits > 8 || len != 1 << nbits) {
		throw haxe_Exception.thrown("BaseCode : base length must be a power of two.");
	}
	this.base = base;
	this.nbits = nbits;
};
$hxClasses["haxe.crypto.BaseCode"] = haxe_crypto_BaseCode;
haxe_crypto_BaseCode.__name__ = "haxe.crypto.BaseCode";
haxe_crypto_BaseCode.prototype = {
	encodeBytes: function(b) {
		var nbits = this.nbits;
		var base = this.base;
		var size = b.length * 8 / nbits | 0;
		var out = new haxe_io_Bytes(new ArrayBuffer(size + (b.length * 8 % nbits == 0 ? 0 : 1)));
		var buf = 0;
		var curbits = 0;
		var mask = (1 << nbits) - 1;
		var pin = 0;
		var pout = 0;
		while(pout < size) {
			while(curbits < nbits) {
				curbits += 8;
				buf <<= 8;
				buf |= b.b[pin++];
			}
			curbits -= nbits;
			out.b[pout++] = base.b[buf >> curbits & mask];
		}
		if(curbits > 0) {
			out.b[pout++] = base.b[buf << nbits - curbits & mask];
		}
		return out;
	}
	,initTable: function() {
		var tbl = [];
		var _g = 0;
		while(_g < 256) {
			var i = _g++;
			tbl[i] = -1;
		}
		var _g = 0;
		var _g1 = this.base.length;
		while(_g < _g1) {
			var i = _g++;
			tbl[this.base.b[i]] = i;
		}
		this.tbl = tbl;
	}
	,decodeBytes: function(b) {
		var nbits = this.nbits;
		var base = this.base;
		if(this.tbl == null) {
			this.initTable();
		}
		var tbl = this.tbl;
		var size = b.length * nbits >> 3;
		var out = new haxe_io_Bytes(new ArrayBuffer(size));
		var buf = 0;
		var curbits = 0;
		var pin = 0;
		var pout = 0;
		while(pout < size) {
			while(curbits < 8) {
				curbits += nbits;
				buf <<= nbits;
				var i = tbl[b.b[pin++]];
				if(i == -1) {
					throw haxe_Exception.thrown("BaseCode : invalid encoded char");
				}
				buf |= i;
			}
			curbits -= 8;
			out.b[pout++] = buf >> curbits & 255;
		}
		return out;
	}
	,__class__: haxe_crypto_BaseCode
};
var haxe_crypto_Md5 = function() {
};
$hxClasses["haxe.crypto.Md5"] = haxe_crypto_Md5;
haxe_crypto_Md5.__name__ = "haxe.crypto.Md5";
haxe_crypto_Md5.encode = function(s) {
	var m = new haxe_crypto_Md5();
	var h = m.doEncode(haxe_crypto_Md5.str2blks(s));
	return m.hex(h);
};
haxe_crypto_Md5.str2blks = function(str) {
	var str1 = haxe_io_Bytes.ofString(str);
	var nblk = (str1.length + 8 >> 6) + 1;
	var blks = [];
	var blksSize = nblk * 16;
	var _g = 0;
	var _g1 = blksSize;
	while(_g < _g1) {
		var i = _g++;
		blks[i] = 0;
	}
	var i = 0;
	var max = str1.length;
	var l = max * 8;
	while(i < max) {
		blks[i >> 2] |= str1.b[i] << (l + i) % 4 * 8;
		++i;
	}
	blks[i >> 2] |= 128 << (l + i) % 4 * 8;
	var k = nblk * 16 - 2;
	blks[k] = l & 255;
	blks[k] |= (l >>> 8 & 255) << 8;
	blks[k] |= (l >>> 16 & 255) << 16;
	blks[k] |= (l >>> 24 & 255) << 24;
	return blks;
};
haxe_crypto_Md5.prototype = {
	bitOR: function(a,b) {
		var lsb = a & 1 | b & 1;
		var msb31 = a >>> 1 | b >>> 1;
		return msb31 << 1 | lsb;
	}
	,bitXOR: function(a,b) {
		var lsb = a & 1 ^ b & 1;
		var msb31 = a >>> 1 ^ b >>> 1;
		return msb31 << 1 | lsb;
	}
	,bitAND: function(a,b) {
		var lsb = a & 1 & (b & 1);
		var msb31 = a >>> 1 & b >>> 1;
		return msb31 << 1 | lsb;
	}
	,addme: function(x,y) {
		var lsw = (x & 65535) + (y & 65535);
		var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
		return msw << 16 | lsw & 65535;
	}
	,hex: function(a) {
		var str = "";
		var hex_chr = "0123456789abcdef";
		var _g = 0;
		while(_g < a.length) {
			var num = a[_g];
			++_g;
			str += hex_chr.charAt(num >> 4 & 15) + hex_chr.charAt(num & 15);
			str += hex_chr.charAt(num >> 12 & 15) + hex_chr.charAt(num >> 8 & 15);
			str += hex_chr.charAt(num >> 20 & 15) + hex_chr.charAt(num >> 16 & 15);
			str += hex_chr.charAt(num >> 28 & 15) + hex_chr.charAt(num >> 24 & 15);
		}
		return str;
	}
	,rol: function(num,cnt) {
		return num << cnt | num >>> 32 - cnt;
	}
	,cmn: function(q,a,b,x,s,t) {
		return this.addme(this.rol(this.addme(this.addme(a,q),this.addme(x,t)),s),b);
	}
	,ff: function(a,b,c,d,x,s,t) {
		return this.cmn(this.bitOR(this.bitAND(b,c),this.bitAND(~b,d)),a,b,x,s,t);
	}
	,gg: function(a,b,c,d,x,s,t) {
		return this.cmn(this.bitOR(this.bitAND(b,d),this.bitAND(c,~d)),a,b,x,s,t);
	}
	,hh: function(a,b,c,d,x,s,t) {
		return this.cmn(this.bitXOR(this.bitXOR(b,c),d),a,b,x,s,t);
	}
	,ii: function(a,b,c,d,x,s,t) {
		return this.cmn(this.bitXOR(c,this.bitOR(b,~d)),a,b,x,s,t);
	}
	,doEncode: function(x) {
		var a = 1732584193;
		var b = -271733879;
		var c = -1732584194;
		var d = 271733878;
		var step;
		var i = 0;
		while(i < x.length) {
			var olda = a;
			var oldb = b;
			var oldc = c;
			var oldd = d;
			step = 0;
			a = this.ff(a,b,c,d,x[i],7,-680876936);
			d = this.ff(d,a,b,c,x[i + 1],12,-389564586);
			c = this.ff(c,d,a,b,x[i + 2],17,606105819);
			b = this.ff(b,c,d,a,x[i + 3],22,-1044525330);
			a = this.ff(a,b,c,d,x[i + 4],7,-176418897);
			d = this.ff(d,a,b,c,x[i + 5],12,1200080426);
			c = this.ff(c,d,a,b,x[i + 6],17,-1473231341);
			b = this.ff(b,c,d,a,x[i + 7],22,-45705983);
			a = this.ff(a,b,c,d,x[i + 8],7,1770035416);
			d = this.ff(d,a,b,c,x[i + 9],12,-1958414417);
			c = this.ff(c,d,a,b,x[i + 10],17,-42063);
			b = this.ff(b,c,d,a,x[i + 11],22,-1990404162);
			a = this.ff(a,b,c,d,x[i + 12],7,1804603682);
			d = this.ff(d,a,b,c,x[i + 13],12,-40341101);
			c = this.ff(c,d,a,b,x[i + 14],17,-1502002290);
			b = this.ff(b,c,d,a,x[i + 15],22,1236535329);
			a = this.gg(a,b,c,d,x[i + 1],5,-165796510);
			d = this.gg(d,a,b,c,x[i + 6],9,-1069501632);
			c = this.gg(c,d,a,b,x[i + 11],14,643717713);
			b = this.gg(b,c,d,a,x[i],20,-373897302);
			a = this.gg(a,b,c,d,x[i + 5],5,-701558691);
			d = this.gg(d,a,b,c,x[i + 10],9,38016083);
			c = this.gg(c,d,a,b,x[i + 15],14,-660478335);
			b = this.gg(b,c,d,a,x[i + 4],20,-405537848);
			a = this.gg(a,b,c,d,x[i + 9],5,568446438);
			d = this.gg(d,a,b,c,x[i + 14],9,-1019803690);
			c = this.gg(c,d,a,b,x[i + 3],14,-187363961);
			b = this.gg(b,c,d,a,x[i + 8],20,1163531501);
			a = this.gg(a,b,c,d,x[i + 13],5,-1444681467);
			d = this.gg(d,a,b,c,x[i + 2],9,-51403784);
			c = this.gg(c,d,a,b,x[i + 7],14,1735328473);
			b = this.gg(b,c,d,a,x[i + 12],20,-1926607734);
			a = this.hh(a,b,c,d,x[i + 5],4,-378558);
			d = this.hh(d,a,b,c,x[i + 8],11,-2022574463);
			c = this.hh(c,d,a,b,x[i + 11],16,1839030562);
			b = this.hh(b,c,d,a,x[i + 14],23,-35309556);
			a = this.hh(a,b,c,d,x[i + 1],4,-1530992060);
			d = this.hh(d,a,b,c,x[i + 4],11,1272893353);
			c = this.hh(c,d,a,b,x[i + 7],16,-155497632);
			b = this.hh(b,c,d,a,x[i + 10],23,-1094730640);
			a = this.hh(a,b,c,d,x[i + 13],4,681279174);
			d = this.hh(d,a,b,c,x[i],11,-358537222);
			c = this.hh(c,d,a,b,x[i + 3],16,-722521979);
			b = this.hh(b,c,d,a,x[i + 6],23,76029189);
			a = this.hh(a,b,c,d,x[i + 9],4,-640364487);
			d = this.hh(d,a,b,c,x[i + 12],11,-421815835);
			c = this.hh(c,d,a,b,x[i + 15],16,530742520);
			b = this.hh(b,c,d,a,x[i + 2],23,-995338651);
			a = this.ii(a,b,c,d,x[i],6,-198630844);
			d = this.ii(d,a,b,c,x[i + 7],10,1126891415);
			c = this.ii(c,d,a,b,x[i + 14],15,-1416354905);
			b = this.ii(b,c,d,a,x[i + 5],21,-57434055);
			a = this.ii(a,b,c,d,x[i + 12],6,1700485571);
			d = this.ii(d,a,b,c,x[i + 3],10,-1894986606);
			c = this.ii(c,d,a,b,x[i + 10],15,-1051523);
			b = this.ii(b,c,d,a,x[i + 1],21,-2054922799);
			a = this.ii(a,b,c,d,x[i + 8],6,1873313359);
			d = this.ii(d,a,b,c,x[i + 15],10,-30611744);
			c = this.ii(c,d,a,b,x[i + 6],15,-1560198380);
			b = this.ii(b,c,d,a,x[i + 13],21,1309151649);
			a = this.ii(a,b,c,d,x[i + 4],6,-145523070);
			d = this.ii(d,a,b,c,x[i + 11],10,-1120210379);
			c = this.ii(c,d,a,b,x[i + 2],15,718787259);
			b = this.ii(b,c,d,a,x[i + 9],21,-343485551);
			a = this.addme(a,olda);
			b = this.addme(b,oldb);
			c = this.addme(c,oldc);
			d = this.addme(d,oldd);
			i += 16;
		}
		return [a,b,c,d];
	}
	,__class__: haxe_crypto_Md5
};
var haxe_ds_ArraySort = function() { };
$hxClasses["haxe.ds.ArraySort"] = haxe_ds_ArraySort;
haxe_ds_ArraySort.__name__ = "haxe.ds.ArraySort";
haxe_ds_ArraySort.sort = function(a,cmp) {
	haxe_ds_ArraySort.rec(a,cmp,0,a.length);
};
haxe_ds_ArraySort.rec = function(a,cmp,from,to) {
	var middle = from + to >> 1;
	if(to - from < 12) {
		if(to <= from) {
			return;
		}
		var _g = from + 1;
		var _g1 = to;
		while(_g < _g1) {
			var i = _g++;
			var j = i;
			while(j > from) {
				if(cmp(a[j],a[j - 1]) < 0) {
					haxe_ds_ArraySort.swap(a,j - 1,j);
				} else {
					break;
				}
				--j;
			}
		}
		return;
	}
	haxe_ds_ArraySort.rec(a,cmp,from,middle);
	haxe_ds_ArraySort.rec(a,cmp,middle,to);
	haxe_ds_ArraySort.doMerge(a,cmp,from,middle,to,middle - from,to - middle);
};
haxe_ds_ArraySort.doMerge = function(a,cmp,from,pivot,to,len1,len2) {
	var first_cut;
	var second_cut;
	var len11;
	var len22;
	if(len1 == 0 || len2 == 0) {
		return;
	}
	if(len1 + len2 == 2) {
		if(cmp(a[pivot],a[from]) < 0) {
			haxe_ds_ArraySort.swap(a,pivot,from);
		}
		return;
	}
	if(len1 > len2) {
		len11 = len1 >> 1;
		first_cut = from + len11;
		second_cut = haxe_ds_ArraySort.lower(a,cmp,pivot,to,first_cut);
		len22 = second_cut - pivot;
	} else {
		len22 = len2 >> 1;
		second_cut = pivot + len22;
		first_cut = haxe_ds_ArraySort.upper(a,cmp,from,pivot,second_cut);
		len11 = first_cut - from;
	}
	haxe_ds_ArraySort.rotate(a,cmp,first_cut,pivot,second_cut);
	var new_mid = first_cut + len22;
	haxe_ds_ArraySort.doMerge(a,cmp,from,first_cut,new_mid,len11,len22);
	haxe_ds_ArraySort.doMerge(a,cmp,new_mid,second_cut,to,len1 - len11,len2 - len22);
};
haxe_ds_ArraySort.rotate = function(a,cmp,from,mid,to) {
	if(from == mid || mid == to) {
		return;
	}
	var n = haxe_ds_ArraySort.gcd(to - from,mid - from);
	while(n-- != 0) {
		var val = a[from + n];
		var shift = mid - from;
		var p1 = from + n;
		var p2 = from + n + shift;
		while(p2 != from + n) {
			a[p1] = a[p2];
			p1 = p2;
			if(to - p2 > shift) {
				p2 += shift;
			} else {
				p2 = from + (shift - (to - p2));
			}
		}
		a[p1] = val;
	}
};
haxe_ds_ArraySort.gcd = function(m,n) {
	while(n != 0) {
		var t = m % n;
		m = n;
		n = t;
	}
	return m;
};
haxe_ds_ArraySort.upper = function(a,cmp,from,to,val) {
	var len = to - from;
	var half;
	var mid;
	while(len > 0) {
		half = len >> 1;
		mid = from + half;
		if(cmp(a[val],a[mid]) < 0) {
			len = half;
		} else {
			from = mid + 1;
			len = len - half - 1;
		}
	}
	return from;
};
haxe_ds_ArraySort.lower = function(a,cmp,from,to,val) {
	var len = to - from;
	var half;
	var mid;
	while(len > 0) {
		half = len >> 1;
		mid = from + half;
		if(cmp(a[mid],a[val]) < 0) {
			from = mid + 1;
			len = len - half - 1;
		} else {
			len = half;
		}
	}
	return from;
};
haxe_ds_ArraySort.swap = function(a,i,j) {
	var tmp = a[i];
	a[i] = a[j];
	a[j] = tmp;
};
var haxe_ds_BalancedTree = function() {
};
$hxClasses["haxe.ds.BalancedTree"] = haxe_ds_BalancedTree;
haxe_ds_BalancedTree.__name__ = "haxe.ds.BalancedTree";
haxe_ds_BalancedTree.__interfaces__ = [haxe_IMap];
haxe_ds_BalancedTree.prototype = {
	set: function(key,value) {
		this.root = this.setLoop(key,value,this.root);
	}
	,get: function(key) {
		var node = this.root;
		while(node != null) {
			var c = this.compare(key,node.key);
			if(c == 0) {
				return node.value;
			}
			if(c < 0) {
				node = node.left;
			} else {
				node = node.right;
			}
		}
		return null;
	}
	,setLoop: function(k,v,node) {
		if(node == null) {
			return new haxe_ds_TreeNode(null,k,v,null);
		}
		var c = this.compare(k,node.key);
		if(c == 0) {
			return new haxe_ds_TreeNode(node.left,k,v,node.right,node == null ? 0 : node._height);
		} else if(c < 0) {
			var nl = this.setLoop(k,v,node.left);
			return this.balance(nl,node.key,node.value,node.right);
		} else {
			var nr = this.setLoop(k,v,node.right);
			return this.balance(node.left,node.key,node.value,nr);
		}
	}
	,balance: function(l,k,v,r) {
		var hl = l == null ? 0 : l._height;
		var hr = r == null ? 0 : r._height;
		if(hl > hr + 2) {
			var _this = l.left;
			var _this1 = l.right;
			if((_this == null ? 0 : _this._height) >= (_this1 == null ? 0 : _this1._height)) {
				return new haxe_ds_TreeNode(l.left,l.key,l.value,new haxe_ds_TreeNode(l.right,k,v,r));
			} else {
				return new haxe_ds_TreeNode(new haxe_ds_TreeNode(l.left,l.key,l.value,l.right.left),l.right.key,l.right.value,new haxe_ds_TreeNode(l.right.right,k,v,r));
			}
		} else if(hr > hl + 2) {
			var _this = r.right;
			var _this1 = r.left;
			if((_this == null ? 0 : _this._height) > (_this1 == null ? 0 : _this1._height)) {
				return new haxe_ds_TreeNode(new haxe_ds_TreeNode(l,k,v,r.left),r.key,r.value,r.right);
			} else {
				return new haxe_ds_TreeNode(new haxe_ds_TreeNode(l,k,v,r.left.left),r.left.key,r.left.value,new haxe_ds_TreeNode(r.left.right,r.key,r.value,r.right));
			}
		} else {
			return new haxe_ds_TreeNode(l,k,v,r,(hl > hr ? hl : hr) + 1);
		}
	}
	,compare: function(k1,k2) {
		return Reflect.compare(k1,k2);
	}
	,__class__: haxe_ds_BalancedTree
};
var haxe_ds_TreeNode = function(l,k,v,r,h) {
	if(h == null) {
		h = -1;
	}
	this.left = l;
	this.key = k;
	this.value = v;
	this.right = r;
	if(h == -1) {
		var tmp;
		var _this = this.left;
		var _this1 = this.right;
		if((_this == null ? 0 : _this._height) > (_this1 == null ? 0 : _this1._height)) {
			var _this = this.left;
			tmp = _this == null ? 0 : _this._height;
		} else {
			var _this = this.right;
			tmp = _this == null ? 0 : _this._height;
		}
		this._height = tmp + 1;
	} else {
		this._height = h;
	}
};
$hxClasses["haxe.ds.TreeNode"] = haxe_ds_TreeNode;
haxe_ds_TreeNode.__name__ = "haxe.ds.TreeNode";
haxe_ds_TreeNode.prototype = {
	__class__: haxe_ds_TreeNode
};
var haxe_ds_EnumValueMap = function() {
	haxe_ds_BalancedTree.call(this);
};
$hxClasses["haxe.ds.EnumValueMap"] = haxe_ds_EnumValueMap;
haxe_ds_EnumValueMap.__name__ = "haxe.ds.EnumValueMap";
haxe_ds_EnumValueMap.__interfaces__ = [haxe_IMap];
haxe_ds_EnumValueMap.__super__ = haxe_ds_BalancedTree;
haxe_ds_EnumValueMap.prototype = $extend(haxe_ds_BalancedTree.prototype,{
	compare: function(k1,k2) {
		var d = k1._hx_index - k2._hx_index;
		if(d != 0) {
			return d;
		}
		var p1 = Type.enumParameters(k1);
		var p2 = Type.enumParameters(k2);
		if(p1.length == 0 && p2.length == 0) {
			return 0;
		}
		return this.compareArgs(p1,p2);
	}
	,compareArgs: function(a1,a2) {
		var ld = a1.length - a2.length;
		if(ld != 0) {
			return ld;
		}
		var _g = 0;
		var _g1 = a1.length;
		while(_g < _g1) {
			var i = _g++;
			var d = this.compareArg(a1[i],a2[i]);
			if(d != 0) {
				return d;
			}
		}
		return 0;
	}
	,compareArg: function(v1,v2) {
		if(Reflect.isEnumValue(v1) && Reflect.isEnumValue(v2)) {
			return this.compare(v1,v2);
		} else if(((v1) instanceof Array) && ((v2) instanceof Array)) {
			return this.compareArgs(v1,v2);
		} else {
			return Reflect.compare(v1,v2);
		}
	}
	,__class__: haxe_ds_EnumValueMap
});
var haxe_ds_List = function() {
	this.length = 0;
};
$hxClasses["haxe.ds.List"] = haxe_ds_List;
haxe_ds_List.__name__ = "haxe.ds.List";
haxe_ds_List.prototype = {
	add: function(item) {
		var x = new haxe_ds__$List_ListNode(item,null);
		if(this.h == null) {
			this.h = x;
		} else {
			this.q.next = x;
		}
		this.q = x;
		this.length++;
	}
	,push: function(item) {
		var x = new haxe_ds__$List_ListNode(item,this.h);
		this.h = x;
		if(this.q == null) {
			this.q = x;
		}
		this.length++;
	}
	,remove: function(v) {
		var prev = null;
		var l = this.h;
		while(l != null) {
			if(l.item == v) {
				if(prev == null) {
					this.h = l.next;
				} else {
					prev.next = l.next;
				}
				if(this.q == l) {
					this.q = prev;
				}
				this.length--;
				return true;
			}
			prev = l;
			l = l.next;
		}
		return false;
	}
	,__class__: haxe_ds_List
};
var haxe_ds__$List_ListNode = function(item,next) {
	this.item = item;
	this.next = next;
};
$hxClasses["haxe.ds._List.ListNode"] = haxe_ds__$List_ListNode;
haxe_ds__$List_ListNode.__name__ = "haxe.ds._List.ListNode";
haxe_ds__$List_ListNode.prototype = {
	__class__: haxe_ds__$List_ListNode
};
var haxe_ds_ObjectMap = function() {
	this.h = { __keys__ : { }};
};
$hxClasses["haxe.ds.ObjectMap"] = haxe_ds_ObjectMap;
haxe_ds_ObjectMap.__name__ = "haxe.ds.ObjectMap";
haxe_ds_ObjectMap.__interfaces__ = [haxe_IMap];
haxe_ds_ObjectMap.prototype = {
	set: function(key,value) {
		var id = key.__id__;
		if(id == null) {
			id = (key.__id__ = $global.$haxeUID++);
		}
		this.h[id] = value;
		this.h.__keys__[id] = key;
	}
	,remove: function(key) {
		var id = key.__id__;
		if(this.h.__keys__[id] == null) {
			return false;
		}
		delete(this.h[id]);
		delete(this.h.__keys__[id]);
		return true;
	}
	,keys: function() {
		var a = [];
		for( var key in this.h.__keys__ ) {
		if(this.h.hasOwnProperty(key)) {
			a.push(this.h.__keys__[key]);
		}
		}
		return new haxe_iterators_ArrayIterator(a);
	}
	,__class__: haxe_ds_ObjectMap
};
var haxe_ds__$StringMap_StringMapKeyIterator = function(h) {
	this.h = h;
	this.keys = Object.keys(h);
	this.length = this.keys.length;
	this.current = 0;
};
$hxClasses["haxe.ds._StringMap.StringMapKeyIterator"] = haxe_ds__$StringMap_StringMapKeyIterator;
haxe_ds__$StringMap_StringMapKeyIterator.__name__ = "haxe.ds._StringMap.StringMapKeyIterator";
haxe_ds__$StringMap_StringMapKeyIterator.prototype = {
	hasNext: function() {
		return this.current < this.length;
	}
	,next: function() {
		return this.keys[this.current++];
	}
	,__class__: haxe_ds__$StringMap_StringMapKeyIterator
};
var haxe_ds__$StringMap_StringMapValueIterator = function(h) {
	this.h = h;
	this.keys = Object.keys(h);
	this.length = this.keys.length;
	this.current = 0;
};
$hxClasses["haxe.ds._StringMap.StringMapValueIterator"] = haxe_ds__$StringMap_StringMapValueIterator;
haxe_ds__$StringMap_StringMapValueIterator.__name__ = "haxe.ds._StringMap.StringMapValueIterator";
haxe_ds__$StringMap_StringMapValueIterator.prototype = {
	hasNext: function() {
		return this.current < this.length;
	}
	,next: function() {
		return this.h[this.keys[this.current++]];
	}
	,__class__: haxe_ds__$StringMap_StringMapValueIterator
};
var haxe_ds_Vector = {};
haxe_ds_Vector.blit = function(src,srcPos,dest,destPos,len) {
	if(src == dest) {
		if(srcPos < destPos) {
			var i = srcPos + len;
			var j = destPos + len;
			var _g = 0;
			var _g1 = len;
			while(_g < _g1) {
				var k = _g++;
				--i;
				--j;
				src[j] = src[i];
			}
		} else if(srcPos > destPos) {
			var i = srcPos;
			var j = destPos;
			var _g = 0;
			var _g1 = len;
			while(_g < _g1) {
				var k = _g++;
				src[j] = src[i];
				++i;
				++j;
			}
		}
	} else {
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			dest[destPos + i] = src[srcPos + i];
		}
	}
};
var haxe_exceptions_PosException = function(message,previous,pos) {
	haxe_Exception.call(this,message,previous);
	if(pos == null) {
		this.posInfos = { fileName : "(unknown)", lineNumber : 0, className : "(unknown)", methodName : "(unknown)"};
	} else {
		this.posInfos = pos;
	}
};
$hxClasses["haxe.exceptions.PosException"] = haxe_exceptions_PosException;
haxe_exceptions_PosException.__name__ = "haxe.exceptions.PosException";
haxe_exceptions_PosException.__super__ = haxe_Exception;
haxe_exceptions_PosException.prototype = $extend(haxe_Exception.prototype,{
	toString: function() {
		return "" + haxe_Exception.prototype.toString.call(this) + " in " + this.posInfos.className + "." + this.posInfos.methodName + " at " + this.posInfos.fileName + ":" + this.posInfos.lineNumber;
	}
	,__class__: haxe_exceptions_PosException
});
var haxe_exceptions_NotImplementedException = function(message,previous,pos) {
	if(message == null) {
		message = "Not implemented";
	}
	haxe_exceptions_PosException.call(this,message,previous,pos);
};
$hxClasses["haxe.exceptions.NotImplementedException"] = haxe_exceptions_NotImplementedException;
haxe_exceptions_NotImplementedException.__name__ = "haxe.exceptions.NotImplementedException";
haxe_exceptions_NotImplementedException.__super__ = haxe_exceptions_PosException;
haxe_exceptions_NotImplementedException.prototype = $extend(haxe_exceptions_PosException.prototype,{
	__class__: haxe_exceptions_NotImplementedException
});
var haxe_io_BytesBuffer = function() {
	this.pos = 0;
	this.size = 0;
};
$hxClasses["haxe.io.BytesBuffer"] = haxe_io_BytesBuffer;
haxe_io_BytesBuffer.__name__ = "haxe.io.BytesBuffer";
haxe_io_BytesBuffer.prototype = {
	addByte: function(byte) {
		if(this.pos == this.size) {
			this.grow(1);
		}
		this.view.setUint8(this.pos++,byte);
	}
	,add: function(src) {
		if(this.pos + src.length > this.size) {
			this.grow(src.length);
		}
		if(this.size == 0) {
			return;
		}
		var sub = new Uint8Array(src.b.buffer,src.b.byteOffset,src.length);
		this.u8.set(sub,this.pos);
		this.pos += src.length;
	}
	,addInt32: function(v) {
		if(this.pos + 4 > this.size) {
			this.grow(4);
		}
		this.view.setInt32(this.pos,v,true);
		this.pos += 4;
	}
	,addFloat: function(v) {
		if(this.pos + 4 > this.size) {
			this.grow(4);
		}
		this.view.setFloat32(this.pos,v,true);
		this.pos += 4;
	}
	,addDouble: function(v) {
		if(this.pos + 8 > this.size) {
			this.grow(8);
		}
		this.view.setFloat64(this.pos,v,true);
		this.pos += 8;
	}
	,addBytes: function(src,pos,len) {
		if(pos < 0 || len < 0 || pos + len > src.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(this.pos + len > this.size) {
			this.grow(len);
		}
		if(this.size == 0) {
			return;
		}
		var sub = new Uint8Array(src.b.buffer,src.b.byteOffset + pos,len);
		this.u8.set(sub,this.pos);
		this.pos += len;
	}
	,grow: function(delta) {
		var req = this.pos + delta;
		var nsize = this.size == 0 ? 16 : this.size;
		while(nsize < req) nsize = nsize * 3 >> 1;
		var nbuf = new ArrayBuffer(nsize);
		var nu8 = new Uint8Array(nbuf);
		if(this.size > 0) {
			nu8.set(this.u8);
		}
		this.size = nsize;
		this.buffer = nbuf;
		this.u8 = nu8;
		this.view = new DataView(this.buffer);
	}
	,getBytes: function() {
		if(this.size == 0) {
			return new haxe_io_Bytes(new ArrayBuffer(0));
		}
		var b = new haxe_io_Bytes(this.buffer);
		b.length = this.pos;
		return b;
	}
	,__class__: haxe_io_BytesBuffer
};
var haxe_io_Input = function() { };
$hxClasses["haxe.io.Input"] = haxe_io_Input;
haxe_io_Input.__name__ = "haxe.io.Input";
haxe_io_Input.prototype = {
	readByte: function() {
		throw new haxe_exceptions_NotImplementedException(null,null,{ fileName : "haxe/io/Input.hx", lineNumber : 53, className : "haxe.io.Input", methodName : "readByte"});
	}
	,readBytes: function(s,pos,len) {
		var k = len;
		var b = s.b;
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		try {
			while(k > 0) {
				b[pos] = this.readByte();
				++pos;
				--k;
			}
		} catch( _g ) {
			if(!((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
				throw _g;
			}
		}
		return len - k;
	}
	,set_bigEndian: function(b) {
		this.bigEndian = b;
		return b;
	}
	,readFullBytes: function(s,pos,len) {
		while(len > 0) {
			var k = this.readBytes(s,pos,len);
			if(k == 0) {
				throw haxe_Exception.thrown(haxe_io_Error.Blocked);
			}
			pos += k;
			len -= k;
		}
	}
	,read: function(nbytes) {
		var s = new haxe_io_Bytes(new ArrayBuffer(nbytes));
		var p = 0;
		while(nbytes > 0) {
			var k = this.readBytes(s,p,nbytes);
			if(k == 0) {
				throw haxe_Exception.thrown(haxe_io_Error.Blocked);
			}
			p += k;
			nbytes -= k;
		}
		return s;
	}
	,readUntil: function(end) {
		var buf = new haxe_io_BytesBuffer();
		var last;
		while(true) {
			last = this.readByte();
			if(!(last != end)) {
				break;
			}
			buf.addByte(last);
		}
		return buf.getBytes().toString();
	}
	,readLine: function() {
		var buf = new haxe_io_BytesBuffer();
		var last;
		var s;
		try {
			while(true) {
				last = this.readByte();
				if(!(last != 10)) {
					break;
				}
				buf.addByte(last);
			}
			s = buf.getBytes().toString();
			if(HxOverrides.cca(s,s.length - 1) == 13) {
				s = HxOverrides.substr(s,0,-1);
			}
		} catch( _g ) {
			var _g1 = haxe_Exception.caught(_g).unwrap();
			if(((_g1) instanceof haxe_io_Eof)) {
				var e = _g1;
				s = buf.getBytes().toString();
				if(s.length == 0) {
					throw haxe_Exception.thrown(e);
				}
			} else {
				throw _g;
			}
		}
		return s;
	}
	,readFloat: function() {
		return haxe_io_FPHelper.i32ToFloat(this.readInt32());
	}
	,readDouble: function() {
		var i1 = this.readInt32();
		var i2 = this.readInt32();
		if(this.bigEndian) {
			return haxe_io_FPHelper.i64ToDouble(i2,i1);
		} else {
			return haxe_io_FPHelper.i64ToDouble(i1,i2);
		}
	}
	,readInt16: function() {
		var ch1 = this.readByte();
		var ch2 = this.readByte();
		var n = this.bigEndian ? ch2 | ch1 << 8 : ch1 | ch2 << 8;
		if((n & 32768) != 0) {
			return n - 65536;
		}
		return n;
	}
	,readUInt16: function() {
		var ch1 = this.readByte();
		var ch2 = this.readByte();
		if(this.bigEndian) {
			return ch2 | ch1 << 8;
		} else {
			return ch1 | ch2 << 8;
		}
	}
	,readUInt24: function() {
		var ch1 = this.readByte();
		var ch2 = this.readByte();
		var ch3 = this.readByte();
		if(this.bigEndian) {
			return ch3 | ch2 << 8 | ch1 << 16;
		} else {
			return ch1 | ch2 << 8 | ch3 << 16;
		}
	}
	,readInt32: function() {
		var ch1 = this.readByte();
		var ch2 = this.readByte();
		var ch3 = this.readByte();
		var ch4 = this.readByte();
		if(this.bigEndian) {
			return ch4 | ch3 << 8 | ch2 << 16 | ch1 << 24;
		} else {
			return ch1 | ch2 << 8 | ch3 << 16 | ch4 << 24;
		}
	}
	,readString: function(len,encoding) {
		var b = new haxe_io_Bytes(new ArrayBuffer(len));
		this.readFullBytes(b,0,len);
		return b.getString(0,len,encoding);
	}
	,__class__: haxe_io_Input
};
var haxe_io_BytesInput = function(b,pos,len) {
	if(pos == null) {
		pos = 0;
	}
	if(len == null) {
		len = b.length - pos;
	}
	if(pos < 0 || len < 0 || pos + len > b.length) {
		throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
	}
	this.b = b.b;
	this.pos = pos;
	this.len = len;
	this.totlen = len;
};
$hxClasses["haxe.io.BytesInput"] = haxe_io_BytesInput;
haxe_io_BytesInput.__name__ = "haxe.io.BytesInput";
haxe_io_BytesInput.__super__ = haxe_io_Input;
haxe_io_BytesInput.prototype = $extend(haxe_io_Input.prototype,{
	set_position: function(p) {
		if(p < 0) {
			p = 0;
		} else if(p > this.totlen) {
			p = this.totlen;
		}
		this.len = this.totlen - p;
		return this.pos = p;
	}
	,readByte: function() {
		if(this.len == 0) {
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
		this.len--;
		return this.b[this.pos++];
	}
	,readBytes: function(buf,pos,len) {
		if(pos < 0 || len < 0 || pos + len > buf.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(this.len == 0 && len > 0) {
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
		if(this.len < len) {
			len = this.len;
		}
		var b1 = this.b;
		var b2 = buf.b;
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			b2[pos + i] = b1[this.pos + i];
		}
		this.pos += len;
		this.len -= len;
		return len;
	}
	,__class__: haxe_io_BytesInput
});
var haxe_io_Output = function() { };
$hxClasses["haxe.io.Output"] = haxe_io_Output;
haxe_io_Output.__name__ = "haxe.io.Output";
haxe_io_Output.prototype = {
	writeByte: function(c) {
		throw new haxe_exceptions_NotImplementedException(null,null,{ fileName : "haxe/io/Output.hx", lineNumber : 47, className : "haxe.io.Output", methodName : "writeByte"});
	}
	,writeBytes: function(s,pos,len) {
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		var b = s.b;
		var k = len;
		while(k > 0) {
			this.writeByte(b[pos]);
			++pos;
			--k;
		}
		return len;
	}
	,flush: function() {
	}
	,close: function() {
	}
	,set_bigEndian: function(b) {
		this.bigEndian = b;
		return b;
	}
	,write: function(s) {
		var l = s.length;
		var p = 0;
		while(l > 0) {
			var k = this.writeBytes(s,p,l);
			if(k == 0) {
				throw haxe_Exception.thrown(haxe_io_Error.Blocked);
			}
			p += k;
			l -= k;
		}
	}
	,writeFullBytes: function(s,pos,len) {
		while(len > 0) {
			var k = this.writeBytes(s,pos,len);
			pos += k;
			len -= k;
		}
	}
	,writeInt32: function(x) {
		if(this.bigEndian) {
			this.writeByte(x >>> 24);
			this.writeByte(x >> 16 & 255);
			this.writeByte(x >> 8 & 255);
			this.writeByte(x & 255);
		} else {
			this.writeByte(x & 255);
			this.writeByte(x >> 8 & 255);
			this.writeByte(x >> 16 & 255);
			this.writeByte(x >>> 24);
		}
	}
	,writeString: function(s,encoding) {
		var b = haxe_io_Bytes.ofString(s,encoding);
		this.writeFullBytes(b,0,b.length);
	}
	,__class__: haxe_io_Output
};
var haxe_io_BytesOutput = function() {
	this.b = new haxe_io_BytesBuffer();
};
$hxClasses["haxe.io.BytesOutput"] = haxe_io_BytesOutput;
haxe_io_BytesOutput.__name__ = "haxe.io.BytesOutput";
haxe_io_BytesOutput.__super__ = haxe_io_Output;
haxe_io_BytesOutput.prototype = $extend(haxe_io_Output.prototype,{
	writeByte: function(c) {
		this.b.addByte(c);
	}
	,writeBytes: function(buf,pos,len) {
		this.b.addBytes(buf,pos,len);
		return len;
	}
	,getBytes: function() {
		return this.b.getBytes();
	}
	,__class__: haxe_io_BytesOutput
});
var haxe_io_Eof = function() {
};
$hxClasses["haxe.io.Eof"] = haxe_io_Eof;
haxe_io_Eof.__name__ = "haxe.io.Eof";
haxe_io_Eof.prototype = {
	toString: function() {
		return "Eof";
	}
	,__class__: haxe_io_Eof
};
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__:true,__constructs__:null
	,Blocked: {_hx_name:"Blocked",_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_name:"Overflow",_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_name:"OutsideBounds",_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_._hx_name="Custom",$_.__params__ = ["e"],$_)
};
haxe_io_Error.__constructs__ = [haxe_io_Error.Blocked,haxe_io_Error.Overflow,haxe_io_Error.OutsideBounds,haxe_io_Error.Custom];
haxe_io_Error.__empty_constructs__ = [haxe_io_Error.Blocked,haxe_io_Error.Overflow,haxe_io_Error.OutsideBounds];
var haxe_io_FPHelper = function() { };
$hxClasses["haxe.io.FPHelper"] = haxe_io_FPHelper;
haxe_io_FPHelper.__name__ = "haxe.io.FPHelper";
haxe_io_FPHelper.i32ToFloat = function(i) {
	haxe_io_FPHelper.helper.setInt32(0,i,true);
	return haxe_io_FPHelper.helper.getFloat32(0,true);
};
haxe_io_FPHelper.floatToI32 = function(f) {
	haxe_io_FPHelper.helper.setFloat32(0,f,true);
	return haxe_io_FPHelper.helper.getInt32(0,true);
};
haxe_io_FPHelper.i64ToDouble = function(low,high) {
	haxe_io_FPHelper.helper.setInt32(0,low,true);
	haxe_io_FPHelper.helper.setInt32(4,high,true);
	return haxe_io_FPHelper.helper.getFloat64(0,true);
};
var haxe_io_Path = function(path) {
	switch(path) {
	case ".":case "..":
		this.dir = path;
		this.file = "";
		return;
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		this.dir = HxOverrides.substr(path,0,c2);
		path = HxOverrides.substr(path,c2 + 1,null);
		this.backslash = true;
	} else if(c2 < c1) {
		this.dir = HxOverrides.substr(path,0,c1);
		path = HxOverrides.substr(path,c1 + 1,null);
	} else {
		this.dir = null;
	}
	var cp = path.lastIndexOf(".");
	if(cp != -1) {
		this.ext = HxOverrides.substr(path,cp + 1,null);
		this.file = HxOverrides.substr(path,0,cp);
	} else {
		this.ext = null;
		this.file = path;
	}
};
$hxClasses["haxe.io.Path"] = haxe_io_Path;
haxe_io_Path.__name__ = "haxe.io.Path";
haxe_io_Path.directory = function(path) {
	var s = new haxe_io_Path(path);
	if(s.dir == null) {
		return "";
	}
	return s.dir;
};
haxe_io_Path.extension = function(path) {
	var s = new haxe_io_Path(path);
	if(s.ext == null) {
		return "";
	}
	return s.ext;
};
haxe_io_Path.withExtension = function(path,ext) {
	var s = new haxe_io_Path(path);
	s.ext = ext;
	return s.toString();
};
haxe_io_Path.join = function(paths) {
	var _g = [];
	var _g1 = 0;
	var _g2 = paths;
	while(_g1 < _g2.length) {
		var v = _g2[_g1];
		++_g1;
		if(v != null && v != "") {
			_g.push(v);
		}
	}
	var paths = _g;
	if(paths.length == 0) {
		return "";
	}
	var path = paths[0];
	var _g = 1;
	var _g1 = paths.length;
	while(_g < _g1) {
		var i = _g++;
		path = haxe_io_Path.addTrailingSlash(path);
		path += paths[i];
	}
	return haxe_io_Path.normalize(path);
};
haxe_io_Path.normalize = function(path) {
	var slash = "/";
	path = path.split("\\").join(slash);
	if(path == slash) {
		return slash;
	}
	var target = [];
	var _g = 0;
	var _g1 = path.split(slash);
	while(_g < _g1.length) {
		var token = _g1[_g];
		++_g;
		if(token == ".." && target.length > 0 && target[target.length - 1] != "..") {
			target.pop();
		} else if(token == "") {
			if(target.length > 0 || HxOverrides.cca(path,0) == 47) {
				target.push(token);
			}
		} else if(token != ".") {
			target.push(token);
		}
	}
	var tmp = target.join(slash);
	var acc_b = "";
	var colon = false;
	var slashes = false;
	var _g_offset = 0;
	var _g_s = tmp;
	while(_g_offset < _g_s.length) {
		var s = _g_s;
		var index = _g_offset++;
		var c = s.charCodeAt(index);
		if(c >= 55296 && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
		}
		var c1 = c;
		if(c1 >= 65536) {
			++_g_offset;
		}
		var c2 = c1;
		switch(c2) {
		case 47:
			if(!colon) {
				slashes = true;
			} else {
				var i = c2;
				colon = false;
				if(slashes) {
					acc_b += "/";
					slashes = false;
				}
				acc_b += String.fromCodePoint(i);
			}
			break;
		case 58:
			acc_b += ":";
			colon = true;
			break;
		default:
			var i1 = c2;
			colon = false;
			if(slashes) {
				acc_b += "/";
				slashes = false;
			}
			acc_b += String.fromCodePoint(i1);
		}
	}
	return acc_b;
};
haxe_io_Path.addTrailingSlash = function(path) {
	if(path.length == 0) {
		return "/";
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		if(c2 != path.length - 1) {
			return path + "\\";
		} else {
			return path;
		}
	} else if(c1 != path.length - 1) {
		return path + "/";
	} else {
		return path;
	}
};
haxe_io_Path.prototype = {
	toString: function() {
		return (this.dir == null ? "" : this.dir + (this.backslash ? "\\" : "/")) + this.file + (this.ext == null ? "" : "." + this.ext);
	}
	,__class__: haxe_io_Path
};
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
$hxClasses["haxe.iterators.ArrayIterator"] = haxe_iterators_ArrayIterator;
haxe_iterators_ArrayIterator.__name__ = "haxe.iterators.ArrayIterator";
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
	,__class__: haxe_iterators_ArrayIterator
};
var haxe_macro_Binop = $hxEnums["haxe.macro.Binop"] = { __ename__:true,__constructs__:null
	,OpAdd: {_hx_name:"OpAdd",_hx_index:0,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpMult: {_hx_name:"OpMult",_hx_index:1,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpDiv: {_hx_name:"OpDiv",_hx_index:2,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpSub: {_hx_name:"OpSub",_hx_index:3,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAssign: {_hx_name:"OpAssign",_hx_index:4,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpEq: {_hx_name:"OpEq",_hx_index:5,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpNotEq: {_hx_name:"OpNotEq",_hx_index:6,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpGt: {_hx_name:"OpGt",_hx_index:7,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpGte: {_hx_name:"OpGte",_hx_index:8,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpLt: {_hx_name:"OpLt",_hx_index:9,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpLte: {_hx_name:"OpLte",_hx_index:10,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAnd: {_hx_name:"OpAnd",_hx_index:11,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpOr: {_hx_name:"OpOr",_hx_index:12,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpXor: {_hx_name:"OpXor",_hx_index:13,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpBoolAnd: {_hx_name:"OpBoolAnd",_hx_index:14,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpBoolOr: {_hx_name:"OpBoolOr",_hx_index:15,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpShl: {_hx_name:"OpShl",_hx_index:16,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpShr: {_hx_name:"OpShr",_hx_index:17,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpUShr: {_hx_name:"OpUShr",_hx_index:18,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpMod: {_hx_name:"OpMod",_hx_index:19,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAssignOp: ($_=function(op) { return {_hx_index:20,op:op,__enum__:"haxe.macro.Binop",toString:$estr}; },$_._hx_name="OpAssignOp",$_.__params__ = ["op"],$_)
	,OpInterval: {_hx_name:"OpInterval",_hx_index:21,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpArrow: {_hx_name:"OpArrow",_hx_index:22,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpIn: {_hx_name:"OpIn",_hx_index:23,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpNullCoal: {_hx_name:"OpNullCoal",_hx_index:24,__enum__:"haxe.macro.Binop",toString:$estr}
};
haxe_macro_Binop.__constructs__ = [haxe_macro_Binop.OpAdd,haxe_macro_Binop.OpMult,haxe_macro_Binop.OpDiv,haxe_macro_Binop.OpSub,haxe_macro_Binop.OpAssign,haxe_macro_Binop.OpEq,haxe_macro_Binop.OpNotEq,haxe_macro_Binop.OpGt,haxe_macro_Binop.OpGte,haxe_macro_Binop.OpLt,haxe_macro_Binop.OpLte,haxe_macro_Binop.OpAnd,haxe_macro_Binop.OpOr,haxe_macro_Binop.OpXor,haxe_macro_Binop.OpBoolAnd,haxe_macro_Binop.OpBoolOr,haxe_macro_Binop.OpShl,haxe_macro_Binop.OpShr,haxe_macro_Binop.OpUShr,haxe_macro_Binop.OpMod,haxe_macro_Binop.OpAssignOp,haxe_macro_Binop.OpInterval,haxe_macro_Binop.OpArrow,haxe_macro_Binop.OpIn,haxe_macro_Binop.OpNullCoal];
haxe_macro_Binop.__empty_constructs__ = [haxe_macro_Binop.OpAdd,haxe_macro_Binop.OpMult,haxe_macro_Binop.OpDiv,haxe_macro_Binop.OpSub,haxe_macro_Binop.OpAssign,haxe_macro_Binop.OpEq,haxe_macro_Binop.OpNotEq,haxe_macro_Binop.OpGt,haxe_macro_Binop.OpGte,haxe_macro_Binop.OpLt,haxe_macro_Binop.OpLte,haxe_macro_Binop.OpAnd,haxe_macro_Binop.OpOr,haxe_macro_Binop.OpXor,haxe_macro_Binop.OpBoolAnd,haxe_macro_Binop.OpBoolOr,haxe_macro_Binop.OpShl,haxe_macro_Binop.OpShr,haxe_macro_Binop.OpUShr,haxe_macro_Binop.OpMod,haxe_macro_Binop.OpInterval,haxe_macro_Binop.OpArrow,haxe_macro_Binop.OpIn,haxe_macro_Binop.OpNullCoal];
var haxe_macro_Unop = $hxEnums["haxe.macro.Unop"] = { __ename__:true,__constructs__:null
	,OpIncrement: {_hx_name:"OpIncrement",_hx_index:0,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpDecrement: {_hx_name:"OpDecrement",_hx_index:1,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNot: {_hx_name:"OpNot",_hx_index:2,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNeg: {_hx_name:"OpNeg",_hx_index:3,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNegBits: {_hx_name:"OpNegBits",_hx_index:4,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpSpread: {_hx_name:"OpSpread",_hx_index:5,__enum__:"haxe.macro.Unop",toString:$estr}
};
haxe_macro_Unop.__constructs__ = [haxe_macro_Unop.OpIncrement,haxe_macro_Unop.OpDecrement,haxe_macro_Unop.OpNot,haxe_macro_Unop.OpNeg,haxe_macro_Unop.OpNegBits,haxe_macro_Unop.OpSpread];
haxe_macro_Unop.__empty_constructs__ = [haxe_macro_Unop.OpIncrement,haxe_macro_Unop.OpDecrement,haxe_macro_Unop.OpNot,haxe_macro_Unop.OpNeg,haxe_macro_Unop.OpNegBits,haxe_macro_Unop.OpSpread];
var haxe_macro_Error = function(message,pos,previous) {
	haxe_Exception.call(this,message,previous);
	this.pos = pos;
};
$hxClasses["haxe.macro.Error"] = haxe_macro_Error;
haxe_macro_Error.__name__ = "haxe.macro.Error";
haxe_macro_Error.__super__ = haxe_Exception;
haxe_macro_Error.prototype = $extend(haxe_Exception.prototype,{
	__class__: haxe_macro_Error
});
var haxe_xml__$Access_NodeAccess = {};
haxe_xml__$Access_NodeAccess.resolve = function(this1,name) {
	var x = this1.elementsNamed(name).next();
	if(x == null) {
		var xname;
		if(this1.nodeType == Xml.Document) {
			xname = "Document";
		} else {
			if(this1.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this1.nodeType == null ? "null" : XmlType.toString(this1.nodeType)));
			}
			xname = this1.nodeName;
		}
		throw haxe_Exception.thrown(xname + " is missing element " + name);
	}
	if(x.nodeType != Xml.Document && x.nodeType != Xml.Element) {
		throw haxe_Exception.thrown("Invalid nodeType " + (x.nodeType == null ? "null" : XmlType.toString(x.nodeType)));
	}
	return x;
};
var haxe_xml__$Access_AttribAccess = {};
haxe_xml__$Access_AttribAccess.resolve = function(this1,name) {
	if(this1.nodeType == Xml.Document) {
		throw haxe_Exception.thrown("Cannot access document attribute " + name);
	}
	var v = this1.get(name);
	if(v == null) {
		if(this1.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this1.nodeType == null ? "null" : XmlType.toString(this1.nodeType)));
		}
		throw haxe_Exception.thrown(this1.nodeName + " is missing attribute " + name);
	}
	return v;
};
var haxe_xml__$Access_HasNodeAccess = {};
haxe_xml__$Access_HasNodeAccess.resolve = function(this1,name) {
	return this1.elementsNamed(name).hasNext();
};
var haxe_xml_XmlParserException = function(message,xml,position) {
	this.xml = xml;
	this.message = message;
	this.position = position;
	this.lineNumber = 1;
	this.positionAtLine = 0;
	var _g = 0;
	var _g1 = position;
	while(_g < _g1) {
		var i = _g++;
		var c = xml.charCodeAt(i);
		if(c == 10) {
			this.lineNumber++;
			this.positionAtLine = 0;
		} else if(c != 13) {
			this.positionAtLine++;
		}
	}
};
$hxClasses["haxe.xml.XmlParserException"] = haxe_xml_XmlParserException;
haxe_xml_XmlParserException.__name__ = "haxe.xml.XmlParserException";
haxe_xml_XmlParserException.prototype = {
	toString: function() {
		var c = js_Boot.getClass(this);
		return c.__name__ + ": " + this.message + " at line " + this.lineNumber + " char " + this.positionAtLine;
	}
	,__class__: haxe_xml_XmlParserException
};
var haxe_xml_Parser = function() { };
$hxClasses["haxe.xml.Parser"] = haxe_xml_Parser;
haxe_xml_Parser.__name__ = "haxe.xml.Parser";
haxe_xml_Parser.parse = function(str,strict) {
	if(strict == null) {
		strict = false;
	}
	var doc = Xml.createDocument();
	haxe_xml_Parser.doParse(str,strict,0,doc);
	return doc;
};
haxe_xml_Parser.doParse = function(str,strict,p,parent) {
	if(p == null) {
		p = 0;
	}
	var xml = null;
	var state = 1;
	var next = 1;
	var aname = null;
	var start = 0;
	var nsubs = 0;
	var nbrackets = 0;
	var buf = new StringBuf();
	var escapeNext = 1;
	var attrValQuote = -1;
	while(p < str.length) {
		var c = str.charCodeAt(p);
		switch(state) {
		case 0:
			switch(c) {
			case 9:case 10:case 13:case 32:
				break;
			default:
				state = next;
				continue;
			}
			break;
		case 1:
			if(c == 60) {
				state = 0;
				next = 2;
			} else {
				start = p;
				state = 13;
				continue;
			}
			break;
		case 2:
			switch(c) {
			case 33:
				if(str.charCodeAt(p + 1) == 91) {
					p += 2;
					if(HxOverrides.substr(str,p,6).toUpperCase() != "CDATA[") {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected <![CDATA[",str,p));
					}
					p += 5;
					state = 17;
					start = p + 1;
				} else if(str.charCodeAt(p + 1) == 68 || str.charCodeAt(p + 1) == 100) {
					if(HxOverrides.substr(str,p + 2,6).toUpperCase() != "OCTYPE") {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected <!DOCTYPE",str,p));
					}
					p += 8;
					state = 16;
					start = p + 1;
				} else if(str.charCodeAt(p + 1) != 45 || str.charCodeAt(p + 2) != 45) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected <!--",str,p));
				} else {
					p += 2;
					state = 15;
					start = p + 1;
				}
				break;
			case 47:
				if(parent == null) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected node name",str,p));
				}
				start = p + 1;
				state = 0;
				next = 10;
				break;
			case 63:
				state = 14;
				start = p;
				break;
			default:
				state = 3;
				start = p;
				continue;
			}
			break;
		case 3:
			if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45)) {
				if(p == start) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected node name",str,p));
				}
				xml = Xml.createElement(HxOverrides.substr(str,start,p - start));
				parent.addChild(xml);
				++nsubs;
				state = 0;
				next = 4;
				continue;
			}
			break;
		case 4:
			switch(c) {
			case 47:
				state = 11;
				break;
			case 62:
				state = 9;
				break;
			default:
				state = 5;
				start = p;
				continue;
			}
			break;
		case 5:
			if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45)) {
				if(start == p) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected attribute name",str,p));
				}
				var tmp = HxOverrides.substr(str,start,p - start);
				aname = tmp;
				if(xml.exists(aname)) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Duplicate attribute [" + aname + "]",str,p));
				}
				state = 0;
				next = 6;
				continue;
			}
			break;
		case 6:
			if(c == 61) {
				state = 0;
				next = 7;
			} else {
				throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected =",str,p));
			}
			break;
		case 7:
			switch(c) {
			case 34:case 39:
				buf = new StringBuf();
				state = 8;
				start = p + 1;
				attrValQuote = c;
				break;
			default:
				throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected \"",str,p));
			}
			break;
		case 8:
			switch(c) {
			case 38:
				var len = p - start;
				buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
				state = 18;
				escapeNext = 8;
				start = p + 1;
				break;
			case 60:case 62:
				if(strict) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Invalid unescaped " + String.fromCodePoint(c) + " in attribute value",str,p));
				} else if(c == attrValQuote) {
					var len1 = p - start;
					buf.b += len1 == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len1);
					var val = buf.b;
					buf = new StringBuf();
					xml.set(aname,val);
					state = 0;
					next = 4;
				}
				break;
			default:
				if(c == attrValQuote) {
					var len2 = p - start;
					buf.b += len2 == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len2);
					var val1 = buf.b;
					buf = new StringBuf();
					xml.set(aname,val1);
					state = 0;
					next = 4;
				}
			}
			break;
		case 9:
			p = haxe_xml_Parser.doParse(str,strict,p,xml);
			start = p;
			state = 1;
			break;
		case 10:
			if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45)) {
				if(start == p) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected node name",str,p));
				}
				var v = HxOverrides.substr(str,start,p - start);
				if(parent == null || parent.nodeType != 0) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Unexpected </" + v + ">, tag is not open",str,p));
				}
				if(parent.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (parent.nodeType == null ? "null" : XmlType.toString(parent.nodeType)));
				}
				if(v != parent.nodeName) {
					if(parent.nodeType != Xml.Element) {
						throw haxe_Exception.thrown("Bad node type, expected Element but found " + (parent.nodeType == null ? "null" : XmlType.toString(parent.nodeType)));
					}
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected </" + parent.nodeName + ">",str,p));
				}
				state = 0;
				next = 12;
				continue;
			}
			break;
		case 11:
			if(c == 62) {
				state = 1;
			} else {
				throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected >",str,p));
			}
			break;
		case 12:
			if(c == 62) {
				if(nsubs == 0) {
					parent.addChild(Xml.createPCData(""));
				}
				return p;
			} else {
				throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected >",str,p));
			}
			break;
		case 13:
			if(c == 60) {
				var len3 = p - start;
				buf.b += len3 == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len3);
				var child = Xml.createPCData(buf.b);
				buf = new StringBuf();
				parent.addChild(child);
				++nsubs;
				state = 0;
				next = 2;
			} else if(c == 38) {
				var len4 = p - start;
				buf.b += len4 == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len4);
				state = 18;
				escapeNext = 13;
				start = p + 1;
			}
			break;
		case 14:
			if(c == 63 && str.charCodeAt(p + 1) == 62) {
				++p;
				var str1 = HxOverrides.substr(str,start + 1,p - start - 2);
				parent.addChild(Xml.createProcessingInstruction(str1));
				++nsubs;
				state = 1;
			}
			break;
		case 15:
			if(c == 45 && str.charCodeAt(p + 1) == 45 && str.charCodeAt(p + 2) == 62) {
				parent.addChild(Xml.createComment(HxOverrides.substr(str,start,p - start)));
				++nsubs;
				p += 2;
				state = 1;
			}
			break;
		case 16:
			if(c == 91) {
				++nbrackets;
			} else if(c == 93) {
				--nbrackets;
			} else if(c == 62 && nbrackets == 0) {
				parent.addChild(Xml.createDocType(HxOverrides.substr(str,start,p - start)));
				++nsubs;
				state = 1;
			}
			break;
		case 17:
			if(c == 93 && str.charCodeAt(p + 1) == 93 && str.charCodeAt(p + 2) == 62) {
				var child1 = Xml.createCData(HxOverrides.substr(str,start,p - start));
				parent.addChild(child1);
				++nsubs;
				p += 2;
				state = 1;
			}
			break;
		case 18:
			if(c == 59) {
				var s = HxOverrides.substr(str,start,p - start);
				if(s.charCodeAt(0) == 35) {
					var c1 = s.charCodeAt(1) == 120 ? Std.parseInt("0" + HxOverrides.substr(s,1,s.length - 1)) : Std.parseInt(HxOverrides.substr(s,1,s.length - 1));
					buf.b += String.fromCodePoint(c1);
				} else if(!Object.prototype.hasOwnProperty.call(haxe_xml_Parser.escapes.h,s)) {
					if(strict) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Undefined entity: " + s,str,p));
					}
					buf.b += Std.string("&" + s + ";");
				} else {
					buf.b += Std.string(haxe_xml_Parser.escapes.h[s]);
				}
				start = p + 1;
				state = escapeNext;
			} else if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45) && c != 35) {
				if(strict) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Invalid character in entity: " + String.fromCodePoint(c),str,p));
				}
				buf.b += String.fromCodePoint(38);
				var len5 = p - start;
				buf.b += len5 == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len5);
				--p;
				start = p + 1;
				state = escapeNext;
			}
			break;
		}
		++p;
	}
	if(state == 1) {
		start = p;
		state = 13;
	}
	if(state == 13) {
		if(parent.nodeType == 0) {
			if(parent.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (parent.nodeType == null ? "null" : XmlType.toString(parent.nodeType)));
			}
			throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Unclosed node <" + parent.nodeName + ">",str,p));
		}
		if(p != start || nsubs == 0) {
			var len = p - start;
			buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
			parent.addChild(Xml.createPCData(buf.b));
			++nsubs;
		}
		return p;
	}
	if(!strict && state == 18 && escapeNext == 13) {
		buf.b += String.fromCodePoint(38);
		var len = p - start;
		buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
		parent.addChild(Xml.createPCData(buf.b));
		++nsubs;
		return p;
	}
	throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Unexpected end",str,p));
};
var haxe_xml_Printer = function(pretty) {
	this.output = new StringBuf();
	this.pretty = pretty;
};
$hxClasses["haxe.xml.Printer"] = haxe_xml_Printer;
haxe_xml_Printer.__name__ = "haxe.xml.Printer";
haxe_xml_Printer.print = function(xml,pretty) {
	if(pretty == null) {
		pretty = false;
	}
	var printer = new haxe_xml_Printer(pretty);
	printer.writeNode(xml,"");
	return printer.output.b;
};
haxe_xml_Printer.prototype = {
	writeNode: function(value,tabs) {
		switch(value.nodeType) {
		case 0:
			this.output.b += Std.string(tabs + "<");
			if(value.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string(value.nodeName);
			var attribute = value.attributes();
			while(attribute.hasNext()) {
				var attribute1 = attribute.next();
				this.output.b += Std.string(" " + attribute1 + "=\"");
				var input = StringTools.htmlEscape(value.get(attribute1),true);
				this.output.b += Std.string(input);
				this.output.b += "\"";
			}
			if(this.hasChildren(value)) {
				this.output.b += ">";
				if(this.pretty) {
					this.output.b += "\n";
				}
				if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
				}
				var _g_current = 0;
				var _g_array = value.children;
				while(_g_current < _g_array.length) {
					var child = _g_array[_g_current++];
					this.writeNode(child,this.pretty ? tabs + "\t" : tabs);
				}
				this.output.b += Std.string(tabs + "</");
				if(value.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
				}
				this.output.b += Std.string(value.nodeName);
				this.output.b += ">";
				if(this.pretty) {
					this.output.b += "\n";
				}
			} else {
				this.output.b += "/>";
				if(this.pretty) {
					this.output.b += "\n";
				}
			}
			break;
		case 1:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			var nodeValue = value.nodeValue;
			if(nodeValue.length != 0) {
				var input = tabs + StringTools.htmlEscape(nodeValue);
				this.output.b += Std.string(input);
				if(this.pretty) {
					this.output.b += "\n";
				}
			}
			break;
		case 2:
			this.output.b += Std.string(tabs + "<![CDATA[");
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string(value.nodeValue);
			this.output.b += "]]>";
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 3:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			var commentContent = value.nodeValue;
			var _this_r = new RegExp("[\n\r\t]+","g".split("u").join(""));
			commentContent = commentContent.replace(_this_r,"");
			commentContent = "<!--" + commentContent + "-->";
			this.output.b += tabs == null ? "null" : "" + tabs;
			var input = StringTools.trim(commentContent);
			this.output.b += Std.string(input);
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 4:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string("<!DOCTYPE " + value.nodeValue + ">");
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 5:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string("<?" + value.nodeValue + "?>");
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 6:
			if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			var _g_current = 0;
			var _g_array = value.children;
			while(_g_current < _g_array.length) {
				var child = _g_array[_g_current++];
				this.writeNode(child,tabs);
			}
			break;
		}
	}
	,hasChildren: function(value) {
		if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
		}
		var _g_current = 0;
		var _g_array = value.children;
		while(_g_current < _g_array.length) {
			var child = _g_array[_g_current++];
			switch(child.nodeType) {
			case 0:case 1:
				return true;
			case 2:case 3:
				if(child.nodeType == Xml.Document || child.nodeType == Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, unexpected " + (child.nodeType == null ? "null" : XmlType.toString(child.nodeType)));
				}
				if(StringTools.ltrim(child.nodeValue).length != 0) {
					return true;
				}
				break;
			default:
			}
		}
		return false;
	}
	,__class__: haxe_xml_Printer
};
var haxe_zip_Compress = function() { };
$hxClasses["haxe.zip.Compress"] = haxe_zip_Compress;
haxe_zip_Compress.__name__ = "haxe.zip.Compress";
haxe_zip_Compress.run = function(s,level) {
	throw new haxe_exceptions_NotImplementedException("Not implemented for this platform",null,{ fileName : "haxe/zip/Compress.hx", lineNumber : 39, className : "haxe.zip.Compress", methodName : "run"});
};
var haxe_zip_Huffman = $hxEnums["haxe.zip.Huffman"] = { __ename__:true,__constructs__:null
	,Found: ($_=function(i) { return {_hx_index:0,i:i,__enum__:"haxe.zip.Huffman",toString:$estr}; },$_._hx_name="Found",$_.__params__ = ["i"],$_)
	,NeedBit: ($_=function(left,right) { return {_hx_index:1,left:left,right:right,__enum__:"haxe.zip.Huffman",toString:$estr}; },$_._hx_name="NeedBit",$_.__params__ = ["left","right"],$_)
	,NeedBits: ($_=function(n,table) { return {_hx_index:2,n:n,table:table,__enum__:"haxe.zip.Huffman",toString:$estr}; },$_._hx_name="NeedBits",$_.__params__ = ["n","table"],$_)
};
haxe_zip_Huffman.__constructs__ = [haxe_zip_Huffman.Found,haxe_zip_Huffman.NeedBit,haxe_zip_Huffman.NeedBits];
haxe_zip_Huffman.__empty_constructs__ = [];
var haxe_zip_HuffTools = function() {
};
$hxClasses["haxe.zip.HuffTools"] = haxe_zip_HuffTools;
haxe_zip_HuffTools.__name__ = "haxe.zip.HuffTools";
haxe_zip_HuffTools.prototype = {
	treeDepth: function(t) {
		switch(t._hx_index) {
		case 0:
			var _g = t.i;
			return 0;
		case 1:
			var a = t.left;
			var b = t.right;
			var da = this.treeDepth(a);
			var db = this.treeDepth(b);
			return 1 + (da < db ? da : db);
		case 2:
			var _g = t.n;
			var _g = t.table;
			throw haxe_Exception.thrown("assert");
		}
	}
	,treeCompress: function(t) {
		var d = this.treeDepth(t);
		if(d == 0) {
			return t;
		}
		if(d == 1) {
			if(t._hx_index == 1) {
				var a = t.left;
				var b = t.right;
				return haxe_zip_Huffman.NeedBit(this.treeCompress(a),this.treeCompress(b));
			} else {
				throw haxe_Exception.thrown("assert");
			}
		}
		var size = 1 << d;
		var table = [];
		var _g = 0;
		var _g1 = size;
		while(_g < _g1) {
			var i = _g++;
			table.push(haxe_zip_Huffman.Found(-1));
		}
		this.treeWalk(table,0,0,d,t);
		return haxe_zip_Huffman.NeedBits(d,table);
	}
	,treeWalk: function(table,p,cd,d,t) {
		if(t._hx_index == 1) {
			var a = t.left;
			var b = t.right;
			if(d > 0) {
				this.treeWalk(table,p,cd + 1,d - 1,a);
				this.treeWalk(table,p | 1 << cd,cd + 1,d - 1,b);
			} else {
				table[p] = this.treeCompress(t);
			}
		} else {
			table[p] = this.treeCompress(t);
		}
	}
	,treeMake: function(bits,maxbits,v,len) {
		if(len > maxbits) {
			throw haxe_Exception.thrown("Invalid huffman");
		}
		var idx = v << 5 | len;
		if(bits.h.hasOwnProperty(idx)) {
			return haxe_zip_Huffman.Found(bits.h[idx]);
		}
		v <<= 1;
		++len;
		return haxe_zip_Huffman.NeedBit(this.treeMake(bits,maxbits,v,len),this.treeMake(bits,maxbits,v | 1,len));
	}
	,make: function(lengths,pos,nlengths,maxbits) {
		if(nlengths == 1) {
			return haxe_zip_Huffman.NeedBit(haxe_zip_Huffman.Found(0),haxe_zip_Huffman.Found(0));
		}
		var counts = [];
		var tmp = [];
		if(maxbits > 32) {
			throw haxe_Exception.thrown("Invalid huffman");
		}
		var _g = 0;
		var _g1 = maxbits;
		while(_g < _g1) {
			var i = _g++;
			counts.push(0);
			tmp.push(0);
		}
		var _g = 0;
		var _g1 = nlengths;
		while(_g < _g1) {
			var i = _g++;
			var p = lengths[i + pos];
			if(p >= maxbits) {
				throw haxe_Exception.thrown("Invalid huffman");
			}
			counts[p]++;
		}
		var code = 0;
		var _g = 1;
		var _g1 = maxbits - 1;
		while(_g < _g1) {
			var i = _g++;
			code = code + counts[i] << 1;
			tmp[i] = code;
		}
		var bits = new haxe_ds_IntMap();
		var _g = 0;
		var _g1 = nlengths;
		while(_g < _g1) {
			var i = _g++;
			var l = lengths[i + pos];
			if(l != 0) {
				var n = tmp[l - 1];
				tmp[l - 1] = n + 1;
				bits.h[n << 5 | l] = i;
			}
		}
		return this.treeCompress(haxe_zip_Huffman.NeedBit(this.treeMake(bits,maxbits,0,1),this.treeMake(bits,maxbits,1,1)));
	}
	,__class__: haxe_zip_HuffTools
};
var haxe_zip__$InflateImpl_Window = function(hasCrc) {
	this.buffer = new haxe_io_Bytes(new ArrayBuffer(65536));
	this.pos = 0;
	if(hasCrc) {
		this.crc = new haxe_crypto_Adler32();
	}
};
$hxClasses["haxe.zip._InflateImpl.Window"] = haxe_zip__$InflateImpl_Window;
haxe_zip__$InflateImpl_Window.__name__ = "haxe.zip._InflateImpl.Window";
haxe_zip__$InflateImpl_Window.prototype = {
	slide: function() {
		if(this.crc != null) {
			this.crc.update(this.buffer,0,32768);
		}
		var b = new haxe_io_Bytes(new ArrayBuffer(65536));
		this.pos -= 32768;
		b.blit(0,this.buffer,32768,this.pos);
		this.buffer = b;
	}
	,addBytes: function(b,p,len) {
		if(this.pos + len > 65536) {
			this.slide();
		}
		this.buffer.blit(this.pos,b,p,len);
		this.pos += len;
	}
	,addByte: function(c) {
		if(this.pos == 65536) {
			this.slide();
		}
		this.buffer.b[this.pos] = c;
		this.pos++;
	}
	,getLastChar: function() {
		return this.buffer.b[this.pos - 1];
	}
	,available: function() {
		return this.pos;
	}
	,checksum: function() {
		if(this.crc != null) {
			this.crc.update(this.buffer,0,this.pos);
		}
		return this.crc;
	}
	,__class__: haxe_zip__$InflateImpl_Window
};
var haxe_zip__$InflateImpl_State = $hxEnums["haxe.zip._InflateImpl.State"] = { __ename__:true,__constructs__:null
	,Head: {_hx_name:"Head",_hx_index:0,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,Block: {_hx_name:"Block",_hx_index:1,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,CData: {_hx_name:"CData",_hx_index:2,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,Flat: {_hx_name:"Flat",_hx_index:3,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,Crc: {_hx_name:"Crc",_hx_index:4,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,Dist: {_hx_name:"Dist",_hx_index:5,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,DistOne: {_hx_name:"DistOne",_hx_index:6,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,Done: {_hx_name:"Done",_hx_index:7,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
};
haxe_zip__$InflateImpl_State.__constructs__ = [haxe_zip__$InflateImpl_State.Head,haxe_zip__$InflateImpl_State.Block,haxe_zip__$InflateImpl_State.CData,haxe_zip__$InflateImpl_State.Flat,haxe_zip__$InflateImpl_State.Crc,haxe_zip__$InflateImpl_State.Dist,haxe_zip__$InflateImpl_State.DistOne,haxe_zip__$InflateImpl_State.Done];
haxe_zip__$InflateImpl_State.__empty_constructs__ = [haxe_zip__$InflateImpl_State.Head,haxe_zip__$InflateImpl_State.Block,haxe_zip__$InflateImpl_State.CData,haxe_zip__$InflateImpl_State.Flat,haxe_zip__$InflateImpl_State.Crc,haxe_zip__$InflateImpl_State.Dist,haxe_zip__$InflateImpl_State.DistOne,haxe_zip__$InflateImpl_State.Done];
var haxe_zip_InflateImpl = function(i,header,crc) {
	if(crc == null) {
		crc = true;
	}
	if(header == null) {
		header = true;
	}
	this.isFinal = false;
	this.htools = new haxe_zip_HuffTools();
	this.huffman = this.buildFixedHuffman();
	this.huffdist = null;
	this.len = 0;
	this.dist = 0;
	this.state = header ? haxe_zip__$InflateImpl_State.Head : haxe_zip__$InflateImpl_State.Block;
	this.input = i;
	this.bits = 0;
	this.nbits = 0;
	this.needed = 0;
	this.output = null;
	this.outpos = 0;
	this.lengths = [];
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.window = new haxe_zip__$InflateImpl_Window(crc);
};
$hxClasses["haxe.zip.InflateImpl"] = haxe_zip_InflateImpl;
haxe_zip_InflateImpl.__name__ = "haxe.zip.InflateImpl";
haxe_zip_InflateImpl.run = function(i,bufsize) {
	if(bufsize == null) {
		bufsize = 65536;
	}
	var buf = new haxe_io_Bytes(new ArrayBuffer(bufsize));
	var output = new haxe_io_BytesBuffer();
	var inflate = new haxe_zip_InflateImpl(i);
	while(true) {
		var len = inflate.readBytes(buf,0,bufsize);
		output.addBytes(buf,0,len);
		if(len < bufsize) {
			break;
		}
	}
	return output.getBytes();
};
haxe_zip_InflateImpl.prototype = {
	buildFixedHuffman: function() {
		if(haxe_zip_InflateImpl.FIXED_HUFFMAN != null) {
			return haxe_zip_InflateImpl.FIXED_HUFFMAN;
		}
		var a = [];
		var _g = 0;
		while(_g < 288) {
			var n = _g++;
			a.push(n <= 143 ? 8 : n <= 255 ? 9 : n <= 279 ? 7 : 8);
		}
		haxe_zip_InflateImpl.FIXED_HUFFMAN = this.htools.make(a,0,288,10);
		return haxe_zip_InflateImpl.FIXED_HUFFMAN;
	}
	,readBytes: function(b,pos,len) {
		this.needed = len;
		this.outpos = pos;
		this.output = b;
		if(len > 0) {
			while(this.inflateLoop()) {
			}
		}
		return len - this.needed;
	}
	,getBits: function(n) {
		while(this.nbits < n) {
			this.bits |= this.input.readByte() << this.nbits;
			this.nbits += 8;
		}
		var b = this.bits & (1 << n) - 1;
		this.nbits -= n;
		this.bits >>= n;
		return b;
	}
	,getBit: function() {
		if(this.nbits == 0) {
			this.nbits = 8;
			this.bits = this.input.readByte();
		}
		var b = (this.bits & 1) == 1;
		this.nbits--;
		this.bits >>= 1;
		return b;
	}
	,getRevBits: function(n) {
		if(n == 0) {
			return 0;
		} else if(this.getBit()) {
			return 1 << n - 1 | this.getRevBits(n - 1);
		} else {
			return this.getRevBits(n - 1);
		}
	}
	,resetBits: function() {
		this.bits = 0;
		this.nbits = 0;
	}
	,addBytes: function(b,p,len) {
		this.window.addBytes(b,p,len);
		this.output.blit(this.outpos,b,p,len);
		this.needed -= len;
		this.outpos += len;
	}
	,addByte: function(b) {
		this.window.addByte(b);
		this.output.b[this.outpos] = b;
		this.needed--;
		this.outpos++;
	}
	,addDistOne: function(n) {
		var c = this.window.getLastChar();
		var _g = 0;
		var _g1 = n;
		while(_g < _g1) {
			var i = _g++;
			this.addByte(c);
		}
	}
	,addDist: function(d,len) {
		this.addBytes(this.window.buffer,this.window.pos - d,len);
	}
	,applyHuffman: function(h) {
		switch(h._hx_index) {
		case 0:
			var n = h.i;
			return n;
		case 1:
			var a = h.left;
			var b = h.right;
			return this.applyHuffman(this.getBit() ? b : a);
		case 2:
			var n = h.n;
			var tbl = h.table;
			return this.applyHuffman(tbl[this.getBits(n)]);
		}
	}
	,inflateLengths: function(a,max) {
		var i = 0;
		var prev = 0;
		while(i < max) {
			var n = this.applyHuffman(this.huffman);
			switch(n) {
			case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:case 11:case 12:case 13:case 14:case 15:
				prev = n;
				a[i] = n;
				++i;
				break;
			case 16:
				var end = i + 3 + this.getBits(2);
				if(end > max) {
					throw haxe_Exception.thrown("Invalid data");
				}
				while(i < end) {
					a[i] = prev;
					++i;
				}
				break;
			case 17:
				i += 3 + this.getBits(3);
				if(i > max) {
					throw haxe_Exception.thrown("Invalid data");
				}
				break;
			case 18:
				i += 11 + this.getBits(7);
				if(i > max) {
					throw haxe_Exception.thrown("Invalid data");
				}
				break;
			default:
				throw haxe_Exception.thrown("Invalid data");
			}
		}
	}
	,inflateLoop: function() {
		switch(this.state._hx_index) {
		case 0:
			var cmf = this.input.readByte();
			var cm = cmf & 15;
			var cinfo = cmf >> 4;
			if(cm != 8) {
				throw haxe_Exception.thrown("Invalid data");
			}
			var flg = this.input.readByte();
			var fdict = (flg & 32) != 0;
			if(((cmf << 8) + flg) % 31 != 0) {
				throw haxe_Exception.thrown("Invalid data");
			}
			if(fdict) {
				throw haxe_Exception.thrown("Unsupported dictionary");
			}
			this.state = haxe_zip__$InflateImpl_State.Block;
			return true;
		case 1:
			this.isFinal = this.getBit();
			switch(this.getBits(2)) {
			case 0:
				this.len = this.input.readUInt16();
				var nlen = this.input.readUInt16();
				if(nlen != 65535 - this.len) {
					throw haxe_Exception.thrown("Invalid data");
				}
				this.state = haxe_zip__$InflateImpl_State.Flat;
				var r = this.inflateLoop();
				this.resetBits();
				return r;
			case 1:
				this.huffman = this.buildFixedHuffman();
				this.huffdist = null;
				this.state = haxe_zip__$InflateImpl_State.CData;
				return true;
			case 2:
				var hlit = this.getBits(5) + 257;
				var hdist = this.getBits(5) + 1;
				var hclen = this.getBits(4) + 4;
				var _g = 0;
				var _g1 = hclen;
				while(_g < _g1) {
					var i = _g++;
					this.lengths[haxe_zip_InflateImpl.CODE_LENGTHS_POS[i]] = this.getBits(3);
				}
				var _g = hclen;
				var _g1 = 19;
				while(_g < _g1) {
					var i = _g++;
					this.lengths[haxe_zip_InflateImpl.CODE_LENGTHS_POS[i]] = 0;
				}
				this.huffman = this.htools.make(this.lengths,0,19,8);
				var lengths = [];
				var _g = 0;
				var _g1 = hlit + hdist;
				while(_g < _g1) {
					var i = _g++;
					lengths.push(0);
				}
				this.inflateLengths(lengths,hlit + hdist);
				this.huffdist = this.htools.make(lengths,hlit,hdist,16);
				this.huffman = this.htools.make(lengths,0,hlit,16);
				this.state = haxe_zip__$InflateImpl_State.CData;
				return true;
			default:
				throw haxe_Exception.thrown("Invalid data");
			}
			break;
		case 2:
			var n = this.applyHuffman(this.huffman);
			if(n < 256) {
				this.addByte(n);
				return this.needed > 0;
			} else if(n == 256) {
				this.state = this.isFinal ? haxe_zip__$InflateImpl_State.Crc : haxe_zip__$InflateImpl_State.Block;
				return true;
			} else {
				n -= 257;
				var extra_bits = haxe_zip_InflateImpl.LEN_EXTRA_BITS_TBL[n];
				if(extra_bits == -1) {
					throw haxe_Exception.thrown("Invalid data");
				}
				this.len = haxe_zip_InflateImpl.LEN_BASE_VAL_TBL[n] + this.getBits(extra_bits);
				var dist_code = this.huffdist == null ? this.getRevBits(5) : this.applyHuffman(this.huffdist);
				extra_bits = haxe_zip_InflateImpl.DIST_EXTRA_BITS_TBL[dist_code];
				if(extra_bits == -1) {
					throw haxe_Exception.thrown("Invalid data");
				}
				this.dist = haxe_zip_InflateImpl.DIST_BASE_VAL_TBL[dist_code] + this.getBits(extra_bits);
				if(this.dist > this.window.available()) {
					throw haxe_Exception.thrown("Invalid data");
				}
				this.state = this.dist == 1 ? haxe_zip__$InflateImpl_State.DistOne : haxe_zip__$InflateImpl_State.Dist;
				return true;
			}
			break;
		case 3:
			var rlen = this.len < this.needed ? this.len : this.needed;
			var bytes = this.input.read(rlen);
			this.len -= rlen;
			this.addBytes(bytes,0,rlen);
			if(this.len == 0) {
				this.state = this.isFinal ? haxe_zip__$InflateImpl_State.Crc : haxe_zip__$InflateImpl_State.Block;
			}
			return this.needed > 0;
		case 4:
			var calc = this.window.checksum();
			if(calc == null) {
				this.state = haxe_zip__$InflateImpl_State.Done;
				return true;
			}
			var crc = haxe_crypto_Adler32.read(this.input);
			if(!calc.equals(crc)) {
				throw haxe_Exception.thrown("Invalid CRC");
			}
			this.state = haxe_zip__$InflateImpl_State.Done;
			return true;
		case 5:
			while(this.len > 0 && this.needed > 0) {
				var rdist = this.len < this.dist ? this.len : this.dist;
				var rlen = this.needed < rdist ? this.needed : rdist;
				this.addDist(this.dist,rlen);
				this.len -= rlen;
			}
			if(this.len == 0) {
				this.state = haxe_zip__$InflateImpl_State.CData;
			}
			return this.needed > 0;
		case 6:
			var rlen = this.len < this.needed ? this.len : this.needed;
			this.addDistOne(rlen);
			this.len -= rlen;
			if(this.len == 0) {
				this.state = haxe_zip__$InflateImpl_State.CData;
			}
			return this.needed > 0;
		case 7:
			return false;
		}
	}
	,__class__: haxe_zip_InflateImpl
};
var haxe_zip_Uncompress = function() { };
$hxClasses["haxe.zip.Uncompress"] = haxe_zip_Uncompress;
haxe_zip_Uncompress.__name__ = "haxe.zip.Uncompress";
haxe_zip_Uncompress.run = function(src,bufsize) {
	return haxe_zip_InflateImpl.run(new haxe_io_BytesInput(src),bufsize);
};
var hxd_BitmapData = function(width,height) {
	if(!(width == -101 && height == -102)) {
		var canvas = window.document.createElement("canvas");
		canvas.width = width;
		canvas.height = height;
		this.ctx = canvas.getContext("2d",null);
	}
};
$hxClasses["hxd.BitmapData"] = hxd_BitmapData;
hxd_BitmapData.__name__ = "hxd.BitmapData";
hxd_BitmapData.notImplemented = function() {
	throw haxe_Exception.thrown("Not implemented");
};
hxd_BitmapData.fromNative = function(data) {
	var b = new hxd_BitmapData(-101,-102);
	b.ctx = data;
	return b;
};
hxd_BitmapData.prototype = {
	clear: function(color) {
		this.fill(0,0,this.ctx.canvas.width,this.ctx.canvas.height,color);
	}
	,fill: function(x,y,width,height,color) {
		this.ctx.fillStyle = "rgba(" + (color >> 16 & 255) + ", " + (color >> 8 & 255) + ", " + (color & 255) + ", " + (color >>> 24) / 255 + ")";
		this.ctx.fillRect(x,y,width,height);
	}
	,draw: function(x,y,src,srcX,srcY,width,height,blendMode) {
		this.drawScaled(x,y,width,height,src,srcX,srcY,width,height,blendMode);
	}
	,drawScaled: function(x,y,width,height,src,srcX,srcY,srcWidth,srcHeight,blendMode,smooth) {
		if(smooth == null) {
			smooth = true;
		}
		if(blendMode == null) {
			blendMode = h2d_BlendMode.Alpha;
		}
		throw haxe_Exception.thrown("Not implemented");
	}
	,line: function(x0,y0,x1,y1,color) {
		var dx = x1 - x0;
		var dy = y1 - y0;
		if(dx == 0) {
			if(y1 < y0) {
				var tmp = y0;
				y0 = y1;
				y1 = tmp;
			}
			if(y0 < 0) {
				y0 = 0;
			}
			if(y1 > this.ctx.canvas.height - 1) {
				y1 = this.ctx.canvas.height - 1;
			}
			var _g = y0;
			var _g1 = y1 + 1;
			while(_g < _g1) {
				var y = _g++;
				this.setPixel(x0,y,color);
			}
		} else if(dy == 0) {
			if(x1 < x0) {
				var tmp = x0;
				x0 = x1;
				x1 = tmp;
			}
			if(x0 < 0) {
				x0 = 0;
			}
			if(x1 > this.ctx.canvas.width - 1) {
				x1 = this.ctx.canvas.width - 1;
			}
			var _g = x0;
			var _g1 = x1 + 1;
			while(_g < _g1) {
				var x = _g++;
				this.setPixel(x,y0,color);
			}
		} else {
			var sx;
			var sy;
			var clip_x0;
			var clip_y0;
			var clip_x1;
			var clip_y1;
			if(x0 < x1) {
				if(x0 >= this.ctx.canvas.width || x1 < 0) {
					return;
				}
				sx = 1;
				clip_x0 = 0;
				clip_x1 = this.ctx.canvas.width - 1;
			} else {
				if(x1 >= this.ctx.canvas.width || x0 < 0) {
					return;
				}
				sx = -1;
				x1 = -x1;
				x0 = -x0;
				clip_x0 = 1 - this.ctx.canvas.width;
				clip_x1 = 0;
			}
			if(y0 < y1) {
				if(y0 >= this.ctx.canvas.height || y1 < 0) {
					return;
				}
				sy = 1;
				clip_y0 = 0;
				clip_y1 = this.ctx.canvas.height - 1;
			} else {
				if(y1 >= this.ctx.canvas.width || y0 < 0) {
					return;
				}
				sy = -1;
				y1 = -y1;
				y0 = -y0;
				clip_y0 = 1 - this.ctx.canvas.height;
				clip_y1 = 0;
			}
			dx = x1 - x0;
			dy = y1 - y0;
			var d2x = dx << 1;
			var d2y = dy << 1;
			var x = x0;
			var y = y0;
			if(dx >= dy) {
				var delta = d2y - dx;
				var tracing_can_start = false;
				if(y0 < clip_y0) {
					var temp = d2x;
					temp = temp * (clip_y0 - y0) - dx;
					var xinc = temp / d2y;
					x += xinc | 0;
					if(x > clip_x1) {
						return;
					}
					if(x >= clip_x0) {
						temp -= xinc * d2y;
						delta -= (temp | 0) + dx;
						y = clip_y0;
						if(temp > 0) {
							++x;
							delta += d2y;
						}
						tracing_can_start = true;
					}
				}
				if(!tracing_can_start && x0 < clip_x0) {
					var temp = d2y;
					temp *= clip_x0 - x0;
					var yinc = temp / d2x;
					y += yinc | 0;
					temp %= d2x;
					if(y > clip_y1 || y == clip_y1 && temp > dx) {
						return;
					}
					x = clip_x0;
					delta += temp | 0;
					if(temp >= dx) {
						++y;
						delta -= d2x;
					}
				}
				var xend = x1;
				if(y1 > clip_y1) {
					var temp = d2x;
					temp = temp * (clip_y1 - y1) + dx;
					var xinc = temp / d2y;
					xend += xinc | 0;
					if(temp - xinc * d2y == 0) {
						--xend;
					}
				}
				if(xend > clip_x1) {
					xend = clip_x1 + 1;
				} else {
					++xend;
				}
				if(sx == -1) {
					x = -x;
					xend = -xend;
				}
				if(sy == -1) {
					y = -y;
				}
				d2x -= d2y;
				while(x != xend) {
					this.setPixel(x,y,color);
					if(delta >= 0) {
						y += sy;
						delta -= d2x;
					} else {
						delta += d2y;
					}
					x += sx;
				}
			} else {
				var delta = d2x - dy;
				var tracing_can_start = false;
				if(x0 < clip_x0) {
					var temp = d2y;
					temp = temp * (clip_x0 - x0) - dy;
					var yinc = temp / d2x;
					y += yinc | 0;
					if(y > clip_y1) {
						return;
					}
					if(y >= clip_y0) {
						temp -= yinc * d2x;
						delta -= (temp | 0) + dy;
						x = clip_x0;
						if(temp > 0) {
							++y;
							delta += d2x;
						}
						tracing_can_start = true;
					}
				}
				if(!tracing_can_start && y0 < clip_y0) {
					var temp = d2x;
					temp *= clip_y0 - y0;
					var xinc = temp / d2y;
					x += xinc | 0;
					temp %= d2y;
					if(x > clip_x1 || x == clip_x1 && temp > dy) {
						return;
					}
					y = clip_y0;
					delta += temp | 0;
					if(temp >= dy) {
						++x;
						delta -= d2y;
					}
				}
				var yend = y1;
				if(x1 > clip_x1) {
					var temp = d2y;
					temp = temp * (clip_x1 - x1) + dy;
					var yinc = temp / d2x;
					yend += yinc | 0;
					if(temp - yinc * d2x == 0) {
						--yend;
					}
				}
				if(yend > clip_y1) {
					yend = clip_y1 + 1;
				} else {
					++yend;
				}
				if(sx == -1) {
					x = -x;
				}
				if(sy == -1) {
					y = -y;
					yend = -yend;
				}
				d2y -= d2x;
				while(y != yend) {
					this.setPixel(x,y,color);
					if(delta >= 0) {
						x += sx;
						delta -= d2y;
					} else {
						delta += d2x;
					}
					y += sy;
				}
			}
		}
	}
	,dispose: function() {
		this.ctx = null;
		this.pixel = null;
	}
	,clone: function() {
		return this.sub(0,0,this.ctx.canvas.width,this.ctx.canvas.height);
	}
	,sub: function(x,y,w,h) {
		var canvas = window.document.createElement("canvas");
		canvas.width = w;
		canvas.height = h;
		var ctx = canvas.getContext("2d",null);
		ctx.drawImage(this.ctx.canvas,x,y,w,h,0,0,w,h);
		return hxd_BitmapData.fromNative(ctx);
	}
	,lock: function() {
		if(this.lockImage == null) {
			this.lockImage = this.ctx.getImageData(0,0,this.ctx.canvas.width,this.ctx.canvas.height);
		}
	}
	,unlock: function() {
		if(this.lockImage != null) {
			this.ctx.putImageData(this.lockImage,0,0);
			this.lockImage = null;
		}
	}
	,getPixel: function(x,y) {
		var i = this.lockImage;
		var a;
		if(i != null) {
			a = x + y * i.width << 2;
		} else {
			a = 0;
			i = this.ctx.getImageData(x,y,1,1);
		}
		return i.data[a] << 16 | i.data[a | 1] << 8 | i.data[a | 2] | i.data[a | 3] << 24;
	}
	,setPixel: function(x,y,c) {
		var i = this.lockImage;
		if(i != null) {
			var a = x + y * i.width << 2;
			i.data[a] = c >> 16 & 255;
			i.data[a | 1] = c >> 8 & 255;
			i.data[a | 2] = c & 255;
			i.data[a | 3] = c >>> 24 & 255;
			return;
		}
		var i = this.pixel;
		if(i == null) {
			i = this.ctx.createImageData(1,1);
			this.pixel = i;
		}
		i.data[0] = c >> 16 & 255;
		i.data[1] = c >> 8 & 255;
		i.data[2] = c & 255;
		i.data[3] = c >>> 24 & 255;
		this.ctx.putImageData(i,x,y);
	}
	,get_width: function() {
		return this.ctx.canvas.width;
	}
	,get_height: function() {
		return this.ctx.canvas.height;
	}
	,getPixels: function() {
		var w = this.ctx.canvas.width;
		var h = this.ctx.canvas.height;
		var data = this.ctx.getImageData(0,0,w,h).data;
		var pixels = data.buffer;
		return new hxd_Pixels(w,h,haxe_io_Bytes.ofData(pixels),hxd_PixelFormat.RGBA);
	}
	,setPixels: function(pixels) {
		if(pixels.width != this.ctx.canvas.width || pixels.height != this.ctx.canvas.height) {
			throw haxe_Exception.thrown("Invalid pixels size");
		}
		var img = this.ctx.createImageData(pixels.width,pixels.height);
		pixels.convert(hxd_PixelFormat.RGBA);
		var _g = 0;
		var _g1 = pixels.width * pixels.height * 4;
		while(_g < _g1) {
			var i = _g++;
			img.data[i] = pixels.bytes.b[i];
		}
		this.ctx.putImageData(img,0,0);
	}
	,toNative: function() {
		return this.ctx;
	}
	,toPNG: function() {
		var pixels = this.getPixels();
		var png = pixels.toPNG();
		pixels.dispose();
		return png;
	}
	,__class__: hxd_BitmapData
};
var hxd_Precision = {};
hxd_Precision._new = function(v) {
	return v;
};
hxd_Precision.getSize = function(this1) {
	return hxd_Precision.SIZES[this1];
};
hxd_Precision.toInt = function(this1) {
	return this1;
};
hxd_Precision.fromInt = function(v) {
	return v;
};
hxd_Precision.toString = function(this1) {
	switch(this1) {
	case 0:
		return "F32";
	case 1:
		return "F16";
	case 2:
		return "U8";
	case 3:
		return "S8";
	}
};
var hxd_InputFormat = {};
hxd_InputFormat._new = function(v) {
	return v;
};
hxd_InputFormat.getSize = function(this1) {
	return this1 & 7;
};
hxd_InputFormat.toInt = function(this1) {
	return this1;
};
hxd_InputFormat.toString = function(this1) {
	switch(this1) {
	case 1:
		return "DFloat";
	case 2:
		return "DVec2";
	case 3:
		return "DVec3";
	case 4:
		return "DVec4";
	case 9:
		return "DBytes4";
	}
};
hxd_InputFormat.fromInt = function(v) {
	return v;
};
hxd_InputFormat.fromHXSL = function(t) {
	switch(t._hx_index) {
	case 3:
		return 1;
	case 5:
		var _g = t.t;
		switch(t.size) {
		case 2:
			if(_g._hx_index == 1) {
				return 2;
			} else {
				throw haxe_Exception.thrown("Unsupported buffer type " + Std.string(t));
			}
			break;
		case 3:
			if(_g._hx_index == 1) {
				return 3;
			} else {
				throw haxe_Exception.thrown("Unsupported buffer type " + Std.string(t));
			}
			break;
		case 4:
			if(_g._hx_index == 1) {
				return 4;
			} else {
				throw haxe_Exception.thrown("Unsupported buffer type " + Std.string(t));
			}
			break;
		default:
			throw haxe_Exception.thrown("Unsupported buffer type " + Std.string(t));
		}
		break;
	case 9:
		if(t.size == 4) {
			return 9;
		} else {
			throw haxe_Exception.thrown("Unsupported buffer type " + Std.string(t));
		}
		break;
	default:
		throw haxe_Exception.thrown("Unsupported buffer type " + Std.string(t));
	}
};
var hxd_BufferInput = function(name,type,precision) {
	if(precision == null) {
		precision = 0;
	}
	this.name = name;
	this.type = type;
	this.precision = precision;
};
$hxClasses["hxd.BufferInput"] = hxd_BufferInput;
hxd_BufferInput.__name__ = "hxd.BufferInput";
hxd_BufferInput.prototype = {
	getBytesSize: function() {
		return (this.type & 7) * hxd_Precision.SIZES[this.precision];
	}
	,equals: function(b) {
		if(this.type == b.type && this.name == b.name) {
			return this.precision == b.precision;
		} else {
			return false;
		}
	}
	,__class__: hxd_BufferInput
};
var hxd_BufferMapping = {};
hxd_BufferMapping._new = function(index,offset,prec) {
	return index << 3 | prec | offset << 16;
};
hxd_BufferMapping.get_bufferIndex = function(this1) {
	return this1 >> 3 & 255;
};
hxd_BufferMapping.get_precision = function(this1) {
	return this1 & 7;
};
hxd_BufferMapping.get_offset = function(this1) {
	return this1 >> 16;
};
var hxd_BufferFormat = function(inputs) {
	this.uid = hxd_BufferFormat._UID++;
	this.stride = this.strideBytes = 0;
	this.inputs = inputs.slice();
	this.hasLowPrecision = false;
	var _g = 0;
	while(_g < inputs.length) {
		var i = inputs[_g];
		++_g;
		this.stride += i.type & 7;
		this.strideBytes += (i.type & 7) * hxd_Precision.SIZES[i.precision];
		if((this.strideBytes & 3) != 0) {
			this.strideBytes += 4 - (this.strideBytes & 3);
		}
		if(i.precision != 0) {
			this.hasLowPrecision = true;
		}
	}
};
$hxClasses["hxd.BufferFormat"] = hxd_BufferFormat;
hxd_BufferFormat.__name__ = "hxd.BufferFormat";
hxd_BufferFormat.get_COMPRESSED_CONFIG = function() {
	if(hxd_BufferFormat.COMPRESSED_CONFIG == null) {
		hxd_BufferFormat.COMPRESSED_CONFIG = hxd_BufferFormat.make([new hxd_BufferInput("data",4,1),new hxd_BufferInput("color",4,1),new hxd_BufferInput("position",2,1),new hxd_BufferInput("normal",3,3),new hxd_BufferInput("uv",2,1),new hxd_BufferInput("position",3,1)]);
		hxd_BufferFormat.COMPRESSED_CONFIG.compressed = hxd_BufferFormat.COMPRESSED_CONFIG;
	}
	return hxd_BufferFormat.COMPRESSED_CONFIG;
};
hxd_BufferFormat.get_H2D = function() {
	return hxd_BufferFormat.get_XY_UV_RGBA();
};
hxd_BufferFormat.get_XY_UV_RGBA = function() {
	if(hxd_BufferFormat.XY_UV_RGBA == null) {
		hxd_BufferFormat.XY_UV_RGBA = hxd_BufferFormat.make([new hxd_BufferInput("position",2,0),new hxd_BufferInput("uv",2,0),new hxd_BufferInput("color",4,0)]);
	}
	return hxd_BufferFormat.XY_UV_RGBA;
};
hxd_BufferFormat.get_XY_UV = function() {
	if(hxd_BufferFormat.XY_UV == null) {
		hxd_BufferFormat.XY_UV = hxd_BufferFormat.make([new hxd_BufferInput("position",2,0),new hxd_BufferInput("uv",2,0)]);
	}
	return hxd_BufferFormat.XY_UV;
};
hxd_BufferFormat.get_POS3D = function() {
	if(hxd_BufferFormat.POS3D == null) {
		hxd_BufferFormat.POS3D = hxd_BufferFormat.make([new hxd_BufferInput("position",3,0)]);
	}
	return hxd_BufferFormat.POS3D;
};
hxd_BufferFormat.get_POS3D_NORMAL = function() {
	if(hxd_BufferFormat.POS3D_NORMAL == null) {
		hxd_BufferFormat.POS3D_NORMAL = hxd_BufferFormat.make([new hxd_BufferInput("position",3,0),new hxd_BufferInput("normal",3,0)]);
	}
	return hxd_BufferFormat.POS3D_NORMAL;
};
hxd_BufferFormat.get_POS3D_NORMAL_UV = function() {
	if(hxd_BufferFormat.POS3D_NORMAL_UV == null) {
		hxd_BufferFormat.POS3D_NORMAL_UV = hxd_BufferFormat.make([new hxd_BufferInput("position",3,0),new hxd_BufferInput("normal",3,0),new hxd_BufferInput("uv",2,0)]);
	}
	return hxd_BufferFormat.POS3D_NORMAL_UV;
};
hxd_BufferFormat.get_POS3D_NORMAL_UV_RGBA = function() {
	if(hxd_BufferFormat.POS3D_NORMAL_UV_RGBA == null) {
		hxd_BufferFormat.POS3D_NORMAL_UV_RGBA = hxd_BufferFormat.get_POS3D_NORMAL_UV().append("color",4);
	}
	return hxd_BufferFormat.POS3D_NORMAL_UV_RGBA;
};
hxd_BufferFormat.get_POS3D_UV = function() {
	if(hxd_BufferFormat.POS3D_UV == null) {
		hxd_BufferFormat.POS3D_UV = hxd_BufferFormat.make([new hxd_BufferInput("position",3,0),new hxd_BufferInput("uv",2,0)]);
	}
	return hxd_BufferFormat.POS3D_UV;
};
hxd_BufferFormat.get_VEC4_DATA = function() {
	if(hxd_BufferFormat.VEC4_DATA == null) {
		hxd_BufferFormat.VEC4_DATA = hxd_BufferFormat.make([new hxd_BufferInput("data",4,0)]);
	}
	return hxd_BufferFormat.VEC4_DATA;
};
hxd_BufferFormat.get_INDEX16 = function() {
	if(hxd_BufferFormat.INDEX16 == null) {
		hxd_BufferFormat.INDEX16 = hxd_BufferFormat.make([new hxd_BufferInput("index",1,1)]);
		hxd_BufferFormat.INDEX16.strideBytes = 2;
	}
	return hxd_BufferFormat.INDEX16;
};
hxd_BufferFormat.get_INDEX32 = function() {
	if(hxd_BufferFormat.INDEX32 == null) {
		hxd_BufferFormat.INDEX32 = hxd_BufferFormat.make([new hxd_BufferInput("index",1,0)]);
	}
	return hxd_BufferFormat.INDEX32;
};
hxd_BufferFormat.fromID = function(uid) {
	var h = hxd_BufferFormat.ALL_FORMATS.h;
	var fl_h = h;
	var fl_keys = Object.keys(h);
	var fl_length = fl_keys.length;
	var fl_current = 0;
	while(fl_current < fl_length) {
		var fl = fl_h[fl_keys[fl_current++]];
		var _g = 0;
		while(_g < fl.length) {
			var f = fl[_g];
			++_g;
			if(f.uid == uid) {
				return f;
			}
		}
	}
	return null;
};
hxd_BufferFormat.make = function(inputs) {
	var names = [];
	var _g = 0;
	while(_g < inputs.length) {
		var b = inputs[_g];
		++_g;
		names.push(b.name);
	}
	var key = names.join("|");
	var arr = hxd_BufferFormat.ALL_FORMATS.h[key];
	if(arr == null) {
		arr = [];
		hxd_BufferFormat.ALL_FORMATS.h[key] = arr;
	}
	var _g = 0;
	while(_g < arr.length) {
		var fmt = arr[_g];
		++_g;
		var found = true;
		var _g1 = 0;
		var _g2 = inputs.length;
		while(_g1 < _g2) {
			var i = _g1++;
			var _this = inputs[i];
			var b = fmt.inputs[i];
			if(!(_this.type == b.type && _this.name == b.name && _this.precision == b.precision)) {
				found = false;
				break;
			}
		}
		if(found) {
			return fmt;
		}
	}
	var fmt = new hxd_BufferFormat(inputs);
	arr.push(fmt);
	return fmt;
};
hxd_BufferFormat.float32to16 = function(v,denormalsAreZero) {
	if(denormalsAreZero == null) {
		denormalsAreZero = false;
	}
	var i = haxe_io_FPHelper.floatToI32(v);
	var sign = (i & -2147483648) >>> 16;
	var exp = (i & 2139095040) >>> 23;
	var bits = i & 8388607;
	if(exp > 112) {
		return sign | exp - 112 << 10 & 31744 | bits >> 13;
	}
	if(exp < 113 && exp > 101 && !denormalsAreZero) {
		return sign | (8384512 + bits >> 125 - exp) + 1 >> 1;
	}
	if(exp > 143) {
		return sign | 32767;
	}
	return 0;
};
hxd_BufferFormat.float16to32 = function(v) {
	var sign = (v & 32768) << 16;
	var bits = (v & 1023) << 13;
	var exp = (v & 31744) >> 10;
	if(exp != 0) {
		return haxe_io_FPHelper.i32ToFloat(sign | exp + 112 << 23 | bits);
	}
	if(bits == 0) {
		return 0;
	}
	var bitcount = haxe_io_FPHelper.floatToI32(bits) >> 23;
	return haxe_io_FPHelper.i32ToFloat(sign | bitcount - 37 << 23 | bits << 150 - bitcount & 8380416);
};
hxd_BufferFormat.float32toS8 = function(v) {
	var i = Math.floor(v * 128);
	if(i >= 127) {
		return 127;
	}
	if(i <= -127) {
		return 128;
	}
	if(i >= 0) {
		return i;
	} else {
		return 127 + i | 128;
	}
};
hxd_BufferFormat.floatS8to32 = function(v) {
	if((v & 128) != 0) {
		return -1 * (127 - (v & 127)) / 128;
	} else {
		return (v & 127) / 128;
	}
};
hxd_BufferFormat.float32toU8 = function(v) {
	if(v < 0) {
		return 0;
	}
	if(v >= 1) {
		return 255;
	}
	return Math.floor(v * 256);
};
hxd_BufferFormat.floatU8to32 = function(v) {
	return (v & 255) / 255;
};
hxd_BufferFormat.prototype = {
	getInput: function(name) {
		var _g = 0;
		var _g1 = this.inputs;
		while(_g < _g1.length) {
			var i = _g1[_g];
			++_g;
			if(i.name == name) {
				return i;
			}
		}
		return null;
	}
	,getCompressed: function() {
		if(this.compressed != null) {
			return this.compressed;
		}
		var compressedInputs = [];
		var lookupIndices = [];
		compressedInputs.length = this.inputs.length;
		lookupIndices.length = this.inputs.length;
		var minStrideBytes = 0;
		var _g_current = 0;
		var _g_array = this.inputs;
		while(_g_current < _g_array.length) {
			var _g_value = _g_array[_g_current];
			var _g_key = _g_current++;
			var index = _g_key;
			var input = _g_value;
			var found = false;
			var _g_current1 = 0;
			var _g_array1 = hxd_BufferFormat.get_COMPRESSED_CONFIG().inputs;
			while(_g_current1 < _g_array1.length) {
				var _g_value1 = _g_array1[_g_current1];
				var _g_key1 = _g_current1++;
				var compressedIndex = _g_key1;
				var compressedInput = _g_value1;
				if(input.type == compressedInput.type && Reflect.compare(input.name,compressedInput.name) == 0) {
					minStrideBytes += (compressedInput.type & 7) * hxd_Precision.SIZES[compressedInput.precision];
					if((minStrideBytes & 3) != 0) {
						minStrideBytes += 4 - (minStrideBytes & 3);
					}
					compressedInputs[index] = new hxd_BufferInput(compressedInput.name,compressedInput.type,compressedInput.precision);
					lookupIndices[index] = { compressedIndex : compressedIndex, index : index};
					found = true;
					break;
				}
			}
			if(!found) {
				minStrideBytes += (input.type & 7) * hxd_Precision.SIZES[input.precision];
				if((minStrideBytes & 3) != 0) {
					minStrideBytes += 4 - (minStrideBytes & 3);
				}
				compressedInputs[index] = new hxd_BufferInput(input.name,input.type,input.precision);
				lookupIndices[index] = { compressedIndex : -1, index : index};
			}
		}
		var maxStrideBytes = minStrideBytes;
		if((maxStrideBytes & 7) != 0) {
			maxStrideBytes += 8 - (maxStrideBytes & 7);
		}
		if(maxStrideBytes != minStrideBytes) {
			lookupIndices.sort(function(o1,o2) {
				return o2.compressedIndex - o1.compressedIndex;
			});
			var _g = 0;
			while(_g < lookupIndices.length) {
				var indices = lookupIndices[_g];
				++_g;
				var currentInput = compressedInputs[indices.index];
				var inputStrideBytes = (currentInput.type & 7) * hxd_Precision.SIZES[currentInput.precision];
				if((inputStrideBytes & 3) != 0) {
					inputStrideBytes += 4 - (inputStrideBytes & 3);
				}
				var strideBytesMinusInput = minStrideBytes - inputStrideBytes;
				var previousCurrentStrideBytes = minStrideBytes;
				var currentStrideBytes = minStrideBytes;
				while(currentStrideBytes < maxStrideBytes && currentInput.precision > 0) {
					previousCurrentStrideBytes = currentStrideBytes;
					currentInput.precision = currentInput.precision - 1;
					currentStrideBytes = strideBytesMinusInput + (currentInput.type & 7) * hxd_Precision.SIZES[currentInput.precision];
					if((currentStrideBytes & 3) != 0) {
						currentStrideBytes += 4 - (currentStrideBytes & 3);
					}
				}
				if(currentStrideBytes > maxStrideBytes) {
					currentInput.precision = currentInput.precision + 1;
					currentStrideBytes = previousCurrentStrideBytes;
				}
				compressedInputs[indices.index] = currentInput;
				minStrideBytes = currentStrideBytes;
				if(minStrideBytes == maxStrideBytes) {
					break;
				}
			}
		}
		this.compressed = hxd_BufferFormat.make(compressedInputs);
		this.compressed.compressed = this.compressed;
		return this.compressed;
	}
	,calculateInputOffset: function(name) {
		var offset = 0;
		var _g = 0;
		var _g1 = this.inputs;
		while(_g < _g1.length) {
			var i = _g1[_g];
			++_g;
			if(i.name == name) {
				return offset;
			}
			offset += (i.type & 7) * hxd_Precision.SIZES[i.precision];
			if((offset & 3) != 0) {
				offset += 4 - (offset & 3);
			}
		}
		throw haxe_Exception.thrown("Input not found : " + name);
	}
	,hasInput: function(name,type) {
		var _g = 0;
		var _g1 = this.inputs;
		while(_g < _g1.length) {
			var i = _g1[_g];
			++_g;
			if(i.name == name) {
				if(type != null) {
					return type == i.type;
				} else {
					return true;
				}
			}
		}
		return false;
	}
	,append: function(name,type) {
		var inputs = this.inputs.slice();
		inputs.push(new hxd_BufferInput(name,type,0));
		return hxd_BufferFormat.make(inputs);
	}
	,pop: function() {
		var inputs = this.inputs.slice();
		inputs.pop();
		return hxd_BufferFormat.make(inputs);
	}
	,isSubSet: function(fmt) {
		if(fmt == this) {
			return true;
		}
		if(this.inputs.length >= fmt.inputs.length) {
			return false;
		}
		var _g = 0;
		var _g1 = this.inputs.length;
		while(_g < _g1) {
			var i = _g++;
			var i1 = this.inputs[i];
			var i2 = fmt.inputs[i];
			if(i1.name != i2.name || i1.type != i2.type) {
				return false;
			}
		}
		return true;
	}
	,resolveMapping: function(target) {
		var m = this.mappings == null ? null : this.mappings[target.uid];
		if(m != null) {
			return m;
		}
		m = [];
		var _g = 0;
		var _g1 = target.inputs;
		while(_g < _g1.length) {
			var i = _g1[_g];
			++_g;
			var found = false;
			var _g2 = 0;
			var _g3 = this.inputs;
			while(_g2 < _g3.length) {
				var i2 = _g3[_g2];
				++_g2;
				if(i2.name == i.name && i2.type == i.type) {
					m.push(hxd_BufferMapping._new(0,this.calculateInputOffset(i2.name),i2.precision));
					found = true;
					break;
				}
			}
			if(!found) {
				throw haxe_Exception.thrown("Missing buffer input '" + i.name + "'");
			}
		}
		if(this.mappings == null) {
			this.mappings = [];
		}
		this.mappings[target.uid] = m;
		return m;
	}
	,getInputs: function() {
		return new haxe_iterators_ArrayIterator(this.inputs);
	}
	,toString: function() {
		var _g = [];
		var _g1 = 0;
		var _g2 = this.inputs;
		while(_g1 < _g2.length) {
			var i = _g2[_g1];
			++_g1;
			_g.push(i.name + ":" + hxd_InputFormat.toString(i.type) + (i.precision == 0 ? "" : "." + hxd_Precision.toString(i.precision).toLowerCase()));
		}
		return _g.toString();
	}
	,__class__: hxd_BufferFormat
};
var hxd_MultiFormat = function(formats) {
	this.mappings = [];
	this.uid = hxd_MultiFormat._UID++;
	this.formats = formats;
};
$hxClasses["hxd.MultiFormat"] = hxd_MultiFormat;
hxd_MultiFormat.__name__ = "hxd.MultiFormat";
hxd_MultiFormat.make = function(formats) {
	if(formats.length > hxd_MultiFormat.MAX_FORMATS) {
		var _g = [];
		var _g1 = 0;
		while(_g1 < formats.length) {
			var f = formats[_g1];
			++_g1;
			_g.push(f.toString());
		}
		throw haxe_Exception.thrown("Too many formats (addBuffer leak?) " + Std.string(_g));
	}
	var c = { found : null, nexts : hxd_MultiFormat.CACHE};
	var _g = 0;
	while(_g < formats.length) {
		var f = formats[_g];
		++_g;
		var c2 = c.nexts.h[f.uid];
		if(c2 == null) {
			c2 = { found : null, nexts : new haxe_ds_IntMap()};
			c.nexts.h[f.uid] = c2;
		}
		c = c2;
	}
	if(c.found == null) {
		c.found = new hxd_MultiFormat(formats);
	}
	return c.found;
};
hxd_MultiFormat.prototype = {
	resolveMapping: function(format) {
		var m = this.mappings[format.uid];
		if(m == null) {
			m = this.makeMapping(format);
		}
		return m;
	}
	,makeMapping: function(format) {
		var m = [];
		var _g_current = 0;
		var _g_array = format.inputs;
		while(_g_current < _g_array.length) {
			var input = _g_array[_g_current++];
			var found = false;
			var match = null;
			var _g_current1 = 0;
			var _g_array1 = this.formats;
			while(_g_current1 < _g_array1.length) {
				var _g_value = _g_array1[_g_current1];
				var _g_key = _g_current1++;
				var idx = _g_key;
				var f = _g_value;
				var i = f.getInput(input.name);
				if(i != null) {
					match = i;
					if(i.type != input.type) {
						continue;
					}
					var offset = f.calculateInputOffset(i.name);
					m.push(hxd_BufferMapping._new(idx,offset,i.precision));
					found = true;
					break;
				}
			}
			if(!found) {
				if(match != null) {
					throw haxe_Exception.thrown("Shader buffer " + input.name + " was requested with " + (input.type == null ? "null" : hxd_InputFormat.toString(input.type)) + " but found with " + (match.type == null ? "null" : hxd_InputFormat.toString(match.type)));
				}
				throw haxe_Exception.thrown("Missing shader buffer " + input.name);
			}
		}
		this.mappings[format.uid] = m;
		return m;
	}
	,__class__: hxd_MultiFormat
};
var hxd_Charset = function() {
	var _gthis = this;
	this.map = new haxe_ds_IntMap();
	var _g = 0;
	while(_g < 94) {
		var i = _g++;
		_gthis.map.h[65281 + i] = 33 + i;
	}
	var _g = 192;
	var _g1 = 199;
	while(_g < _g1) {
		var i = _g++;
		_gthis.map.h[i] = 65;
	}
	var _g = 224;
	var _g1 = 231;
	while(_g < _g1) {
		var i = _g++;
		_gthis.map.h[i] = 97;
	}
	var _g = 200;
	var _g1 = 204;
	while(_g < _g1) {
		var i = _g++;
		_gthis.map.h[i] = 69;
	}
	var _g = 232;
	var _g1 = 236;
	while(_g < _g1) {
		var i = _g++;
		_gthis.map.h[i] = 101;
	}
	var _g = 204;
	var _g1 = 208;
	while(_g < _g1) {
		var i = _g++;
		_gthis.map.h[i] = 73;
	}
	var _g = 236;
	var _g1 = 240;
	while(_g < _g1) {
		var i = _g++;
		_gthis.map.h[i] = 105;
	}
	var _g = 210;
	var _g1 = 215;
	while(_g < _g1) {
		var i = _g++;
		_gthis.map.h[i] = 79;
	}
	var _g = 242;
	var _g1 = 247;
	while(_g < _g1) {
		var i = _g++;
		_gthis.map.h[i] = 111;
	}
	var _g = 217;
	var _g1 = 221;
	while(_g < _g1) {
		var i = _g++;
		_gthis.map.h[i] = 85;
	}
	var _g = 249;
	var _g1 = 253;
	while(_g < _g1) {
		var i = _g++;
		_gthis.map.h[i] = 117;
	}
	_gthis.map.h[199] = 67;
	_gthis.map.h[231] = 67;
	_gthis.map.h[208] = 68;
	_gthis.map.h[222] = 100;
	_gthis.map.h[209] = 78;
	_gthis.map.h[241] = 110;
	_gthis.map.h[221] = 89;
	_gthis.map.h[253] = 121;
	_gthis.map.h[255] = 121;
	_gthis.map.h[8364] = 69;
	_gthis.map.h[12288] = 32;
	_gthis.map.h[160] = 32;
	_gthis.map.h[171] = 34;
	_gthis.map.h[187] = 34;
	_gthis.map.h[8220] = 34;
	_gthis.map.h[8221] = 34;
	_gthis.map.h[8222] = 34;
	_gthis.map.h[8216] = 39;
	_gthis.map.h[8217] = 39;
	_gthis.map.h[180] = 39;
	_gthis.map.h[8216] = 39;
	_gthis.map.h[8249] = 60;
	_gthis.map.h[8250] = 62;
	_gthis.map.h[8211] = 45;
};
$hxClasses["hxd.Charset"] = hxd_Charset;
hxd_Charset.__name__ = "hxd.Charset";
hxd_Charset.getDefault = function() {
	if(hxd_Charset.inst == null) {
		hxd_Charset.inst = new hxd_Charset();
	}
	return hxd_Charset.inst;
};
hxd_Charset.prototype = {
	resolveChar: function(code,glyphs) {
		var c = code;
		while(c != null) {
			var g = glyphs.h[c];
			if(g != null) {
				return g;
			}
			c = this.map.h[c];
		}
		return null;
	}
	,isCJK: function(code) {
		if(!(code >= 11904 && code <= 42191 || code >= 63744 && code <= 64255)) {
			if(code >= 131072) {
				return code <= 262141;
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	,isSpace: function(code) {
		if(code != 32) {
			return code == 12288;
		} else {
			return true;
		}
	}
	,isBreakChar: function(code) {
		if(!this.isSpace(code)) {
			return this.isCJK(code);
		} else {
			return true;
		}
	}
	,isComplementChar: function(code) {
		return hxd_Charset.complementChars.h.hasOwnProperty(code);
	}
	,__class__: hxd_Charset
};
var hxd_Cursor = $hxEnums["hxd.Cursor"] = { __ename__:true,__constructs__:null
	,Default: {_hx_name:"Default",_hx_index:0,__enum__:"hxd.Cursor",toString:$estr}
	,Button: {_hx_name:"Button",_hx_index:1,__enum__:"hxd.Cursor",toString:$estr}
	,Move: {_hx_name:"Move",_hx_index:2,__enum__:"hxd.Cursor",toString:$estr}
	,TextInput: {_hx_name:"TextInput",_hx_index:3,__enum__:"hxd.Cursor",toString:$estr}
	,Hide: {_hx_name:"Hide",_hx_index:4,__enum__:"hxd.Cursor",toString:$estr}
	,Custom: ($_=function(custom) { return {_hx_index:5,custom:custom,__enum__:"hxd.Cursor",toString:$estr}; },$_._hx_name="Custom",$_.__params__ = ["custom"],$_)
	,Callback: ($_=function(f) { return {_hx_index:6,f:f,__enum__:"hxd.Cursor",toString:$estr}; },$_._hx_name="Callback",$_.__params__ = ["f"],$_)
};
hxd_Cursor.__constructs__ = [hxd_Cursor.Default,hxd_Cursor.Button,hxd_Cursor.Move,hxd_Cursor.TextInput,hxd_Cursor.Hide,hxd_Cursor.Custom,hxd_Cursor.Callback];
hxd_Cursor.__empty_constructs__ = [hxd_Cursor.Default,hxd_Cursor.Button,hxd_Cursor.Move,hxd_Cursor.TextInput,hxd_Cursor.Hide];
var hxd_CustomCursor = function(frames,speed,offsetX,offsetY) {
	this.frames = frames;
	this.speed = speed;
	this.offsetX = offsetX;
	this.offsetY = offsetY;
	this.frameDelay = 1 / speed;
	this.frameTime = 0;
	this.frameIndex = 0;
};
$hxClasses["hxd.CustomCursor"] = hxd_CustomCursor;
hxd_CustomCursor.__name__ = "hxd.CustomCursor";
hxd_CustomCursor.getNativeCursor = function(name) {
	var c = new hxd_CustomCursor([],0,0,0);
	c.alloc = [name];
	return hxd_Cursor.Custom(c);
};
hxd_CustomCursor.prototype = {
	reset: function() {
		this.frameTime = 0;
		this.frameIndex = 0;
	}
	,update: function(dt) {
		var newTime = this.frameTime + dt;
		var delay = this.frameDelay;
		var index = this.frameIndex;
		while(newTime >= delay) {
			newTime -= delay;
			++index;
		}
		this.frameTime = newTime;
		if(index >= this.frames.length) {
			index %= this.frames.length;
		}
		if(index != this.frameIndex) {
			this.frameIndex = index;
			return index;
		}
		return -1;
	}
	,dispose: function() {
		var _g = 0;
		var _g1 = this.frames;
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			f.ctx = null;
			f.pixel = null;
		}
		this.frames = [];
		if(this.alloc != null) {
			this.alloc = null;
		}
	}
	,__class__: hxd_CustomCursor
};
var hxd_DroppedFile = function(file) {
	this.file = file;
};
$hxClasses["hxd.DroppedFile"] = hxd_DroppedFile;
hxd_DroppedFile.__name__ = "hxd.DroppedFile";
hxd_DroppedFile.prototype = {
	__class__: hxd_DroppedFile
};
var hxd_DropFileEvent = function(files,dx,dy) {
	this.files = files;
	this.dropX = dx;
	this.dropY = dy;
};
$hxClasses["hxd.DropFileEvent"] = hxd_DropFileEvent;
hxd_DropFileEvent.__name__ = "hxd.DropFileEvent";
hxd_DropFileEvent.prototype = {
	get_file: function() {
		return this.files[0];
	}
	,__class__: hxd_DropFileEvent
};
var hxd_EventKind = $hxEnums["hxd.EventKind"] = { __ename__:true,__constructs__:null
	,EPush: {_hx_name:"EPush",_hx_index:0,__enum__:"hxd.EventKind",toString:$estr}
	,ERelease: {_hx_name:"ERelease",_hx_index:1,__enum__:"hxd.EventKind",toString:$estr}
	,EMove: {_hx_name:"EMove",_hx_index:2,__enum__:"hxd.EventKind",toString:$estr}
	,EOver: {_hx_name:"EOver",_hx_index:3,__enum__:"hxd.EventKind",toString:$estr}
	,EOut: {_hx_name:"EOut",_hx_index:4,__enum__:"hxd.EventKind",toString:$estr}
	,EWheel: {_hx_name:"EWheel",_hx_index:5,__enum__:"hxd.EventKind",toString:$estr}
	,EFocus: {_hx_name:"EFocus",_hx_index:6,__enum__:"hxd.EventKind",toString:$estr}
	,EFocusLost: {_hx_name:"EFocusLost",_hx_index:7,__enum__:"hxd.EventKind",toString:$estr}
	,EKeyDown: {_hx_name:"EKeyDown",_hx_index:8,__enum__:"hxd.EventKind",toString:$estr}
	,EKeyUp: {_hx_name:"EKeyUp",_hx_index:9,__enum__:"hxd.EventKind",toString:$estr}
	,EReleaseOutside: {_hx_name:"EReleaseOutside",_hx_index:10,__enum__:"hxd.EventKind",toString:$estr}
	,ETextInput: {_hx_name:"ETextInput",_hx_index:11,__enum__:"hxd.EventKind",toString:$estr}
	,ECheck: {_hx_name:"ECheck",_hx_index:12,__enum__:"hxd.EventKind",toString:$estr}
};
hxd_EventKind.__constructs__ = [hxd_EventKind.EPush,hxd_EventKind.ERelease,hxd_EventKind.EMove,hxd_EventKind.EOver,hxd_EventKind.EOut,hxd_EventKind.EWheel,hxd_EventKind.EFocus,hxd_EventKind.EFocusLost,hxd_EventKind.EKeyDown,hxd_EventKind.EKeyUp,hxd_EventKind.EReleaseOutside,hxd_EventKind.ETextInput,hxd_EventKind.ECheck];
hxd_EventKind.__empty_constructs__ = [hxd_EventKind.EPush,hxd_EventKind.ERelease,hxd_EventKind.EMove,hxd_EventKind.EOver,hxd_EventKind.EOut,hxd_EventKind.EWheel,hxd_EventKind.EFocus,hxd_EventKind.EFocusLost,hxd_EventKind.EKeyDown,hxd_EventKind.EKeyUp,hxd_EventKind.EReleaseOutside,hxd_EventKind.ETextInput,hxd_EventKind.ECheck];
var hxd_Event = function(k,x,y) {
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.button = 0;
	this.kind = k;
	this.relX = x;
	this.relY = y;
};
$hxClasses["hxd.Event"] = hxd_Event;
hxd_Event.__name__ = "hxd.Event";
hxd_Event.prototype = {
	toString: function() {
		var tmp = Std.string(this.kind) + "[" + (this.relX | 0) + "," + (this.relY | 0) + "]";
		var tmp1;
		switch(this.kind._hx_index) {
		case 5:
			tmp1 = ",wheelDelta=" + this.wheelDelta;
			break;
		case 8:case 9:
			tmp1 = ",keyCode=" + this.keyCode;
			break;
		case 0:case 1:case 10:
			tmp1 = ",button=" + this.button;
			break;
		case 11:
			tmp1 = ",charCode=" + this.charCode;
			break;
		case 2:case 3:case 4:case 6:case 7:case 12:
			tmp1 = "";
			break;
		}
		return tmp + tmp1;
	}
	,__class__: hxd_Event
};
var hxd__$FloatBuffer_Float32Expand = {};
hxd__$FloatBuffer_Float32Expand._new = function(length) {
	return { pos : length, array : new Float32Array(new ArrayBuffer(length << 2))};
};
hxd__$FloatBuffer_Float32Expand.get_length = function(this1) {
	return this1.pos;
};
hxd__$FloatBuffer_Float32Expand.set_length = function(this1,v) {
	if(this1.pos != v) {
		var newArray = new Float32Array(v);
		newArray.set(this1.array);
		this1.array = newArray;
	}
	this1.pos = v;
	return v;
};
hxd__$FloatBuffer_Float32Expand.push = function(this1,v) {
	if(this1.pos == this1.array.length) {
		var newSize = this1.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(this1.array);
		this1.array = newArray;
	}
	this1.array[this1.pos++] = v;
};
hxd__$FloatBuffer_Float32Expand.get = function(this1,index) {
	return this1.array[index];
};
hxd__$FloatBuffer_Float32Expand.set = function(this1,index,v) {
	return this1.array[index] = v;
};
hxd__$FloatBuffer_Float32Expand.toF32Array = function(this1) {
	return this1.array;
};
hxd__$FloatBuffer_Float32Expand.toArray = function(this1) {
	var _g = [];
	var _g1 = 0;
	var _g2 = this1.pos;
	while(_g1 < _g2) {
		var i = _g1++;
		_g.push(this1.array[i]);
	}
	return _g;
};
var hxd__$FloatBuffer_InnerIterator = function(b) {
	this.b = b;
	this.len = this.b.pos;
	this.pos = 0;
};
$hxClasses["hxd._FloatBuffer.InnerIterator"] = hxd__$FloatBuffer_InnerIterator;
hxd__$FloatBuffer_InnerIterator.__name__ = "hxd._FloatBuffer.InnerIterator";
hxd__$FloatBuffer_InnerIterator.prototype = {
	hasNext: function() {
		return this.pos < this.len;
	}
	,next: function() {
		return this.b.array[this.pos++];
	}
	,__class__: hxd__$FloatBuffer_InnerIterator
};
var hxd_FloatBuffer = {};
hxd_FloatBuffer._new = function(length) {
	if(length == null) {
		length = 0;
	}
	return hxd__$FloatBuffer_Float32Expand._new(length);
};
hxd_FloatBuffer.push = function(this1,v) {
	if(this1.pos == this1.array.length) {
		var newSize = this1.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(this1.array);
		this1.array = newArray;
	}
	this1.array[this1.pos++] = v;
};
hxd_FloatBuffer.grow = function(this1,v) {
	var _g = this1.pos;
	var _g1 = v;
	while(_g < _g1) {
		var i = _g++;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = 0.;
	}
};
hxd_FloatBuffer.resize = function(this1,v) {
	if(this1.pos != v) {
		var newArray = new Float32Array(v);
		newArray.set(this1.array);
		this1.array = newArray;
	}
	this1.pos = v;
};
hxd_FloatBuffer.arrayRead = function(this1,key) {
	return this1.array[key];
};
hxd_FloatBuffer.arrayWrite = function(this1,key,value) {
	return this1.array[key] = value;
};
hxd_FloatBuffer.getNative = function(this1) {
	return this1;
};
hxd_FloatBuffer.iterator = function(this1) {
	return new hxd__$FloatBuffer_InnerIterator(this1);
};
hxd_FloatBuffer.get_length = function(this1) {
	return this1.pos;
};
var hxd__$IndexBuffer_InnerIterator = function(b) {
	this.b = b;
	this.len = this.b.length;
	this.pos = 0;
};
$hxClasses["hxd._IndexBuffer.InnerIterator"] = hxd__$IndexBuffer_InnerIterator;
hxd__$IndexBuffer_InnerIterator.__name__ = "hxd._IndexBuffer.InnerIterator";
hxd__$IndexBuffer_InnerIterator.prototype = {
	hasNext: function() {
		return this.pos < this.len;
	}
	,next: function() {
		return this.b[this.pos++];
	}
	,__class__: hxd__$IndexBuffer_InnerIterator
};
var hxd_IndexBuffer = {};
hxd_IndexBuffer._new = function(length) {
	if(length == null) {
		length = 0;
	}
	return new Array(length);
};
hxd_IndexBuffer.push = function(this1,v) {
	this1.push(v);
};
hxd_IndexBuffer.grow = function(this1,v) {
	while(this1.length < v) this1.push(0);
};
hxd_IndexBuffer.arrayRead = function(this1,key) {
	return this1[key];
};
hxd_IndexBuffer.arrayWrite = function(this1,key,value) {
	return this1[key] = value;
};
hxd_IndexBuffer.getNative = function(this1) {
	return this1;
};
hxd_IndexBuffer.iterator = function(this1) {
	return new hxd__$IndexBuffer_InnerIterator(this1);
};
hxd_IndexBuffer.get_length = function(this1) {
	return this1.length;
};
var hxd_Key = function() { };
$hxClasses["hxd.Key"] = hxd_Key;
hxd_Key.__name__ = "hxd.Key";
hxd_Key.isDown = function(code) {
	return hxd_Key.keyPressed[code] > 0;
};
hxd_Key.getFrame = function() {
	return hxd_Timer.frameCount + 2;
};
hxd_Key.isPressed = function(code) {
	return hxd_Key.keyPressed[code] == hxd_Timer.frameCount + 2 - 1;
};
hxd_Key.isReleased = function(code) {
	return hxd_Key.keyPressed[code] == -(hxd_Timer.frameCount + 2) + 1;
};
hxd_Key.initialize = function() {
	if(hxd_Key.initDone) {
		hxd_Key.dispose();
	}
	hxd_Key.initDone = true;
	hxd_Key.keyPressed = [];
	hxd_Window.getInstance().addEventTarget(hxd_Key.onEvent);
};
hxd_Key.dispose = function() {
	if(hxd_Key.initDone) {
		hxd_Window.getInstance().removeEventTarget(hxd_Key.onEvent);
		hxd_Key.initDone = false;
		hxd_Key.keyPressed = [];
	}
};
hxd_Key.onEvent = function(e) {
	switch(e.kind._hx_index) {
	case 0:
		if(e.button < 5) {
			hxd_Key.keyPressed[e.button] = hxd_Timer.frameCount + 2;
		}
		break;
	case 1:
		if(e.button < 5) {
			hxd_Key.keyPressed[e.button] = -(hxd_Timer.frameCount + 2);
		}
		break;
	case 5:
		hxd_Key.keyPressed[e.wheelDelta > 0 ? 6 : 5] = hxd_Timer.frameCount + 2;
		break;
	case 8:
		if(!hxd_Key.ALLOW_KEY_REPEAT && hxd_Key.keyPressed[e.keyCode] > 0) {
			return;
		}
		hxd_Key.keyPressed[e.keyCode] = hxd_Timer.frameCount + 2;
		break;
	case 9:
		hxd_Key.keyPressed[e.keyCode] = -(hxd_Timer.frameCount + 2);
		break;
	case 10:
		hxd_Key.keyPressed = [];
		break;
	default:
	}
};
hxd_Key.getKeyName = function(keyCode) {
	var c = keyCode;
	switch(c) {
	case 0:
		return "MouseLeft";
	case 1:
		return "MouseRight";
	case 2:
		return "MouseMiddle";
	case 3:
		return "Mouse3";
	case 4:
		return "Mouse4";
	case 8:
		return "Backspace";
	case 9:
		return "Tab";
	case 13:
		return "Enter";
	case 16:
		return "Shift";
	case 17:
		return "Ctrl";
	case 18:
		return "Alt";
	case 19:
		return "PauseBreak";
	case 20:
		return "CapsLock";
	case 27:
		return "Escape";
	case 32:
		return "Space";
	case 33:
		return "PageUp";
	case 34:
		return "PageDown";
	case 35:
		return "End";
	case 36:
		return "Home";
	case 37:
		return "Left";
	case 38:
		return "Up";
	case 39:
		return "Right";
	case 40:
		return "Down";
	case 45:
		return "Insert";
	case 46:
		return "Delete";
	case 91:
		return "LeftWindowKey";
	case 92:
		return "RightWindowKey";
	case 93:
		return "ContextMenu";
	case 106:
		return "NumPad*";
	case 107:
		return "NumPad+";
	case 108:
		return "NumPadEnter";
	case 109:
		return "NumPad-";
	case 110:
		return "NumPad.";
	case 111:
		return "NumPad/";
	case 144:
		return "NumLock";
	case 145:
		return "ScrollLock";
	case 186:
		return "Semicolon";
	case 187:
		return "Equals";
	case 188:
		return "Comma";
	case 189:
		return "Minus";
	case 190:
		return "Period";
	case 191:
		return "Slash";
	case 192:
		return "Tilde";
	case 219:
		return "BracketLeft";
	case 220:
		return "Backslash";
	case 221:
		return "BracketRight";
	case 222:
		return "Quote";
	case 226:
		return "IntlBackslash";
	case 272:
		return "LShift";
	case 273:
		return "LCtrl";
	case 274:
		return "LAlt";
	case 528:
		return "RShift";
	case 529:
		return "RCtrl";
	case 530:
		return "RAlt";
	default:
		if(c >= 48 && c <= 57) {
			return "" + (c - 48);
		} else if(c >= 96 && c <= 105) {
			return "NumPad" + (c - 96);
		} else if(c >= 65 && c <= 90) {
			return String.fromCodePoint((65 + c - 65));
		} else if(c >= 112 && c <= 135) {
			return "F" + (c - 112 + 1);
		} else {
			return null;
		}
	}
};
var hxd_Math = function() { };
$hxClasses["hxd.Math"] = hxd_Math;
hxd_Math.__name__ = "hxd.Math";
hxd_Math.get_POSITIVE_INFINITY = function() {
	return Infinity;
};
hxd_Math.get_NEGATIVE_INFINITY = function() {
	return -Infinity;
};
hxd_Math.get_NaN = function() {
	return NaN;
};
hxd_Math.isNaN = function(v) {
	return isNaN(v);
};
hxd_Math.fmt = function(v) {
	var neg;
	if(v < 0) {
		neg = -1.0;
		v = -v;
	} else {
		neg = 1.0;
	}
	if(isNaN(v) || !isFinite(v)) {
		return v;
	}
	var digits = 4 - Math.log(v) / Math.log(10) | 0;
	if(digits < 1) {
		digits = 1;
	} else if(digits >= 10) {
		return 0.;
	}
	var exp = Math.pow(10,digits);
	return Math.floor(v * exp + .49999) * neg / exp;
};
hxd_Math.floor = function(f) {
	return Math.floor(f);
};
hxd_Math.ceil = function(f) {
	return Math.ceil(f);
};
hxd_Math.round = function(f) {
	return Math.round(f);
};
hxd_Math.clamp = function(f,min,max) {
	if(max == null) {
		max = 1.;
	}
	if(min == null) {
		min = 0.;
	}
	if(f < min) {
		return min;
	} else if(f > max) {
		return max;
	} else {
		return f;
	}
};
hxd_Math.pow = function(v,p) {
	return Math.pow(v,p);
};
hxd_Math.cos = function(f) {
	return Math.cos(f);
};
hxd_Math.sin = function(f) {
	return Math.sin(f);
};
hxd_Math.tan = function(f) {
	return Math.tan(f);
};
hxd_Math.acos = function(f) {
	return Math.acos(f);
};
hxd_Math.asin = function(f) {
	return Math.asin(f);
};
hxd_Math.atan = function(f) {
	return Math.atan(f);
};
hxd_Math.sqrt = function(f) {
	return Math.sqrt(f);
};
hxd_Math.invSqrt = function(f) {
	return 1. / Math.sqrt(f);
};
hxd_Math.atan2 = function(dy,dx) {
	return Math.atan2(dy,dx);
};
hxd_Math.abs = function(f) {
	if(f < 0) {
		return -f;
	} else {
		return f;
	}
};
hxd_Math.max = function(a,b) {
	if(a < b) {
		return b;
	} else {
		return a;
	}
};
hxd_Math.min = function(a,b) {
	if(a > b) {
		return b;
	} else {
		return a;
	}
};
hxd_Math.iabs = function(i) {
	if(i < 0) {
		return -i;
	} else {
		return i;
	}
};
hxd_Math.imax = function(a,b) {
	if(a < b) {
		return b;
	} else {
		return a;
	}
};
hxd_Math.imin = function(a,b) {
	if(a > b) {
		return b;
	} else {
		return a;
	}
};
hxd_Math.iclamp = function(v,min,max) {
	if(v < min) {
		return min;
	} else if(v > max) {
		return max;
	} else {
		return v;
	}
};
hxd_Math.lerp = function(a,b,k) {
	return a + k * (b - a);
};
hxd_Math.inverseLerp = function(a,b,val) {
	return (val - a) / (b - a);
};
hxd_Math.ease = function(a,b,k,easing) {
	var p = Math.pow(k,1 + easing);
	return a + p / (p + Math.pow(1 - k,easing + 1)) * (b - a);
};
hxd_Math.easeFactor = function(k,easing) {
	var p = Math.pow(k,1 + easing);
	return p / (p + Math.pow(1 - k,easing + 1));
};
hxd_Math.lerpTime = function(a,b,k,dt) {
	return a + (1 - Math.pow(1 - k,dt * hxd_Timer.wantedFPS)) * (b - a);
};
hxd_Math.bitCount = function(v) {
	v -= v >> 1 & 1431655765;
	v = (v & 858993459) + (v >> 2 & 858993459);
	return (v + (v >> 4) & 252645135) * 16843009 >> 24;
};
hxd_Math.isPOT = function(v) {
	return (v & v - 1) == 0;
};
hxd_Math.nextPOT = function(v) {
	--v;
	v |= v >> 1;
	v |= v >> 2;
	v |= v >> 4;
	v |= v >> 8;
	v |= v >> 16;
	return ++v;
};
hxd_Math.distanceSq = function(dx,dy,dz) {
	if(dz == null) {
		dz = 0.;
	}
	return dx * dx + dy * dy + dz * dz;
};
hxd_Math.distance = function(dx,dy,dz) {
	if(dz == null) {
		dz = 0.;
	}
	var dz1 = dz;
	if(dz1 == null) {
		dz1 = 0.;
	}
	return Math.sqrt(dx * dx + dy * dy + dz1 * dz1);
};
hxd_Math.colorLerp = function(c1,c2,k) {
	var a1 = c1 >>> 24;
	var r1 = c1 >> 16 & 255;
	var g1 = c1 >> 8 & 255;
	var b1 = c1 & 255;
	var a2 = c2 >>> 24;
	var r2 = c2 >> 16 & 255;
	var g2 = c2 >> 8 & 255;
	var b2 = c2 & 255;
	var a = a1 * (1 - k) + a2 * k | 0;
	var r = r1 * (1 - k) + r2 * k | 0;
	var g = g1 * (1 - k) + g2 * k | 0;
	var b = b1 * (1 - k) + b2 * k | 0;
	return a << 24 | r << 16 | g << 8 | b;
};
hxd_Math.angle = function(da) {
	da %= 6.2831853071795862;
	if(da > 3.14159265358979323) {
		da -= 6.2831853071795862;
	} else if(da <= -3.1415926535897931) {
		da += 6.2831853071795862;
	}
	return da;
};
hxd_Math.angleLerp = function(a,b,k) {
	var da = b - a;
	da %= 6.2831853071795862;
	if(da > 3.14159265358979323) {
		da -= 6.2831853071795862;
	} else if(da <= -3.1415926535897931) {
		da += 6.2831853071795862;
	}
	return a + da * k;
};
hxd_Math.angleMove = function(a,b,max) {
	var da = b - a;
	da %= 6.2831853071795862;
	if(da > 3.14159265358979323) {
		da -= 6.2831853071795862;
	} else if(da <= -3.1415926535897931) {
		da += 6.2831853071795862;
	}
	var da1 = da;
	if(da1 > -max && da1 < max) {
		return b;
	} else {
		return a + (da1 < 0 ? -max : max);
	}
};
hxd_Math.valueMove = function(v,target,max) {
	if(v < target) {
		v += max;
		if(v > target) {
			v = target;
		}
	} else if(v > target) {
		v -= max;
		if(v < target) {
			v = target;
		}
	}
	return v;
};
hxd_Math.shuffle = function(a) {
	var len = a.length;
	var _g = 0;
	var _g1 = len;
	while(_g < _g1) {
		var i = _g++;
		var x = Std.random(len);
		var y = Std.random(len);
		var tmp = a[x];
		a[x] = a[y];
		a[y] = tmp;
	}
};
hxd_Math.random = function(max) {
	if(max == null) {
		max = 1.0;
	}
	return Math.random() * max;
};
hxd_Math.srand = function(max) {
	if(max == null) {
		max = 1.0;
	}
	return (Math.random() - 0.5) * (max * 2);
};
hxd_Math.b2f = function(v) {
	return (v & 255) * 0.0039215686274509803921568627451;
};
hxd_Math.f2b = function(v) {
	return (v < 0. ? 0. : v > 1. ? 1. : v) * 255.0 | 0;
};
hxd_Math.umod = function(value,modulo) {
	var r = value % modulo;
	if(r >= 0) {
		return r;
	} else {
		return r + modulo;
	}
};
hxd_Math.ufmod = function(value,modulo) {
	var r = value % modulo;
	if(r >= 0) {
		return r;
	} else {
		return r + modulo;
	}
};
hxd_Math.degToRad = function(deg) {
	return deg * 3.14159265358979323 / 180.0;
};
hxd_Math.radToDeg = function(rad) {
	return rad * 180.0 / 3.14159265358979323;
};
var hxd_Flags = $hxEnums["hxd.Flags"] = { __ename__:true,__constructs__:null
	,ReadOnly: {_hx_name:"ReadOnly",_hx_index:0,__enum__:"hxd.Flags",toString:$estr}
	,AlphaPremultiplied: {_hx_name:"AlphaPremultiplied",_hx_index:1,__enum__:"hxd.Flags",toString:$estr}
};
hxd_Flags.__constructs__ = [hxd_Flags.ReadOnly,hxd_Flags.AlphaPremultiplied];
hxd_Flags.__empty_constructs__ = [hxd_Flags.ReadOnly,hxd_Flags.AlphaPremultiplied];
var hxd_PixelsARGB = {};
hxd_PixelsARGB.getPixel = function(this1,x,y) {
	var v = this1.bytes.getInt32((x + y * this1.width << 2) + this1.offset);
	return v >>> 24 | v >> 8 & 65280 | v << 8 & 16711680 | v << 24;
};
hxd_PixelsARGB.setPixel = function(this1,x,y,v) {
	this1.bytes.setInt32((x + y * this1.width << 2) + this1.offset,v >>> 24 | v >> 8 & 65280 | v << 8 & 16711680 | v << 24);
};
hxd_PixelsARGB.fromPixels = function(p) {
	p.convert(hxd_PixelFormat.ARGB);
	return p;
};
var hxd_PixelsFloat = {};
hxd_PixelsFloat.getPixelF = function(this1,x,y,v) {
	if(v == null) {
		v = new h3d_Vector4Impl(0.,0.,0.,1.);
	}
	var pix = (x + y * this1.width << 2) + this1.offset;
	v.x = this1.bytes.getFloat(pix);
	return v;
};
hxd_PixelsFloat.setPixelF = function(this1,x,y,v) {
	var pix = (x + y * this1.width << 2) + this1.offset;
	this1.bytes.setFloat(pix,v.x);
};
hxd_PixelsFloat.fromPixels = function(p) {
	p.convert(hxd_PixelFormat.R32F);
	return p;
};
var hxd_PixelsFloatRGBA = {};
hxd_PixelsFloatRGBA.getPixelF = function(this1,x,y,v) {
	if(v == null) {
		v = new h3d_Vector4Impl(0.,0.,0.,1.);
	}
	var pix = (x + y * this1.width << 4) + this1.offset;
	v.x = this1.bytes.getFloat(pix);
	v.y = this1.bytes.getFloat(pix + 4);
	v.z = this1.bytes.getFloat(pix + 8);
	v.w = this1.bytes.getFloat(pix + 12);
	return v;
};
hxd_PixelsFloatRGBA.setPixelF = function(this1,x,y,v) {
	var pix = (x + y * this1.width << 4) + this1.offset;
	this1.bytes.setFloat(pix,v.x);
	this1.bytes.setFloat(pix + 4,v.y);
	this1.bytes.setFloat(pix + 8,v.z);
	this1.bytes.setFloat(pix + 12,v.w);
};
hxd_PixelsFloatRGBA.fromPixels = function(p) {
	p.convert(hxd_PixelFormat.RGBA32F);
	return p;
};
var hxd_Channel = {};
hxd_Channel.toInt = function(this1) {
	return this1;
};
hxd_Channel.fromInt = function(v) {
	return v;
};
var hxd_Pixels = function(width,height,bytes,format,offset) {
	if(offset == null) {
		offset = 0;
	}
	this.width = width;
	this.height = height;
	this.bytes = bytes;
	this.set_innerFormat(format);
	this.offset = offset;
	var i = 0;
	if(i == null) {
		i = 0;
	}
	this.flags = i;
};
$hxClasses["hxd.Pixels"] = hxd_Pixels;
hxd_Pixels.__name__ = "hxd.Pixels";
hxd_Pixels.switchEndian = function(v) {
	return v >>> 24 | v >> 8 & 65280 | v << 8 & 16711680 | v << 24;
};
hxd_Pixels.switchBR = function(v) {
	return v & -16711936 | v << 16 & 16711680 | v >> 16 & 255;
};
hxd_Pixels.calcDataSize = function(width,height,format) {
	if(format._hx_index == 22) {
		var _g = format.v;
		return (height + 3 >> 2 << 2) * hxd_Pixels.calcStride(width,format);
	} else {
		return height * hxd_Pixels.calcStride(width,format);
	}
};
hxd_Pixels.calcStride = function(width,format) {
	var tmp;
	switch(format._hx_index) {
	case 3:case 21:
		tmp = 8;
		break;
	case 4:
		tmp = 16;
		break;
	case 5:
		tmp = 1;
		break;
	case 6:case 18:
		tmp = 2;
		break;
	case 7:
		tmp = 4;
		break;
	case 8:
		tmp = 2;
		break;
	case 9:case 19:
		tmp = 4;
		break;
	case 10:
		tmp = 8;
		break;
	case 11:
		tmp = 3;
		break;
	case 12:case 20:
		tmp = 6;
		break;
	case 13:
		tmp = 12;
		break;
	case 0:case 1:case 2:case 14:case 15:
		tmp = 4;
		break;
	case 16:
		tmp = 4;
		break;
	case 17:
		tmp = 4;
		break;
	case 22:
		var n = format.v;
		var blocks = width + 3 >> 2;
		if(n == 1 || n == 4) {
			return blocks << 1;
		}
		return blocks << 2;
	case 23:
		tmp = 2;
		break;
	case 24:
		tmp = 3;
		break;
	case 25:case 26:
		tmp = 4;
		break;
	}
	return width * tmp;
};
hxd_Pixels.isFloatFormat = function(format) {
	switch(format._hx_index) {
	case 3:case 6:case 9:case 12:
		return true;
	case 4:case 7:case 10:case 13:
		return true;
	case 22:
		if(format.v == 6) {
			return true;
		} else {
			return false;
		}
		break;
	default:
		return false;
	}
};
hxd_Pixels.getChannelOffset = function(format,channel) {
	switch(format._hx_index) {
	case 0:
		return [1,2,3,0][channel];
	case 1:
		return [2,1,0,3][channel];
	case 4:
		return channel * 4;
	case 8:case 9:case 10:case 19:
		var p = hxd_Pixels.calcStride(1,format);
		return [0,p,-1,-1][channel];
	case 2:case 14:case 15:
		return channel;
	case 16:case 17:
		throw haxe_Exception.thrown("Bit packed format");
	case 5:case 6:case 7:case 18:
		if(channel == 0) {
			return 0;
		} else {
			return -1;
		}
		break;
	case 11:case 12:case 13:case 20:
		var p = hxd_Pixels.calcStride(1,format);
		return [0,p,p << 1,-1][channel];
	case 3:case 21:
		return channel * 2;
	case 22:
		var _g = format.v;
		throw haxe_Exception.thrown("Not supported");
	case 23:case 24:case 25:case 26:
		throw haxe_Exception.thrown("Not supported");
	}
};
hxd_Pixels.alloc = function(width,height,format) {
	return new hxd_Pixels(width,height,new haxe_io_Bytes(new ArrayBuffer(hxd_Pixels.calcDataSize(width,height,format))),format);
};
hxd_Pixels.toDDSLayers = function(pixels,isCubeMap) {
	if(isCubeMap == null) {
		isCubeMap = false;
	}
	if(pixels.length == 0) {
		throw haxe_Exception.thrown("Must contain at least one image");
	}
	var ref = pixels[0];
	var fmt = ref.innerFormat;
	var levels = [];
	var outSize = 0;
	var _g = 0;
	while(_g < pixels.length) {
		var p = pixels[_g];
		++_g;
		if(!Type.enumEq(p.innerFormat,fmt)) {
			throw haxe_Exception.thrown("All images must be of the same pixel format");
		}
		outSize += p.dataSize;
		var found = false;
		var _g1 = 0;
		while(_g1 < levels.length) {
			var sz = levels[_g1];
			++_g1;
			if(sz[0].width == p.width && sz[0].height == p.height) {
				sz.push(p);
				found = true;
				break;
			}
		}
		if(!found) {
			levels.push([p]);
		}
	}
	levels.sort(function(a1,a2) {
		return a2[0].width * a2[0].height - a1[0].width * a1[0].height;
	});
	var layerCount = levels[0].length;
	var width = levels[0][0].width;
	var height = levels[0][0].height;
	var _g = 1;
	var _g1 = levels.length;
	while(_g < _g1) {
		var i = _g++;
		var level = levels[i];
		if(level.length != layerCount) {
			throw haxe_Exception.thrown("Invalid number of mipmaps at level " + i + ": " + level.length + " should be " + layerCount);
		}
		var w = width >> i;
		if(w == 0) {
			w = 1;
		}
		var h = height >> i;
		if(h == 0) {
			h = 1;
		}
		var lw = level[0].width;
		var lh = level[0].height;
		if(lw != w || lh != h) {
			throw haxe_Exception.thrown("Invalid mip level size " + i + ": " + lw + "x" + lh + " should be " + w + "x" + h);
		}
	}
	outSize += 128;
	var dx10h = layerCount > 1 && !isCubeMap;
	if(dx10h) {
		outSize += 20;
	}
	var ddsOut = new haxe_io_Bytes(new ArrayBuffer(outSize));
	var outPos = 0;
	ddsOut.setInt32(outPos,542327876);
	outPos += 4;
	ddsOut.setInt32(outPos,124);
	outPos += 4;
	ddsOut.setInt32(outPos,135183);
	outPos += 4;
	ddsOut.setInt32(outPos,height);
	outPos += 4;
	ddsOut.setInt32(outPos,width);
	outPos += 4;
	ddsOut.setInt32(outPos,ref.stride);
	outPos += 4;
	ddsOut.setInt32(outPos,1);
	outPos += 4;
	ddsOut.setInt32(outPos,levels.length);
	outPos += 4;
	ddsOut.setInt32(outPos,0);
	outPos += 4;
	ddsOut.setInt32(outPos,0);
	outPos += 4;
	ddsOut.setInt32(outPos,0);
	outPos += 4;
	ddsOut.setInt32(outPos,0);
	outPos += 4;
	ddsOut.setInt32(outPos,0);
	outPos += 4;
	ddsOut.setInt32(outPos,0);
	outPos += 4;
	ddsOut.setInt32(outPos,0);
	outPos += 4;
	ddsOut.setInt32(outPos,0);
	outPos += 4;
	ddsOut.setInt32(outPos,0);
	outPos += 4;
	ddsOut.setInt32(outPos,0);
	outPos += 4;
	ddsOut.setInt32(outPos,0);
	outPos += 4;
	ddsOut.setInt32(outPos,32);
	outPos += 4;
	if(dx10h) {
		ddsOut.setInt32(outPos,4);
		outPos += 4;
		ddsOut.setInt32(outPos,808540228);
		outPos += 4;
		ddsOut.setInt32(outPos,0);
		outPos += 4;
		ddsOut.setInt32(outPos,0);
		outPos += 4;
		ddsOut.setInt32(outPos,0);
		outPos += 4;
		ddsOut.setInt32(outPos,0);
		outPos += 4;
		ddsOut.setInt32(outPos,0);
		outPos += 4;
	} else {
		switch(fmt._hx_index) {
		case 0:case 1:case 2:
			ddsOut.setInt32(outPos,65);
			outPos += 4;
			ddsOut.setInt32(outPos,0);
			outPos += 4;
			ddsOut.setInt32(outPos,32);
			outPos += 4;
			var byte = hxd_Pixels.getChannelOffset(fmt,0);
			ddsOut.setInt32(outPos,255 << byte * 8);
			outPos += 4;
			var byte = hxd_Pixels.getChannelOffset(fmt,1);
			ddsOut.setInt32(outPos,255 << byte * 8);
			outPos += 4;
			var byte = hxd_Pixels.getChannelOffset(fmt,2);
			ddsOut.setInt32(outPos,255 << byte * 8);
			outPos += 4;
			var byte = hxd_Pixels.getChannelOffset(fmt,3);
			ddsOut.setInt32(outPos,255 << byte * 8);
			outPos += 4;
			break;
		default:
			ddsOut.setInt32(outPos,4);
			outPos += 4;
			var v;
			switch(fmt._hx_index) {
			case 3:
				v = 113;
				break;
			case 4:
				v = 116;
				break;
			case 6:
				v = 111;
				break;
			case 7:
				v = 114;
				break;
			case 9:
				v = 112;
				break;
			case 10:
				v = 115;
				break;
			default:
				throw haxe_Exception.thrown("Unsupported format " + Std.string(fmt));
			}
			ddsOut.setInt32(outPos,v);
			outPos += 4;
			ddsOut.setInt32(outPos,0);
			outPos += 4;
			ddsOut.setInt32(outPos,0);
			outPos += 4;
			ddsOut.setInt32(outPos,0);
			outPos += 4;
			ddsOut.setInt32(outPos,0);
			outPos += 4;
			ddsOut.setInt32(outPos,0);
			outPos += 4;
		}
	}
	ddsOut.setInt32(outPos,dx10h ? 4096 : (pixels.length == 1 ? 0 : 8) | 4096 | (levels.length == 1 ? 0 : 4194304));
	outPos += 4;
	var cubebits = 1536 | (layerCount > 1 ? 2048 : 0) | (layerCount > 2 ? 4096 : 0) | (layerCount > 3 ? 8192 : 0) | (layerCount > 4 ? 16384 : 0) | (layerCount > 5 ? 32768 : 0);
	ddsOut.setInt32(outPos,isCubeMap ? cubebits : 0);
	outPos += 4;
	ddsOut.setInt32(outPos,0);
	outPos += 4;
	ddsOut.setInt32(outPos,0);
	outPos += 4;
	ddsOut.setInt32(outPos,0);
	outPos += 4;
	if(dx10h) {
		switch(fmt._hx_index) {
		case 2:
			ddsOut.setInt32(outPos,28);
			outPos += 4;
			break;
		case 22:
			var n = fmt.v;
			var v;
			switch(n) {
			case 1:
				v = 71;
				break;
			case 2:
				v = 74;
				break;
			case 3:
				v = 77;
				break;
			case 7:
				v = 98;
				break;
			default:
				throw haxe_Exception.thrown("Unnsupported format " + Std.string(fmt));
			}
			ddsOut.setInt32(outPos,v);
			outPos += 4;
			break;
		default:
			throw haxe_Exception.thrown("Unsupported DXT10 format " + Std.string(fmt));
		}
		ddsOut.setInt32(outPos,3);
		outPos += 4;
		ddsOut.setInt32(outPos,0);
		outPos += 4;
		ddsOut.setInt32(outPos,layerCount);
		outPos += 4;
		ddsOut.setInt32(outPos,0);
		outPos += 4;
	}
	var _g = 0;
	var _g1 = layerCount;
	while(_g < _g1) {
		var i = _g++;
		var _g2 = 0;
		var _g3 = levels.length;
		while(_g2 < _g3) {
			var l = _g2++;
			var p = levels[l][i];
			ddsOut.blit(outPos,p.bytes,p.offset,p.dataSize);
			outPos += p.dataSize;
		}
	}
	return ddsOut;
};
hxd_Pixels.prototype = {
	get_format: function() {
		return this.innerFormat;
	}
	,set_innerFormat: function(fmt) {
		this.innerFormat = fmt;
		this.stride = hxd_Pixels.calcStride(this.width,fmt);
		this.dataSize = hxd_Pixels.calcDataSize(this.width,this.height,fmt);
		this.bytesPerPixel = hxd_Pixels.calcStride(1,fmt);
		return fmt;
	}
	,invalidFormat: function() {
		throw haxe_Exception.thrown("Unsupported format for this operation : " + Std.string(this.innerFormat));
	}
	,sub: function(x,y,width,height) {
		if(x < 0 || y < 0 || x + width > this.width || y + height > this.height) {
			throw haxe_Exception.thrown("Pixels.sub() outside bounds");
		}
		var out = new haxe_io_Bytes(new ArrayBuffer(height * this.stride));
		var stride = hxd_Pixels.calcStride(width,this.innerFormat);
		var outP = 0;
		var _g = 0;
		var _g1 = height;
		while(_g < _g1) {
			var dy = _g++;
			var p = (x + (y + dy) * this.width) * this.bytesPerPixel + this.offset;
			out.blit(outP,this.bytes,p,stride);
			outP += stride;
		}
		return new hxd_Pixels(width,height,out,this.innerFormat);
	}
	,blit: function(x,y,src,srcX,srcY,width,height) {
		if(x < 0 || y < 0 || x + width > this.width || y + height > this.height) {
			throw haxe_Exception.thrown("Pixels.blit() outside bounds");
		}
		if(srcX < 0 || srcX < 0 || srcX + width > src.width || srcY + height > src.height) {
			throw haxe_Exception.thrown("Pixels.blit() outside src bounds");
		}
		if((this.flags & 1 << hxd_Flags.ReadOnly._hx_index) != 0) {
			this.copyInner();
		}
		src.convert(this.innerFormat);
		var bpp = this.bytesPerPixel;
		if(bpp == 0) {
			throw haxe_Exception.thrown("assert");
		}
		var stride = hxd_Pixels.calcStride(width,this.innerFormat);
		var _g = 0;
		var _g1 = height;
		while(_g < _g1) {
			var dy = _g++;
			var srcP = (srcX + (dy + srcY) * src.width) * bpp + src.offset;
			var dstP = (x + (dy + y) * this.width) * bpp + this.offset;
			this.bytes.blit(dstP,src.bytes,srcP,stride);
		}
	}
	,clear: function(color,preserveMask) {
		if(preserveMask == null) {
			preserveMask = 0;
		}
		var mask = preserveMask;
		if((this.flags & 1 << hxd_Flags.ReadOnly._hx_index) != 0) {
			this.copyInner();
		}
		if((color & 255) == (color >> 8 & 255) && (color & 65535) == color >>> 16 && mask == 0) {
			this.bytes.fill(this.offset,this.width * this.height * this.bytesPerPixel,color & 255);
			return;
		}
		switch(this.innerFormat._hx_index) {
		case 0:
			color = color >>> 24 | color >> 8 & 65280 | color << 8 & 16711680 | color << 24;
			mask = mask >>> 24 | mask >> 8 & 65280 | mask << 8 & 16711680 | mask << 24;
			break;
		case 1:
			break;
		case 2:
			color = color & -16711936 | color << 16 & 16711680 | color >> 16 & 255;
			mask = mask & -16711936 | mask << 16 & 16711680 | mask >> 16 & 255;
			break;
		default:
			this.invalidFormat();
		}
		var p = this.offset;
		if(mask == 0) {
			var _g = 0;
			var _g1 = this.width * this.height;
			while(_g < _g1) {
				var i = _g++;
				this.bytes.setInt32(p,color);
				p += 4;
			}
		} else {
			var _g = 0;
			var _g1 = this.width * this.height;
			while(_g < _g1) {
				var i = _g++;
				this.bytes.setInt32(p,color | this.bytes.getInt32(p) & mask);
				p += 4;
			}
		}
	}
	,toVector: function() {
		var vec = new Array(this.width * this.height);
		var idx = 0;
		var p = this.offset;
		var dl = 0;
		switch(this.innerFormat._hx_index) {
		case 0:
			var _g = 0;
			var _g1 = this.height;
			while(_g < _g1) {
				var y = _g++;
				var _g2 = 0;
				var _g3 = this.width;
				while(_g2 < _g3) {
					var x = _g2++;
					var v = this.bytes.getInt32(p);
					vec[idx++] = v >>> 24 | v >> 8 & 65280 | v << 8 & 16711680 | v << 24;
					p += 4;
				}
				p += dl;
			}
			break;
		case 1:
			var _g = 0;
			var _g1 = this.height;
			while(_g < _g1) {
				var y = _g++;
				var _g2 = 0;
				var _g3 = this.width;
				while(_g2 < _g3) {
					var x = _g2++;
					vec[idx++] = this.bytes.getInt32(p);
					p += 4;
				}
				p += dl;
			}
			break;
		case 2:
			var _g = 0;
			var _g1 = this.height;
			while(_g < _g1) {
				var y = _g++;
				var _g2 = 0;
				var _g3 = this.width;
				while(_g2 < _g3) {
					var x = _g2++;
					var v = this.bytes.getInt32(p);
					vec[idx++] = v & -16711936 | v << 16 & 16711680 | v >> 16 & 255;
					p += 4;
				}
				p += dl;
			}
			break;
		default:
			this.invalidFormat();
		}
		return vec;
	}
	,makeSquare: function(copy) {
		var w = this.width;
		var h = this.height;
		var tw = w == 0 ? 0 : 1;
		var th = h == 0 ? 0 : 1;
		while(tw < w) tw <<= 1;
		while(th < h) th <<= 1;
		if(w == tw && h == th) {
			return this;
		}
		var bpp = this.bytesPerPixel;
		var out = new haxe_io_Bytes(new ArrayBuffer(tw * th * bpp));
		var p = 0;
		var b = this.offset;
		var _g = 0;
		var _g1 = h;
		while(_g < _g1) {
			var y = _g++;
			out.blit(p,this.bytes,b,w * bpp);
			p += w * bpp;
			b += w * bpp;
			var _g2 = 0;
			var _g3 = (tw - w) * bpp >> 2;
			while(_g2 < _g3) {
				var i = _g2++;
				out.setInt32(p,0);
				p += 4;
			}
		}
		var _g = 0;
		var _g1 = (th - h) * tw * bpp >> 2;
		while(_g < _g1) {
			var i = _g++;
			out.setInt32(p,0);
			p += 4;
		}
		if(copy) {
			return new hxd_Pixels(tw,th,out,this.innerFormat);
		}
		this.bytes = out;
		this.width = tw;
		this.height = th;
		return this;
	}
	,copyInner: function() {
		var old = this.bytes;
		this.bytes = new haxe_io_Bytes(new ArrayBuffer(this.dataSize));
		this.bytes.blit(0,old,this.offset,this.dataSize);
		this.offset = 0;
		this.flags &= -1 - (1 << hxd_Flags.ReadOnly._hx_index);
	}
	,willChange: function() {
		if((this.flags & 1 << hxd_Flags.ReadOnly._hx_index) != 0) {
			this.copyInner();
		}
	}
	,flipY: function() {
		if((this.flags & 1 << hxd_Flags.ReadOnly._hx_index) != 0) {
			this.copyInner();
		}
		if(this.stride % 4 != 0) {
			this.invalidFormat();
		}
		var _g = 0;
		var _g1 = this.height >> 1;
		while(_g < _g1) {
			var y = _g++;
			var p1 = y * this.stride + this.offset;
			var p2 = (this.height - 1 - y) * this.stride + this.offset;
			var _g2 = 0;
			var _g3 = this.stride >> 2;
			while(_g2 < _g3) {
				var x = _g2++;
				var a = this.bytes.getInt32(p1);
				var b = this.bytes.getInt32(p2);
				this.bytes.setInt32(p1,b);
				this.bytes.setInt32(p2,a);
				p1 += 4;
				p2 += 4;
			}
		}
	}
	,convert: function(target) {
		if(this.innerFormat == target || Type.enumEq(this.innerFormat,target)) {
			return;
		}
		if((this.flags & 1 << hxd_Flags.ReadOnly._hx_index) != 0) {
			this.copyInner();
		}
		var bytes = this.bytes.b;
		var _g = this.innerFormat;
		switch(_g._hx_index) {
		case 0:
			switch(target._hx_index) {
			case 1:
				var _g1 = 0;
				var _g2 = this.width * this.height;
				while(_g1 < _g2) {
					var i = _g1++;
					var p = (i << 2) + this.offset;
					var a = bytes[p];
					var r = bytes[p + 1];
					var g = bytes[p + 2];
					var b = bytes[p + 3];
					bytes[p++] = b;
					bytes[p++] = g;
					bytes[p++] = r;
					bytes[p] = a;
				}
				break;
			case 2:
				var _g1 = 0;
				var _g2 = this.width * this.height;
				while(_g1 < _g2) {
					var i = _g1++;
					var p = (i << 2) + this.offset;
					var a = bytes[p];
					var v = bytes[p + 1];
					bytes[p] = v;
					var v1 = bytes[p + 2];
					bytes[p + 1] = v1;
					var v2 = bytes[p + 3];
					bytes[p + 2] = v2;
					bytes[p + 3] = a;
				}
				break;
			default:
				throw haxe_Exception.thrown("Cannot convert from " + Std.string(this.innerFormat) + " to " + Std.string(target));
			}
			break;
		case 1:
			switch(target._hx_index) {
			case 0:
				var _g1 = 0;
				var _g2 = this.width * this.height;
				while(_g1 < _g2) {
					var i = _g1++;
					var p = (i << 2) + this.offset;
					var a = bytes[p];
					var r = bytes[p + 1];
					var g = bytes[p + 2];
					var b = bytes[p + 3];
					bytes[p++] = b;
					bytes[p++] = g;
					bytes[p++] = r;
					bytes[p] = a;
				}
				break;
			case 2:
				var _g1 = 0;
				var _g2 = this.width * this.height;
				while(_g1 < _g2) {
					var i = _g1++;
					var p = (i << 2) + this.offset;
					var b = bytes[p];
					var r = bytes[p + 2];
					bytes[p] = r;
					bytes[p + 2] = b;
				}
				break;
			default:
				throw haxe_Exception.thrown("Cannot convert from " + Std.string(this.innerFormat) + " to " + Std.string(target));
			}
			break;
		case 2:
			switch(target._hx_index) {
			case 0:
				var _g1 = 0;
				var _g2 = this.width * this.height;
				while(_g1 < _g2) {
					var i = _g1++;
					var p = (i << 2) + this.offset;
					var a = bytes[p + 3];
					var v = bytes[p + 2];
					bytes[p + 3] = v;
					var v1 = bytes[p + 1];
					bytes[p + 2] = v1;
					var v2 = bytes[p];
					bytes[p + 1] = v2;
					bytes[p] = a;
				}
				break;
			case 1:
				var _g1 = 0;
				var _g2 = this.width * this.height;
				while(_g1 < _g2) {
					var i = _g1++;
					var p = (i << 2) + this.offset;
					var b = bytes[p];
					var r = bytes[p + 2];
					bytes[p] = r;
					bytes[p + 2] = b;
				}
				break;
			case 5:
				var nbytes = new haxe_io_Bytes(new ArrayBuffer(this.width * this.height));
				var out = nbytes.b;
				var _g1 = 0;
				var _g2 = this.width * this.height;
				while(_g1 < _g2) {
					var i = _g1++;
					var v = bytes[i << 2];
					out[i] = v;
				}
				this.bytes = nbytes;
				break;
			default:
				throw haxe_Exception.thrown("Cannot convert from " + Std.string(this.innerFormat) + " to " + Std.string(target));
			}
			break;
		case 4:
			if(target._hx_index == 7) {
				var nbytes = new haxe_io_Bytes(new ArrayBuffer(this.height * this.width * 4));
				var out = nbytes.b;
				var _g1 = 0;
				var _g2 = this.width * this.height;
				while(_g1 < _g2) {
					var i = _g1++;
					nbytes.setFloat(i << 2,this.bytes.getFloat(i << 4));
				}
				this.bytes = nbytes;
			} else {
				throw haxe_Exception.thrown("Cannot convert from " + Std.string(this.innerFormat) + " to " + Std.string(target));
			}
			break;
		case 7:
			switch(target._hx_index) {
			case 1:case 2:
				var fbytes = this.bytes;
				var p = 0;
				var _g1 = 0;
				var _g2 = this.width * this.height;
				while(_g1 < _g2) {
					var i = _g1++;
					var v = fbytes.getFloat(p) * 255 | 0;
					if(v < 0) {
						v = 0;
					} else if(v > 255) {
						v = 255;
					}
					bytes[p++] = v;
					bytes[p++] = v;
					bytes[p++] = v;
					bytes[p++] = 255;
				}
				break;
			default:
				throw haxe_Exception.thrown("Cannot convert from " + Std.string(this.innerFormat) + " to " + Std.string(target));
			}
			break;
		case 18:
			if(target._hx_index == 7) {
				var nbytes = new haxe_io_Bytes(new ArrayBuffer(this.width * this.height * 4));
				var fbytes = this.bytes;
				var _g1 = 0;
				var _g2 = this.width * this.height;
				while(_g1 < _g2) {
					var i = _g1++;
					var nv = fbytes.getUInt16(i << 1);
					nbytes.setFloat(i << 2,nv / 65535.0);
				}
				this.bytes = nbytes;
			} else {
				throw haxe_Exception.thrown("Cannot convert from " + Std.string(this.innerFormat) + " to " + Std.string(target));
			}
			break;
		case 22:
			if(target._hx_index == 22) {
				var b = target.v;
				var a = _g.v;
				if(a != b) {
					throw haxe_Exception.thrown("Cannot convert from " + Std.string(this.innerFormat) + " to " + Std.string(target));
				}
			} else {
				throw haxe_Exception.thrown("Cannot convert from " + Std.string(this.innerFormat) + " to " + Std.string(target));
			}
			break;
		default:
			throw haxe_Exception.thrown("Cannot convert from " + Std.string(this.innerFormat) + " to " + Std.string(target));
		}
		this.set_innerFormat(target);
	}
	,getPixel: function(x,y) {
		var p = (x + y * this.width) * this.bytesPerPixel + this.offset;
		switch(this.innerFormat._hx_index) {
		case 0:
			var v = this.bytes.getInt32(p);
			return v >>> 24 | v >> 8 & 65280 | v << 8 & 16711680 | v << 24;
		case 1:
			return this.bytes.getInt32(p);
		case 2:
			var v = this.bytes.getInt32(p);
			return v & -16711936 | v << 16 & 16711680 | v >> 16 & 255;
		case 5:
			return this.bytes.b[p];
		case 8:
			var b = this.bytes.getUInt16(p);
			return (b & 255) << 8 | b >> 8;
		default:
			this.invalidFormat();
			return 0;
		}
	}
	,setPixel: function(x,y,color) {
		var p = (x + y * this.width) * this.bytesPerPixel + this.offset;
		if((this.flags & 1 << hxd_Flags.ReadOnly._hx_index) != 0) {
			this.copyInner();
		}
		switch(this.innerFormat._hx_index) {
		case 0:
			this.bytes.setInt32(p,color >>> 24 | color >> 8 & 65280 | color << 8 & 16711680 | color << 24);
			break;
		case 1:
			this.bytes.setInt32(p,color);
			break;
		case 2:
			this.bytes.setInt32(p,color & -16711936 | color << 16 & 16711680 | color >> 16 & 255);
			break;
		case 5:
			this.bytes.b[p] = color;
			break;
		case 8:
			this.bytes.setUInt16(p,(color & 255) << 8 | (color & 65280) >> 8);
			break;
		default:
			this.invalidFormat();
		}
	}
	,getPixelF: function(x,y,v) {
		if(v == null) {
			v = new h3d_Vector4Impl(0.,0.,0.,1.);
		}
		var p = (x + y * this.width) * this.bytesPerPixel + this.offset;
		switch(this.innerFormat._hx_index) {
		case 4:
			var _this = v;
			var x1 = this.bytes.getFloat(p);
			var y1 = this.bytes.getFloat(p + 4);
			var z = this.bytes.getFloat(p + 8);
			var w = this.bytes.getFloat(p + 12);
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			_this.x = x1;
			_this.y = y1;
			_this.z = z;
			_this.w = w;
			return v;
		case 7:
			var _this = v;
			var x1 = this.bytes.getFloat(p);
			var y1 = 0;
			var z = 0;
			var w = 0;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			_this.x = x1;
			_this.y = y1;
			_this.z = z;
			_this.w = w;
			return v;
		case 10:
			var _this = v;
			var x1 = this.bytes.getFloat(p);
			var y1 = this.bytes.getFloat(p + 4);
			var z = 0;
			var w = 0;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			_this.x = x1;
			_this.y = y1;
			_this.z = z;
			_this.w = w;
			return v;
		case 18:
			var _this = v;
			var x1 = this.bytes.getUInt16(p) / 65535.0;
			var y1 = 0;
			var z = 0;
			var w = 0;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			_this.x = x1;
			_this.y = y1;
			_this.z = z;
			_this.w = w;
			return v;
		default:
			var _this = v;
			var c = this.getPixel(x,y);
			_this.x = (c >> 16 & 255) / 255;
			_this.y = (c >> 8 & 255) / 255;
			_this.z = (c & 255) / 255;
			_this.w = (c >>> 24) / 255;
			return v;
		}
	}
	,setPixelF: function(x,y,v) {
		if((this.flags & 1 << hxd_Flags.ReadOnly._hx_index) != 0) {
			this.copyInner();
		}
		var p = (x + y * this.width) * this.bytesPerPixel + this.offset;
		switch(this.innerFormat._hx_index) {
		case 4:
			this.bytes.setFloat(p,v.x);
			this.bytes.setFloat(p + 4,v.y);
			this.bytes.setFloat(p + 8,v.z);
			this.bytes.setFloat(p + 12,v.w);
			break;
		case 7:
			this.bytes.setFloat(p,v.x);
			break;
		default:
			var _this = v;
			var f = _this.w;
			var f1 = _this.x;
			var f2 = _this.y;
			var f3 = _this.z;
			this.setPixel(x,y,((f < 0. ? 0. : f > 1. ? 1. : f) * 255 + 0.499 | 0) << 24 | ((f1 < 0. ? 0. : f1 > 1. ? 1. : f1) * 255 + 0.499 | 0) << 16 | ((f2 < 0. ? 0. : f2 > 1. ? 1. : f2) * 255 + 0.499 | 0) << 8 | ((f3 < 0. ? 0. : f3 > 1. ? 1. : f3) * 255 + 0.499 | 0));
		}
	}
	,dispose: function() {
		this.bytes = null;
	}
	,toString: function() {
		return "Pixels(" + this.width + "x" + this.height + " " + Std.string(this.innerFormat) + ")";
	}
	,toPNG: function(level) {
		if(level == null) {
			level = 9;
		}
		var png;
		if(this.offset != 0) {
			this.bytes = this.bytes.sub(this.offset,hxd_Pixels.calcDataSize(this.width,this.height,this.innerFormat));
			this.offset = 0;
		}
		switch(this.innerFormat._hx_index) {
		case 0:
			png = format_png_Tools.build32ARGB(this.width,this.height,this.bytes,level);
			break;
		case 5:
			png = format_png_Tools.buildGrey(this.width,this.height,this.bytes,level);
			break;
		default:
			this.convert(hxd_PixelFormat.BGRA);
			png = format_png_Tools.build32BGRA(this.width,this.height,this.bytes,level);
		}
		var o = new haxe_io_BytesOutput();
		new format_png_Writer(o).write(png);
		return o.getBytes();
	}
	,toDDS: function() {
		return hxd_Pixels.toDDSLayers([this]);
	}
	,clone: function() {
		var p = new hxd_Pixels(this.width,this.height,null,this.innerFormat);
		p.flags = this.flags;
		p.flags &= -1 - (1 << hxd_Flags.ReadOnly._hx_index);
		if(this.bytes != null) {
			p.bytes = new haxe_io_Bytes(new ArrayBuffer(this.dataSize));
			p.bytes.blit(0,this.bytes,this.offset,this.dataSize);
		}
		return p;
	}
	,__class__: hxd_Pixels
};
var hxd_Res = function() { };
$hxClasses["hxd.Res"] = hxd_Res;
hxd_Res.__name__ = "hxd.Res";
hxd_Res.load = function(name) {
	return hxd_Res.get_loader().load(name);
};
hxd_Res.get_loader = function() {
	var l = hxd_res_Loader.currentInstance;
	if(l == null) {
		throw haxe_Exception.thrown("Resource loader not initialized: call to hxd.Res.initXXX() required");
	}
	return l;
};
hxd_Res.set_loader = function(l) {
	return hxd_res_Loader.currentInstance = l;
};
var hxd_SceneEvents = function($window) {
	this.defaultCursor = hxd_Cursor.Default;
	this.mouseCheckMove = true;
	this.enablePhysicalMouse = true;
	this.isOut = false;
	this.onOver = new hxd_Event(hxd_EventKind.EOver);
	this.onOut = new hxd_Event(hxd_EventKind.EOut);
	this.checkPos = new hxd_Event(hxd_EventKind.ECheck);
	this.focusLost = new hxd_Event(hxd_EventKind.EFocusLost);
	this.lastTouch = 0;
	this.mouseY = -1.;
	this.mouseX = -1.;
	this.overIndex = -1;
	this.scenes = [];
	this.pendingEvents = [];
	this.pushList = [];
	this.overList = [];
	this.overCandidates = [];
	if($window == null) {
		$window = hxd_Window.getInstance();
	}
	this.window = $window;
	$window.addEventTarget($bind(this,this.onEvent));
};
$hxClasses["hxd.SceneEvents"] = hxd_SceneEvents;
hxd_SceneEvents.__name__ = "hxd.SceneEvents";
hxd_SceneEvents.prototype = {
	setMousePos: function(xPos,yPos) {
		this.mouseX = xPos;
		this.mouseY = yPos;
	}
	,onRemove: function(i) {
		if(i == this.currentFocus) {
			this.currentFocus = null;
		}
		if(this.overIndex >= 0) {
			var index = this.overList.indexOf(i);
			if(index >= 0) {
				HxOverrides.remove(this.overList,i);
				if(index < this.overIndex) {
					this.overIndex--;
				}
			}
		} else {
			HxOverrides.remove(this.overList,i);
			this.selectCursor();
		}
		HxOverrides.remove(this.pushList,i);
	}
	,addScene: function(s,index) {
		s.setEvents(this);
		if(index == null) {
			this.scenes.push(s);
		} else {
			this.scenes.splice(index,0,s);
		}
	}
	,removeScene: function(s) {
		if(HxOverrides.remove(this.scenes,s)) {
			s.setEvents(null);
		}
	}
	,dispose: function() {
		this.window.removeEventTarget($bind(this,this.onEvent));
	}
	,focus: function(i) {
		if(this.currentFocus == i) {
			return;
		}
		if(i == null) {
			this.blur();
			return;
		}
		if(this.currentFocus != null) {
			this.blur();
			if(this.currentFocus != null) {
				return;
			}
		}
		var e = new hxd_Event(hxd_EventKind.EFocus);
		i.handleEvent(e);
		if(!e.cancel) {
			this.currentFocus = i;
		}
	}
	,blur: function() {
		if(this.currentFocus == null) {
			return;
		}
		this.focusLost.cancel = false;
		this.currentFocus.handleEvent(this.focusLost);
		if(!this.focusLost.cancel) {
			this.currentFocus = null;
		}
	}
	,checkFocus: function() {
		if(this.currentFocus == null) {
			return;
		}
		var s = this.currentFocus.getInteractiveScene();
		if(s == null) {
			this.currentFocus = null;
			return;
		}
		if(!s.isInteractiveVisible(this.currentFocus)) {
			this.blur();
		}
	}
	,emitEvent: function(event) {
		var oldX = event.relX;
		var oldY = event.relY;
		var overCandidateCount = 0;
		var handled = false;
		var checkOver = false;
		var fillOver = false;
		var checkPush = false;
		var cancelFocus = false;
		var updateCursor = false;
		this.overIndex = 0;
		switch(event.kind._hx_index) {
		case 0:
			cancelFocus = true;
			checkPush = true;
			break;
		case 1:
			checkPush = true;
			break;
		case 5:case 8:case 9:case 11:
			if(this.currentFocus != null) {
				event.relX = event.relY = 0;
				this.currentFocus.handleEvent(event);
				event.relX = oldX;
				event.relY = oldY;
				if(!event.propagate) {
					return;
				}
			}
			break;
		case 2:case 12:
			checkOver = true;
			fillOver = true;
			break;
		default:
		}
		var _g = 0;
		var _g1 = this.scenes;
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			var last = null;
			while(true) {
				var i = s.handleEvent(event,last);
				if(i == null) {
					event.relX = oldX;
					event.relY = oldY;
					break;
				}
				if(checkOver) {
					if(fillOver) {
						var idx = this.overList.indexOf(i);
						if(idx == -1) {
							if(this.overCandidates.length == overCandidateCount) {
								this.overCandidates[overCandidateCount] = { i : i, s : s, x : event.relX, y : event.relY, z : event.relZ};
							} else {
								var info = this.overCandidates[overCandidateCount];
								info.i = i;
								info.s = s;
								info.x = event.relX;
								info.y = event.relY;
								info.z = event.relZ;
							}
							++overCandidateCount;
							this.overList.splice(this.overIndex++,0,i);
							updateCursor = true;
						} else {
							if(idx < this.overIndex) {
								do {
									this.overList[idx] = this.overList[idx + 1];
									++idx;
								} while(idx < this.overIndex);
								this.overList[this.overIndex] = i;
								updateCursor = true;
							} else if(idx > this.overIndex) {
								do {
									this.overList[idx] = this.overList[idx - 1];
									--idx;
								} while(idx > this.overIndex);
								this.overList[this.overIndex] = i;
								updateCursor = true;
							}
							this.overIndex++;
						}
						fillOver = event.propagate;
					}
				} else {
					if(checkPush) {
						if(event.kind == hxd_EventKind.EPush) {
							this.pushList.push(i);
						} else {
							HxOverrides.remove(this.pushList,i);
						}
					}
					if(cancelFocus && i == this.currentFocus) {
						cancelFocus = false;
					}
				}
				event.relX = oldX;
				event.relY = oldY;
				if(!event.propagate) {
					handled = true;
					break;
				}
				last = i;
				event.propagate = false;
			}
			if(handled) {
				break;
			}
		}
		if(cancelFocus && this.currentFocus != null) {
			this.blur();
		}
		if(checkOver) {
			if(this.overIndex < this.overList.length) {
				while(this.overIndex < this.overList.length) {
					var e = this.overList.pop();
					e.handleEvent(this.onOut);
				}
				updateCursor = true;
			}
			if(overCandidateCount != 0) {
				var i = 0;
				var ev = this.onOver;
				do {
					var info = this.overCandidates[i++];
					ev.relX = info.x;
					ev.relY = info.y;
					ev.relZ = info.z;
					if(info.s.isInteractiveVisible(info.i)) {
						info.i.handleEvent(ev);
					} else {
						HxOverrides.remove(this.overList,info.i);
					}
					info.i = null;
					info.s = null;
				} while(i < overCandidateCount);
			}
		}
		this.overIndex = -1;
		if(updateCursor) {
			this.selectCursor();
		}
		if(!handled && event != this.checkPos) {
			if(event.kind == hxd_EventKind.EPush) {
				this.pushList.push(null);
			} else if(event.kind == hxd_EventKind.ERelease) {
				HxOverrides.remove(this.pushList,null);
			}
			this.dispatchListeners(event);
		}
		if(event.kind == hxd_EventKind.ERelease && this.pushList.length > 0) {
			var _g = 0;
			var _g1 = this.pushList;
			while(_g < _g1.length) {
				var i = _g1[_g];
				++_g;
				if(i == null) {
					event.kind = hxd_EventKind.EReleaseOutside;
					this.dispatchListeners(event);
					event.kind = hxd_EventKind.ERelease;
				} else {
					var s = i.getInteractiveScene();
					if(s == null) {
						continue;
					}
					event.kind = hxd_EventKind.EReleaseOutside;
					s.dispatchEvent(event,i);
					event.kind = hxd_EventKind.ERelease;
					event.relX = oldX;
					event.relY = oldY;
				}
			}
			this.pushList = [];
		}
	}
	,checkEvents: function() {
		var old = this.pendingEvents;
		var checkMoved = !this.mouseCheckMove;
		var checkFocused = this.currentFocus == null;
		if(old.length > 0) {
			this.pendingEvents = [];
			var _g = 0;
			while(_g < old.length) {
				var e = old[_g];
				++_g;
				var ox = e.relX;
				var oy = e.relY;
				switch(e.kind._hx_index) {
				case 0:case 1:
					this.mouseX = e.relX;
					this.mouseY = e.relY;
					this.lastTouch = e.touchId;
					break;
				case 2:
					checkMoved = true;
					this.mouseX = e.relX;
					this.mouseY = e.relY;
					this.lastTouch = e.touchId;
					break;
				case 3:
					this.isOut = false;
					this.selectCursor();
					continue;
				case 4:
					this.isOut = true;
					if(this.overList.length > 0) {
						var i = this.overList.length - 1;
						while(i >= 0) {
							this.onOut.cancel = false;
							this.overList[i].handleEvent(this.onOut);
							HxOverrides.remove(this.overList,this.overList[i]);
							--i;
						}
						this.selectCursor();
					}
					continue;
				case 5:case 8:case 9:case 11:
					if(!checkFocused) {
						checkFocused = true;
						this.checkFocus();
					}
					break;
				default:
				}
				if(this.currentDrag != null && (this.currentDrag.ref == null || this.currentDrag.ref == e.touchId)) {
					e.propagate = true;
					e.cancel = false;
					this.currentDrag.f(e);
					e.relX = ox;
					e.relY = oy;
					if(!e.propagate) {
						continue;
					}
					e.propagate = false;
				}
				this.emitEvent(e);
			}
		}
		if(!checkFocused) {
			this.checkFocus();
		}
		if(!checkMoved && !this.isOut && this.currentDrag == null) {
			this.checkPos.relX = this.mouseX;
			this.checkPos.relY = this.mouseY;
			this.checkPos.touchId = this.lastTouch;
			this.checkPos.cancel = false;
			this.checkPos.propagate = false;
			this.emitEvent(this.checkPos);
		}
	}
	,startCapture: function(f,onCancel,touchId) {
		if(this.currentDrag != null && this.currentDrag.onCancel != null) {
			this.currentDrag.onCancel();
		}
		this.currentDrag = { f : f, ref : touchId, onCancel : onCancel};
	}
	,stopCapture: function() {
		if(this.currentDrag != null && this.currentDrag.onCancel != null) {
			this.currentDrag.onCancel();
		}
		this.currentDrag = null;
	}
	,startDrag: function(f,onCancel,refEvent) {
		this.startCapture(f,onCancel,refEvent != null ? refEvent.touchId : null);
	}
	,stopDrag: function() {
		this.stopCapture();
	}
	,getFocus: function() {
		return this.currentFocus;
	}
	,updateCursor: function(i) {
		if(this.overList.indexOf(i) != -1) {
			this.selectCursor();
		}
	}
	,set_defaultCursor: function(c) {
		if(Type.enumEq(c,this.defaultCursor)) {
			return c;
		}
		this.defaultCursor = c;
		this.selectCursor();
		return c;
	}
	,selectCursor: function() {
		var cur = this.defaultCursor;
		var _g = 0;
		var _g1 = this.overList;
		while(_g < _g1.length) {
			var o = _g1[_g];
			++_g;
			if(o.cursor != null) {
				cur = o.cursor;
				break;
			}
		}
		if(cur._hx_index == 6) {
			var f = cur.f;
			f();
		} else {
			hxd_System.setCursor(cur);
		}
	}
	,onEvent: function(e) {
		if(!this.enablePhysicalMouse && e.kind == hxd_EventKind.EMove) {
			return;
		}
		this.pendingEvents.push(e);
	}
	,dispatchListeners: function(event) {
		var ox = event.relX;
		var oy = event.relY;
		event.propagate = true;
		var _g = 0;
		var _g1 = this.scenes;
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			event.cancel = false;
			s.dispatchListeners(event);
			event.relX = ox;
			event.relY = oy;
			if(!event.propagate) {
				break;
			}
		}
	}
	,__class__: hxd_SceneEvents
};
var hxd_Platform = $hxEnums["hxd.Platform"] = { __ename__:true,__constructs__:null
	,IOS: {_hx_name:"IOS",_hx_index:0,__enum__:"hxd.Platform",toString:$estr}
	,Android: {_hx_name:"Android",_hx_index:1,__enum__:"hxd.Platform",toString:$estr}
	,WebGL: {_hx_name:"WebGL",_hx_index:2,__enum__:"hxd.Platform",toString:$estr}
	,PC: {_hx_name:"PC",_hx_index:3,__enum__:"hxd.Platform",toString:$estr}
	,Console: {_hx_name:"Console",_hx_index:4,__enum__:"hxd.Platform",toString:$estr}
	,FlashPlayer: {_hx_name:"FlashPlayer",_hx_index:5,__enum__:"hxd.Platform",toString:$estr}
};
hxd_Platform.__constructs__ = [hxd_Platform.IOS,hxd_Platform.Android,hxd_Platform.WebGL,hxd_Platform.PC,hxd_Platform.Console,hxd_Platform.FlashPlayer];
hxd_Platform.__empty_constructs__ = [hxd_Platform.IOS,hxd_Platform.Android,hxd_Platform.WebGL,hxd_Platform.PC,hxd_Platform.Console,hxd_Platform.FlashPlayer];
var hxd_SystemValue = $hxEnums["hxd.SystemValue"] = { __ename__:true,__constructs__:null
	,IsTouch: {_hx_name:"IsTouch",_hx_index:0,__enum__:"hxd.SystemValue",toString:$estr}
	,IsWindowed: {_hx_name:"IsWindowed",_hx_index:1,__enum__:"hxd.SystemValue",toString:$estr}
	,IsMobile: {_hx_name:"IsMobile",_hx_index:2,__enum__:"hxd.SystemValue",toString:$estr}
};
hxd_SystemValue.__constructs__ = [hxd_SystemValue.IsTouch,hxd_SystemValue.IsWindowed,hxd_SystemValue.IsMobile];
hxd_SystemValue.__empty_constructs__ = [hxd_SystemValue.IsTouch,hxd_SystemValue.IsWindowed,hxd_SystemValue.IsMobile];
var hxd_Timer = function() { };
$hxClasses["hxd.Timer"] = hxd_Timer;
hxd_Timer.__name__ = "hxd.Timer";
hxd_Timer.update = function() {
	hxd_Timer.frameCount++;
	var newTime = HxOverrides.now() / 1000;
	hxd_Timer.elapsedTime = newTime - hxd_Timer.lastTimeStamp;
	hxd_Timer.lastTimeStamp = newTime;
	if(hxd_Timer.elapsedTime < hxd_Timer.maxDeltaTime) {
		var a = hxd_Timer.elapsedTime;
		hxd_Timer.currentDT = a + hxd_Timer.smoothFactor * (hxd_Timer.currentDT - a);
	} else {
		hxd_Timer.elapsedTime = 1 / hxd_Timer.wantedFPS;
	}
	hxd_Timer.dt = hxd_Timer.currentDT;
};
hxd_Timer.get_tmod = function() {
	return hxd_Timer.dt * hxd_Timer.wantedFPS;
};
hxd_Timer.set_tmod = function(v) {
	hxd_Timer.dt = v / hxd_Timer.wantedFPS;
	return v;
};
hxd_Timer.fps = function() {
	return 1. / hxd_Timer.currentDT;
};
hxd_Timer.skip = function() {
	hxd_Timer.lastTimeStamp = HxOverrides.now() / 1000;
};
hxd_Timer.reset = function() {
	hxd_Timer.lastTimeStamp = HxOverrides.now() / 1000;
	hxd_Timer.dt = hxd_Timer.currentDT = 1. / hxd_Timer.wantedFPS;
};
var hxd_Window = function(canvas,globalEvents) {
	this.canLockMouse = true;
	this.discardMouseUp = -1;
	this.discardMouseCaptureEvent = true;
	this.useScreenPixels = js_Browser.get_supported();
	this.curMouseY = 0.;
	this.curMouseX = 0.;
	this.mouseMode = hxd_impl_MouseMode.Absolute;
	var _gthis = this;
	var customCanvas = canvas != null;
	this.eventTargets = new haxe_ds_List();
	this.resizeEvents = new haxe_ds_List();
	this.dropTargets = new haxe_ds_List();
	if(!js_Browser.get_supported()) {
		this.canvasPos = { "width" : 0, "top" : 0, "left" : 0, "height" : 0};
		return;
	}
	if(canvas == null) {
		canvas = window.document.getElementById("webgl");
		if(canvas == null) {
			throw haxe_Exception.thrown("Missing canvas #webgl");
		}
		if(canvas.getAttribute("globalEvents") == "1") {
			globalEvents = true;
		}
	}
	this.canvas = canvas;
	this.propagateKeyEvents = globalEvents;
	var propagate = canvas.getAttribute("propagateKeyEvents");
	if(propagate != null) {
		this.propagateKeyEvents = propagate != "0" && propagate != "false";
	}
	this.focused = globalEvents;
	this.element = globalEvents ? window : canvas;
	this.canvasPos = canvas.getBoundingClientRect();
	if(customCanvas) {
		canvas.addEventListener("mousemove",$bind(this,this.onMouseMove));
	} else {
		window.addEventListener("mousemove",$bind(this,this.onMouseMove));
	}
	this.element.addEventListener("mousedown",$bind(this,this.onMouseDown));
	this.element.addEventListener("mouseup",$bind(this,this.onMouseUp));
	this.element.addEventListener("mouseleave",$bind(this,this.onMouseLeave));
	this.element.addEventListener("wheel",$bind(this,this.onMouseWheel));
	this.element.addEventListener("touchstart",$bind(this,this.onTouchStart));
	this.element.addEventListener("touchmove",$bind(this,this.onTouchMove));
	this.element.addEventListener("touchend",$bind(this,this.onTouchEnd));
	this.element.addEventListener("keydown",$bind(this,this.onKeyDown));
	this.element.addEventListener("keyup",$bind(this,this.onKeyUp));
	this.element.addEventListener("keypress",$bind(this,this.onKeyPress));
	var _g = this;
	var b = false;
	var tmp = function() {
		_g.onFocus(b);
	};
	this.element.addEventListener("blur",tmp);
	var _g1 = this;
	var b1 = true;
	var tmp = function() {
		_g1.onFocus(b1);
	};
	this.element.addEventListener("focus",tmp);
	if(window.ResizeObserver != null) {
		this.observer = new ResizeObserver(function(e) {
			_gthis.checkResize();
		});
		this.observer.observe(canvas);
	}
	window.addEventListener("resize",$bind(this,this.checkResize));
	window.document.addEventListener("pointerlockchange",$bind(this,this.onPointerLockChange));
	canvas.addEventListener("contextmenu",function(e) {
		e.stopPropagation();
		if(e.button == 2) {
			e.preventDefault();
		}
		return false;
	});
	if(globalEvents) {
		canvas.addEventListener("mousedown",function(e) {
			_gthis.onMouseDown(e);
			e.stopPropagation();
			e.preventDefault();
		});
		this.element.addEventListener("contextmenu",function(e) {
			e.stopPropagation();
			e.preventDefault();
			return false;
		});
	} else {
		if(canvas.getAttribute("tabindex") == null) {
			canvas.setAttribute("tabindex","1");
		}
		canvas.style.outline = "none";
	}
	this.curW = this.get_width();
	this.curH = this.get_height();
};
$hxClasses["hxd.Window"] = hxd_Window;
hxd_Window.__name__ = "hxd.Window";
hxd_Window.getInstance = function() {
	if(hxd_Window.inst == null) {
		hxd_Window.inst = new hxd_Window();
	}
	return hxd_Window.inst;
};
hxd_Window.prototype = {
	checkResize: function() {
		this.canvasPos = this.canvas.getBoundingClientRect();
		var cw = this.get_width();
		var ch = this.get_height();
		if(this.curW != cw || this.curH != ch) {
			this.curW = cw;
			this.curH = ch;
			this.onResize(null);
		}
	}
	,dispose: function() {
		if(hxd_Window.inst == this) {
			hxd_Window.inst = null;
		}
		if(window.ResizeObserver != null) {
			if(this.observer != null) {
				this.observer.disconnect();
				this.observer = null;
			}
		}
	}
	,onClose: function() {
		return true;
	}
	,onMouseModeChange: function(from,to) {
		return null;
	}
	,event: function(e) {
		var _g_head = this.eventTargets.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var et = val;
			et(e);
		}
	}
	,addEventTarget: function(et) {
		this.eventTargets.add(et);
	}
	,removeEventTarget: function(et) {
		var _g_head = this.eventTargets.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var e = val;
			if(e == et) {
				this.eventTargets.remove(e);
				break;
			}
		}
	}
	,addResizeEvent: function(f) {
		this.resizeEvents.push(f);
	}
	,removeResizeEvent: function(f) {
		var _g_head = this.resizeEvents.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var e = val;
			if(e == f) {
				this.resizeEvents.remove(f);
				break;
			}
		}
	}
	,onResize: function(e) {
		var _g_head = this.resizeEvents.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var r = val;
			r();
		}
	}
	,resize: function(width,height) {
	}
	,addDragAndDropTarget: function(f) {
		if(this.dropTargets.length == 0) {
			var element = this.canvas;
			element.addEventListener("dragover",$bind(this,this.handleDragAndDropEvent));
			element.addEventListener("drop",$bind(this,this.handleDragAndDropEvent));
		}
		this.dropTargets.add(f);
	}
	,removeDragAndDropTarget: function(f) {
		var _g_head = this.dropTargets.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var e = val;
			if(e == f) {
				this.dropTargets.remove(f);
				break;
			}
		}
		if(this.dropTargets.length == 0) {
			var element = this.canvas;
			element.removeEventListener("dragover",$bind(this,this.handleDragAndDropEvent));
			element.removeEventListener("drop",$bind(this,this.handleDragAndDropEvent));
		}
	}
	,handleDragAndDropEvent: function(e) {
		e.preventDefault();
		if(e.type == "dragover" || e.dataTransfer == null || e.dataTransfer.files.length == 0) {
			return;
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = e.dataTransfer.files;
		while(_g1 < _g2.length) {
			var file = _g2[_g1];
			++_g1;
			_g.push(new hxd__$Window_NativeDroppedFile(file));
		}
		var ev = new hxd_DropFileEvent(_g,Math.round((e.clientX - this.canvasPos.left) * this.getPixelRatio()),Math.round((e.clientY - this.canvasPos.top) * this.getPixelRatio()));
		var _g_head = this.dropTargets.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var dt = val;
			dt(ev);
		}
	}
	,setFullScreen: function(v) {
		var doc = window.document;
		var elt = doc.documentElement;
		if(doc.fullscreenElement == elt == v) {
			return;
		}
		if(v) {
			elt.requestFullscreen();
		} else {
			doc.exitFullscreen();
		}
	}
	,setCursorPos: function(x,y,emitEvent) {
		if(emitEvent == null) {
			emitEvent = false;
		}
		if(this.mouseMode == hxd_impl_MouseMode.Absolute) {
			throw haxe_Exception.thrown("setCursorPos only allowed in relative mouse modes on this platform.");
		}
		this.curMouseX = x + this.canvasPos.left;
		this.curMouseY = y + this.canvasPos.top;
		if(emitEvent) {
			this.event(new hxd_Event(hxd_EventKind.EMove,x,y));
		}
	}
	,setCurrent: function() {
		hxd_Window.inst = this;
	}
	,getPixelRatio: function() {
		if(this.useScreenPixels) {
			return window.devicePixelRatio;
		} else {
			return 1;
		}
	}
	,get_width: function() {
		return Math.round(this.canvasPos.width * this.getPixelRatio());
	}
	,get_height: function() {
		return Math.round(this.canvasPos.height * this.getPixelRatio());
	}
	,get_mouseX: function() {
		return Math.round((this.curMouseX - this.canvasPos.left) * this.getPixelRatio());
	}
	,get_mouseY: function() {
		return Math.round((this.curMouseY - this.canvasPos.top) * this.getPixelRatio());
	}
	,get_mouseLock: function() {
		var _g = this.mouseMode;
		if(_g._hx_index == 2) {
			var _g1 = _g.restorePos;
			return true;
		} else {
			return false;
		}
	}
	,set_mouseLock: function(v) {
		return Type.enumEq(this.set_mouseMode(v ? hxd_impl_MouseMode.AbsoluteUnbound(true) : hxd_impl_MouseMode.Absolute),hxd_impl_MouseMode.AbsoluteUnbound(true));
	}
	,get_mouseClip: function() {
		return false;
	}
	,set_mouseClip: function(v) {
		if(v) {
			throw haxe_Exception.thrown("Can't clip cursor on this platform.");
		}
		return false;
	}
	,set_mouseMode: function(v) {
		if(Type.enumEq(v,this.mouseMode)) {
			return v;
		}
		var forced = this.onMouseModeChange(this.mouseMode,v);
		if(forced != null) {
			v = forced;
		}
		var target = this.pointerLockTarget = this.canvas != null ? this.canvas : window.document.documentElement;
		if(v == hxd_impl_MouseMode.Absolute) {
			if(target.ownerDocument.pointerLockElement == target) {
				target.ownerDocument.exitPointerLock();
			}
		} else if(this.canLockMouse) {
			if(target.ownerDocument.pointerLockElement != target) {
				target.requestPointerLock();
			}
		}
		return this.mouseMode = v;
	}
	,get_vsync: function() {
		return true;
	}
	,set_vsync: function(b) {
		if(!b) {
			throw haxe_Exception.thrown("Can't disable vsync on this platform");
		}
		return true;
	}
	,onPointerLockChange: function(e) {
		if(this.mouseMode != hxd_impl_MouseMode.Absolute && this.pointerLockTarget.ownerDocument.pointerLockElement != this.pointerLockTarget) {
			this.canLockMouse = false;
			this.set_mouseMode(hxd_impl_MouseMode.Absolute);
			this.canLockMouse = true;
		}
	}
	,onMouseDown: function(e) {
		if(this.mouseMode == hxd_impl_MouseMode.Absolute) {
			if(e.clientX != this.curMouseX || e.clientY != this.curMouseY) {
				this.onMouseMove(e);
			}
		} else {
			if(this.pointerLockTarget.ownerDocument.pointerLockElement != this.pointerLockTarget) {
				this.pointerLockTarget.requestPointerLock();
				if(this.discardMouseCaptureEvent) {
					this.discardMouseUp = e.button;
					return;
				}
			}
			if(e.movementX != 0 || e.movementY != 0) {
				this.onMouseMove(e);
			}
		}
		var ev = new hxd_Event(hxd_EventKind.EPush,this.get_mouseX(),this.get_mouseY());
		var _g = e.button;
		var tmp;
		switch(_g) {
		case 1:
			tmp = 2;
			break;
		case 2:
			tmp = 1;
			break;
		default:
			var x = _g;
			tmp = x;
		}
		ev.button = tmp;
		this.event(ev);
	}
	,onMouseUp: function(e) {
		if(this.discardMouseUp == e.button) {
			this.discardMouseUp = -1;
			return;
		}
		if(this.mouseMode == hxd_impl_MouseMode.Absolute ? e.clientX != this.curMouseX || e.clientY != this.curMouseY : e.movementX != 0 || e.movementY != 0) {
			this.onMouseMove(e);
		}
		var ev = new hxd_Event(hxd_EventKind.ERelease,this.get_mouseX(),this.get_mouseY());
		var _g = e.button;
		var tmp;
		switch(_g) {
		case 1:
			tmp = 2;
			break;
		case 2:
			tmp = 1;
			break;
		default:
			var x = _g;
			tmp = x;
		}
		ev.button = tmp;
		this.event(ev);
	}
	,onMouseLeave: function(e) {
		var ev = new hxd_Event(hxd_EventKind.EReleaseOutside,this.get_mouseX(),this.get_mouseY());
		var _g = e.button;
		var tmp;
		switch(_g) {
		case 1:
			tmp = 2;
			break;
		case 2:
			tmp = 1;
			break;
		default:
			var x = _g;
			tmp = x;
		}
		ev.button = tmp;
		this.event(ev);
	}
	,onMouseMove: function(e) {
		var _g = this.mouseMode;
		switch(_g._hx_index) {
		case 0:
			this.curMouseX = e.clientX;
			this.curMouseY = e.clientY;
			this.event(new hxd_Event(hxd_EventKind.EMove,this.get_mouseX(),this.get_mouseY()));
			break;
		case 1:
			var _g1 = _g.restorePos;
			var callback = _g.callback;
			if(this.pointerLockTarget.ownerDocument.pointerLockElement != this.pointerLockTarget) {
				return;
			}
			var ev = new hxd_Event(hxd_EventKind.EMove,e.movementX,e.movementY);
			callback(ev);
			if(!ev.cancel && ev.propagate) {
				ev.cancel = false;
				ev.propagate = false;
				ev.relX = this.curMouseX;
				ev.relY = this.curMouseY;
				this.event(ev);
			}
			break;
		case 2:
			var _g1 = _g.restorePos;
			if(this.pointerLockTarget.ownerDocument.pointerLockElement != this.pointerLockTarget) {
				return;
			}
			this.curMouseX += e.movementX;
			this.curMouseY += e.movementY;
			this.event(new hxd_Event(hxd_EventKind.EMove,this.get_mouseX(),this.get_mouseY()));
			break;
		}
	}
	,onMouseWheel: function(e) {
		e.preventDefault();
		var ev = new hxd_Event(hxd_EventKind.EWheel,this.get_mouseX(),this.get_mouseY());
		ev.wheelDelta = e.deltaY / 120;
		this.event(ev);
	}
	,onTouchStart: function(e) {
		e.preventDefault();
		var x;
		var y;
		var ev;
		var _g = 0;
		var _g1 = e.changedTouches;
		while(_g < _g1.length) {
			var touch = _g1[_g];
			++_g;
			x = Math.round((touch.clientX - this.canvasPos.left) * this.getPixelRatio());
			y = Math.round((touch.clientY - this.canvasPos.top) * this.getPixelRatio());
			ev = new hxd_Event(hxd_EventKind.EPush,x,y);
			ev.touchId = touch.identifier;
			this.event(ev);
		}
	}
	,onTouchMove: function(e) {
		e.preventDefault();
		var x;
		var y;
		var ev;
		var _g = 0;
		var _g1 = e.changedTouches;
		while(_g < _g1.length) {
			var touch = _g1[_g];
			++_g;
			x = Math.round((touch.clientX - this.canvasPos.left) * this.getPixelRatio());
			y = Math.round((touch.clientY - this.canvasPos.top) * this.getPixelRatio());
			ev = new hxd_Event(hxd_EventKind.EMove,x,y);
			ev.touchId = touch.identifier;
			this.event(ev);
		}
	}
	,onTouchEnd: function(e) {
		e.preventDefault();
		var x;
		var y;
		var ev;
		var _g = 0;
		var _g1 = e.changedTouches;
		while(_g < _g1.length) {
			var touch = _g1[_g];
			++_g;
			x = Math.round((touch.clientX - this.canvasPos.left) * this.getPixelRatio());
			y = Math.round((touch.clientY - this.canvasPos.top) * this.getPixelRatio());
			ev = new hxd_Event(hxd_EventKind.ERelease,x,y);
			ev.touchId = touch.identifier;
			this.event(ev);
		}
	}
	,onKeyUp: function(e) {
		var ev = new hxd_Event(hxd_EventKind.EKeyUp,this.get_mouseX(),this.get_mouseY());
		ev.keyCode = e.keyCode;
		this.event(ev);
		if(!this.propagateKeyEvents) {
			e.preventDefault();
			e.stopPropagation();
		}
	}
	,onKeyDown: function(e) {
		var ev = new hxd_Event(hxd_EventKind.EKeyDown,this.get_mouseX(),this.get_mouseY());
		ev.keyCode = e.keyCode;
		this.event(ev);
		if(!this.propagateKeyEvents) {
			switch(ev.keyCode) {
			case 8:case 9:case 16:case 17:case 33:case 34:case 35:case 36:case 37:case 38:case 39:case 40:
				e.preventDefault();
				break;
			default:
			}
			e.stopPropagation();
		}
	}
	,onKeyPress: function(e) {
		var ev = new hxd_Event(hxd_EventKind.ETextInput,this.get_mouseX(),this.get_mouseY());
		ev.charCode = e.charCode;
		this.event(ev);
		if(!this.propagateKeyEvents) {
			e.preventDefault();
			e.stopPropagation();
		}
	}
	,onFocus: function(b) {
		this.event(new hxd_Event(b ? hxd_EventKind.EFocus : hxd_EventKind.EFocusLost));
		this.focused = b;
	}
	,get_isFocused: function() {
		return this.focused;
	}
	,get_displayMode: function() {
		var doc = window.document;
		if(doc.fullscreenElement != null) {
			return hxd_DisplayMode.Borderless;
		}
		return hxd_DisplayMode.Windowed;
	}
	,set_displayMode: function(m) {
		if(!js_Browser.get_supported()) {
			return m;
		}
		var doc = window.document;
		var elt = doc.documentElement;
		var fullscreen = m != hxd_DisplayMode.Windowed;
		if(doc.fullscreenElement == elt == fullscreen) {
			return hxd_DisplayMode.Windowed;
		}
		if(m != hxd_DisplayMode.Windowed) {
			elt.requestFullscreen();
		} else {
			doc.exitFullscreen();
		}
		return m;
	}
	,get_title: function() {
		return window.document.title;
	}
	,set_title: function(t) {
		return window.document.title = t;
	}
	,__class__: hxd_Window
};
var js_Browser = function() { };
$hxClasses["js.Browser"] = js_Browser;
js_Browser.__name__ = "js.Browser";
js_Browser.get_supported = function() {
	if(typeof(window) != "undefined" && typeof(window.location) != "undefined") {
		return typeof(window.location.protocol) == "string";
	} else {
		return false;
	}
};
var hxd_System = function() { };
$hxClasses["hxd.System"] = hxd_System;
hxd_System.__name__ = "hxd.System";
hxd_System.timeoutTick = function() {
};
hxd_System.getCurrentLoop = function() {
	return hxd_System.loopFunc;
};
hxd_System.setLoop = function(f) {
	if(!hxd_System.loopInit) {
		hxd_System.loopInit = true;
		hxd_System.browserLoop();
	}
	hxd_System.loopFunc = f;
};
hxd_System.browserLoop = function() {
	if(js_Browser.get_supported()) {
		var $window = window;
		var rqf = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame || $window.mozRequestAnimationFrame;
		if(hxd_System.fpsLimit > 0) {
			window.setTimeout(function() {
				return rqf(hxd_System.browserLoop);
			},1000 / hxd_System.fpsLimit);
		} else {
			rqf(hxd_System.browserLoop);
		}
	} else {
		throw haxe_Exception.thrown("Cannot use browserLoop without Browser support nor defining nodejs + hxnodejs");
	}
	if(hxd_System.loopFunc != null) {
		hxd_System.loopFunc();
	}
};
hxd_System.start = function(callb) {
	callb();
};
hxd_System.setNativeCursor = function(c) {
	if(hxd_System.currentNativeCursor != null && Type.enumEq(c,hxd_System.currentNativeCursor)) {
		return;
	}
	hxd_System.currentNativeCursor = c;
	hxd_System.currentCustomCursor = null;
	var canvas = hxd_Window.getInstance().canvas;
	if(canvas != null) {
		var tmp;
		switch(c._hx_index) {
		case 0:
			tmp = "default";
			break;
		case 1:
			tmp = "pointer";
			break;
		case 2:
			tmp = "move";
			break;
		case 3:
			tmp = "text";
			break;
		case 4:
			tmp = "none";
			break;
		case 5:
			var cur = c.custom;
			if(cur.alloc == null) {
				cur.alloc = [];
				var _g = 0;
				var _g1 = cur.frames;
				while(_g < _g1.length) {
					var frame = _g1[_g];
					++_g;
					cur.alloc.push("url(\"" + frame.ctx.canvas.toDataURL("image/png") + "\") " + cur.offsetX + " " + cur.offsetY + ", default");
				}
			}
			if(cur.frames.length > 1) {
				hxd_System.currentCustomCursor = cur;
				cur.reset();
			}
			tmp = cur.alloc[cur.frameIndex];
			break;
		case 6:
			var _g = c.f;
			throw haxe_Exception.thrown("assert");
		}
		canvas.style.cursor = tmp;
	}
};
hxd_System.getDeviceName = function() {
	return "Unknown";
};
hxd_System.getDefaultFrameRate = function() {
	return 60.;
};
hxd_System.getValue = function(s) {
	switch(s._hx_index) {
	case 0:
		if(hxd_System.get_platform() != hxd_Platform.Android) {
			return hxd_System.get_platform() == hxd_Platform.IOS;
		} else {
			return true;
		}
		break;
	case 1:
		return true;
	case 2:
		if(hxd_System.get_platform() != hxd_Platform.Android) {
			return hxd_System.get_platform() == hxd_Platform.IOS;
		} else {
			return true;
		}
		break;
	}
};
hxd_System.exit = function() {
};
hxd_System.openURL = function(url) {
	window.open(url,"_blank");
};
hxd_System.updateCursor = function() {
	if(hxd_System.currentCustomCursor != null) {
		var change = hxd_System.currentCustomCursor.update(hxd_Timer.elapsedTime);
		if(change != -1) {
			var canvas = hxd_Window.getInstance().canvas;
			if(canvas != null) {
				canvas.style.cursor = hxd_System.currentCustomCursor.alloc[change];
			}
		}
	}
};
hxd_System.getClipboardText = function() {
	return null;
};
hxd_System.setClipboardText = function(text) {
	return false;
};
hxd_System.getLocale = function() {
	return $global.navigator.language + "_" + $global.navigator.language.toUpperCase();
};
hxd_System.get_width = function() {
	return Math.round(window.document.body.clientWidth * window.devicePixelRatio);
};
hxd_System.get_height = function() {
	return Math.round(window.document.body.clientHeight * window.devicePixelRatio);
};
hxd_System.get_lang = function() {
	return $global.navigator.language;
};
hxd_System.get_platform = function() {
	var ua = $global.navigator.userAgent.toLowerCase();
	if(ua.indexOf("android") >= 0) {
		return hxd_Platform.Android;
	} else if(ua.indexOf("ipad") >= 0 || ua.indexOf("iphone") >= 0 || ua.indexOf("ipod") >= 0) {
		return hxd_Platform.IOS;
	} else {
		return hxd_Platform.PC;
	}
};
hxd_System.get_screenDPI = function() {
	return 72;
};
hxd_System.get_allowTimeout = function() {
	return false;
};
hxd_System.set_allowTimeout = function(b) {
	return false;
};
var hxd_DisplayMode = $hxEnums["hxd.DisplayMode"] = { __ename__:true,__constructs__:null
	,Windowed: {_hx_name:"Windowed",_hx_index:0,__enum__:"hxd.DisplayMode",toString:$estr}
	,Borderless: {_hx_name:"Borderless",_hx_index:1,__enum__:"hxd.DisplayMode",toString:$estr}
	,Fullscreen: {_hx_name:"Fullscreen",_hx_index:2,__enum__:"hxd.DisplayMode",toString:$estr}
	,FullscreenResize: {_hx_name:"FullscreenResize",_hx_index:3,__enum__:"hxd.DisplayMode",toString:$estr}
};
hxd_DisplayMode.__constructs__ = [hxd_DisplayMode.Windowed,hxd_DisplayMode.Borderless,hxd_DisplayMode.Fullscreen,hxd_DisplayMode.FullscreenResize];
hxd_DisplayMode.__empty_constructs__ = [hxd_DisplayMode.Windowed,hxd_DisplayMode.Borderless,hxd_DisplayMode.Fullscreen,hxd_DisplayMode.FullscreenResize];
var hxd__$Window_NativeDroppedFile = function(native) {
	hxd_DroppedFile.call(this,native.name);
	this.native = native;
};
$hxClasses["hxd._Window.NativeDroppedFile"] = hxd__$Window_NativeDroppedFile;
hxd__$Window_NativeDroppedFile.__name__ = "hxd._Window.NativeDroppedFile";
hxd__$Window_NativeDroppedFile.__super__ = hxd_DroppedFile;
hxd__$Window_NativeDroppedFile.prototype = $extend(hxd_DroppedFile.prototype,{
	getBytes: function(callback) {
		var reader = new FileReader();
		reader.onload = function(_) {
			callback(haxe_io_Bytes.ofData(reader.result));
		};
		reader.onerror = function(_) {
			callback(null);
		};
		reader.readAsArrayBuffer(this.native);
	}
	,__class__: hxd__$Window_NativeDroppedFile
});
var hxd_clipper_ClipType = $hxEnums["hxd.clipper.ClipType"] = { __ename__:true,__constructs__:null
	,Intersection: {_hx_name:"Intersection",_hx_index:0,__enum__:"hxd.clipper.ClipType",toString:$estr}
	,Union: {_hx_name:"Union",_hx_index:1,__enum__:"hxd.clipper.ClipType",toString:$estr}
	,Difference: {_hx_name:"Difference",_hx_index:2,__enum__:"hxd.clipper.ClipType",toString:$estr}
	,Xor: {_hx_name:"Xor",_hx_index:3,__enum__:"hxd.clipper.ClipType",toString:$estr}
};
hxd_clipper_ClipType.__constructs__ = [hxd_clipper_ClipType.Intersection,hxd_clipper_ClipType.Union,hxd_clipper_ClipType.Difference,hxd_clipper_ClipType.Xor];
hxd_clipper_ClipType.__empty_constructs__ = [hxd_clipper_ClipType.Intersection,hxd_clipper_ClipType.Union,hxd_clipper_ClipType.Difference,hxd_clipper_ClipType.Xor];
var hxd_clipper__$Clipper_EdgeSide = $hxEnums["hxd.clipper._Clipper.EdgeSide"] = { __ename__:true,__constructs__:null
	,Left: {_hx_name:"Left",_hx_index:0,__enum__:"hxd.clipper._Clipper.EdgeSide",toString:$estr}
	,Right: {_hx_name:"Right",_hx_index:1,__enum__:"hxd.clipper._Clipper.EdgeSide",toString:$estr}
};
hxd_clipper__$Clipper_EdgeSide.__constructs__ = [hxd_clipper__$Clipper_EdgeSide.Left,hxd_clipper__$Clipper_EdgeSide.Right];
hxd_clipper__$Clipper_EdgeSide.__empty_constructs__ = [hxd_clipper__$Clipper_EdgeSide.Left,hxd_clipper__$Clipper_EdgeSide.Right];
var hxd_clipper__$Clipper_Direction = $hxEnums["hxd.clipper._Clipper.Direction"] = { __ename__:true,__constructs__:null
	,RightToLeft: {_hx_name:"RightToLeft",_hx_index:0,__enum__:"hxd.clipper._Clipper.Direction",toString:$estr}
	,LeftToRight: {_hx_name:"LeftToRight",_hx_index:1,__enum__:"hxd.clipper._Clipper.Direction",toString:$estr}
};
hxd_clipper__$Clipper_Direction.__constructs__ = [hxd_clipper__$Clipper_Direction.RightToLeft,hxd_clipper__$Clipper_Direction.LeftToRight];
hxd_clipper__$Clipper_Direction.__empty_constructs__ = [hxd_clipper__$Clipper_Direction.RightToLeft,hxd_clipper__$Clipper_Direction.LeftToRight];
var hxd_clipper__$Clipper_PolyNode = function() {
	var points = [];
	this.polygon = points == null ? [] : points;
	this.childs = [];
};
$hxClasses["hxd.clipper._Clipper.PolyNode"] = hxd_clipper__$Clipper_PolyNode;
hxd_clipper__$Clipper_PolyNode.__name__ = "hxd.clipper._Clipper.PolyNode";
hxd_clipper__$Clipper_PolyNode.prototype = {
	isHoleNode: function() {
		var result = true;
		var node = this.parent;
		while(node != null) {
			result = !result;
			node = node.parent;
		}
		return result;
	}
	,get_childCount: function() {
		return this.childs.length;
	}
	,get_contour: function() {
		return this.polygon;
	}
	,addChild: function(child) {
		var cnt = this.childs.length;
		this.childs.push(child);
		child.parent = this;
		child.index = cnt;
	}
	,getNext: function() {
		if(this.childs.length > 0) {
			return this.childs[0];
		} else {
			return this.getNextSiblingUp();
		}
	}
	,getNextSiblingUp: function() {
		if(this.parent == null) {
			return null;
		} else if(this.index == this.parent.childs.length - 1) {
			return this.parent.getNextSiblingUp();
		} else {
			return this.parent.childs[this.index + 1];
		}
	}
	,isHole: function() {
		return this.isHoleNode();
	}
	,__class__: hxd_clipper__$Clipper_PolyNode
};
var hxd_clipper__$Clipper_PolyTree = function() {
	hxd_clipper__$Clipper_PolyNode.call(this);
	this.allPolys = [];
};
$hxClasses["hxd.clipper._Clipper.PolyTree"] = hxd_clipper__$Clipper_PolyTree;
hxd_clipper__$Clipper_PolyTree.__name__ = "hxd.clipper._Clipper.PolyTree";
hxd_clipper__$Clipper_PolyTree.__super__ = hxd_clipper__$Clipper_PolyNode;
hxd_clipper__$Clipper_PolyTree.prototype = $extend(hxd_clipper__$Clipper_PolyNode.prototype,{
	toPolygons: function(polygons) {
		polygons = [];
		this.addRec(this,polygons);
	}
	,addRec: function(polynode,polygons) {
		if(polynode.polygon.length > 0) {
			polygons.push(polynode.polygon);
		}
		var _g = 0;
		var _g1 = polynode.childs;
		while(_g < _g1.length) {
			var pn = _g1[_g];
			++_g;
			this.addRec(pn,polygons);
		}
	}
	,clear: function() {
		this.allPolys = [];
		this.childs = [];
	}
	,getFirst: function() {
		if(this.childs.length > 0) {
			return this.childs[0];
		}
		return null;
	}
	,get_total: function() {
		var result = this.allPolys.length;
		if(result > 0 && this.childs[0] != this.allPolys[0]) {
			--result;
		}
		return result;
	}
	,__class__: hxd_clipper__$Clipper_PolyTree
});
var hxd_clipper__$Clipper_Ref = function(v) {
	this.val = v;
};
$hxClasses["hxd.clipper._Clipper.Ref"] = hxd_clipper__$Clipper_Ref;
hxd_clipper__$Clipper_Ref.__name__ = "hxd.clipper._Clipper.Ref";
hxd_clipper__$Clipper_Ref.prototype = {
	__class__: hxd_clipper__$Clipper_Ref
};
var hxd_clipper__$Clipper_TEdge = function() {
};
$hxClasses["hxd.clipper._Clipper.TEdge"] = hxd_clipper__$Clipper_TEdge;
hxd_clipper__$Clipper_TEdge.__name__ = "hxd.clipper._Clipper.TEdge";
hxd_clipper__$Clipper_TEdge.prototype = {
	get_top: function() {
		return new h2d_col_IPoint(this.topX,this.topY);
	}
	,get_bot: function() {
		return new h2d_col_IPoint(this.botX,this.botY);
	}
	,get_curr: function() {
		return new h2d_col_IPoint(this.currX,this.currY);
	}
	,set_top: function(p) {
		this.topX = p.x;
		this.topY = p.y;
		return p;
	}
	,set_bot: function(p) {
		this.botX = p.x;
		this.botY = p.y;
		return p;
	}
	,set_curr: function(p) {
		this.currX = p.x;
		this.currY = p.y;
		return p;
	}
	,__class__: hxd_clipper__$Clipper_TEdge
};
var hxd_clipper__$Clipper_IntersectNode = function() {
};
$hxClasses["hxd.clipper._Clipper.IntersectNode"] = hxd_clipper__$Clipper_IntersectNode;
hxd_clipper__$Clipper_IntersectNode.__name__ = "hxd.clipper._Clipper.IntersectNode";
hxd_clipper__$Clipper_IntersectNode.prototype = {
	__class__: hxd_clipper__$Clipper_IntersectNode
};
var hxd_clipper__$Clipper_LocalMinima = function() {
};
$hxClasses["hxd.clipper._Clipper.LocalMinima"] = hxd_clipper__$Clipper_LocalMinima;
hxd_clipper__$Clipper_LocalMinima.__name__ = "hxd.clipper._Clipper.LocalMinima";
hxd_clipper__$Clipper_LocalMinima.prototype = {
	__class__: hxd_clipper__$Clipper_LocalMinima
};
var hxd_clipper__$Clipper_Scanbeam = function() {
};
$hxClasses["hxd.clipper._Clipper.Scanbeam"] = hxd_clipper__$Clipper_Scanbeam;
hxd_clipper__$Clipper_Scanbeam.__name__ = "hxd.clipper._Clipper.Scanbeam";
hxd_clipper__$Clipper_Scanbeam.prototype = {
	__class__: hxd_clipper__$Clipper_Scanbeam
};
var hxd_clipper__$Clipper_OutRec = function() {
};
$hxClasses["hxd.clipper._Clipper.OutRec"] = hxd_clipper__$Clipper_OutRec;
hxd_clipper__$Clipper_OutRec.__name__ = "hxd.clipper._Clipper.OutRec";
hxd_clipper__$Clipper_OutRec.prototype = {
	__class__: hxd_clipper__$Clipper_OutRec
};
var hxd_clipper__$Clipper_OutPt = function() {
};
$hxClasses["hxd.clipper._Clipper.OutPt"] = hxd_clipper__$Clipper_OutPt;
hxd_clipper__$Clipper_OutPt.__name__ = "hxd.clipper._Clipper.OutPt";
hxd_clipper__$Clipper_OutPt.prototype = {
	__class__: hxd_clipper__$Clipper_OutPt
};
var hxd_clipper__$Clipper_Join = function() {
};
$hxClasses["hxd.clipper._Clipper.Join"] = hxd_clipper__$Clipper_Join;
hxd_clipper__$Clipper_Join.__name__ = "hxd.clipper._Clipper.Join";
hxd_clipper__$Clipper_Join.prototype = {
	__class__: hxd_clipper__$Clipper_Join
};
var hxd_clipper__$Clipper_ClipperBase = function() {
	this.m_edges = [];
	this.m_MinimaList = null;
	this.m_CurrentLM = null;
};
$hxClasses["hxd.clipper._Clipper.ClipperBase"] = hxd_clipper__$Clipper_ClipperBase;
hxd_clipper__$Clipper_ClipperBase.__name__ = "hxd.clipper._Clipper.ClipperBase";
hxd_clipper__$Clipper_ClipperBase.nearZero = function(v) {
	if(v > -1e-020) {
		return v < 1E-20;
	} else {
		return false;
	}
};
hxd_clipper__$Clipper_ClipperBase.getBounds = function(pols) {
	var result = new hxd_clipper_Rect();
	var i = 0;
	var count = pols.length;
	while(i < count && pols[i].length == 0) ++i;
	var tmp = i == count;
	result.left = result.right = pols[i][0].x;
	result.top = result.bottom = pols[i][0].y;
	var _g = 0;
	var _g1 = count;
	while(_g < _g1) {
		var i = _g++;
		var _g_i = 0;
		var _g_a = pols[i];
		var _g_l = _g_a.length;
		while(_g_i < _g_l) {
			var p = _g_a[_g_i++];
			if(p.x < result.left) {
				result.left = p.x;
			} else if(p.x > result.right) {
				result.right = p.x;
			}
			if(p.y < result.top) {
				result.top = p.y;
			} else if(p.y > result.bottom) {
				result.bottom = p.y;
			}
		}
	}
	return result;
};
hxd_clipper__$Clipper_ClipperBase.prototype = {
	isHorizontal: function(e) {
		return e.deltaY == 0;
	}
	,abs: function(i) {
		if(i < 0) {
			return -i;
		} else {
			return i;
		}
	}
	,PointIsVertex: function(pt,pp) {
		var pp2 = pp;
		do {
			var pt1 = pp2.pt;
			if(pt1.x == pt.x && pt1.y == pt.y) {
				return true;
			}
			pp2 = pp2.next;
		} while(pp2 != pp);
		return false;
	}
	,PointOnLineSegment: function(pt,linePt1,linePt2) {
		if(!(pt.x == linePt1.x && pt.y == linePt1.y || pt.x == linePt2.x && pt.y == linePt2.y)) {
			if(pt.x > linePt1.x == pt.x < linePt2.x && pt.y > linePt1.y == pt.y < linePt2.y) {
				return (pt.x - linePt1.x) * (linePt2.y - linePt1.y) == (linePt2.x - linePt1.x) * (pt.y - linePt1.y);
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	,PointOnPolygon: function(pt,pp) {
		var pp2 = pp;
		do {
			if(this.PointOnLineSegment(pt,pp2.pt,pp2.next.pt)) {
				return true;
			}
			pp2 = pp2.next;
		} while(pp2 != pp);
		return false;
	}
	,SlopesEqual: function(e1,e2) {
		return e1.deltaY * e2.deltaX == e1.deltaX * e2.deltaY;
	}
	,SlopesEqual3: function(pt1,pt2,pt3) {
		return (pt1.y - pt2.y) * (pt2.x - pt3.x) - (pt1.x - pt2.x) * (pt2.y - pt3.y) == 0;
	}
	,clear: function() {
		this.disposeLocalMinimaList();
		this.m_edges = [];
	}
	,disposeLocalMinimaList: function() {
		while(this.m_MinimaList != null) {
			var tmpLm = this.m_MinimaList.next;
			this.m_MinimaList = null;
			this.m_MinimaList = tmpLm;
		}
		this.m_CurrentLM = null;
	}
	,addPolygons: function(ppg,polyType) {
		var result = false;
		var _g_i = 0;
		var _g_a = ppg;
		var _g_l = _g_a.length;
		while(_g_i < _g_l) {
			var p = _g_a[_g_i++];
			if(this.addPolygon(p,polyType)) {
				result = true;
			}
		}
		return result;
	}
	,addPolygon: function(pg,polyType) {
		var highI = pg.length - 1;
		while(highI > 0 && pg[highI] == pg[0]) --highI;
		while(highI > 0 && pg[highI] == pg[highI - 1]) --highI;
		if(highI < 2) {
			return false;
		}
		var edges = [];
		var _g = 0;
		var _g1 = highI + 1;
		while(_g < _g1) {
			var i = _g++;
			edges.push(new hxd_clipper__$Clipper_TEdge());
		}
		var isFlat = true;
		var _this = edges[1];
		var p = pg[1];
		_this.currX = p.x;
		_this.currY = p.y;
		var e = edges[0];
		var pt = pg[0];
		e.next = edges[1];
		e.prev = edges[highI];
		e.currX = pt.x;
		e.currY = pt.y;
		e.outIdx = -1;
		var e = edges[highI];
		var pt = pg[highI];
		e.next = edges[0];
		e.prev = edges[highI - 1];
		e.currX = pt.x;
		e.currY = pt.y;
		e.outIdx = -1;
		var i = highI - 1;
		while(i > 0) {
			var e = edges[i];
			var pt = pg[i];
			e.next = edges[i + 1];
			e.prev = edges[i - 1];
			e.currX = pt.x;
			e.currY = pt.y;
			e.outIdx = -1;
			--i;
		}
		var eStart = edges[0];
		var eStop = eStart;
		var e = eStart;
		while(true) {
			if(e.currX == e.next.currX && e.currY == e.next.currY) {
				if(e == e.next) {
					break;
				}
				if(e == eStart) {
					eStart = e.next;
				}
				e = this.RemoveEdge(e);
				eStop = e;
				continue;
			}
			if(e.prev == e.next) {
				break;
			}
			var tmp;
			var _this = e.prev;
			var x = _this.currX;
			var y = _this.currY;
			if(y == null) {
				y = 0;
			}
			if(x == null) {
				x = 0;
			}
			var pt1_x = x;
			var pt1_y = y;
			var x1 = e.currX;
			var y1 = e.currY;
			if(y1 == null) {
				y1 = 0;
			}
			if(x1 == null) {
				x1 = 0;
			}
			var pt2_x = x1;
			var pt2_y = y1;
			var _this1 = e.next;
			var x2 = _this1.currX;
			var y2 = _this1.currY;
			if(y2 == null) {
				y2 = 0;
			}
			if(x2 == null) {
				x2 = 0;
			}
			var pt3_x = x2;
			var pt3_y = y2;
			if((pt1_y - pt2_y) * (pt2_x - pt3_x) - (pt1_x - pt2_x) * (pt2_y - pt3_y) == 0) {
				if(this.preserveCollinear) {
					var _this2 = e.prev;
					var tmp1 = new h2d_col_IPoint(_this2.currX,_this2.currY);
					var tmp2 = new h2d_col_IPoint(e.currX,e.currY);
					var _this3 = e.next;
					tmp = !this.Pt2IsBetweenPt1AndPt3(tmp1,tmp2,new h2d_col_IPoint(_this3.currX,_this3.currY));
				} else {
					tmp = true;
				}
			} else {
				tmp = false;
			}
			if(tmp) {
				if(e == eStart) {
					eStart = e.next;
				}
				e = this.RemoveEdge(e);
				e = e.prev;
				eStop = e;
				continue;
			}
			e = e.next;
			if(e == eStop) {
				break;
			}
		}
		if(e.prev == e.next) {
			return false;
		}
		e = eStart;
		do {
			if(e.currY >= e.next.currY) {
				e.botX = e.currX;
				e.botY = e.currY;
				e.topX = e.next.currX;
				e.topY = e.next.currY;
			} else {
				e.topX = e.currX;
				e.topY = e.currY;
				e.botX = e.next.currX;
				e.botY = e.next.currY;
			}
			this.SetDx(e);
			e.polyType = polyType;
			e = e.next;
			if(e.currY != eStart.currY) {
				isFlat = false;
			}
		} while(e != eStart);
		if(isFlat) {
			return false;
		}
		this.m_edges.push(edges);
		var leftBoundIsForward;
		var eMin = null;
		if(e.prev.botX == e.prev.topX && e.prev.botY == e.prev.topY) {
			e = e.next;
		}
		var old = null;
		while(true) {
			e = this.FindNextLocMin(e);
			if(e == eMin) {
				break;
			} else if(eMin == null) {
				eMin = e;
			}
			if(e == old) {
				throw haxe_Exception.thrown("!");
			}
			old = e;
			var locMin = new hxd_clipper__$Clipper_LocalMinima();
			locMin.next = null;
			locMin.y = e.botY;
			if(e.dx < e.prev.dx) {
				locMin.leftBound = e.prev;
				locMin.rightBound = e;
				leftBoundIsForward = false;
			} else {
				locMin.leftBound = e;
				locMin.rightBound = e.prev;
				leftBoundIsForward = true;
			}
			locMin.leftBound.side = hxd_clipper__$Clipper_EdgeSide.Left;
			locMin.rightBound.side = hxd_clipper__$Clipper_EdgeSide.Right;
			if(locMin.leftBound.next == locMin.rightBound) {
				locMin.leftBound.windDelta = -1;
			} else {
				locMin.leftBound.windDelta = 1;
			}
			locMin.rightBound.windDelta = -locMin.leftBound.windDelta;
			e = this.ProcessBound(locMin.leftBound,leftBoundIsForward);
			if(e.outIdx == -2) {
				e = this.ProcessBound(e,leftBoundIsForward);
			}
			var e2 = this.ProcessBound(locMin.rightBound,!leftBoundIsForward);
			if(e2.outIdx == -2) {
				e2 = this.ProcessBound(e2,!leftBoundIsForward);
			}
			if(locMin.leftBound.outIdx == -2) {
				locMin.leftBound = null;
			} else if(locMin.rightBound.outIdx == -2) {
				locMin.rightBound = null;
			}
			this.InsertLocalMinima(locMin);
			if(!leftBoundIsForward) {
				e = e2;
			}
		}
		return true;
	}
	,InitEdge: function(e,eNext,ePrev,pt) {
		e.next = eNext;
		e.prev = ePrev;
		e.currX = pt.x;
		e.currY = pt.y;
		e.outIdx = -1;
	}
	,InitEdge2: function(e,polyType) {
		if(e.currY >= e.next.currY) {
			e.botX = e.currX;
			e.botY = e.currY;
			e.topX = e.next.currX;
			e.topY = e.next.currY;
		} else {
			e.topX = e.currX;
			e.topY = e.currY;
			e.botX = e.next.currX;
			e.botY = e.next.currY;
		}
		this.SetDx(e);
		e.polyType = polyType;
	}
	,RemoveEdge: function(e) {
		e.prev.next = e.next;
		e.next.prev = e.prev;
		var result = e.next;
		e.prev = null;
		return result;
	}
	,FindNextLocMin: function(e) {
		var e2;
		while(true) {
			while(e.botX != e.prev.botX || e.botY != e.prev.botY || e.currX == e.topX && e.currY == e.topY) e = e.next;
			if(e.dx != -9007199254740992. && e.prev.dx != -9007199254740992.) {
				break;
			}
			while(e.prev.dx == -9007199254740992.) e = e.prev;
			e2 = e;
			while(e.dx == -9007199254740992.) e = e.next;
			if(e.topY == e.prev.botY) {
				continue;
			}
			if(e2.prev.botX < e.botX) {
				e = e2;
			}
			break;
		}
		return e;
	}
	,ProcessBound: function(E,LeftBoundIsForward) {
		var EStart;
		var Horz;
		var Result = E;
		if(Result.outIdx == -2) {
			E = Result;
			if(LeftBoundIsForward) {
				while(E.topY == E.next.botY) E = E.next;
				while(E != Result && E.dx == -9007199254740992.) E = E.prev;
			} else {
				while(E.topY == E.prev.botY) E = E.prev;
				while(E != Result && E.dx == -9007199254740992.) E = E.next;
			}
			if(E == Result) {
				if(LeftBoundIsForward) {
					Result = E.next;
				} else {
					Result = E.prev;
				}
			} else {
				if(LeftBoundIsForward) {
					E = Result.next;
				} else {
					E = Result.prev;
				}
				var locMin = new hxd_clipper__$Clipper_LocalMinima();
				locMin.next = null;
				locMin.y = E.botY;
				locMin.leftBound = null;
				locMin.rightBound = E;
				E.windDelta = 0;
				Result = this.ProcessBound(E,LeftBoundIsForward);
				this.InsertLocalMinima(locMin);
			}
			return Result;
		}
		if(E.dx == -9007199254740992.) {
			if(LeftBoundIsForward) {
				EStart = E.prev;
			} else {
				EStart = E.next;
			}
			if(EStart.outIdx != -2) {
				if(EStart.dx == -9007199254740992.) {
					if(EStart.botX != E.botX && EStart.topX != E.botX) {
						this.ReverseHorizontal(E);
					}
				} else if(EStart.botX != E.botX) {
					this.ReverseHorizontal(E);
				}
			}
		}
		EStart = E;
		if(LeftBoundIsForward) {
			while(Result.topY == Result.next.botY && Result.next.outIdx != -2) Result = Result.next;
			if(Result.dx == -9007199254740992. && Result.next.outIdx != -2) {
				Horz = Result;
				while(Horz.prev.dx == -9007199254740992.) Horz = Horz.prev;
				if(Horz.prev.topX == Result.next.topX) {
					if(!LeftBoundIsForward) {
						Result = Horz.prev;
					}
				} else if(Horz.prev.topX > Result.next.topX) {
					Result = Horz.prev;
				}
			}
			while(E != Result) {
				E.nextInLML = E.next;
				if(E.dx == -9007199254740992. && E != EStart && E.botX != E.prev.topX) {
					this.ReverseHorizontal(E);
				}
				E = E.next;
			}
			if(E.dx == -9007199254740992. && E != EStart && E.botX != E.prev.topX) {
				this.ReverseHorizontal(E);
			}
			Result = Result.next;
		} else {
			while(Result.topY == Result.prev.botY && Result.prev.outIdx != -2) Result = Result.prev;
			if(Result.dx == -9007199254740992. && Result.prev.outIdx != -2) {
				Horz = Result;
				while(Horz.next.dx == -9007199254740992.) Horz = Horz.next;
				if(Horz.next.topX == Result.prev.topX) {
					if(!LeftBoundIsForward) {
						Result = Horz.next;
					}
				} else if(Horz.next.topX > Result.prev.topX) {
					Result = Horz.next;
				}
			}
			while(E != Result) {
				E.nextInLML = E.prev;
				if(E.dx == -9007199254740992. && E != EStart && E.botX != E.next.topX) {
					this.ReverseHorizontal(E);
				}
				E = E.prev;
			}
			if(E.dx == -9007199254740992. && E != EStart && E.botX != E.next.topX) {
				this.ReverseHorizontal(E);
			}
			Result = Result.prev;
		}
		return Result;
	}
	,ReverseHorizontal: function(e) {
		var tmp = e.topX;
		e.topX = e.botX;
		e.botX = tmp;
	}
	,Pt2IsBetweenPt1AndPt3: function(pt1,pt2,pt3) {
		if(pt1.x == pt3.x && pt1.y == pt3.y || pt1.x == pt2.x && pt1.y == pt2.y || pt3.x == pt2.x && pt3.y == pt2.y) {
			return false;
		} else if(pt1.x != pt3.x) {
			return pt2.x > pt1.x == pt2.x < pt3.x;
		} else {
			return pt2.y > pt1.y == pt2.y < pt3.y;
		}
	}
	,SetDx: function(e) {
		e.deltaX = e.topX - e.botX;
		e.deltaY = e.topY - e.botY;
		if(e.deltaY == 0) {
			e.dx = -9007199254740992.;
		} else {
			e.dx = e.deltaX / e.deltaY;
		}
	}
	,InsertLocalMinima: function(newLm) {
		if(this.m_MinimaList == null) {
			this.m_MinimaList = newLm;
		} else if(newLm.y >= this.m_MinimaList.y) {
			newLm.next = this.m_MinimaList;
			this.m_MinimaList = newLm;
		} else {
			var tmpLm = this.m_MinimaList;
			while(tmpLm.next != null && newLm.y < tmpLm.next.y) tmpLm = tmpLm.next;
			newLm.next = tmpLm.next;
			tmpLm.next = newLm;
		}
	}
	,PopLocalMinima: function() {
		if(this.m_CurrentLM == null) {
			return;
		}
		this.m_CurrentLM = this.m_CurrentLM.next;
	}
	,SwapX: function(e) {
		e.currX = e.topX;
		e.topX = e.botX;
		e.botX = e.currX;
	}
	,equals: function(pt1,pt2) {
		if(pt1.x == pt2.x) {
			return pt1.y == pt2.y;
		} else {
			return false;
		}
	}
	,Reset: function() {
		this.m_CurrentLM = this.m_MinimaList;
		var lm = this.m_MinimaList;
		while(lm != null) {
			var e = lm.leftBound;
			if(e != null) {
				e.currX = e.botX;
				e.currY = e.botY;
				e.side = hxd_clipper__$Clipper_EdgeSide.Left;
				e.outIdx = -1;
				e = e.nextInLML;
			}
			e = lm.rightBound;
			if(e != null) {
				e.currX = e.botX;
				e.currY = e.botY;
				e.side = hxd_clipper__$Clipper_EdgeSide.Right;
				e.outIdx = -1;
				e = e.nextInLML;
			}
			lm = lm.next;
		}
	}
	,__class__: hxd_clipper__$Clipper_ClipperBase
};
var hxd_clipper_NodeType = $hxEnums["hxd.clipper.NodeType"] = { __ename__:true,__constructs__:null
	,Any: {_hx_name:"Any",_hx_index:0,__enum__:"hxd.clipper.NodeType",toString:$estr}
	,Open: {_hx_name:"Open",_hx_index:1,__enum__:"hxd.clipper.NodeType",toString:$estr}
	,Closed: {_hx_name:"Closed",_hx_index:2,__enum__:"hxd.clipper.NodeType",toString:$estr}
};
hxd_clipper_NodeType.__constructs__ = [hxd_clipper_NodeType.Any,hxd_clipper_NodeType.Open,hxd_clipper_NodeType.Closed];
hxd_clipper_NodeType.__empty_constructs__ = [hxd_clipper_NodeType.Any,hxd_clipper_NodeType.Open,hxd_clipper_NodeType.Closed];
var hxd_clipper_ResultKind = $hxEnums["hxd.clipper.ResultKind"] = { __ename__:true,__constructs__:null
	,All: {_hx_name:"All",_hx_index:0,__enum__:"hxd.clipper.ResultKind",toString:$estr}
	,NoHoles: {_hx_name:"NoHoles",_hx_index:1,__enum__:"hxd.clipper.ResultKind",toString:$estr}
	,HolesOnly: {_hx_name:"HolesOnly",_hx_index:2,__enum__:"hxd.clipper.ResultKind",toString:$estr}
};
hxd_clipper_ResultKind.__constructs__ = [hxd_clipper_ResultKind.All,hxd_clipper_ResultKind.NoHoles,hxd_clipper_ResultKind.HolesOnly];
hxd_clipper_ResultKind.__empty_constructs__ = [hxd_clipper_ResultKind.All,hxd_clipper_ResultKind.NoHoles,hxd_clipper_ResultKind.HolesOnly];
var hxd_clipper_Clipper = function() {
	hxd_clipper__$Clipper_ClipperBase.call(this);
	this.m_Scanbeam = null;
	this.m_ActiveEdges = null;
	this.m_SortedEdges = null;
	this.m_IntersectList = [];
	this.m_ExecuteLocked = false;
	this.m_UsingPolyTree = false;
	this.m_PolyOuts = [];
	this.m_Joins = [];
	this.m_GhostJoins = [];
	this.reverseSolution = false;
	this.strictlySimple = false;
	this.preserveCollinear = false;
	this.resultKind = hxd_clipper_ResultKind.All;
};
$hxClasses["hxd.clipper.Clipper"] = hxd_clipper_Clipper;
hxd_clipper_Clipper.__name__ = "hxd.clipper.Clipper";
hxd_clipper_Clipper.compareY = function(n1,n2) {
	if(n2.pt.y - n1.pt.y >= 0) {
		return 1;
	} else {
		return -1;
	}
};
hxd_clipper_Clipper.Orientation = function(poly) {
	return hxd_clipper_Clipper.polArea(poly) >= 0;
};
hxd_clipper_Clipper.polArea = function(poly) {
	var cnt = poly.length;
	if(cnt < 3) {
		return 0.;
	}
	var a = 0.;
	var j = cnt - 1;
	var _g = 0;
	var _g1 = cnt;
	while(_g < _g1) {
		var i = _g++;
		a += (poly[j].x + poly[i].x) * (poly[j].y - poly[i].y);
		j = i;
	}
	return -a * 0.5;
};
hxd_clipper_Clipper.SimplifyPolygon = function(poly,fillType) {
	if(fillType == null) {
		fillType = hxd_clipper_PolyFillType.EvenOdd;
	}
	var c = new hxd_clipper_Clipper();
	c.strictlySimple = true;
	c.addPolygon(poly,hxd_clipper_PolyType.Subject);
	return c.execute(hxd_clipper_ClipType.Union,fillType,fillType);
};
hxd_clipper_Clipper.SimplifyPolygons = function(polys,fillType) {
	if(fillType == null) {
		fillType = hxd_clipper_PolyFillType.EvenOdd;
	}
	var c = new hxd_clipper_Clipper();
	c.strictlySimple = true;
	c.addPolygons(polys,hxd_clipper_PolyType.Subject);
	return c.execute(hxd_clipper_ClipType.Union,fillType,fillType);
};
hxd_clipper_Clipper.MinkowskiSums = function(pattern,pols,kind) {
	var c = new hxd_clipper_Clipper();
	c.resultKind = kind == null ? hxd_clipper_ResultKind.All : kind;
	var _g = 0;
	var _g1 = pols.length;
	while(_g < _g1) {
		var i = _g++;
		var tmp = c.Minkowski(pattern,pols[i],true);
		c.addPolygons(tmp,hxd_clipper_PolyType.Subject);
		var path = c.TranslatePath(pols[i],pattern[0]);
		c.addPolygon(path,hxd_clipper_PolyType.Clip);
	}
	return c.execute(hxd_clipper_ClipType.Union,hxd_clipper_PolyFillType.NonZero,hxd_clipper_PolyFillType.NonZero);
};
hxd_clipper_Clipper.MinkowskiDiff = function(pattern,pol,kind) {
	var c = new hxd_clipper_Clipper();
	var paths = c.Minkowski(pattern,pol,false);
	c.resultKind = kind == null ? hxd_clipper_ResultKind.All : kind;
	c.addPolygons(paths,hxd_clipper_PolyType.Subject);
	return c.execute(hxd_clipper_ClipType.Union,hxd_clipper_PolyFillType.NonZero,hxd_clipper_PolyFillType.NonZero);
};
hxd_clipper_Clipper.__super__ = hxd_clipper__$Clipper_ClipperBase;
hxd_clipper_Clipper.prototype = $extend(hxd_clipper__$Clipper_ClipperBase.prototype,{
	xor: function(a,b) {
		if(a) {
			return !b;
		} else {
			return b;
		}
	}
	,DisposeScanbeamList: function() {
		while(this.m_Scanbeam != null) {
			var sb2 = this.m_Scanbeam.next;
			this.m_Scanbeam = null;
			this.m_Scanbeam = sb2;
		}
	}
	,Reset: function() {
		hxd_clipper__$Clipper_ClipperBase.prototype.Reset.call(this);
		this.m_Scanbeam = null;
		this.m_ActiveEdges = null;
		this.m_SortedEdges = null;
		var lm = this.m_MinimaList;
		while(lm != null) {
			this.InsertScanbeam(lm.y);
			lm = lm.next;
		}
	}
	,InsertScanbeam: function(y) {
		if(this.m_Scanbeam == null) {
			this.m_Scanbeam = new hxd_clipper__$Clipper_Scanbeam();
			this.m_Scanbeam.next = null;
			this.m_Scanbeam.y = y;
		} else if(y > this.m_Scanbeam.y) {
			var newSb = new hxd_clipper__$Clipper_Scanbeam();
			newSb.y = y;
			newSb.next = this.m_Scanbeam;
			this.m_Scanbeam = newSb;
		} else {
			var sb2 = this.m_Scanbeam;
			while(sb2.next != null && y <= sb2.next.y) sb2 = sb2.next;
			if(y == sb2.y) {
				return;
			}
			var newSb = new hxd_clipper__$Clipper_Scanbeam();
			newSb.y = y;
			newSb.next = sb2.next;
			sb2.next = newSb;
		}
	}
	,execute: function(clipType,subjFillType,clipFillType) {
		if(subjFillType == null) {
			subjFillType = hxd_clipper_PolyFillType.EvenOdd;
		}
		if(clipFillType == null) {
			clipFillType = hxd_clipper_PolyFillType.EvenOdd;
		}
		if(this.m_ExecuteLocked) {
			return [];
		}
		this.m_ExecuteLocked = true;
		var solution = [];
		this.m_SubjFillType = subjFillType;
		this.m_ClipFillType = clipFillType;
		this.m_ClipType = clipType;
		this.m_UsingPolyTree = false;
		var succeeded = this.ExecuteInternal();
		if(succeeded) {
			solution = this.BuildResult();
		}
		this.DisposeAllPolyPts();
		this.m_ExecuteLocked = false;
		return solution;
	}
	,ExecuteTree: function(clipType,polytree,subjFillType,clipFillType) {
		if(subjFillType == null) {
			subjFillType = hxd_clipper_PolyFillType.EvenOdd;
		}
		if(clipFillType == null) {
			clipFillType = hxd_clipper_PolyFillType.EvenOdd;
		}
		if(this.m_ExecuteLocked) {
			return false;
		}
		this.m_ExecuteLocked = true;
		this.m_SubjFillType = subjFillType;
		this.m_ClipFillType = clipFillType;
		this.m_ClipType = clipType;
		this.m_UsingPolyTree = true;
		var succeeded = this.ExecuteInternal();
		if(succeeded) {
			this.BuildResult2(polytree);
		}
		this.m_ExecuteLocked = false;
		return succeeded;
	}
	,FixHoleLinkage: function(outRec) {
		if(outRec.firstLeft == null || outRec.isHole != outRec.firstLeft.isHole && outRec.firstLeft.pts != null) {
			return;
		}
		var orfl = outRec.firstLeft;
		while(orfl != null && (orfl.isHole == outRec.isHole || orfl.pts == null)) orfl = orfl.firstLeft;
		outRec.firstLeft = orfl;
	}
	,ExecuteInternal: function() {
		this.Reset();
		if(this.m_CurrentLM == null) {
			return false;
		}
		var botY = this.PopScanbeam();
		do {
			this.InsertLocalMinimaIntoAEL(botY);
			if(this.m_GhostJoins.length > 0) {
				this.m_GhostJoins = [];
			}
			this.ProcessHorizontals(false);
			if(this.m_Scanbeam == null) {
				break;
			}
			var topY = this.PopScanbeam();
			if(!this.ProcessIntersections(topY)) {
				return false;
			}
			this.ProcessEdgesAtTopOfScanbeam(topY);
			botY = topY;
		} while(this.m_Scanbeam != null || this.m_CurrentLM != null);
		var _g = 0;
		var _g1 = this.m_PolyOuts;
		while(_g < _g1.length) {
			var outRec = _g1[_g];
			++_g;
			if(outRec.pts == null) {
				continue;
			}
			var b = this.reverseSolution;
			if((outRec.isHole ? !b : b) == this.Area(outRec) > 0) {
				this.ReversePolyPtLinks(outRec.pts);
			}
		}
		this.JoinCommonEdges();
		var _g = 0;
		var _g1 = this.m_PolyOuts;
		while(_g < _g1.length) {
			var outRec = _g1[_g];
			++_g;
			if(outRec.pts != null) {
				this.FixupOutPolygon(outRec);
			}
		}
		if(this.strictlySimple) {
			this.DoSimplePolygons();
		}
		this.m_Joins = [];
		this.m_GhostJoins = [];
		return true;
	}
	,PopScanbeam: function() {
		var y = this.m_Scanbeam.y;
		this.m_Scanbeam = this.m_Scanbeam.next;
		return y;
	}
	,DisposeAllPolyPts: function() {
		var _g = 0;
		var _g1 = this.m_PolyOuts.length;
		while(_g < _g1) {
			var i = _g++;
			this.DisposeOutRec(i);
		}
		this.m_PolyOuts = [];
	}
	,DisposeOutRec: function(index) {
		var outRec = this.m_PolyOuts[index];
		outRec.pts = null;
		outRec = null;
		this.m_PolyOuts[index] = null;
	}
	,AddJoin: function(op1,op2,offPt) {
		var j = new hxd_clipper__$Clipper_Join();
		j.outPt1 = op1;
		j.outPt2 = op2;
		j.offPt = offPt;
		this.m_Joins.push(j);
	}
	,AddGhostJoin: function(op,offPt) {
		var j = new hxd_clipper__$Clipper_Join();
		j.outPt1 = op;
		j.offPt = offPt;
		this.m_GhostJoins.push(j);
	}
	,InsertLocalMinimaIntoAEL: function(botY) {
		while(this.m_CurrentLM != null && this.m_CurrentLM.y == botY) {
			var lb = this.m_CurrentLM.leftBound;
			var rb = this.m_CurrentLM.rightBound;
			this.PopLocalMinima();
			var op1 = null;
			if(lb == null) {
				this.InsertEdgeIntoAEL(rb);
				this.SetWindingCount(rb);
				if(this.IsContributing(rb)) {
					op1 = this.AddOutPt(rb,new h2d_col_IPoint(rb.botX,rb.botY));
				}
			} else if(rb == null) {
				this.InsertEdgeIntoAEL(lb);
				this.SetWindingCount(lb);
				if(this.IsContributing(lb)) {
					op1 = this.AddOutPt(lb,new h2d_col_IPoint(lb.botX,lb.botY));
				}
				this.InsertScanbeam(lb.topY);
			} else {
				this.InsertEdgeIntoAEL(lb);
				this.InsertEdgeIntoAEL(rb,lb);
				this.SetWindingCount(lb);
				rb.windCnt = lb.windCnt;
				rb.windCnt2 = lb.windCnt2;
				if(this.IsContributing(lb)) {
					op1 = this.AddLocalMinPoly(lb,rb,new h2d_col_IPoint(lb.botX,lb.botY));
				}
				this.InsertScanbeam(lb.topY);
			}
			if(rb != null) {
				if(rb.deltaY == 0) {
					this.AddEdgeToSEL(rb);
				} else {
					this.InsertScanbeam(rb.topY);
				}
			}
			if(lb == null || rb == null) {
				continue;
			}
			if(op1 != null && rb.deltaY == 0 && this.m_GhostJoins.length > 0 && rb.windDelta != 0) {
				var _g = 0;
				var _g1 = this.m_GhostJoins;
				while(_g < _g1.length) {
					var j = _g1[_g];
					++_g;
					if(this.HorzSegmentsOverlap(j.outPt1.pt.x,j.offPt.x,rb.botX,rb.topX)) {
						this.AddJoin(j.outPt1,op1,j.offPt);
					}
				}
			}
			var tmp;
			if(lb.outIdx >= 0 && lb.prevInAEL != null && lb.prevInAEL.currX == lb.botX && lb.prevInAEL.outIdx >= 0) {
				var e1 = lb.prevInAEL;
				tmp = e1.deltaY * lb.deltaX == e1.deltaX * lb.deltaY;
			} else {
				tmp = false;
			}
			if(tmp && lb.windDelta != 0 && lb.prevInAEL.windDelta != 0) {
				var op2 = this.AddOutPt(lb.prevInAEL,new h2d_col_IPoint(lb.botX,lb.botY));
				this.AddJoin(op1,op2,new h2d_col_IPoint(lb.topX,lb.topY));
			}
			if(lb.nextInAEL != rb) {
				var tmp1;
				if(rb.outIdx >= 0 && rb.prevInAEL.outIdx >= 0) {
					var e11 = rb.prevInAEL;
					tmp1 = e11.deltaY * rb.deltaX == e11.deltaX * rb.deltaY;
				} else {
					tmp1 = false;
				}
				if(tmp1 && rb.windDelta != 0 && rb.prevInAEL.windDelta != 0) {
					var op21 = this.AddOutPt(rb.prevInAEL,new h2d_col_IPoint(rb.botX,rb.botY));
					this.AddJoin(op1,op21,new h2d_col_IPoint(rb.topX,rb.topY));
				}
				var e = lb.nextInAEL;
				if(e != null) {
					while(e != rb) {
						this.IntersectEdges(rb,e,new h2d_col_IPoint(lb.currX,lb.currY));
						e = e.nextInAEL;
					}
				}
			}
		}
	}
	,InsertEdgeIntoAEL: function(edge,startEdge) {
		if(this.m_ActiveEdges == null) {
			edge.prevInAEL = null;
			edge.nextInAEL = null;
			this.m_ActiveEdges = edge;
		} else if(startEdge == null && this.E2InsertsBeforeE1(this.m_ActiveEdges,edge)) {
			edge.prevInAEL = null;
			edge.nextInAEL = this.m_ActiveEdges;
			this.m_ActiveEdges.prevInAEL = edge;
			this.m_ActiveEdges = edge;
		} else {
			if(startEdge == null) {
				startEdge = this.m_ActiveEdges;
			}
			while(startEdge.nextInAEL != null && !this.E2InsertsBeforeE1(startEdge.nextInAEL,edge)) startEdge = startEdge.nextInAEL;
			edge.nextInAEL = startEdge.nextInAEL;
			if(startEdge.nextInAEL != null) {
				startEdge.nextInAEL.prevInAEL = edge;
			}
			edge.prevInAEL = startEdge;
			startEdge.nextInAEL = edge;
		}
	}
	,E2InsertsBeforeE1: function(e1,e2) {
		if(e2.currX == e1.currX) {
			if(e2.topY > e1.topY) {
				var currentY = e2.topY;
				var tmp;
				if(currentY == e1.topY) {
					tmp = e1.topX;
				} else {
					var value = e1.dx * (currentY - e1.botY);
					tmp = e1.botX + (value < 0 ? value - 0.5 | 0 : value + 0.5 | 0);
				}
				return e2.topX < tmp;
			} else {
				var currentY = e1.topY;
				var tmp;
				if(currentY == e2.topY) {
					tmp = e2.topX;
				} else {
					var value = e2.dx * (currentY - e2.botY);
					tmp = e2.botX + (value < 0 ? value - 0.5 | 0 : value + 0.5 | 0);
				}
				return e1.topX > tmp;
			}
		} else {
			return e2.currX < e1.currX;
		}
	}
	,IsEvenOddFillType: function(edge) {
		if(edge.polyType == hxd_clipper_PolyType.Subject) {
			return this.m_SubjFillType == hxd_clipper_PolyFillType.EvenOdd;
		} else {
			return this.m_ClipFillType == hxd_clipper_PolyFillType.EvenOdd;
		}
	}
	,IsEvenOddAltFillType: function(edge) {
		if(edge.polyType == hxd_clipper_PolyType.Subject) {
			return this.m_ClipFillType == hxd_clipper_PolyFillType.EvenOdd;
		} else {
			return this.m_SubjFillType == hxd_clipper_PolyFillType.EvenOdd;
		}
	}
	,IsContributing: function(edge) {
		var pft;
		var pft2;
		if(edge.polyType == hxd_clipper_PolyType.Subject) {
			pft = this.m_SubjFillType;
			pft2 = this.m_ClipFillType;
		} else {
			pft = this.m_ClipFillType;
			pft2 = this.m_SubjFillType;
		}
		switch(pft._hx_index) {
		case 0:
			if(edge.windDelta == 0 && edge.windCnt != 1) {
				return false;
			}
			break;
		case 1:
			var f = edge.windCnt;
			if((f < 0 ? -f : f) != 1) {
				return false;
			}
			break;
		case 2:
			if(edge.windCnt != 1) {
				return false;
			}
			break;
		default:
			if(edge.windCnt != -1) {
				return false;
			}
		}
		switch(this.m_ClipType._hx_index) {
		case 0:
			switch(pft2._hx_index) {
			case 0:case 1:
				return edge.windCnt2 != 0;
			case 2:
				return edge.windCnt2 > 0;
			default:
				return edge.windCnt2 < 0;
			}
			break;
		case 1:
			switch(pft2._hx_index) {
			case 0:case 1:
				return edge.windCnt2 == 0;
			case 2:
				return edge.windCnt2 <= 0;
			default:
				return edge.windCnt2 >= 0;
			}
			break;
		case 2:
			if(edge.polyType == hxd_clipper_PolyType.Subject) {
				switch(pft2._hx_index) {
				case 0:case 1:
					return edge.windCnt2 == 0;
				case 2:
					return edge.windCnt2 <= 0;
				default:
					return edge.windCnt2 >= 0;
				}
			} else {
				switch(pft2._hx_index) {
				case 0:case 1:
					return edge.windCnt2 != 0;
				case 2:
					return edge.windCnt2 > 0;
				default:
					return edge.windCnt2 < 0;
				}
			}
			break;
		case 3:
			if(edge.windDelta == 0) {
				switch(pft2._hx_index) {
				case 0:case 1:
					return edge.windCnt2 == 0;
				case 2:
					return edge.windCnt2 <= 0;
				default:
					return edge.windCnt2 >= 0;
				}
			} else {
				return true;
			}
			break;
		}
	}
	,SetWindingCount: function(edge) {
		var e = edge.prevInAEL;
		while(e != null && (e.polyType != edge.polyType || e.windDelta == 0)) e = e.prevInAEL;
		if(e == null) {
			edge.windCnt = edge.windDelta == 0 ? 1 : edge.windDelta;
			edge.windCnt2 = 0;
			e = this.m_ActiveEdges;
		} else if(edge.windDelta == 0 && this.m_ClipType != hxd_clipper_ClipType.Union) {
			edge.windCnt = 1;
			edge.windCnt2 = e.windCnt2;
			e = e.nextInAEL;
		} else if(edge.polyType == hxd_clipper_PolyType.Subject ? this.m_SubjFillType == hxd_clipper_PolyFillType.EvenOdd : this.m_ClipFillType == hxd_clipper_PolyFillType.EvenOdd) {
			if(edge.windDelta == 0) {
				var Inside = true;
				var e2 = e.prevInAEL;
				while(e2 != null) {
					if(e2.polyType == e.polyType && e2.windDelta != 0) {
						Inside = !Inside;
					}
					e2 = e2.prevInAEL;
				}
				edge.windCnt = Inside ? 0 : 1;
			} else {
				edge.windCnt = edge.windDelta;
			}
			edge.windCnt2 = e.windCnt2;
			e = e.nextInAEL;
		} else {
			if(e.windCnt * e.windDelta < 0) {
				if(e.windCnt > 1 || e.windCnt < -1) {
					if(e.windDelta * edge.windDelta < 0) {
						edge.windCnt = e.windCnt;
					} else {
						edge.windCnt = e.windCnt + edge.windDelta;
					}
				} else {
					edge.windCnt = edge.windDelta == 0 ? 1 : edge.windDelta;
				}
			} else if(edge.windDelta == 0) {
				edge.windCnt = e.windCnt < 0 ? e.windCnt - 1 : e.windCnt + 1;
			} else if(e.windDelta * edge.windDelta < 0) {
				edge.windCnt = e.windCnt;
			} else {
				edge.windCnt = e.windCnt + edge.windDelta;
			}
			edge.windCnt2 = e.windCnt2;
			e = e.nextInAEL;
		}
		if(edge.polyType == hxd_clipper_PolyType.Subject ? this.m_ClipFillType == hxd_clipper_PolyFillType.EvenOdd : this.m_SubjFillType == hxd_clipper_PolyFillType.EvenOdd) {
			while(e != edge) {
				if(e.windDelta != 0) {
					edge.windCnt2 = edge.windCnt2 == 0 ? 1 : 0;
				}
				e = e.nextInAEL;
			}
		} else {
			while(e != edge) {
				edge.windCnt2 += e.windDelta;
				e = e.nextInAEL;
			}
		}
	}
	,AddEdgeToSEL: function(edge) {
		if(this.m_SortedEdges == null) {
			this.m_SortedEdges = edge;
			edge.prevInSEL = null;
			edge.nextInSEL = null;
		} else {
			edge.nextInSEL = this.m_SortedEdges;
			edge.prevInSEL = null;
			this.m_SortedEdges.prevInSEL = edge;
			this.m_SortedEdges = edge;
		}
	}
	,CopyAELToSEL: function() {
		var e = this.m_ActiveEdges;
		this.m_SortedEdges = e;
		while(e != null) {
			e.prevInSEL = e.prevInAEL;
			e.nextInSEL = e.nextInAEL;
			e = e.nextInAEL;
		}
	}
	,SwapPositionsInAEL: function(edge1,edge2) {
		if(edge1.nextInAEL == edge1.prevInAEL || edge2.nextInAEL == edge2.prevInAEL) {
			return;
		}
		if(edge1.nextInAEL == edge2) {
			var next = edge2.nextInAEL;
			if(next != null) {
				next.prevInAEL = edge1;
			}
			var prev = edge1.prevInAEL;
			if(prev != null) {
				prev.nextInAEL = edge2;
			}
			edge2.prevInAEL = prev;
			edge2.nextInAEL = edge1;
			edge1.prevInAEL = edge2;
			edge1.nextInAEL = next;
		} else if(edge2.nextInAEL == edge1) {
			var next = edge1.nextInAEL;
			if(next != null) {
				next.prevInAEL = edge2;
			}
			var prev = edge2.prevInAEL;
			if(prev != null) {
				prev.nextInAEL = edge1;
			}
			edge1.prevInAEL = prev;
			edge1.nextInAEL = edge2;
			edge2.prevInAEL = edge1;
			edge2.nextInAEL = next;
		} else {
			var next = edge1.nextInAEL;
			var prev = edge1.prevInAEL;
			edge1.nextInAEL = edge2.nextInAEL;
			if(edge1.nextInAEL != null) {
				edge1.nextInAEL.prevInAEL = edge1;
			}
			edge1.prevInAEL = edge2.prevInAEL;
			if(edge1.prevInAEL != null) {
				edge1.prevInAEL.nextInAEL = edge1;
			}
			edge2.nextInAEL = next;
			if(edge2.nextInAEL != null) {
				edge2.nextInAEL.prevInAEL = edge2;
			}
			edge2.prevInAEL = prev;
			if(edge2.prevInAEL != null) {
				edge2.prevInAEL.nextInAEL = edge2;
			}
		}
		if(edge1.prevInAEL == null) {
			this.m_ActiveEdges = edge1;
		} else if(edge2.prevInAEL == null) {
			this.m_ActiveEdges = edge2;
		}
	}
	,SwapPositionsInSEL: function(edge1,edge2) {
		if(edge1.nextInSEL == null && edge1.prevInSEL == null) {
			return;
		}
		if(edge2.nextInSEL == null && edge2.prevInSEL == null) {
			return;
		}
		if(edge1.nextInSEL == edge2) {
			var next = edge2.nextInSEL;
			if(next != null) {
				next.prevInSEL = edge1;
			}
			var prev = edge1.prevInSEL;
			if(prev != null) {
				prev.nextInSEL = edge2;
			}
			edge2.prevInSEL = prev;
			edge2.nextInSEL = edge1;
			edge1.prevInSEL = edge2;
			edge1.nextInSEL = next;
		} else if(edge2.nextInSEL == edge1) {
			var next = edge1.nextInSEL;
			if(next != null) {
				next.prevInSEL = edge2;
			}
			var prev = edge2.prevInSEL;
			if(prev != null) {
				prev.nextInSEL = edge1;
			}
			edge1.prevInSEL = prev;
			edge1.nextInSEL = edge2;
			edge2.prevInSEL = edge1;
			edge2.nextInSEL = next;
		} else {
			var next = edge1.nextInSEL;
			var prev = edge1.prevInSEL;
			edge1.nextInSEL = edge2.nextInSEL;
			if(edge1.nextInSEL != null) {
				edge1.nextInSEL.prevInSEL = edge1;
			}
			edge1.prevInSEL = edge2.prevInSEL;
			if(edge1.prevInSEL != null) {
				edge1.prevInSEL.nextInSEL = edge1;
			}
			edge2.nextInSEL = next;
			if(edge2.nextInSEL != null) {
				edge2.nextInSEL.prevInSEL = edge2;
			}
			edge2.prevInSEL = prev;
			if(edge2.prevInSEL != null) {
				edge2.prevInSEL.nextInSEL = edge2;
			}
		}
		if(edge1.prevInSEL == null) {
			this.m_SortedEdges = edge1;
		} else if(edge2.prevInSEL == null) {
			this.m_SortedEdges = edge2;
		}
	}
	,AddLocalMaxPoly: function(e1,e2,pt) {
		this.AddOutPt(e1,pt);
		if(e2.windDelta == 0) {
			this.AddOutPt(e2,pt);
		}
		if(e1.outIdx == e2.outIdx) {
			e1.outIdx = -1;
			e2.outIdx = -1;
		} else if(e1.outIdx < e2.outIdx) {
			this.AppendPolygon(e1,e2);
		} else {
			this.AppendPolygon(e2,e1);
		}
	}
	,AddLocalMinPoly: function(e1,e2,pt) {
		var result;
		var e;
		var prevE;
		if(e2.deltaY == 0 || e1.dx > e2.dx) {
			result = this.AddOutPt(e1,pt);
			e2.outIdx = e1.outIdx;
			e1.side = hxd_clipper__$Clipper_EdgeSide.Left;
			e2.side = hxd_clipper__$Clipper_EdgeSide.Right;
			e = e1;
			if(e.prevInAEL == e2) {
				prevE = e2.prevInAEL;
			} else {
				prevE = e.prevInAEL;
			}
		} else {
			result = this.AddOutPt(e2,pt);
			e1.outIdx = e2.outIdx;
			e1.side = hxd_clipper__$Clipper_EdgeSide.Right;
			e2.side = hxd_clipper__$Clipper_EdgeSide.Left;
			e = e2;
			if(e.prevInAEL == e1) {
				prevE = e1.prevInAEL;
			} else {
				prevE = e.prevInAEL;
			}
		}
		var tmp;
		if(prevE != null && prevE.outIdx >= 0) {
			var currentY = pt.y;
			var tmp1;
			if(currentY == prevE.topY) {
				tmp1 = prevE.topX;
			} else {
				var value = prevE.dx * (currentY - prevE.botY);
				tmp1 = prevE.botX + (value < 0 ? value - 0.5 | 0 : value + 0.5 | 0);
			}
			var currentY = pt.y;
			var tmp2;
			if(currentY == e.topY) {
				tmp2 = e.topX;
			} else {
				var value = e.dx * (currentY - e.botY);
				tmp2 = e.botX + (value < 0 ? value - 0.5 | 0 : value + 0.5 | 0);
			}
			tmp = tmp1 == tmp2;
		} else {
			tmp = false;
		}
		if(tmp && e.deltaY * prevE.deltaX == e.deltaX * prevE.deltaY && e.windDelta != 0 && prevE.windDelta != 0) {
			var out = this.AddOutPt(prevE,pt);
			this.AddJoin(result,out,new h2d_col_IPoint(e.topX,e.topY));
		}
		return result;
	}
	,CreateOutRec: function() {
		var result = new hxd_clipper__$Clipper_OutRec();
		result.idx = -1;
		result.isHole = false;
		result.firstLeft = null;
		result.pts = null;
		result.bottomPt = null;
		result.polyNode = null;
		this.m_PolyOuts.push(result);
		result.idx = this.m_PolyOuts.length - 1;
		return result;
	}
	,AddOutPt: function(e,pt) {
		var ToFront = e.side == hxd_clipper__$Clipper_EdgeSide.Left;
		if(e.outIdx < 0) {
			var outRec = this.CreateOutRec();
			var op = new hxd_clipper__$Clipper_OutPt();
			outRec.pts = op;
			op.idx = outRec.idx;
			op.pt = new h2d_col_IPoint(pt.x,pt.y);
			op.next = op;
			op.prev = op;
			this.SetHoleState(e,outRec);
			e.outIdx = outRec.idx;
			return op;
		} else {
			var outRec = this.m_PolyOuts[e.outIdx];
			var op = outRec.pts;
			var tmp;
			if(ToFront) {
				var pt2 = op.pt;
				tmp = pt.x == pt2.x && pt.y == pt2.y;
			} else {
				tmp = false;
			}
			if(tmp) {
				return op;
			} else {
				var tmp;
				if(!ToFront) {
					var pt2 = op.prev.pt;
					tmp = pt.x == pt2.x && pt.y == pt2.y;
				} else {
					tmp = false;
				}
				if(tmp) {
					return op.prev;
				}
			}
			var op2 = new hxd_clipper__$Clipper_OutPt();
			op2.idx = outRec.idx;
			op2.pt = new h2d_col_IPoint(pt.x,pt.y);
			op2.next = op;
			op2.prev = op.prev;
			op2.prev.next = op2;
			op.prev = op2;
			if(ToFront) {
				outRec.pts = op2;
			}
			return op2;
		}
	}
	,HorzSegmentsOverlap: function(seg1a,seg1b,seg2a,seg2b) {
		if(seg1a > seg1b) {
			var tmp = seg1a;
			seg1a = seg1b;
			seg1b = tmp;
		}
		if(seg2a > seg2b) {
			var tmp = seg2a;
			seg2a = seg2b;
			seg2b = tmp;
		}
		if(seg1a < seg2b) {
			return seg2a < seg1b;
		} else {
			return false;
		}
	}
	,SetHoleState: function(e,outRec) {
		var isHole = false;
		var e2 = e.prevInAEL;
		while(e2 != null) {
			if(e2.outIdx >= 0 && e2.windDelta != 0) {
				isHole = !isHole;
				if(outRec.firstLeft == null) {
					outRec.firstLeft = this.m_PolyOuts[e2.outIdx];
				}
			}
			e2 = e2.prevInAEL;
		}
		if(isHole) {
			outRec.isHole = true;
		}
	}
	,GetDx: function(pt1,pt2) {
		if(pt1.y == pt2.y) {
			return -9007199254740992.;
		} else {
			return (pt2.x - pt1.x) / (pt2.y - pt1.y);
		}
	}
	,FirstIsBottomPt: function(btmPt1,btmPt2) {
		var p = btmPt1.prev;
		while(true) {
			var pt1 = p.pt;
			var pt2 = btmPt1.pt;
			if(!(pt1.x == pt2.x && pt1.y == pt2.y && p != btmPt1)) {
				break;
			}
			p = p.prev;
		}
		var f = this.GetDx(btmPt1.pt,p.pt);
		var dx1p = f < 0 ? -f : f;
		p = btmPt1.next;
		while(true) {
			var pt1 = p.pt;
			var pt2 = btmPt1.pt;
			if(!(pt1.x == pt2.x && pt1.y == pt2.y && p != btmPt1)) {
				break;
			}
			p = p.next;
		}
		var f = this.GetDx(btmPt1.pt,p.pt);
		var dx1n = f < 0 ? -f : f;
		p = btmPt2.prev;
		while(true) {
			var pt1 = p.pt;
			var pt2 = btmPt2.pt;
			if(!(pt1.x == pt2.x && pt1.y == pt2.y && p != btmPt2)) {
				break;
			}
			p = p.prev;
		}
		var f = this.GetDx(btmPt2.pt,p.pt);
		var dx2p = f < 0 ? -f : f;
		p = btmPt2.next;
		while(true) {
			var pt1 = p.pt;
			var pt2 = btmPt2.pt;
			if(!(pt1.x == pt2.x && pt1.y == pt2.y && p != btmPt2)) {
				break;
			}
			p = p.next;
		}
		var f = this.GetDx(btmPt2.pt,p.pt);
		var dx2n = f < 0 ? -f : f;
		if(!(dx1p >= dx2p && dx1p >= dx2n)) {
			if(dx1n >= dx2p) {
				return dx1n >= dx2n;
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	,GetBottomPt: function(pp) {
		var dups = null;
		var p = pp.next;
		while(p != pp) {
			if(p.pt.y > pp.pt.y) {
				pp = p;
				dups = null;
			} else if(p.pt.y == pp.pt.y && p.pt.x <= pp.pt.x) {
				if(p.pt.x < pp.pt.x) {
					dups = null;
					pp = p;
				} else if(p.next != pp && p.prev != pp) {
					dups = p;
				}
			}
			p = p.next;
		}
		if(dups != null) {
			var n = 0;
			while(dups != p) {
				if(!this.FirstIsBottomPt(p,dups)) {
					pp = dups;
				}
				dups = dups.next;
				while(true) {
					var pt1 = dups.pt;
					var pt2 = pp.pt;
					if(pt1.x == pt2.x && pt1.y == pt2.y) {
						break;
					}
					dups = dups.next;
				}
			}
		}
		return pp;
	}
	,GetLowermostRec: function(outRec1,outRec2) {
		if(outRec1.bottomPt == null) {
			outRec1.bottomPt = this.GetBottomPt(outRec1.pts);
		}
		if(outRec2.bottomPt == null) {
			outRec2.bottomPt = this.GetBottomPt(outRec2.pts);
		}
		var bPt1 = outRec1.bottomPt;
		var bPt2 = outRec2.bottomPt;
		if(bPt1.pt.y > bPt2.pt.y) {
			return outRec1;
		} else if(bPt1.pt.y < bPt2.pt.y) {
			return outRec2;
		} else if(bPt1.pt.x < bPt2.pt.x) {
			return outRec1;
		} else if(bPt1.pt.x > bPt2.pt.x) {
			return outRec2;
		} else if(bPt1.next == bPt1) {
			return outRec2;
		} else if(bPt2.next == bPt2) {
			return outRec1;
		} else if(this.FirstIsBottomPt(bPt1,bPt2)) {
			return outRec1;
		} else {
			return outRec2;
		}
	}
	,Param1RightOfParam2: function(outRec1,outRec2) {
		do {
			outRec1 = outRec1.firstLeft;
			if(outRec1 == outRec2) {
				return true;
			}
		} while(outRec1 != null);
		return false;
	}
	,GetOutRec: function(idx) {
		var outrec = this.m_PolyOuts[idx];
		while(outrec != this.m_PolyOuts[outrec.idx]) outrec = this.m_PolyOuts[outrec.idx];
		return outrec;
	}
	,AppendPolygon: function(e1,e2) {
		var outRec1 = this.m_PolyOuts[e1.outIdx];
		var outRec2 = this.m_PolyOuts[e2.outIdx];
		var holeStateRec;
		if(this.Param1RightOfParam2(outRec1,outRec2)) {
			holeStateRec = outRec2;
		} else if(this.Param1RightOfParam2(outRec2,outRec1)) {
			holeStateRec = outRec1;
		} else {
			holeStateRec = this.GetLowermostRec(outRec1,outRec2);
		}
		var p1_lft = outRec1.pts;
		var p1_rt = p1_lft.prev;
		var p2_lft = outRec2.pts;
		var p2_rt = p2_lft.prev;
		var side;
		if(e1.side == hxd_clipper__$Clipper_EdgeSide.Left) {
			if(e2.side == hxd_clipper__$Clipper_EdgeSide.Left) {
				this.ReversePolyPtLinks(p2_lft);
				p2_lft.next = p1_lft;
				p1_lft.prev = p2_lft;
				p1_rt.next = p2_rt;
				p2_rt.prev = p1_rt;
				outRec1.pts = p2_rt;
			} else {
				p2_rt.next = p1_lft;
				p1_lft.prev = p2_rt;
				p2_lft.prev = p1_rt;
				p1_rt.next = p2_lft;
				outRec1.pts = p2_lft;
			}
			side = hxd_clipper__$Clipper_EdgeSide.Left;
		} else {
			if(e2.side == hxd_clipper__$Clipper_EdgeSide.Right) {
				this.ReversePolyPtLinks(p2_lft);
				p1_rt.next = p2_rt;
				p2_rt.prev = p1_rt;
				p2_lft.next = p1_lft;
				p1_lft.prev = p2_lft;
			} else {
				p1_rt.next = p2_lft;
				p2_lft.prev = p1_rt;
				p1_lft.prev = p2_rt;
				p2_rt.next = p1_lft;
			}
			side = hxd_clipper__$Clipper_EdgeSide.Right;
		}
		outRec1.bottomPt = null;
		if(holeStateRec == outRec2) {
			if(outRec2.firstLeft != outRec1) {
				outRec1.firstLeft = outRec2.firstLeft;
			}
			outRec1.isHole = outRec2.isHole;
		}
		outRec2.pts = null;
		outRec2.bottomPt = null;
		outRec2.firstLeft = outRec1;
		var OKIdx = e1.outIdx;
		var ObsoleteIdx = e2.outIdx;
		e1.outIdx = -1;
		e2.outIdx = -1;
		var e = this.m_ActiveEdges;
		while(e != null) {
			if(e.outIdx == ObsoleteIdx) {
				e.outIdx = OKIdx;
				e.side = side;
				break;
			}
			e = e.nextInAEL;
		}
		outRec2.idx = outRec1.idx;
	}
	,ReversePolyPtLinks: function(pp) {
		if(pp == null) {
			return;
		}
		var pp2;
		var pp1 = pp;
		do {
			pp2 = pp1.next;
			pp1.next = pp1.prev;
			pp1.prev = pp2;
			pp1 = pp2;
		} while(pp1 != pp);
	}
	,SwapSides: function(edge1,edge2) {
		var side = edge1.side;
		edge1.side = edge2.side;
		edge2.side = side;
	}
	,SwapPolyIndexes: function(edge1,edge2) {
		var outIdx = edge1.outIdx;
		edge1.outIdx = edge2.outIdx;
		edge2.outIdx = outIdx;
	}
	,IntersectEdges: function(e1,e2,pt) {
		var e1Contributing = e1.outIdx >= 0;
		var e2Contributing = e2.outIdx >= 0;
		if(e1.polyType == e2.polyType) {
			if(e1.polyType == hxd_clipper_PolyType.Subject ? this.m_SubjFillType == hxd_clipper_PolyFillType.EvenOdd : this.m_ClipFillType == hxd_clipper_PolyFillType.EvenOdd) {
				var oldE1WindCnt = e1.windCnt;
				e1.windCnt = e2.windCnt;
				e2.windCnt = oldE1WindCnt;
			} else {
				if(e1.windCnt + e2.windDelta == 0) {
					e1.windCnt = -e1.windCnt;
				} else {
					e1.windCnt += e2.windDelta;
				}
				if(e2.windCnt - e1.windDelta == 0) {
					e2.windCnt = -e2.windCnt;
				} else {
					e2.windCnt -= e1.windDelta;
				}
			}
		} else {
			if(!(e2.polyType == hxd_clipper_PolyType.Subject ? this.m_SubjFillType == hxd_clipper_PolyFillType.EvenOdd : this.m_ClipFillType == hxd_clipper_PolyFillType.EvenOdd)) {
				e1.windCnt2 += e2.windDelta;
			} else {
				e1.windCnt2 = e1.windCnt2 == 0 ? 1 : 0;
			}
			if(!(e1.polyType == hxd_clipper_PolyType.Subject ? this.m_SubjFillType == hxd_clipper_PolyFillType.EvenOdd : this.m_ClipFillType == hxd_clipper_PolyFillType.EvenOdd)) {
				e2.windCnt2 -= e1.windDelta;
			} else {
				e2.windCnt2 = e2.windCnt2 == 0 ? 1 : 0;
			}
		}
		var e1FillType;
		var e2FillType;
		var e1FillType2;
		var e2FillType2;
		if(e1.polyType == hxd_clipper_PolyType.Subject) {
			e1FillType = this.m_SubjFillType;
			e1FillType2 = this.m_ClipFillType;
		} else {
			e1FillType = this.m_ClipFillType;
			e1FillType2 = this.m_SubjFillType;
		}
		if(e2.polyType == hxd_clipper_PolyType.Subject) {
			e2FillType = this.m_SubjFillType;
			e2FillType2 = this.m_ClipFillType;
		} else {
			e2FillType = this.m_ClipFillType;
			e2FillType2 = this.m_SubjFillType;
		}
		var e1Wc;
		var e2Wc;
		switch(e1FillType._hx_index) {
		case 2:
			e1Wc = e1.windCnt;
			break;
		case 3:
			e1Wc = -e1.windCnt;
			break;
		default:
			var i = e1.windCnt;
			e1Wc = i < 0 ? -i : i;
		}
		switch(e2FillType._hx_index) {
		case 2:
			e2Wc = e2.windCnt;
			break;
		case 3:
			e2Wc = -e2.windCnt;
			break;
		default:
			var i = e2.windCnt;
			e2Wc = i < 0 ? -i : i;
		}
		if(e1Contributing && e2Contributing) {
			if(e1Wc != 0 && e1Wc != 1 || e2Wc != 0 && e2Wc != 1 || e1.polyType != e2.polyType && this.m_ClipType != hxd_clipper_ClipType.Xor) {
				this.AddLocalMaxPoly(e1,e2,pt);
			} else {
				this.AddOutPt(e1,pt);
				this.AddOutPt(e2,pt);
				var side = e1.side;
				e1.side = e2.side;
				e2.side = side;
				this.SwapPolyIndexes(e1,e2);
			}
		} else if(e1Contributing) {
			if(e2Wc == 0 || e2Wc == 1) {
				this.AddOutPt(e1,pt);
				var side = e1.side;
				e1.side = e2.side;
				e2.side = side;
				this.SwapPolyIndexes(e1,e2);
			}
		} else if(e2Contributing) {
			if(e1Wc == 0 || e1Wc == 1) {
				this.AddOutPt(e2,pt);
				var side = e1.side;
				e1.side = e2.side;
				e2.side = side;
				this.SwapPolyIndexes(e1,e2);
			}
		} else if((e1Wc == 0 || e1Wc == 1) && (e2Wc == 0 || e2Wc == 1)) {
			var e1Wc2;
			var e2Wc2;
			switch(e1FillType2._hx_index) {
			case 2:
				e1Wc2 = e1.windCnt2;
				break;
			case 3:
				e1Wc2 = -e1.windCnt2;
				break;
			default:
				var i = e1.windCnt2;
				e1Wc2 = i < 0 ? -i : i;
			}
			switch(e2FillType2._hx_index) {
			case 2:
				e2Wc2 = e2.windCnt2;
				break;
			case 3:
				e2Wc2 = -e2.windCnt2;
				break;
			default:
				var i = e2.windCnt2;
				e2Wc2 = i < 0 ? -i : i;
			}
			if(e1.polyType != e2.polyType) {
				this.AddLocalMinPoly(e1,e2,pt);
			} else if(e1Wc == 1 && e2Wc == 1) {
				switch(this.m_ClipType._hx_index) {
				case 0:
					if(e1Wc2 > 0 && e2Wc2 > 0) {
						this.AddLocalMinPoly(e1,e2,pt);
					}
					break;
				case 1:
					if(e1Wc2 <= 0 && e2Wc2 <= 0) {
						this.AddLocalMinPoly(e1,e2,pt);
					}
					break;
				case 2:
					if(e1.polyType == hxd_clipper_PolyType.Clip && e1Wc2 > 0 && e2Wc2 > 0 || e1.polyType == hxd_clipper_PolyType.Subject && e1Wc2 <= 0 && e2Wc2 <= 0) {
						this.AddLocalMinPoly(e1,e2,pt);
					}
					break;
				case 3:
					this.AddLocalMinPoly(e1,e2,pt);
					break;
				}
			} else {
				var side = e1.side;
				e1.side = e2.side;
				e2.side = side;
			}
		}
	}
	,DeleteFromAEL: function(e) {
		var AelPrev = e.prevInAEL;
		var AelNext = e.nextInAEL;
		if(AelPrev == null && AelNext == null && e != this.m_ActiveEdges) {
			return;
		}
		if(AelPrev != null) {
			AelPrev.nextInAEL = AelNext;
		} else {
			this.m_ActiveEdges = AelNext;
		}
		if(AelNext != null) {
			AelNext.prevInAEL = AelPrev;
		}
		e.nextInAEL = null;
		e.prevInAEL = null;
	}
	,DeleteFromSEL: function(e) {
		var SelPrev = e.prevInSEL;
		var SelNext = e.nextInSEL;
		if(SelPrev == null && SelNext == null && e != this.m_SortedEdges) {
			return;
		}
		if(SelPrev != null) {
			SelPrev.nextInSEL = SelNext;
		} else {
			this.m_SortedEdges = SelNext;
		}
		if(SelNext != null) {
			SelNext.prevInSEL = SelPrev;
		}
		e.nextInSEL = null;
		e.prevInSEL = null;
	}
	,UpdateEdgeIntoAEL: function(e) {
		if(e.nextInLML == null) {
			throw haxe_Exception.thrown("UpdateEdgeIntoAEL: invalid call");
		}
		var AelPrev = e.prevInAEL;
		var AelNext = e.nextInAEL;
		e.nextInLML.outIdx = e.outIdx;
		if(AelPrev != null) {
			AelPrev.nextInAEL = e.nextInLML;
		} else {
			this.m_ActiveEdges = e.nextInLML;
		}
		if(AelNext != null) {
			AelNext.prevInAEL = e.nextInLML;
		}
		e.nextInLML.side = e.side;
		e.nextInLML.windDelta = e.windDelta;
		e.nextInLML.windCnt = e.windCnt;
		e.nextInLML.windCnt2 = e.windCnt2;
		e = e.nextInLML;
		e.currX = e.botX;
		e.currY = e.botY;
		e.prevInAEL = AelPrev;
		e.nextInAEL = AelNext;
		if(e.deltaY != 0) {
			this.InsertScanbeam(e.topY);
		}
		return e;
	}
	,GetHorzDirection: function(HorzEdge) {
		if(HorzEdge.botX < HorzEdge.topX) {
			return { left : HorzEdge.botX, right : HorzEdge.topX, dir : hxd_clipper__$Clipper_Direction.LeftToRight};
		} else {
			return { left : HorzEdge.topX, right : HorzEdge.botX, dir : hxd_clipper__$Clipper_Direction.RightToLeft};
		}
	}
	,ProcessHorizontals: function(isTopOfScanbeam) {
		var horzEdge = this.m_SortedEdges;
		while(horzEdge != null) {
			this.DeleteFromSEL(horzEdge);
			this.ProcessHorizontal(horzEdge,isTopOfScanbeam);
			horzEdge = this.m_SortedEdges;
		}
	}
	,ProcessHorizontal: function(horzEdge,isTopOfScanbeam) {
		var res = this.GetHorzDirection(horzEdge);
		var dir = res.dir;
		var horzLeft = res.left;
		var horzRight = res.right;
		var eLastHorz = horzEdge;
		var eMaxPair = null;
		while(eLastHorz.nextInLML != null && eLastHorz.nextInLML.deltaY == 0) eLastHorz = eLastHorz.nextInLML;
		if(eLastHorz.nextInLML == null) {
			eMaxPair = this.GetMaximaPair(eLastHorz);
		}
		while(true) {
			var IsLastHorz = horzEdge == eLastHorz;
			var e = dir == hxd_clipper__$Clipper_Direction.LeftToRight ? horzEdge.nextInAEL : horzEdge.prevInAEL;
			while(e != null) {
				if(e.currX == horzEdge.topX && horzEdge.nextInLML != null && e.dx < horzEdge.nextInLML.dx) {
					break;
				}
				var eNext = dir == hxd_clipper__$Clipper_Direction.LeftToRight ? e.nextInAEL : e.prevInAEL;
				if(dir == hxd_clipper__$Clipper_Direction.LeftToRight && e.currX <= horzRight || dir == hxd_clipper__$Clipper_Direction.RightToLeft && e.currX >= horzLeft) {
					if(e == eMaxPair && IsLastHorz) {
						if(horzEdge.outIdx >= 0) {
							var op1 = this.AddOutPt(horzEdge,new h2d_col_IPoint(horzEdge.topX,horzEdge.topY));
							var eNextHorz = this.m_SortedEdges;
							while(eNextHorz != null) {
								if(eNextHorz.outIdx >= 0 && this.HorzSegmentsOverlap(horzEdge.botX,horzEdge.topX,eNextHorz.botX,eNextHorz.topX)) {
									var op2 = this.AddOutPt(eNextHorz,new h2d_col_IPoint(eNextHorz.botX,eNextHorz.botY));
									this.AddJoin(op2,op1,new h2d_col_IPoint(eNextHorz.topX,eNextHorz.topY));
								}
								eNextHorz = eNextHorz.nextInSEL;
							}
							this.AddGhostJoin(op1,new h2d_col_IPoint(horzEdge.botX,horzEdge.botY));
							this.AddLocalMaxPoly(horzEdge,eMaxPair,new h2d_col_IPoint(horzEdge.topX,horzEdge.topY));
						}
						this.DeleteFromAEL(horzEdge);
						this.DeleteFromAEL(eMaxPair);
						return;
					} else if(dir == hxd_clipper__$Clipper_Direction.LeftToRight) {
						var Pt = new h2d_col_IPoint(e.currX,horzEdge.currY);
						this.IntersectEdges(horzEdge,e,Pt);
					} else {
						var Pt1 = new h2d_col_IPoint(e.currX,horzEdge.currY);
						this.IntersectEdges(e,horzEdge,Pt1);
					}
					this.SwapPositionsInAEL(horzEdge,e);
				} else if(dir == hxd_clipper__$Clipper_Direction.LeftToRight && e.currX >= horzRight || dir == hxd_clipper__$Clipper_Direction.RightToLeft && e.currX <= horzLeft) {
					break;
				}
				e = eNext;
			}
			if(horzEdge.nextInLML != null && horzEdge.nextInLML.deltaY == 0) {
				horzEdge = this.UpdateEdgeIntoAEL(horzEdge);
				if(horzEdge.outIdx >= 0) {
					this.AddOutPt(horzEdge,new h2d_col_IPoint(horzEdge.botX,horzEdge.botY));
				}
				var out = this.GetHorzDirection(horzEdge);
				dir = out.dir;
				horzLeft = out.left;
				horzRight = out.right;
			} else {
				break;
			}
		}
		if(horzEdge.nextInLML != null) {
			if(horzEdge.outIdx >= 0) {
				var op1 = this.AddOutPt(horzEdge,new h2d_col_IPoint(horzEdge.topX,horzEdge.topY));
				if(isTopOfScanbeam) {
					this.AddGhostJoin(op1,new h2d_col_IPoint(horzEdge.botX,horzEdge.botY));
				}
				horzEdge = this.UpdateEdgeIntoAEL(horzEdge);
				if(horzEdge.windDelta == 0) {
					return;
				}
				var ePrev = horzEdge.prevInAEL;
				var eNext = horzEdge.nextInAEL;
				if(ePrev != null && ePrev.currX == horzEdge.botX && ePrev.currY == horzEdge.botY && ePrev.windDelta != 0 && (ePrev.outIdx >= 0 && ePrev.currY > ePrev.topY && horzEdge.deltaY * ePrev.deltaX == horzEdge.deltaX * ePrev.deltaY)) {
					var op2 = this.AddOutPt(ePrev,new h2d_col_IPoint(horzEdge.botX,horzEdge.botY));
					this.AddJoin(op1,op2,new h2d_col_IPoint(horzEdge.topX,horzEdge.topY));
				} else if(eNext != null && eNext.currX == horzEdge.botX && eNext.currY == horzEdge.botY && eNext.windDelta != 0 && eNext.outIdx >= 0 && eNext.currY > eNext.topY && horzEdge.deltaY * eNext.deltaX == horzEdge.deltaX * eNext.deltaY) {
					var op2 = this.AddOutPt(eNext,new h2d_col_IPoint(horzEdge.botX,horzEdge.botY));
					this.AddJoin(op1,op2,new h2d_col_IPoint(horzEdge.topX,horzEdge.topY));
				}
			} else {
				horzEdge = this.UpdateEdgeIntoAEL(horzEdge);
			}
		} else {
			if(horzEdge.outIdx >= 0) {
				this.AddOutPt(horzEdge,new h2d_col_IPoint(horzEdge.topX,horzEdge.topY));
			}
			this.DeleteFromAEL(horzEdge);
		}
	}
	,GetNextInAEL: function(e,dir) {
		if(dir == hxd_clipper__$Clipper_Direction.LeftToRight) {
			return e.nextInAEL;
		} else {
			return e.prevInAEL;
		}
	}
	,IsMinima: function(e) {
		if(e != null && e.prev.nextInLML != e) {
			return e.next.nextInLML != e;
		} else {
			return false;
		}
	}
	,IsMaxima: function(e,y) {
		if(e != null && e.topY == y) {
			return e.nextInLML == null;
		} else {
			return false;
		}
	}
	,IsIntermediate: function(e,y) {
		if(e.topY == y) {
			return e.nextInLML != null;
		} else {
			return false;
		}
	}
	,GetMaximaPair: function(e) {
		var result = null;
		if(e.next.topX == e.topX && e.next.topY == e.topY && e.next.nextInLML == null) {
			result = e.next;
		} else if(e.prev.topX == e.topX && e.prev.topY == e.topY && e.prev.nextInLML == null) {
			result = e.prev;
		}
		if(result != null && (result.outIdx == -2 || result.nextInAEL == result.prevInAEL && result.deltaY != 0)) {
			return null;
		}
		return result;
	}
	,ProcessIntersections: function(topY) {
		if(this.m_ActiveEdges == null) {
			return true;
		}
		this.BuildIntersectList(topY);
		if(this.m_IntersectList.length == 0) {
			return true;
		}
		if(this.m_IntersectList.length == 1 || this.FixupIntersectionOrder()) {
			this.ProcessIntersectList();
		} else {
			return false;
		}
		this.m_SortedEdges = null;
		return true;
	}
	,BuildIntersectList: function(topY) {
		if(this.m_ActiveEdges == null) {
			return;
		}
		var e = this.m_ActiveEdges;
		this.m_SortedEdges = e;
		while(e != null) {
			e.prevInSEL = e.prevInAEL;
			e.nextInSEL = e.nextInAEL;
			var tmp;
			if(topY == e.topY) {
				tmp = e.topX;
			} else {
				var value = e.dx * (topY - e.botY);
				tmp = e.botX + (value < 0 ? value - 0.5 | 0 : value + 0.5 | 0);
			}
			e.currX = tmp;
			e = e.nextInAEL;
		}
		var isModified = true;
		while(isModified && this.m_SortedEdges != null) {
			isModified = false;
			e = this.m_SortedEdges;
			while(e.nextInSEL != null) {
				var eNext = e.nextInSEL;
				var pt;
				if(e.currX > eNext.currX) {
					var ipx;
					var ipy;
					var b1;
					var b2;
					if(e.dx == eNext.dx) {
						ipy = e.currY;
						if(ipy == e.topY) {
							ipx = e.topX;
						} else {
							var value = e.dx * (ipy - e.botY);
							ipx = e.botX + (value < 0 ? value - 0.5 | 0 : value + 0.5 | 0);
						}
						pt = new h2d_col_IPoint(ipx,ipy);
					} else {
						if(e.deltaX == 0) {
							ipx = e.botX;
							if(eNext.deltaY == 0) {
								ipy = eNext.botY;
							} else {
								b2 = eNext.botY - eNext.botX / eNext.dx;
								var value1 = ipx / eNext.dx + b2;
								ipy = value1 < 0 ? value1 - 0.5 | 0 : value1 + 0.5 | 0;
							}
						} else if(eNext.deltaX == 0) {
							ipx = eNext.botX;
							if(e.deltaY == 0) {
								ipy = e.botY;
							} else {
								b1 = e.botY - e.botX / e.dx;
								var value2 = ipx / e.dx + b1;
								ipy = value2 < 0 ? value2 - 0.5 | 0 : value2 + 0.5 | 0;
							}
						} else {
							b1 = e.botX - e.botY * e.dx;
							b2 = eNext.botX - eNext.botY * eNext.dx;
							var q = (b2 - b1) / (e.dx - eNext.dx);
							ipy = q < 0 ? q - 0.5 | 0 : q + 0.5 | 0;
							var f = e.dx;
							var f1 = eNext.dx;
							if((f < 0 ? -f : f) < (f1 < 0 ? -f1 : f1)) {
								var value3 = e.dx * q + b1;
								ipx = value3 < 0 ? value3 - 0.5 | 0 : value3 + 0.5 | 0;
							} else {
								var value4 = eNext.dx * q + b2;
								ipx = value4 < 0 ? value4 - 0.5 | 0 : value4 + 0.5 | 0;
							}
						}
						if(ipy < e.topY || ipy < eNext.topY) {
							if(e.topY > eNext.topY) {
								ipy = e.topY;
							} else {
								ipy = eNext.topY;
							}
							var f2 = e.dx;
							var f3 = eNext.dx;
							if((f2 < 0 ? -f2 : f2) < (f3 < 0 ? -f3 : f3)) {
								if(ipy == e.topY) {
									ipx = e.topX;
								} else {
									var value5 = e.dx * (ipy - e.botY);
									ipx = e.botX + (value5 < 0 ? value5 - 0.5 | 0 : value5 + 0.5 | 0);
								}
							} else if(ipy == eNext.topY) {
								ipx = eNext.topX;
							} else {
								var value6 = eNext.dx * (ipy - eNext.botY);
								ipx = eNext.botX + (value6 < 0 ? value6 - 0.5 | 0 : value6 + 0.5 | 0);
							}
						}
						if(ipy > e.currY) {
							ipy = e.currY;
							var f4 = e.dx;
							var f5 = eNext.dx;
							if((f4 < 0 ? -f4 : f4) > (f5 < 0 ? -f5 : f5)) {
								if(ipy == eNext.topY) {
									ipx = eNext.topX;
								} else {
									var value7 = eNext.dx * (ipy - eNext.botY);
									ipx = eNext.botX + (value7 < 0 ? value7 - 0.5 | 0 : value7 + 0.5 | 0);
								}
							} else if(ipy == e.topY) {
								ipx = e.topX;
							} else {
								var value8 = e.dx * (ipy - e.botY);
								ipx = e.botX + (value8 < 0 ? value8 - 0.5 | 0 : value8 + 0.5 | 0);
							}
						}
						pt = new h2d_col_IPoint(ipx,ipy);
					}
					var newNode = new hxd_clipper__$Clipper_IntersectNode();
					newNode.edge1 = e;
					newNode.edge2 = eNext;
					newNode.pt = pt;
					this.m_IntersectList.push(newNode);
					this.SwapPositionsInSEL(e,eNext);
					isModified = true;
				} else {
					e = eNext;
				}
			}
			if(e.prevInSEL != null) {
				e.prevInSEL.nextInSEL = null;
			} else {
				break;
			}
		}
		this.m_SortedEdges = null;
	}
	,EdgesAdjacent: function(inode) {
		if(inode.edge1.nextInSEL != inode.edge2) {
			return inode.edge1.prevInSEL == inode.edge2;
		} else {
			return true;
		}
	}
	,IntersectNodeSort: function(node1,node2) {
		return node2.pt.y - node1.pt.y | 0;
	}
	,FixupIntersectionOrder: function() {
		this.m_IntersectList.sort(hxd_clipper_Clipper.compareY);
		var e = this.m_ActiveEdges;
		this.m_SortedEdges = e;
		while(e != null) {
			e.prevInSEL = e.prevInAEL;
			e.nextInSEL = e.nextInAEL;
			e = e.nextInAEL;
		}
		var cnt = this.m_IntersectList.length;
		var _g = 0;
		var _g1 = cnt;
		while(_g < _g1) {
			var i = _g++;
			var inode = this.m_IntersectList[i];
			if(!(inode.edge1.nextInSEL == inode.edge2 || inode.edge1.prevInSEL == inode.edge2)) {
				var j = i + 1;
				while(true) {
					var tmp;
					if(j < cnt) {
						var inode1 = this.m_IntersectList[j];
						tmp = !(inode1.edge1.nextInSEL == inode1.edge2 || inode1.edge1.prevInSEL == inode1.edge2);
					} else {
						tmp = false;
					}
					if(!tmp) {
						break;
					}
					++j;
				}
				if(j == cnt) {
					return false;
				}
				var tmp1 = this.m_IntersectList[i];
				this.m_IntersectList[i] = this.m_IntersectList[j];
				this.m_IntersectList[j] = tmp1;
			}
			this.SwapPositionsInSEL(this.m_IntersectList[i].edge1,this.m_IntersectList[i].edge2);
		}
		return true;
	}
	,ProcessIntersectList: function() {
		var _g = 0;
		var _g1 = this.m_IntersectList.length;
		while(_g < _g1) {
			var i = _g++;
			var iNode = this.m_IntersectList[i];
			this.IntersectEdges(iNode.edge1,iNode.edge2,iNode.pt);
			this.SwapPositionsInAEL(iNode.edge1,iNode.edge2);
		}
		this.m_IntersectList = [];
	}
	,Round: function(value) {
		if(value < 0) {
			return value - 0.5 | 0;
		} else {
			return value + 0.5 | 0;
		}
	}
	,TopX: function(edge,currentY) {
		if(currentY == edge.topY) {
			return edge.topX;
		}
		var value = edge.dx * (currentY - edge.botY);
		return edge.botX + (value < 0 ? value - 0.5 | 0 : value + 0.5 | 0);
	}
	,IntersectPoint: function(edge1,edge2) {
		var ipx;
		var ipy;
		var b1;
		var b2;
		if(edge1.dx == edge2.dx) {
			ipy = edge1.currY;
			if(ipy == edge1.topY) {
				ipx = edge1.topX;
			} else {
				var value = edge1.dx * (ipy - edge1.botY);
				ipx = edge1.botX + (value < 0 ? value - 0.5 | 0 : value + 0.5 | 0);
			}
			return new h2d_col_IPoint(ipx,ipy);
		}
		if(edge1.deltaX == 0) {
			ipx = edge1.botX;
			if(edge2.deltaY == 0) {
				ipy = edge2.botY;
			} else {
				b2 = edge2.botY - edge2.botX / edge2.dx;
				var value = ipx / edge2.dx + b2;
				ipy = value < 0 ? value - 0.5 | 0 : value + 0.5 | 0;
			}
		} else if(edge2.deltaX == 0) {
			ipx = edge2.botX;
			if(edge1.deltaY == 0) {
				ipy = edge1.botY;
			} else {
				b1 = edge1.botY - edge1.botX / edge1.dx;
				var value = ipx / edge1.dx + b1;
				ipy = value < 0 ? value - 0.5 | 0 : value + 0.5 | 0;
			}
		} else {
			b1 = edge1.botX - edge1.botY * edge1.dx;
			b2 = edge2.botX - edge2.botY * edge2.dx;
			var q = (b2 - b1) / (edge1.dx - edge2.dx);
			ipy = q < 0 ? q - 0.5 | 0 : q + 0.5 | 0;
			var f = edge1.dx;
			var f1 = edge2.dx;
			if((f < 0 ? -f : f) < (f1 < 0 ? -f1 : f1)) {
				var value = edge1.dx * q + b1;
				ipx = value < 0 ? value - 0.5 | 0 : value + 0.5 | 0;
			} else {
				var value = edge2.dx * q + b2;
				ipx = value < 0 ? value - 0.5 | 0 : value + 0.5 | 0;
			}
		}
		if(ipy < edge1.topY || ipy < edge2.topY) {
			if(edge1.topY > edge2.topY) {
				ipy = edge1.topY;
			} else {
				ipy = edge2.topY;
			}
			var f = edge1.dx;
			var f1 = edge2.dx;
			if((f < 0 ? -f : f) < (f1 < 0 ? -f1 : f1)) {
				if(ipy == edge1.topY) {
					ipx = edge1.topX;
				} else {
					var value = edge1.dx * (ipy - edge1.botY);
					ipx = edge1.botX + (value < 0 ? value - 0.5 | 0 : value + 0.5 | 0);
				}
			} else if(ipy == edge2.topY) {
				ipx = edge2.topX;
			} else {
				var value = edge2.dx * (ipy - edge2.botY);
				ipx = edge2.botX + (value < 0 ? value - 0.5 | 0 : value + 0.5 | 0);
			}
		}
		if(ipy > edge1.currY) {
			ipy = edge1.currY;
			var f = edge1.dx;
			var f1 = edge2.dx;
			if((f < 0 ? -f : f) > (f1 < 0 ? -f1 : f1)) {
				if(ipy == edge2.topY) {
					ipx = edge2.topX;
				} else {
					var value = edge2.dx * (ipy - edge2.botY);
					ipx = edge2.botX + (value < 0 ? value - 0.5 | 0 : value + 0.5 | 0);
				}
			} else if(ipy == edge1.topY) {
				ipx = edge1.topX;
			} else {
				var value = edge1.dx * (ipy - edge1.botY);
				ipx = edge1.botX + (value < 0 ? value - 0.5 | 0 : value + 0.5 | 0);
			}
		}
		return new h2d_col_IPoint(ipx,ipy);
	}
	,ProcessEdgesAtTopOfScanbeam: function(topY) {
		var e = this.m_ActiveEdges;
		while(e != null) {
			var IsMaximaEdge = e != null && e.topY == topY && e.nextInLML == null;
			if(IsMaximaEdge) {
				var eMaxPair = this.GetMaximaPair(e);
				IsMaximaEdge = eMaxPair == null || eMaxPair.deltaY != 0;
			}
			if(IsMaximaEdge) {
				var ePrev = e.prevInAEL;
				this.DoMaxima(e);
				if(ePrev == null) {
					e = this.m_ActiveEdges;
				} else {
					e = ePrev.nextInAEL;
				}
			} else {
				if(e.topY == topY && e.nextInLML != null && e.nextInLML.deltaY == 0) {
					e = this.UpdateEdgeIntoAEL(e);
					if(e.outIdx >= 0) {
						this.AddOutPt(e,new h2d_col_IPoint(e.botX,e.botY));
					}
					this.AddEdgeToSEL(e);
				} else {
					var tmp;
					if(topY == e.topY) {
						tmp = e.topX;
					} else {
						var value = e.dx * (topY - e.botY);
						tmp = e.botX + (value < 0 ? value - 0.5 | 0 : value + 0.5 | 0);
					}
					e.currX = tmp;
					e.currY = topY;
				}
				if(this.strictlySimple) {
					var ePrev1 = e.prevInAEL;
					if(e.outIdx >= 0 && e.windDelta != 0 && ePrev1 != null && ePrev1.outIdx >= 0 && ePrev1.currX == e.currX && ePrev1.windDelta != 0) {
						var ip = new h2d_col_IPoint(e.currX,e.currY);
						var op = this.AddOutPt(ePrev1,ip);
						var op2 = this.AddOutPt(e,ip);
						this.AddJoin(op,op2,ip);
					}
				}
				e = e.nextInAEL;
			}
		}
		this.ProcessHorizontals(true);
		e = this.m_ActiveEdges;
		while(e != null) {
			if(e.topY == topY && e.nextInLML != null) {
				var op = null;
				if(e.outIdx >= 0) {
					op = this.AddOutPt(e,new h2d_col_IPoint(e.topX,e.topY));
				}
				e = this.UpdateEdgeIntoAEL(e);
				var ePrev = e.prevInAEL;
				var eNext = e.nextInAEL;
				if(ePrev != null && ePrev.currX == e.botX && ePrev.currY == e.botY && op != null && ePrev.outIdx >= 0 && ePrev.currY > ePrev.topY && e.deltaY * ePrev.deltaX == e.deltaX * ePrev.deltaY && e.windDelta != 0 && ePrev.windDelta != 0) {
					var op2 = this.AddOutPt(ePrev,new h2d_col_IPoint(e.botX,e.botY));
					this.AddJoin(op,op2,new h2d_col_IPoint(e.topX,e.topY));
				} else if(eNext != null && eNext.currX == e.botX && eNext.currY == e.botY && op != null && eNext.outIdx >= 0 && eNext.currY > eNext.topY && e.deltaY * eNext.deltaX == e.deltaX * eNext.deltaY && e.windDelta != 0 && eNext.windDelta != 0) {
					var op21 = this.AddOutPt(eNext,new h2d_col_IPoint(e.botX,e.botY));
					this.AddJoin(op,op21,new h2d_col_IPoint(e.topX,e.topY));
				}
			}
			e = e.nextInAEL;
		}
	}
	,DoMaxima: function(e) {
		var eMaxPair = this.GetMaximaPair(e);
		if(eMaxPair == null) {
			if(e.outIdx >= 0) {
				this.AddOutPt(e,new h2d_col_IPoint(e.topX,e.topY));
			}
			this.DeleteFromAEL(e);
			return;
		}
		var eNext = e.nextInAEL;
		while(eNext != null && eNext != eMaxPair) {
			this.IntersectEdges(e,eNext,new h2d_col_IPoint(e.topX,e.topY));
			this.SwapPositionsInAEL(e,eNext);
			eNext = e.nextInAEL;
		}
		if(e.outIdx == -1 && eMaxPair.outIdx == -1) {
			this.DeleteFromAEL(e);
			this.DeleteFromAEL(eMaxPair);
		} else if(e.outIdx >= 0 && eMaxPair.outIdx >= 0) {
			if(e.outIdx >= 0) {
				this.AddLocalMaxPoly(e,eMaxPair,new h2d_col_IPoint(e.topX,e.topY));
			}
			this.DeleteFromAEL(e);
			this.DeleteFromAEL(eMaxPair);
		} else {
			throw haxe_Exception.thrown("DoMaxima error");
		}
	}
	,reversePolygons: function(polys) {
		var _g_i = 0;
		var _g_a = polys;
		var _g_l = _g_a.length;
		while(_g_i < _g_l) {
			var p = _g_a[_g_i++];
			h2d_col_IPolygon.reverse(p);
		}
	}
	,PointCount: function(pts) {
		if(pts == null) {
			return 0;
		}
		var result = 0;
		var p = pts;
		do {
			++result;
			p = p.next;
		} while(p != pts);
		return result;
	}
	,BuildResult: function() {
		var solution = [];
		var _g = 0;
		var _g1 = this.m_PolyOuts;
		while(_g < _g1.length) {
			var outRec = _g1[_g];
			++_g;
			if(outRec.pts == null) {
				continue;
			}
			if(this.resultKind == hxd_clipper_ResultKind.NoHoles && outRec.isHole) {
				continue;
			}
			if(this.resultKind == hxd_clipper_ResultKind.HolesOnly && !outRec.isHole) {
				continue;
			}
			var p = outRec.pts.prev;
			var cnt = this.PointCount(p);
			if(cnt < 2) {
				continue;
			}
			var points = null;
			var pg = points == null ? [] : points;
			var _g2 = 0;
			var _g3 = cnt;
			while(_g2 < _g3) {
				var j = _g2++;
				pg.push(p.pt);
				p = p.prev;
			}
			solution.push(pg);
		}
		return solution;
	}
	,BuildResult2: function(polytree) {
		polytree.clear();
		var _g = 0;
		var _g1 = this.m_PolyOuts;
		while(_g < _g1.length) {
			var outRec = _g1[_g];
			++_g;
			var cnt = this.PointCount(outRec.pts);
			if(cnt < 3) {
				continue;
			}
			this.FixHoleLinkage(outRec);
			var pn = new hxd_clipper__$Clipper_PolyNode();
			polytree.allPolys.push(pn);
			outRec.polyNode = pn;
			var op = outRec.pts.prev;
			var _g2 = 0;
			var _g3 = cnt;
			while(_g2 < _g3) {
				var j = _g2++;
				pn.polygon.push(op.pt);
				op = op.prev;
			}
		}
		var _g = 0;
		var _g1 = this.m_PolyOuts;
		while(_g < _g1.length) {
			var outRec = _g1[_g];
			++_g;
			if(outRec.polyNode == null) {
				continue;
			} else if(outRec.firstLeft != null && outRec.firstLeft.polyNode != null) {
				outRec.firstLeft.polyNode.addChild(outRec.polyNode);
			} else {
				polytree.addChild(outRec.polyNode);
			}
		}
	}
	,FixupOutPolygon: function(outRec) {
		var lastOK = null;
		outRec.bottomPt = null;
		var pp = outRec.pts;
		while(true) {
			if(pp.prev == pp || pp.prev == pp.next) {
				outRec.pts = null;
				return;
			}
			var tmp;
			var tmp1;
			var pt1 = pp.pt;
			var pt2 = pp.next.pt;
			if(!(pt1.x == pt2.x && pt1.y == pt2.y)) {
				var pt11 = pp.pt;
				var pt21 = pp.prev.pt;
				tmp1 = pt11.x == pt21.x && pt11.y == pt21.y;
			} else {
				tmp1 = true;
			}
			if(!tmp1) {
				var pt12 = pp.prev.pt;
				var pt22 = pp.pt;
				var pt3 = pp.next.pt;
				tmp = (pt12.y - pt22.y) * (pt22.x - pt3.x) - (pt12.x - pt22.x) * (pt22.y - pt3.y) == 0 && (!this.preserveCollinear || !this.Pt2IsBetweenPt1AndPt3(pp.prev.pt,pp.pt,pp.next.pt));
			} else {
				tmp = true;
			}
			if(tmp) {
				lastOK = null;
				var tmp2 = pp;
				pp.prev.next = pp.next;
				pp.next.prev = pp.prev;
				pp = pp.prev;
				tmp2 = null;
			} else if(pp == lastOK) {
				break;
			} else {
				if(lastOK == null) {
					lastOK = pp;
				}
				pp = pp.next;
			}
		}
		outRec.pts = pp;
	}
	,DupOutPt: function(outPt,InsertAfter) {
		var result = new hxd_clipper__$Clipper_OutPt();
		result.pt = outPt.pt;
		result.idx = outPt.idx;
		if(InsertAfter) {
			result.next = outPt.next;
			result.prev = outPt;
			outPt.next.prev = result;
			outPt.next = result;
		} else {
			result.prev = outPt.prev;
			result.next = outPt;
			outPt.prev.next = result;
			outPt.prev = result;
		}
		return result;
	}
	,GetOverlap: function(a1,a2,b1,b2) {
		var Left;
		var Right;
		if(a1 < a2) {
			if(b1 < b2) {
				Left = a1 < b1 ? b1 : a1;
				Right = a2 > b2 ? b2 : a2;
			} else {
				Left = a1 < b2 ? b2 : a1;
				Right = a2 > b1 ? b1 : a2;
			}
		} else if(b1 < b2) {
			Left = a2 < b1 ? b1 : a2;
			Right = a1 > b2 ? b2 : a1;
		} else {
			Left = a2 < b2 ? b2 : a2;
			Right = a1 > b1 ? b1 : a1;
		}
		return { left : Left, right : Right, done : Left < Right};
	}
	,JoinHorz: function(op1,op1b,op2,op2b,pt,DiscardLeft) {
		var Dir1 = op1.pt.x > op1b.pt.x ? hxd_clipper__$Clipper_Direction.RightToLeft : hxd_clipper__$Clipper_Direction.LeftToRight;
		var Dir2 = op2.pt.x > op2b.pt.x ? hxd_clipper__$Clipper_Direction.RightToLeft : hxd_clipper__$Clipper_Direction.LeftToRight;
		if(Dir1 == Dir2) {
			return false;
		}
		if(Dir1 == hxd_clipper__$Clipper_Direction.LeftToRight) {
			while(op1.next.pt.x <= pt.x && op1.next.pt.x >= op1.pt.x && op1.next.pt.y == pt.y) op1 = op1.next;
			if(DiscardLeft && op1.pt.x != pt.x) {
				op1 = op1.next;
			}
			op1b = this.DupOutPt(op1,!DiscardLeft);
			if(op1b.pt != pt) {
				op1 = op1b;
				op1.pt = pt;
				op1b = this.DupOutPt(op1,!DiscardLeft);
			}
		} else {
			while(op1.next.pt.x >= pt.x && op1.next.pt.x <= op1.pt.x && op1.next.pt.y == pt.y) op1 = op1.next;
			if(!DiscardLeft && op1.pt.x != pt.x) {
				op1 = op1.next;
			}
			op1b = this.DupOutPt(op1,DiscardLeft);
			if(op1b.pt != pt) {
				op1 = op1b;
				op1.pt = pt;
				op1b = this.DupOutPt(op1,DiscardLeft);
			}
		}
		if(Dir2 == hxd_clipper__$Clipper_Direction.LeftToRight) {
			while(op2.next.pt.x <= pt.x && op2.next.pt.x >= op2.pt.x && op2.next.pt.y == pt.y) op2 = op2.next;
			if(DiscardLeft && op2.pt.x != pt.x) {
				op2 = op2.next;
			}
			op2b = this.DupOutPt(op2,!DiscardLeft);
			if(op2b.pt != pt) {
				op2 = op2b;
				op2.pt = pt;
				op2b = this.DupOutPt(op2,!DiscardLeft);
			}
		} else {
			while(op2.next.pt.x >= pt.x && op2.next.pt.x <= op2.pt.x && op2.next.pt.y == pt.y) op2 = op2.next;
			if(!DiscardLeft && op2.pt.x != pt.x) {
				op2 = op2.next;
			}
			op2b = this.DupOutPt(op2,DiscardLeft);
			if(op2b.pt != pt) {
				op2 = op2b;
				op2.pt = pt;
				op2b = this.DupOutPt(op2,DiscardLeft);
			}
		}
		if(Dir1 == hxd_clipper__$Clipper_Direction.LeftToRight == DiscardLeft) {
			op1.prev = op2;
			op2.next = op1;
			op1b.next = op2b;
			op2b.prev = op1b;
		} else {
			op1.next = op2;
			op2.prev = op1;
			op1b.prev = op2b;
			op2b.next = op1b;
		}
		return true;
	}
	,JoinPoints: function(j,outRec1,outRec2) {
		var op1 = j.outPt1;
		var op1b;
		var op2 = j.outPt2;
		var op2b;
		var isHorizontal = j.outPt1.pt.y == j.offPt.y;
		var tmp;
		var tmp1;
		if(isHorizontal) {
			var pt1 = j.offPt;
			var pt2 = j.outPt1.pt;
			tmp1 = pt1.x == pt2.x && pt1.y == pt2.y;
		} else {
			tmp1 = false;
		}
		if(tmp1) {
			var pt1 = j.offPt;
			var pt2 = j.outPt2.pt;
			tmp = pt1.x == pt2.x && pt1.y == pt2.y;
		} else {
			tmp = false;
		}
		if(tmp) {
			if(outRec1 != outRec2) {
				return false;
			}
			op1b = j.outPt1.next;
			while(true) {
				var tmp;
				if(op1b != op1) {
					var pt1 = op1b.pt;
					var pt2 = j.offPt;
					tmp = pt1.x == pt2.x && pt1.y == pt2.y;
				} else {
					tmp = false;
				}
				if(!tmp) {
					break;
				}
				op1b = op1b.next;
			}
			var reverse1 = op1b.pt.y > j.offPt.y;
			op2b = j.outPt2.next;
			while(true) {
				var tmp;
				if(op2b != op2) {
					var pt1 = op2b.pt;
					var pt2 = j.offPt;
					tmp = pt1.x == pt2.x && pt1.y == pt2.y;
				} else {
					tmp = false;
				}
				if(!tmp) {
					break;
				}
				op2b = op2b.next;
			}
			var reverse2 = op2b.pt.y > j.offPt.y;
			if(reverse1 == reverse2) {
				return false;
			}
			if(reverse1) {
				op1b = this.DupOutPt(op1,false);
				op2b = this.DupOutPt(op2,true);
				op1.prev = op2;
				op2.next = op1;
				op1b.next = op2b;
				op2b.prev = op1b;
				j.outPt1 = op1;
				j.outPt2 = op1b;
				return true;
			} else {
				op1b = this.DupOutPt(op1,true);
				op2b = this.DupOutPt(op2,false);
				op1.next = op2;
				op2.prev = op1;
				op1b.prev = op2b;
				op2b.next = op1b;
				j.outPt1 = op1;
				j.outPt2 = op1b;
				return true;
			}
		} else if(isHorizontal) {
			op1b = op1;
			while(op1.prev.pt.y == op1.pt.y && op1.prev != op1b && op1.prev != op2) op1 = op1.prev;
			while(op1b.next.pt.y == op1b.pt.y && op1b.next != op1 && op1b.next != op2) op1b = op1b.next;
			if(op1b.next == op1 || op1b.next == op2) {
				return false;
			}
			op2b = op2;
			while(op2.prev.pt.y == op2.pt.y && op2.prev != op2b && op2.prev != op1b) op2 = op2.prev;
			while(op2b.next.pt.y == op2b.pt.y && op2b.next != op2 && op2b.next != op1) op2b = op2b.next;
			if(op2b.next == op2 || op2b.next == op1) {
				return false;
			}
			var out = this.GetOverlap(op1.pt.x,op1b.pt.x,op2.pt.x,op2b.pt.x);
			if(!out.done) {
				return false;
			}
			var Left = out.left;
			var Right = out.right;
			var Pt;
			var DiscardLeftSide;
			if(op1.pt.x >= Left && op1.pt.x <= Right) {
				Pt = op1.pt;
				DiscardLeftSide = op1.pt.x > op1b.pt.x;
			} else if(op2.pt.x >= Left && op2.pt.x <= Right) {
				Pt = op2.pt;
				DiscardLeftSide = op2.pt.x > op2b.pt.x;
			} else if(op1b.pt.x >= Left && op1b.pt.x <= Right) {
				Pt = op1b.pt;
				DiscardLeftSide = op1b.pt.x > op1.pt.x;
			} else {
				Pt = op2b.pt;
				DiscardLeftSide = op2b.pt.x > op2.pt.x;
			}
			j.outPt1 = op1;
			j.outPt2 = op2;
			return this.JoinHorz(op1,op1b,op2,op2b,Pt,DiscardLeftSide);
		} else {
			op1b = op1.next;
			while(true) {
				var pt1 = op1b.pt;
				var pt2 = op1.pt;
				if(!(pt1.x == pt2.x && pt1.y == pt2.y && op1b != op1)) {
					break;
				}
				op1b = op1b.next;
			}
			var Reverse1;
			if(op1b.pt.y <= op1.pt.y) {
				var pt1 = op1.pt;
				var pt2 = op1b.pt;
				var pt3 = j.offPt;
				Reverse1 = (pt1.y - pt2.y) * (pt2.x - pt3.x) - (pt1.x - pt2.x) * (pt2.y - pt3.y) != 0;
			} else {
				Reverse1 = true;
			}
			if(Reverse1) {
				op1b = op1.prev;
				while(true) {
					var pt1 = op1b.pt;
					var pt2 = op1.pt;
					if(!(pt1.x == pt2.x && pt1.y == pt2.y && op1b != op1)) {
						break;
					}
					op1b = op1b.prev;
				}
				var tmp;
				if(op1b.pt.y <= op1.pt.y) {
					var pt1 = op1.pt;
					var pt2 = op1b.pt;
					var pt3 = j.offPt;
					tmp = (pt1.y - pt2.y) * (pt2.x - pt3.x) - (pt1.x - pt2.x) * (pt2.y - pt3.y) != 0;
				} else {
					tmp = true;
				}
				if(tmp) {
					return false;
				}
			}
			op2b = op2.next;
			while(true) {
				var pt1 = op2b.pt;
				var pt2 = op2.pt;
				if(!(pt1.x == pt2.x && pt1.y == pt2.y && op2b != op2)) {
					break;
				}
				op2b = op2b.next;
			}
			var Reverse2;
			if(op2b.pt.y <= op2.pt.y) {
				var pt1 = op2.pt;
				var pt2 = op2b.pt;
				var pt3 = j.offPt;
				Reverse2 = (pt1.y - pt2.y) * (pt2.x - pt3.x) - (pt1.x - pt2.x) * (pt2.y - pt3.y) != 0;
			} else {
				Reverse2 = true;
			}
			if(Reverse2) {
				op2b = op2.prev;
				while(true) {
					var pt1 = op2b.pt;
					var pt2 = op2.pt;
					if(!(pt1.x == pt2.x && pt1.y == pt2.y && op2b != op2)) {
						break;
					}
					op2b = op2b.prev;
				}
				var tmp;
				if(op2b.pt.y <= op2.pt.y) {
					var pt1 = op2.pt;
					var pt2 = op2b.pt;
					var pt3 = j.offPt;
					tmp = (pt1.y - pt2.y) * (pt2.x - pt3.x) - (pt1.x - pt2.x) * (pt2.y - pt3.y) != 0;
				} else {
					tmp = true;
				}
				if(tmp) {
					return false;
				}
			}
			if(op1b == op1 || op2b == op2 || op1b == op2b || outRec1 == outRec2 && Reverse1 == Reverse2) {
				return false;
			}
			if(Reverse1) {
				op1b = this.DupOutPt(op1,false);
				op2b = this.DupOutPt(op2,true);
				op1.prev = op2;
				op2.next = op1;
				op1b.next = op2b;
				op2b.prev = op1b;
				j.outPt1 = op1;
				j.outPt2 = op1b;
				return true;
			} else {
				op1b = this.DupOutPt(op1,true);
				op2b = this.DupOutPt(op2,false);
				op1.next = op2;
				op2.prev = op1;
				op1b.prev = op2b;
				op2b.next = op1b;
				j.outPt1 = op1;
				j.outPt2 = op1b;
				return true;
			}
		}
	}
	,PointInPolygon: function(pt,pol) {
		var result = 0;
		var cnt = pol.length;
		if(cnt < 3) {
			return 0;
		}
		var ip = pol[0];
		var _g = 1;
		var _g1 = cnt + 1;
		while(_g < _g1) {
			var i = _g++;
			var ipNext = i == cnt ? pol[0] : pol[i];
			if(ipNext.y == pt.y) {
				if(ipNext.x == pt.x || ip.y == pt.y && ipNext.x > pt.x == ip.x < pt.x) {
					return -1;
				}
			}
			if(ip.y < pt.y != ipNext.y < pt.y) {
				if(ip.x >= pt.x) {
					if(ipNext.x > pt.x) {
						result = 1 - result;
					} else {
						var d = (ip.x - pt.x) * (ipNext.y - pt.y) - (ipNext.x - pt.x) * (ip.y - pt.y);
						if(d == 0) {
							return -1;
						} else if(d > 0 == ipNext.y > ip.y) {
							result = 1 - result;
						}
					}
				} else if(ipNext.x > pt.x) {
					var d1 = (ip.x - pt.x) * (ipNext.y - pt.y) - (ipNext.x - pt.x) * (ip.y - pt.y);
					if(d1 == 0) {
						return -1;
					} else if(d1 > 0 == ipNext.y > ip.y) {
						result = 1 - result;
					}
				}
			}
			ip = ipNext;
		}
		return result;
	}
	,PointInPolygon2: function(pt,op) {
		var result = 0;
		var startOp = op;
		var ptx = pt.x;
		var pty = pt.y;
		var poly0x = op.pt.x;
		var poly0y = op.pt.y;
		do {
			op = op.next;
			var poly1x = op.pt.x;
			var poly1y = op.pt.y;
			if(poly1y == pty) {
				if(poly1x == ptx || poly0y == pty && poly1x > ptx == poly0x < ptx) {
					return -1;
				}
			}
			if(poly0y < pty != poly1y < pty) {
				if(poly0x >= ptx) {
					if(poly1x > ptx) {
						result = 1 - result;
					} else {
						var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);
						if(d == 0) {
							return -1;
						}
						if(d > 0 == poly1y > poly0y) {
							result = 1 - result;
						}
					}
				} else if(poly1x > ptx) {
					var d1 = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);
					if(d1 == 0) {
						return -1;
					}
					if(d1 > 0 == poly1y > poly0y) {
						result = 1 - result;
					}
				}
			}
			poly0x = poly1x;
			poly0y = poly1y;
		} while(startOp != op);
		return result;
	}
	,Poly2ContainsPoly1: function(outPt1,outPt2) {
		var op = outPt1;
		do {
			var res = this.PointInPolygon2(op.pt,outPt2);
			if(res >= 0) {
				return res > 0;
			}
			op = op.next;
		} while(op != outPt1);
		return true;
	}
	,FixupFirstLefts1: function(OldOutRec,NewOutRec) {
		var _g = 0;
		var _g1 = this.m_PolyOuts;
		while(_g < _g1.length) {
			var outRec = _g1[_g];
			++_g;
			if(outRec.pts == null || outRec.firstLeft == null) {
				continue;
			}
			var firstLeft = this.ParseFirstLeft(outRec.firstLeft);
			if(firstLeft == OldOutRec) {
				if(this.Poly2ContainsPoly1(outRec.pts,NewOutRec.pts)) {
					outRec.firstLeft = NewOutRec;
				}
			}
		}
	}
	,FixupFirstLefts2: function(OldOutRec,NewOutRec) {
		var _g = 0;
		var _g1 = this.m_PolyOuts;
		while(_g < _g1.length) {
			var outRec = _g1[_g];
			++_g;
			if(outRec.firstLeft == OldOutRec) {
				outRec.firstLeft = NewOutRec;
			}
		}
	}
	,ParseFirstLeft: function(FirstLeft) {
		while(FirstLeft != null && FirstLeft.pts == null) FirstLeft = FirstLeft.firstLeft;
		return FirstLeft;
	}
	,JoinCommonEdges: function() {
		var _g = 0;
		var _g1 = this.m_Joins.length;
		while(_g < _g1) {
			var i = _g++;
			var join = this.m_Joins[i];
			var outRec1 = this.GetOutRec(join.outPt1.idx);
			var outRec2 = this.GetOutRec(join.outPt2.idx);
			if(outRec1.pts == null || outRec2.pts == null) {
				continue;
			}
			var holeStateRec;
			if(outRec1 == outRec2) {
				holeStateRec = outRec1;
			} else if(this.Param1RightOfParam2(outRec1,outRec2)) {
				holeStateRec = outRec2;
			} else if(this.Param1RightOfParam2(outRec2,outRec1)) {
				holeStateRec = outRec1;
			} else {
				holeStateRec = this.GetLowermostRec(outRec1,outRec2);
			}
			if(!this.JoinPoints(join,outRec1,outRec2)) {
				continue;
			}
			if(outRec1 == outRec2) {
				outRec1.pts = join.outPt1;
				outRec1.bottomPt = null;
				outRec2 = this.CreateOutRec();
				outRec2.pts = join.outPt2;
				this.UpdateOutPtIdxs(outRec2);
				if(this.m_UsingPolyTree) {
					var _g2 = 0;
					var _g3 = this.m_PolyOuts.length - 1;
					while(_g2 < _g3) {
						var j = _g2++;
						var oRec = this.m_PolyOuts[j];
						if(oRec.pts == null || this.ParseFirstLeft(oRec.firstLeft) != outRec1 || oRec.isHole == outRec1.isHole) {
							continue;
						}
						if(this.Poly2ContainsPoly1(oRec.pts,join.outPt2)) {
							oRec.firstLeft = outRec2;
						}
					}
				}
				if(this.Poly2ContainsPoly1(outRec2.pts,outRec1.pts)) {
					outRec2.isHole = !outRec1.isHole;
					outRec2.firstLeft = outRec1;
					if(this.m_UsingPolyTree) {
						this.FixupFirstLefts2(outRec2,outRec1);
					}
					var b = this.reverseSolution;
					if((outRec2.isHole ? !b : b) == this.Area(outRec2) > 0) {
						this.ReversePolyPtLinks(outRec2.pts);
					}
				} else if(this.Poly2ContainsPoly1(outRec1.pts,outRec2.pts)) {
					outRec2.isHole = outRec1.isHole;
					outRec1.isHole = !outRec2.isHole;
					outRec2.firstLeft = outRec1.firstLeft;
					outRec1.firstLeft = outRec2;
					if(this.m_UsingPolyTree) {
						this.FixupFirstLefts2(outRec1,outRec2);
					}
					var b1 = this.reverseSolution;
					if((outRec1.isHole ? !b1 : b1) == this.Area(outRec1) > 0) {
						this.ReversePolyPtLinks(outRec1.pts);
					}
				} else {
					outRec2.isHole = outRec1.isHole;
					outRec2.firstLeft = outRec1.firstLeft;
					if(this.m_UsingPolyTree) {
						this.FixupFirstLefts1(outRec1,outRec2);
					}
				}
			} else {
				outRec2.pts = null;
				outRec2.bottomPt = null;
				outRec2.idx = outRec1.idx;
				outRec1.isHole = holeStateRec.isHole;
				if(holeStateRec == outRec2) {
					outRec1.firstLeft = outRec2.firstLeft;
				}
				outRec2.firstLeft = outRec1;
				if(this.m_UsingPolyTree) {
					this.FixupFirstLefts2(outRec2,outRec1);
				}
			}
		}
	}
	,UpdateOutPtIdxs: function(outrec) {
		var op = outrec.pts;
		do {
			op.idx = outrec.idx;
			op = op.prev;
		} while(op != outrec.pts);
	}
	,DoSimplePolygons: function() {
		var i = 0;
		while(i < this.m_PolyOuts.length) {
			var outrec = this.m_PolyOuts[i++];
			var op = outrec.pts;
			if(op == null) {
				continue;
			}
			do {
				var op2 = op.next;
				while(op2 != outrec.pts) {
					var pt1 = op.pt;
					var pt2 = op2.pt;
					if(pt1.x == pt2.x && pt1.y == pt2.y && op2.next != op && op2.prev != op) {
						var op3 = op.prev;
						var op4 = op2.prev;
						op.prev = op4;
						op4.next = op;
						op2.prev = op3;
						op3.next = op2;
						outrec.pts = op;
						var outrec2 = this.CreateOutRec();
						outrec2.pts = op2;
						this.UpdateOutPtIdxs(outrec2);
						if(this.Poly2ContainsPoly1(outrec2.pts,outrec.pts)) {
							outrec2.isHole = !outrec.isHole;
							outrec2.firstLeft = outrec;
						} else if(this.Poly2ContainsPoly1(outrec.pts,outrec2.pts)) {
							outrec2.isHole = outrec.isHole;
							outrec.isHole = !outrec2.isHole;
							outrec2.firstLeft = outrec.firstLeft;
							outrec.firstLeft = outrec2;
						} else {
							outrec2.isHole = outrec.isHole;
							outrec2.firstLeft = outrec.firstLeft;
						}
						op2 = op;
					}
					op2 = op2.next;
				}
				op = op.next;
			} while(op != outrec.pts);
		}
	}
	,Area: function(outRec) {
		var op = outRec.pts;
		if(op == null) {
			return 0.;
		}
		var a = 0;
		do {
			a += (op.pt.x + op.prev.pt.x) * (op.prev.pt.y - op.pt.y);
			op = op.next;
		} while(op != outRec.pts);
		return a / 2;
	}
	,DistanceFromLineSqrd: function(pt,ln1,ln2) {
		var A = ln1.y - ln2.y;
		var B = ln2.x - ln1.x;
		var C = A * ln1.x + B * ln1.y;
		C = A * pt.x + B * pt.y - C;
		return C * C / (A * A + B * B);
	}
	,SlopesNearCollinear: function(pt1,pt2,pt3,distSqrd) {
		var f = pt1.x - pt2.x;
		var f1 = pt1.y - pt2.y;
		if((f < 0 ? -f : f) > (f1 < 0 ? -f1 : f1)) {
			if(pt1.x > pt2.x == pt1.x < pt3.x) {
				return this.DistanceFromLineSqrd(pt1,pt2,pt3) < distSqrd;
			} else if(pt2.x > pt1.x == pt2.x < pt3.x) {
				return this.DistanceFromLineSqrd(pt2,pt1,pt3) < distSqrd;
			} else {
				return this.DistanceFromLineSqrd(pt3,pt1,pt2) < distSqrd;
			}
		} else if(pt1.y > pt2.y == pt1.y < pt3.y) {
			return this.DistanceFromLineSqrd(pt1,pt2,pt3) < distSqrd;
		} else if(pt2.y > pt1.y == pt2.y < pt3.y) {
			return this.DistanceFromLineSqrd(pt2,pt1,pt3) < distSqrd;
		} else {
			return this.DistanceFromLineSqrd(pt3,pt1,pt2) < distSqrd;
		}
	}
	,PointsAreClose: function(pt1,pt2,distSqrd) {
		var dx = pt1.x - pt2.x;
		var dy = pt1.y - pt2.y;
		return dx * dx + dy * dy <= distSqrd;
	}
	,ExcludeOp: function(op) {
		var result = op.prev;
		result.next = op.next;
		op.next.prev = result;
		result.idx = 0;
		return result;
	}
	,CleanPolygon: function(path,distance) {
		if(distance == null) {
			distance = 1.415;
		}
		var cnt = path.length;
		if(cnt == 0) {
			var points = null;
			return points == null ? [] : points;
		}
		var outPts = [];
		var _g = 0;
		var _g1 = cnt;
		while(_g < _g1) {
			var i = _g++;
			outPts[i] = new hxd_clipper__$Clipper_OutPt();
			outPts[i].pt = path[i];
			outPts[i].next = outPts[(i + 1) % cnt];
			outPts[i].next.prev = outPts[i];
			outPts[i].idx = 0;
		}
		var distSqrd = distance * distance;
		var op = outPts[0];
		while(op.idx == 0 && op.next != op.prev) if(this.PointsAreClose(op.pt,op.prev.pt,distSqrd)) {
			op = this.ExcludeOp(op);
			--cnt;
		} else if(this.PointsAreClose(op.prev.pt,op.next.pt,distSqrd)) {
			this.ExcludeOp(op.next);
			op = this.ExcludeOp(op);
			cnt -= 2;
		} else if(this.SlopesNearCollinear(op.prev.pt,op.pt,op.next.pt,distSqrd)) {
			op = this.ExcludeOp(op);
			--cnt;
		} else {
			op.idx = 1;
			op = op.next;
		}
		if(cnt < 3) {
			cnt = 0;
		}
		var points = null;
		var result = points == null ? [] : points;
		var _g = 0;
		var _g1 = cnt;
		while(_g < _g1) {
			var i = _g++;
			result.push(op.pt);
			op = op.next;
		}
		outPts = null;
		return result;
	}
	,CleanPolygons: function(polys,distance) {
		if(distance == null) {
			distance = 1.415;
		}
		var polygons = null;
		var result = polygons == null ? [] : polygons;
		var _g = 0;
		var _g1 = polys.length;
		while(_g < _g1) {
			var i = _g++;
			result.push(this.CleanPolygon(polys[i],distance));
		}
		return result;
	}
	,Minkowski: function(pattern,path,IsSum) {
		var polyCnt = pattern.length;
		var pathCnt = path.length;
		var polygons = null;
		var result = polygons == null ? [] : polygons;
		var _g = 0;
		var _g1 = pathCnt;
		while(_g < _g1) {
			var i = _g++;
			var points = null;
			var p = points == null ? [] : points;
			var _g_i = 0;
			var _g_a = pattern;
			var _g_l = _g_a.length;
			while(_g_i < _g_l) {
				var ip = _g_a[_g_i++];
				if(IsSum) {
					p.push(new h2d_col_IPoint(path[i].x + ip.x,path[i].y + ip.y));
				} else {
					p.push(new h2d_col_IPoint(path[i].x - ip.x,path[i].y - ip.y));
				}
			}
			result.push(p);
		}
		var polygons = null;
		var quads = polygons == null ? [] : polygons;
		var _g = 0;
		var _g1 = pathCnt;
		while(_g < _g1) {
			var i = _g++;
			var _g2 = 0;
			var _g3 = polyCnt;
			while(_g2 < _g3) {
				var j = _g2++;
				var points = null;
				var quad = points == null ? [] : points;
				quad.push(result[i % pathCnt][j % polyCnt]);
				quad.push(result[(i + 1) % pathCnt][j % polyCnt]);
				quad.push(result[(i + 1) % pathCnt][(j + 1) % polyCnt]);
				quad.push(result[i % pathCnt][(j + 1) % polyCnt]);
				if(!(hxd_clipper_Clipper.polArea(quad) >= 0)) {
					h2d_col_IPolygon.reverse(quad);
				}
				quads.push(quad);
			}
		}
		return quads;
	}
	,MinkowskiSum: function(pattern,pol,kind) {
		var paths = this.Minkowski(pattern,pol,true);
		var c = new hxd_clipper_Clipper();
		c.resultKind = kind == null ? hxd_clipper_ResultKind.All : kind;
		c.addPolygons(paths,hxd_clipper_PolyType.Subject);
		return c.execute(hxd_clipper_ClipType.Union,hxd_clipper_PolyFillType.NonZero,hxd_clipper_PolyFillType.NonZero);
	}
	,TranslatePath: function(path,delta) {
		var points = null;
		var outPath = points == null ? [] : points;
		var _g = 0;
		var _g1 = path.length;
		while(_g < _g1) {
			var i = _g++;
			outPath.push(new h2d_col_IPoint(path[i].x + delta.x,path[i].y + delta.y));
		}
		return outPath;
	}
	,PolyTreeToPaths: function(polytree) {
		var polygons = null;
		var result = polygons == null ? [] : polygons;
		this.AddPolyNodeToPaths(polytree,hxd_clipper_NodeType.Any,result);
		return result;
	}
	,AddPolyNodeToPaths: function(polynode,nt,paths) {
		var match = true;
		if(nt._hx_index == 1) {
			return;
		}
		if(polynode.polygon.length > 0 && match) {
			paths.push(polynode.polygon);
		}
		var _g = 0;
		var _g1 = polynode.childs;
		while(_g < _g1.length) {
			var pn = _g1[_g];
			++_g;
			this.AddPolyNodeToPaths(pn,nt,paths);
		}
	}
	,__class__: hxd_clipper_Clipper
});
var hxd_clipper_ClipperOffset = function(miterLimit,arcTolerance) {
	if(arcTolerance == null) {
		arcTolerance = 0.25;
	}
	if(miterLimit == null) {
		miterLimit = 2.0;
	}
	this.two_pi = 6.2831853071795862;
	this.def_arc_tolerance = 0.25;
	this.MiterLimit = miterLimit;
	this.ArcTolerance = arcTolerance;
	this.m_lowest = new h2d_col_IPoint(-1,0);
	this.m_normals = [];
	this.m_polyNodes = new hxd_clipper__$Clipper_PolyNode();
	this.resultKind = hxd_clipper_ResultKind.All;
};
$hxClasses["hxd.clipper.ClipperOffset"] = hxd_clipper_ClipperOffset;
hxd_clipper_ClipperOffset.__name__ = "hxd.clipper.ClipperOffset";
hxd_clipper_ClipperOffset.prototype = {
	clear: function() {
		this.m_polyNodes = new hxd_clipper__$Clipper_PolyNode();
		this.m_lowest = new h2d_col_IPoint(-1,0);
	}
	,addPolygon: function(pol,joinType,endType) {
		var highI = pol.length - 1;
		if(highI < 0) {
			return;
		}
		var newNode = new hxd_clipper__$Clipper_PolyNode();
		newNode.jointype = joinType;
		newNode.endtype = endType;
		if(endType == hxd_clipper_EndType.ClosedLine || endType == hxd_clipper_EndType.ClosedPol) {
			while(highI > 0 && pol[0] == pol[highI]) --highI;
		}
		newNode.polygon.push(pol[0]);
		var j = 0;
		var k = 0;
		var _g = 1;
		var _g1 = highI + 1;
		while(_g < _g1) {
			var i = _g++;
			if(newNode.polygon[j] != pol[i]) {
				++j;
				newNode.polygon.push(pol[i]);
				if(pol[i].y > newNode.polygon[k].y || pol[i].y == newNode.polygon[k].y && pol[i].x < newNode.polygon[k].x) {
					k = j;
				}
			}
		}
		if(endType == hxd_clipper_EndType.ClosedPol && j < 2) {
			return;
		}
		this.m_polyNodes.addChild(newNode);
		if(endType != hxd_clipper_EndType.ClosedPol) {
			return;
		}
		if(this.m_lowest.x < 0) {
			this.m_lowest = new h2d_col_IPoint(this.m_polyNodes.childs.length - 1,k);
		} else {
			var ip = this.m_polyNodes.childs[this.m_lowest.x].polygon[this.m_lowest.y];
			if(newNode.polygon[k].y > ip.y || newNode.polygon[k].y == ip.y && newNode.polygon[k].x < ip.x) {
				this.m_lowest = new h2d_col_IPoint(this.m_polyNodes.childs.length - 1,k);
			}
		}
	}
	,addPolygons: function(pols,joinType,endType) {
		var _g_i = 0;
		var _g_a = pols;
		var _g_l = _g_a.length;
		while(_g_i < _g_l) {
			var p = _g_a[_g_i++];
			this.addPolygon(p,joinType,endType);
		}
	}
	,fixOrientations: function() {
		if(this.m_lowest.x >= 0 && !(hxd_clipper_Clipper.polArea(this.m_polyNodes.childs[this.m_lowest.x].polygon) >= 0)) {
			var _g = 0;
			var _g1 = this.m_polyNodes.childs;
			while(_g < _g1.length) {
				var node = _g1[_g];
				++_g;
				if(node.endtype == hxd_clipper_EndType.ClosedPol || node.endtype == hxd_clipper_EndType.ClosedLine && hxd_clipper_Clipper.polArea(node.polygon) >= 0) {
					h2d_col_IPolygon.reverse(node.polygon);
				}
			}
		} else {
			var _g = 0;
			var _g1 = this.m_polyNodes.childs;
			while(_g < _g1.length) {
				var node = _g1[_g];
				++_g;
				if(node.endtype == hxd_clipper_EndType.ClosedLine && !(hxd_clipper_Clipper.polArea(node.polygon) >= 0)) {
					h2d_col_IPolygon.reverse(node.polygon);
				}
			}
		}
	}
	,getUnitNormal: function(pt1,pt2) {
		var dx = pt2.x - pt1.x;
		var dy = pt2.y - pt1.y;
		if(dx == 0 && dy == 0) {
			return new h2d_col_PointImpl(0.,0.);
		}
		var dz = 0.;
		if(dz == null) {
			dz = 0.;
		}
		var f = 1 / Math.sqrt(dx * dx + dy * dy + dz * dz);
		dx *= f;
		var x = dy *= f;
		var y = -dx;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h2d_col_PointImpl(x,y);
	}
	,doOffset: function(delta) {
		var polygons = null;
		this.m_destPolys = polygons == null ? [] : polygons;
		this.m_delta = delta;
		if(delta > -1e-020 && delta < 1E-20) {
			var _g = 0;
			var _g1 = this.m_polyNodes.childs;
			while(_g < _g1.length) {
				var node = _g1[_g];
				++_g;
				if(node.endtype == hxd_clipper_EndType.ClosedPol) {
					this.m_destPolys.push(node.polygon);
				}
			}
			return;
		}
		if(this.MiterLimit > 2) {
			this.m_miterLim = 2 / (this.MiterLimit * this.MiterLimit);
		} else {
			this.m_miterLim = 0.5;
		}
		var y;
		if(this.ArcTolerance <= 0.0) {
			y = this.def_arc_tolerance;
		} else if(this.ArcTolerance > (delta < 0 ? -delta : delta) * this.def_arc_tolerance) {
			y = (delta < 0 ? -delta : delta) * this.def_arc_tolerance;
		} else {
			y = this.ArcTolerance;
		}
		var steps = 3.14159265358979323 / Math.acos(1 - y / (delta < 0 ? -delta : delta)) | 0;
		this.m_sin = Math.sin(this.two_pi / steps);
		this.m_cos = Math.cos(this.two_pi / steps);
		this.m_StepsPerRad = steps / this.two_pi;
		if(delta < 0.) {
			this.m_sin = -this.m_sin;
		}
		var _g = 0;
		var _g1 = this.m_polyNodes.childs;
		while(_g < _g1.length) {
			var node = _g1[_g];
			++_g;
			this.m_srcPoly = node.polygon;
			var len = this.m_srcPoly.length;
			if(len == 0 || delta <= 0 && (len < 3 || node.endtype != hxd_clipper_EndType.ClosedPol)) {
				continue;
			}
			var points = null;
			this.m_destPoly = points == null ? [] : points;
			if(len == 1) {
				if(node.jointype == hxd_clipper_JoinType.Round) {
					var X = 1.;
					var Y = 0.;
					var _g2 = 1;
					var _g3 = steps + 1;
					while(_g2 < _g3) {
						var j = _g2++;
						this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[0].x + X * delta),Math.round(this.m_srcPoly[0].y + Y * delta)));
						var X2 = X;
						X = X * this.m_cos - this.m_sin * Y;
						Y = X2 * this.m_sin + Y * this.m_cos;
					}
				} else {
					var X1 = -1.;
					var Y1 = -1.;
					this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[0].x + X1 * delta),Math.round(this.m_srcPoly[0].y + Y1 * delta)));
					if(X1 < 0) {
						X1 = 1;
					} else if(Y1 < 0) {
						Y1 = 1;
					} else {
						X1 = -1;
					}
					this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[0].x + X1 * delta),Math.round(this.m_srcPoly[0].y + Y1 * delta)));
					if(X1 < 0) {
						X1 = 1;
					} else if(Y1 < 0) {
						Y1 = 1;
					} else {
						X1 = -1;
					}
					this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[0].x + X1 * delta),Math.round(this.m_srcPoly[0].y + Y1 * delta)));
					if(X1 < 0) {
						X1 = 1;
					} else if(Y1 < 0) {
						Y1 = 1;
					} else {
						X1 = -1;
					}
					this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[0].x + X1 * delta),Math.round(this.m_srcPoly[0].y + Y1 * delta)));
					if(X1 < 0) {
						X1 = 1;
					} else if(Y1 < 0) {
						Y1 = 1;
					} else {
						X1 = -1;
					}
				}
				this.m_destPolys.push(this.m_destPoly);
				continue;
			}
			this.m_normals = [];
			var _g4 = 0;
			var _g5 = len - 1;
			while(_g4 < _g5) {
				var j1 = _g4++;
				this.m_normals.push(this.getUnitNormal(this.m_srcPoly[j1],this.m_srcPoly[j1 + 1]));
			}
			if(node.endtype == hxd_clipper_EndType.ClosedLine || node.endtype == hxd_clipper_EndType.ClosedPol) {
				this.m_normals.push(this.getUnitNormal(this.m_srcPoly[len - 1],this.m_srcPoly[0]));
			} else {
				this.m_normals.push(this.m_normals[len - 2]);
			}
			if(node.endtype == hxd_clipper_EndType.ClosedPol) {
				var k = len - 1;
				var _g6 = 0;
				var _g7 = len;
				while(_g6 < _g7) {
					var j2 = _g6++;
					k = this.offsetPoint(j2,k,node.jointype);
				}
				this.m_destPolys.push(this.m_destPoly);
			} else if(node.endtype == hxd_clipper_EndType.ClosedLine) {
				var k1 = len - 1;
				var _g8 = 0;
				var _g9 = len;
				while(_g8 < _g9) {
					var j3 = _g8++;
					k1 = this.offsetPoint(j3,k1,node.jointype);
				}
				this.m_destPolys.push(this.m_destPoly);
				var points1 = null;
				this.m_destPoly = points1 == null ? [] : points1;
				var n = this.m_normals[len - 1];
				var j4 = len - 1;
				while(j4 > 0) {
					var x = -this.m_normals[j4 - 1].x;
					var y = -this.m_normals[j4 - 1].y;
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					this.m_normals[j4] = new h2d_col_PointImpl(x,y);
					--j4;
				}
				var x1 = -n.x;
				var y1 = -n.y;
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				this.m_normals[0] = new h2d_col_PointImpl(x1,y1);
				k1 = 0;
				var j5 = len - 1;
				while(j5 > 0) {
					k1 = this.offsetPoint(j5,k1,node.jointype);
					--j5;
				}
				this.m_destPolys.push(this.m_destPoly);
			} else {
				var k2 = 0;
				var _g10 = 1;
				var _g11 = len - 1;
				while(_g10 < _g11) {
					var j6 = _g10++;
					k2 = this.offsetPoint(j6,k2,node.jointype);
				}
				var pt1;
				if(node.endtype == hxd_clipper_EndType.OpenButt) {
					var j7 = len - 1;
					pt1 = new h2d_col_IPoint(Math.round(this.m_srcPoly[j7].x + this.m_normals[j7].x * delta),Math.round(this.m_srcPoly[j7].y + this.m_normals[j7].y * delta));
					this.m_destPoly.push(pt1);
					pt1 = new h2d_col_IPoint(Math.round(this.m_srcPoly[j7].x - this.m_normals[j7].x * delta),Math.round(this.m_srcPoly[j7].y - this.m_normals[j7].y * delta));
					this.m_destPoly.push(pt1);
				} else {
					var j8 = len - 1;
					k2 = len - 2;
					this.m_sinA = 0;
					var x2 = -this.m_normals[j8].x;
					var y2 = -this.m_normals[j8].y;
					if(y2 == null) {
						y2 = 0.;
					}
					if(x2 == null) {
						x2 = 0.;
					}
					this.m_normals[j8] = new h2d_col_PointImpl(x2,y2);
					if(node.endtype == hxd_clipper_EndType.OpenSquare) {
						var dx = Math.tan(Math.atan2(this.m_sinA,this.m_normals[k2].x * this.m_normals[j8].x + this.m_normals[k2].y * this.m_normals[j8].y) * 0.25);
						this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[j8].x + this.m_delta * (this.m_normals[k2].x - this.m_normals[k2].y * dx)),Math.round(this.m_srcPoly[j8].y + this.m_delta * (this.m_normals[k2].y + this.m_normals[k2].x * dx))));
						this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[j8].x + this.m_delta * (this.m_normals[j8].x + this.m_normals[j8].y * dx)),Math.round(this.m_srcPoly[j8].y + this.m_delta * (this.m_normals[j8].y - this.m_normals[j8].x * dx))));
					} else {
						var a = Math.atan2(this.m_sinA,this.m_normals[k2].x * this.m_normals[j8].x + this.m_normals[k2].y * this.m_normals[j8].y);
						var a1 = Math.round(this.m_StepsPerRad * (a < 0 ? -a : a));
						var steps1 = a1 < 1 ? 1 : a1;
						var X3 = this.m_normals[k2].x;
						var Y2 = this.m_normals[k2].y;
						var X21;
						var _g12 = 0;
						var _g13 = steps1;
						while(_g12 < _g13) {
							var i = _g12++;
							this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[j8].x + X3 * this.m_delta),Math.round(this.m_srcPoly[j8].y + Y2 * this.m_delta)));
							X21 = X3;
							X3 = X3 * this.m_cos - this.m_sin * Y2;
							Y2 = X21 * this.m_sin + Y2 * this.m_cos;
						}
						this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[j8].x + this.m_normals[j8].x * this.m_delta),Math.round(this.m_srcPoly[j8].y + this.m_normals[j8].y * this.m_delta)));
					}
				}
				var j9 = len - 1;
				while(j9 > 0) {
					var x3 = -this.m_normals[j9 - 1].x;
					var y3 = -this.m_normals[j9 - 1].y;
					if(y3 == null) {
						y3 = 0.;
					}
					if(x3 == null) {
						x3 = 0.;
					}
					this.m_normals[j9] = new h2d_col_PointImpl(x3,y3);
					--j9;
				}
				var x4 = -this.m_normals[1].x;
				var y4 = -this.m_normals[1].y;
				if(y4 == null) {
					y4 = 0.;
				}
				if(x4 == null) {
					x4 = 0.;
				}
				this.m_normals[0] = new h2d_col_PointImpl(x4,y4);
				k2 = len - 1;
				var j10 = k2 - 1;
				while(j10 > 0) {
					k2 = this.offsetPoint(j10,k2,node.jointype);
					--j10;
				}
				if(node.endtype == hxd_clipper_EndType.OpenButt) {
					pt1 = new h2d_col_IPoint(Math.round(this.m_srcPoly[0].x - this.m_normals[0].x * delta),Math.round(this.m_srcPoly[0].y - this.m_normals[0].y * delta));
					this.m_destPoly.push(pt1);
					pt1 = new h2d_col_IPoint(Math.round(this.m_srcPoly[0].x + this.m_normals[0].x * delta),Math.round(this.m_srcPoly[0].y + this.m_normals[0].y * delta));
					this.m_destPoly.push(pt1);
				} else {
					k2 = 1;
					this.m_sinA = 0;
					if(node.endtype == hxd_clipper_EndType.OpenSquare) {
						var dx1 = Math.tan(Math.atan2(this.m_sinA,this.m_normals[1].x * this.m_normals[0].x + this.m_normals[1].y * this.m_normals[0].y) * 0.25);
						this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[0].x + this.m_delta * (this.m_normals[1].x - this.m_normals[1].y * dx1)),Math.round(this.m_srcPoly[0].y + this.m_delta * (this.m_normals[1].y + this.m_normals[1].x * dx1))));
						this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[0].x + this.m_delta * (this.m_normals[0].x + this.m_normals[0].y * dx1)),Math.round(this.m_srcPoly[0].y + this.m_delta * (this.m_normals[0].y - this.m_normals[0].x * dx1))));
					} else {
						var a2 = Math.atan2(this.m_sinA,this.m_normals[1].x * this.m_normals[0].x + this.m_normals[1].y * this.m_normals[0].y);
						var a3 = Math.round(this.m_StepsPerRad * (a2 < 0 ? -a2 : a2));
						var steps2 = a3 < 1 ? 1 : a3;
						var X4 = this.m_normals[1].x;
						var Y3 = this.m_normals[1].y;
						var X22;
						var _g14 = 0;
						var _g15 = steps2;
						while(_g14 < _g15) {
							var i1 = _g14++;
							this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[0].x + X4 * this.m_delta),Math.round(this.m_srcPoly[0].y + Y3 * this.m_delta)));
							X22 = X4;
							X4 = X4 * this.m_cos - this.m_sin * Y3;
							Y3 = X22 * this.m_sin + Y3 * this.m_cos;
						}
						this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[0].x + this.m_normals[0].x * this.m_delta),Math.round(this.m_srcPoly[0].y + this.m_normals[0].y * this.m_delta)));
					}
				}
				this.m_destPolys.push(this.m_destPoly);
			}
		}
	}
	,execute: function(delta) {
		this.fixOrientations();
		this.doOffset(delta);
		var clpr = new hxd_clipper_Clipper();
		clpr.resultKind = this.resultKind;
		clpr.addPolygons(this.m_destPolys,hxd_clipper_PolyType.Subject);
		if(delta > 0) {
			return clpr.execute(hxd_clipper_ClipType.Union,hxd_clipper_PolyFillType.Positive,hxd_clipper_PolyFillType.Positive);
		} else {
			var r = hxd_clipper__$Clipper_ClipperBase.getBounds(this.m_destPolys);
			var points = null;
			var outer = points == null ? [] : points;
			outer.push(new h2d_col_IPoint(r.left - 10,r.bottom + 10));
			outer.push(new h2d_col_IPoint(r.right + 10,r.bottom + 10));
			outer.push(new h2d_col_IPoint(r.right + 10,r.top - 10));
			outer.push(new h2d_col_IPoint(r.left - 10,r.top - 10));
			clpr.addPolygon(outer,hxd_clipper_PolyType.Subject);
			clpr.reverseSolution = true;
			var out = clpr.execute(hxd_clipper_ClipType.Union,hxd_clipper_PolyFillType.Negative,hxd_clipper_PolyFillType.Negative);
			if(out.length > 0) {
				out.shift();
			}
			return out;
		}
	}
	,offsetPoint: function(j,k,jointype) {
		this.m_sinA = this.m_normals[k].x * this.m_normals[j].y - this.m_normals[j].x * this.m_normals[k].y;
		var f = this.m_sinA * this.m_delta;
		if((f < 0 ? -f : f) < 1.0) {
			var cosA = this.m_normals[k].x * this.m_normals[j].x + this.m_normals[j].y * this.m_normals[k].y;
			if(cosA > 0) {
				this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[j].x + this.m_normals[k].x * this.m_delta),Math.round(this.m_srcPoly[j].y + this.m_normals[k].y * this.m_delta)));
				return k;
			}
		} else if(this.m_sinA > 1.0) {
			this.m_sinA = 1.0;
		} else if(this.m_sinA < -1.0) {
			this.m_sinA = -1.0;
		}
		if(this.m_sinA * this.m_delta < 0) {
			var p1 = new h2d_col_IPoint(Math.round(this.m_srcPoly[j].x + this.m_normals[k].x * this.m_delta),Math.round(this.m_srcPoly[j].y + this.m_normals[k].y * this.m_delta));
			var p2 = new h2d_col_IPoint(Math.round(this.m_srcPoly[j].x + this.m_normals[j].x * this.m_delta),Math.round(this.m_srcPoly[j].y + this.m_normals[j].y * this.m_delta));
			this.m_destPoly.push(p1);
			var dx = p1.x - p2.x;
			var dy = p1.y - p2.y;
			if(dx * dx + dy * dy > 1) {
				this.m_destPoly.push(this.m_srcPoly[j]);
				this.m_destPoly.push(p2);
			}
		} else {
			switch(jointype._hx_index) {
			case 0:
				var dx = Math.tan(Math.atan2(this.m_sinA,this.m_normals[k].x * this.m_normals[j].x + this.m_normals[k].y * this.m_normals[j].y) * 0.25);
				this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[j].x + this.m_delta * (this.m_normals[k].x - this.m_normals[k].y * dx)),Math.round(this.m_srcPoly[j].y + this.m_delta * (this.m_normals[k].y + this.m_normals[k].x * dx))));
				this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[j].x + this.m_delta * (this.m_normals[j].x + this.m_normals[j].y * dx)),Math.round(this.m_srcPoly[j].y + this.m_delta * (this.m_normals[j].y - this.m_normals[j].x * dx))));
				break;
			case 1:
				var a = Math.atan2(this.m_sinA,this.m_normals[k].x * this.m_normals[j].x + this.m_normals[k].y * this.m_normals[j].y);
				var a1 = Math.round(this.m_StepsPerRad * (a < 0 ? -a : a));
				var steps = a1 < 1 ? 1 : a1;
				var X = this.m_normals[k].x;
				var Y = this.m_normals[k].y;
				var X2;
				var _g = 0;
				var _g1 = steps;
				while(_g < _g1) {
					var i = _g++;
					this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[j].x + X * this.m_delta),Math.round(this.m_srcPoly[j].y + Y * this.m_delta)));
					X2 = X;
					X = X * this.m_cos - this.m_sin * Y;
					Y = X2 * this.m_sin + Y * this.m_cos;
				}
				this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[j].x + this.m_normals[j].x * this.m_delta),Math.round(this.m_srcPoly[j].y + this.m_normals[j].y * this.m_delta)));
				break;
			case 2:
				var r = 1 + (this.m_normals[j].x * this.m_normals[k].x + this.m_normals[j].y * this.m_normals[k].y);
				if(r >= this.m_miterLim) {
					var q = this.m_delta / r;
					this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[j].x + (this.m_normals[k].x + this.m_normals[j].x) * q),Math.round(this.m_srcPoly[j].y + (this.m_normals[k].y + this.m_normals[j].y) * q)));
				} else {
					var dx = Math.tan(Math.atan2(this.m_sinA,this.m_normals[k].x * this.m_normals[j].x + this.m_normals[k].y * this.m_normals[j].y) * 0.25);
					this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[j].x + this.m_delta * (this.m_normals[k].x - this.m_normals[k].y * dx)),Math.round(this.m_srcPoly[j].y + this.m_delta * (this.m_normals[k].y + this.m_normals[k].x * dx))));
					this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[j].x + this.m_delta * (this.m_normals[j].x + this.m_normals[j].y * dx)),Math.round(this.m_srcPoly[j].y + this.m_delta * (this.m_normals[j].y - this.m_normals[j].x * dx))));
				}
				break;
			}
		}
		return j;
	}
	,doSquare: function(j,k) {
		var dx = Math.tan(Math.atan2(this.m_sinA,this.m_normals[k].x * this.m_normals[j].x + this.m_normals[k].y * this.m_normals[j].y) * 0.25);
		this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[j].x + this.m_delta * (this.m_normals[k].x - this.m_normals[k].y * dx)),Math.round(this.m_srcPoly[j].y + this.m_delta * (this.m_normals[k].y + this.m_normals[k].x * dx))));
		this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[j].x + this.m_delta * (this.m_normals[j].x + this.m_normals[j].y * dx)),Math.round(this.m_srcPoly[j].y + this.m_delta * (this.m_normals[j].y - this.m_normals[j].x * dx))));
	}
	,doMiter: function(j,k,r) {
		var q = this.m_delta / r;
		this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[j].x + (this.m_normals[k].x + this.m_normals[j].x) * q),Math.round(this.m_srcPoly[j].y + (this.m_normals[k].y + this.m_normals[j].y) * q)));
	}
	,doRound: function(j,k) {
		var a = Math.atan2(this.m_sinA,this.m_normals[k].x * this.m_normals[j].x + this.m_normals[k].y * this.m_normals[j].y);
		var a1 = Math.round(this.m_StepsPerRad * (a < 0 ? -a : a));
		var steps = a1 < 1 ? 1 : a1;
		var X = this.m_normals[k].x;
		var Y = this.m_normals[k].y;
		var X2;
		var _g = 0;
		var _g1 = steps;
		while(_g < _g1) {
			var i = _g++;
			this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[j].x + X * this.m_delta),Math.round(this.m_srcPoly[j].y + Y * this.m_delta)));
			X2 = X;
			X = X * this.m_cos - this.m_sin * Y;
			Y = X2 * this.m_sin + Y * this.m_cos;
		}
		this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[j].x + this.m_normals[j].x * this.m_delta),Math.round(this.m_srcPoly[j].y + this.m_normals[j].y * this.m_delta)));
	}
	,__class__: hxd_clipper_ClipperOffset
};
var hxd_clipper_EndType = $hxEnums["hxd.clipper.EndType"] = { __ename__:true,__constructs__:null
	,ClosedPol: {_hx_name:"ClosedPol",_hx_index:0,__enum__:"hxd.clipper.EndType",toString:$estr}
	,ClosedLine: {_hx_name:"ClosedLine",_hx_index:1,__enum__:"hxd.clipper.EndType",toString:$estr}
	,OpenButt: {_hx_name:"OpenButt",_hx_index:2,__enum__:"hxd.clipper.EndType",toString:$estr}
	,OpenSquare: {_hx_name:"OpenSquare",_hx_index:3,__enum__:"hxd.clipper.EndType",toString:$estr}
	,OpenRound: {_hx_name:"OpenRound",_hx_index:4,__enum__:"hxd.clipper.EndType",toString:$estr}
};
hxd_clipper_EndType.__constructs__ = [hxd_clipper_EndType.ClosedPol,hxd_clipper_EndType.ClosedLine,hxd_clipper_EndType.OpenButt,hxd_clipper_EndType.OpenSquare,hxd_clipper_EndType.OpenRound];
hxd_clipper_EndType.__empty_constructs__ = [hxd_clipper_EndType.ClosedPol,hxd_clipper_EndType.ClosedLine,hxd_clipper_EndType.OpenButt,hxd_clipper_EndType.OpenSquare,hxd_clipper_EndType.OpenRound];
var hxd_clipper_JoinType = $hxEnums["hxd.clipper.JoinType"] = { __ename__:true,__constructs__:null
	,Square: {_hx_name:"Square",_hx_index:0,__enum__:"hxd.clipper.JoinType",toString:$estr}
	,Round: {_hx_name:"Round",_hx_index:1,__enum__:"hxd.clipper.JoinType",toString:$estr}
	,Miter: {_hx_name:"Miter",_hx_index:2,__enum__:"hxd.clipper.JoinType",toString:$estr}
};
hxd_clipper_JoinType.__constructs__ = [hxd_clipper_JoinType.Square,hxd_clipper_JoinType.Round,hxd_clipper_JoinType.Miter];
hxd_clipper_JoinType.__empty_constructs__ = [hxd_clipper_JoinType.Square,hxd_clipper_JoinType.Round,hxd_clipper_JoinType.Miter];
var hxd_clipper_PolyFillType = $hxEnums["hxd.clipper.PolyFillType"] = { __ename__:true,__constructs__:null
	,EvenOdd: {_hx_name:"EvenOdd",_hx_index:0,__enum__:"hxd.clipper.PolyFillType",toString:$estr}
	,NonZero: {_hx_name:"NonZero",_hx_index:1,__enum__:"hxd.clipper.PolyFillType",toString:$estr}
	,Positive: {_hx_name:"Positive",_hx_index:2,__enum__:"hxd.clipper.PolyFillType",toString:$estr}
	,Negative: {_hx_name:"Negative",_hx_index:3,__enum__:"hxd.clipper.PolyFillType",toString:$estr}
};
hxd_clipper_PolyFillType.__constructs__ = [hxd_clipper_PolyFillType.EvenOdd,hxd_clipper_PolyFillType.NonZero,hxd_clipper_PolyFillType.Positive,hxd_clipper_PolyFillType.Negative];
hxd_clipper_PolyFillType.__empty_constructs__ = [hxd_clipper_PolyFillType.EvenOdd,hxd_clipper_PolyFillType.NonZero,hxd_clipper_PolyFillType.Positive,hxd_clipper_PolyFillType.Negative];
var hxd_clipper_PolyType = $hxEnums["hxd.clipper.PolyType"] = { __ename__:true,__constructs__:null
	,Subject: {_hx_name:"Subject",_hx_index:0,__enum__:"hxd.clipper.PolyType",toString:$estr}
	,Clip: {_hx_name:"Clip",_hx_index:1,__enum__:"hxd.clipper.PolyType",toString:$estr}
};
hxd_clipper_PolyType.__constructs__ = [hxd_clipper_PolyType.Subject,hxd_clipper_PolyType.Clip];
hxd_clipper_PolyType.__empty_constructs__ = [hxd_clipper_PolyType.Subject,hxd_clipper_PolyType.Clip];
var hxd_clipper_Rect = function(l,t,r,b) {
	if(b == null) {
		b = 0;
	}
	if(r == null) {
		r = 0;
	}
	if(t == null) {
		t = 0;
	}
	if(l == null) {
		l = 0;
	}
	this.left = l;
	this.top = t;
	this.right = r;
	this.bottom = b;
};
$hxClasses["hxd.clipper.Rect"] = hxd_clipper_Rect;
hxd_clipper_Rect.__name__ = "hxd.clipper.Rect";
hxd_clipper_Rect.prototype = {
	__class__: hxd_clipper_Rect
};
var hxd_earcut_EarNode = function() {
};
$hxClasses["hxd.earcut.EarNode"] = hxd_earcut_EarNode;
hxd_earcut_EarNode.__name__ = "hxd.earcut.EarNode";
hxd_earcut_EarNode.prototype = {
	__class__: hxd_earcut_EarNode
};
var hxd_earcut_Earcut = function() {
};
$hxClasses["hxd.earcut.Earcut"] = hxd_earcut_Earcut;
hxd_earcut_Earcut.__name__ = "hxd.earcut.Earcut";
hxd_earcut_Earcut.prototype = {
	triangulate_h2d_GPoint: function(points,holes) {
		var hasHoles = holes != null && holes.length > 0;
		var outerLen = hasHoles ? holes[0] : points.length;
		if(outerLen < 3) {
			return [];
		}
		var root = this.setLinkedList_triangulate_T(points,0,outerLen,true);
		if(holes != null) {
			root = this.eliminateHoles_triangulate_T(points,holes,root);
		}
		return this.triangulateNode(root,points.length > 80);
	}
	,triangulate_anon_y_Float_x_Float: function(points,holes) {
		var hasHoles = holes != null && holes.length > 0;
		var outerLen = hasHoles ? holes[0] : points.length;
		if(outerLen < 3) {
			return [];
		}
		var root = this.setLinkedList_triangulate_T(points,0,outerLen,true);
		if(holes != null) {
			root = this.eliminateHoles_triangulate_T(points,holes,root);
		}
		return this.triangulateNode(root,points.length > 80);
	}
	,eliminateHoles_triangulate_T: function(points,holes,root) {
		var queue = [];
		var _g = 0;
		var _g1 = holes.length;
		while(_g < _g1) {
			var i = _g++;
			var s = holes[i];
			var e = i == holes.length - 1 ? points.length : holes[i + 1];
			var node = this.setLinkedList_eliminateHoles_T(points,s,e,false);
			if(node == node.next) {
				node.steiner = true;
			}
			queue.push(this.getLeftmost(node));
		}
		queue.sort($bind(this,this.compareX));
		var _g = 0;
		while(_g < queue.length) {
			var q = queue[_g];
			++_g;
			this.eliminateHole(q,root);
			root = this.filterPoints(root,root.next);
		}
		return root;
	}
	,setLinkedList_eliminateHoles_T: function(points,start,end,clockwise) {
		var sum = 0.;
		var j = end - 1;
		var _g = start;
		var _g1 = end;
		while(_g < _g1) {
			var i = _g++;
			sum += (points[j].x - points[i].x) * (points[i].y + points[j].y);
			j = i;
		}
		var last = null;
		var n = this.cache;
		if(n == null) {
			n = new hxd_earcut_EarNode();
			n.allocNext = this.allocated;
			this.allocated = n;
		} else {
			this.cache = n.next;
		}
		n.i = -1;
		n.z = -1;
		n.x = 0;
		n.y = 0;
		n.next = null;
		n.prev = last;
		n.steiner = false;
		n.prevZ = null;
		n.nextZ = null;
		if(last != null) {
			last.next = n;
		}
		var node = n;
		var first = node;
		if(clockwise == sum > 0) {
			var _g = start;
			var _g1 = end;
			while(_g < _g1) {
				var i = _g++;
				var p = points[i];
				var x = p.x;
				var y = p.y;
				var n = this.cache;
				if(n == null) {
					n = new hxd_earcut_EarNode();
					n.allocNext = this.allocated;
					this.allocated = n;
				} else {
					this.cache = n.next;
				}
				n.i = i;
				n.z = -1;
				n.x = x;
				n.y = y;
				n.next = null;
				n.prev = node;
				n.steiner = false;
				n.prevZ = null;
				n.nextZ = null;
				if(node != null) {
					node.next = n;
				}
				node = n;
			}
		} else {
			var i = end - 1;
			while(i >= start) {
				var p = points[i];
				var x = p.x;
				var y = p.y;
				var n = this.cache;
				if(n == null) {
					n = new hxd_earcut_EarNode();
					n.allocNext = this.allocated;
					this.allocated = n;
				} else {
					this.cache = n.next;
				}
				n.i = i;
				n.z = -1;
				n.x = x;
				n.y = y;
				n.next = null;
				n.prev = node;
				n.steiner = false;
				n.prevZ = null;
				n.nextZ = null;
				if(node != null) {
					node.next = n;
				}
				node = n;
				--i;
			}
		}
		node.next = first.next;
		node.next.prev = node;
		return node;
	}
	,setLinkedList_triangulate_T: function(points,start,end,clockwise) {
		var sum = 0.;
		var j = end - 1;
		var _g = start;
		var _g1 = end;
		while(_g < _g1) {
			var i = _g++;
			sum += (points[j].x - points[i].x) * (points[i].y + points[j].y);
			j = i;
		}
		var last = null;
		var n = this.cache;
		if(n == null) {
			n = new hxd_earcut_EarNode();
			n.allocNext = this.allocated;
			this.allocated = n;
		} else {
			this.cache = n.next;
		}
		n.i = -1;
		n.z = -1;
		n.x = 0;
		n.y = 0;
		n.next = null;
		n.prev = last;
		n.steiner = false;
		n.prevZ = null;
		n.nextZ = null;
		if(last != null) {
			last.next = n;
		}
		var node = n;
		var first = node;
		if(clockwise == sum > 0) {
			var _g = start;
			var _g1 = end;
			while(_g < _g1) {
				var i = _g++;
				var p = points[i];
				var x = p.x;
				var y = p.y;
				var n = this.cache;
				if(n == null) {
					n = new hxd_earcut_EarNode();
					n.allocNext = this.allocated;
					this.allocated = n;
				} else {
					this.cache = n.next;
				}
				n.i = i;
				n.z = -1;
				n.x = x;
				n.y = y;
				n.next = null;
				n.prev = node;
				n.steiner = false;
				n.prevZ = null;
				n.nextZ = null;
				if(node != null) {
					node.next = n;
				}
				node = n;
			}
		} else {
			var i = end - 1;
			while(i >= start) {
				var p = points[i];
				var x = p.x;
				var y = p.y;
				var n = this.cache;
				if(n == null) {
					n = new hxd_earcut_EarNode();
					n.allocNext = this.allocated;
					this.allocated = n;
				} else {
					this.cache = n.next;
				}
				n.i = i;
				n.z = -1;
				n.x = x;
				n.y = y;
				n.next = null;
				n.prev = node;
				n.steiner = false;
				n.prevZ = null;
				n.nextZ = null;
				if(node != null) {
					node.next = n;
				}
				node = n;
				--i;
			}
		}
		node.next = first.next;
		node.next.prev = node;
		return node;
	}
	,triangulateNode: function(root,useZOrder) {
		this.triangles = [];
		root = this.filterPoints(root);
		if(useZOrder && root != null) {
			var maxX = root.x;
			this.minX = maxX;
			var maxY = root.y;
			this.minY = maxY;
			var p = root.next;
			while(p != root) {
				var x = p.x;
				var y = p.y;
				if(x < this.minX) {
					this.minX = x;
				}
				if(y < this.minY) {
					this.minY = y;
				}
				if(x > maxX) {
					maxX = x;
				}
				if(y > maxY) {
					maxY = y;
				}
				p = p.next;
			}
			var a = maxX - this.minX;
			var b = maxY - this.minY;
			this.size = a < b ? b : a;
			this.hasSize = true;
		} else {
			this.hasSize = false;
		}
		this.earcutLinked(root);
		var result = this.triangles;
		this.triangles = null;
		var n = this.allocated;
		if(this.cache != null) {
			while(n != this.cache) n = n.allocNext;
			n = n.allocNext;
		}
		while(n != null) {
			n.next = this.cache;
			this.cache = n;
			n = n.allocNext;
		}
		return result;
	}
	,eliminateHole: function(hole,root) {
		root = this.findHoleBridge(hole,root);
		if(root != null) {
			var b = this.splitPolygon(root,hole);
			this.filterPoints(b,b.next);
		}
	}
	,findHoleBridge: function(hole,root) {
		var p = root;
		var hx = hole.x;
		var hy = hole.y;
		var qx = -Infinity;
		var m = null;
		do {
			if(hy <= p.y && hy >= p.next.y) {
				var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
				if(x <= hx && x > qx) {
					qx = x;
					m = p.x < p.next.x ? p : p.next;
				}
			}
			p = p.next;
		} while(p != root);
		if(m == null) {
			return null;
		}
		var stop = m;
		var tanMin = Infinity;
		var tan;
		p = m.next;
		while(p != stop) {
			var tmp;
			if(hx >= p.x && p.x >= m.x) {
				var ax = hy < m.y ? hx : qx;
				var bx = m.x;
				var by = m.y;
				var cx = hy < m.y ? qx : hx;
				var px = p.x;
				var py = p.y;
				tmp = (cx - px) * (hy - py) - (ax - px) * (hy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (hy - py) >= 0 && (bx - px) * (hy - py) - (cx - px) * (by - py) >= 0;
			} else {
				tmp = false;
			}
			if(tmp) {
				var f = hy - p.y;
				tan = (f < 0 ? -f : f) / (hx - p.x);
				var tmp1;
				if(tan < tanMin || tan == tanMin && p.x > m.x) {
					var p1 = p.prev;
					var r = p.next;
					if((p.y - p1.y) * (r.x - p.x) - (p.x - p1.x) * (r.y - p.y) < 0) {
						var r1 = p.next;
						if((hole.y - p.y) * (r1.x - hole.x) - (hole.x - p.x) * (r1.y - hole.y) >= 0) {
							var q = p.prev;
							tmp1 = (q.y - p.y) * (hole.x - q.x) - (q.x - p.x) * (hole.y - q.y) >= 0;
						} else {
							tmp1 = false;
						}
					} else {
						var r2 = p.prev;
						if(!((hole.y - p.y) * (r2.x - hole.x) - (hole.x - p.x) * (r2.y - hole.y) < 0)) {
							var q1 = p.next;
							tmp1 = (q1.y - p.y) * (hole.x - q1.x) - (q1.x - p.x) * (hole.y - q1.y) < 0;
						} else {
							tmp1 = true;
						}
					}
				} else {
					tmp1 = false;
				}
				if(tmp1) {
					m = p;
					tanMin = tan;
				}
			}
			p = p.next;
		}
		return m;
	}
	,getLeftmost: function(node) {
		var p = node;
		var leftmost = node;
		do {
			if(p.x < leftmost.x) {
				leftmost = p;
			}
			p = p.next;
		} while(p != node);
		return leftmost;
	}
	,compareX: function(a,b) {
		if(a.x - b.x > 0) {
			return 1;
		} else {
			return -1;
		}
	}
	,equals: function(p1,p2) {
		if(p1.x == p2.x) {
			return p1.y == p2.y;
		} else {
			return false;
		}
	}
	,area: function(p,q,r) {
		return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
	}
	,intersects: function(p1,q1,p2,q2) {
		if((q1.y - p1.y) * (p2.x - q1.x) - (q1.x - p1.x) * (p2.y - q1.y) > 0 != (q1.y - p1.y) * (q2.x - q1.x) - (q1.x - p1.x) * (q2.y - q1.y) > 0) {
			return (q2.y - p2.y) * (p1.x - q2.x) - (q2.x - p2.x) * (p1.y - q2.y) > 0 != (q2.y - p2.y) * (q1.x - q2.x) - (q2.x - p2.x) * (q1.y - q2.y) > 0;
		} else {
			return false;
		}
	}
	,locallyInside: function(a,b) {
		var p = a.prev;
		var r = a.next;
		if((a.y - p.y) * (r.x - a.x) - (a.x - p.x) * (r.y - a.y) < 0) {
			var r = a.next;
			if((b.y - a.y) * (r.x - b.x) - (b.x - a.x) * (r.y - b.y) >= 0) {
				var q = a.prev;
				return (q.y - a.y) * (b.x - q.x) - (q.x - a.x) * (b.y - q.y) >= 0;
			} else {
				return false;
			}
		} else {
			var r = a.prev;
			if(!((b.y - a.y) * (r.x - b.x) - (b.x - a.x) * (r.y - b.y) < 0)) {
				var q = a.next;
				return (q.y - a.y) * (b.x - q.x) - (q.x - a.x) * (b.y - q.y) < 0;
			} else {
				return true;
			}
		}
	}
	,filterPoints: function(start,end) {
		if(start == null) {
			return start;
		}
		if(end == null) {
			end = start;
		}
		var p = start;
		var again;
		do {
			again = false;
			var tmp;
			if(!p.steiner) {
				var p2 = p.next;
				if(!(p.x == p2.x && p.y == p2.y)) {
					var p1 = p.prev;
					var r = p.next;
					tmp = (p.y - p1.y) * (r.x - p.x) - (p.x - p1.x) * (r.y - p.y) == 0;
				} else {
					tmp = true;
				}
			} else {
				tmp = false;
			}
			if(tmp) {
				p.next.prev = p.prev;
				p.prev.next = p.next;
				if(p.prevZ != null) {
					p.prevZ.nextZ = p.nextZ;
				}
				if(p.nextZ != null) {
					p.nextZ.prevZ = p.prevZ;
				}
				end = p.prev;
				p = end;
				if(p == p.next) {
					return null;
				}
				again = true;
			} else {
				p = p.next;
			}
		} while(again || p != end);
		return end;
	}
	,removeNode: function(p) {
		p.next.prev = p.prev;
		p.prev.next = p.next;
		if(p.prevZ != null) {
			p.prevZ.nextZ = p.nextZ;
		}
		if(p.nextZ != null) {
			p.nextZ.prevZ = p.prevZ;
		}
	}
	,allocNode: function(i,x,y,last) {
		var n = this.cache;
		if(n == null) {
			n = new hxd_earcut_EarNode();
			n.allocNext = this.allocated;
			this.allocated = n;
		} else {
			this.cache = n.next;
		}
		n.i = i;
		n.z = -1;
		n.x = x;
		n.y = y;
		n.next = null;
		n.prev = last;
		n.steiner = false;
		n.prevZ = null;
		n.nextZ = null;
		if(last != null) {
			last.next = n;
		}
		return n;
	}
	,earcutLinked: function(ear,pass) {
		if(pass == null) {
			pass = 0;
		}
		if(ear == null) {
			return;
		}
		if(pass == 0 && this.hasSize) {
			this.indexCurve(ear);
		}
		var stop = ear;
		var prev;
		var next;
		while(ear.prev != ear.next) {
			prev = ear.prev;
			next = ear.next;
			if(this.hasSize ? this.isEarHashed(ear) : this.isEar(ear)) {
				this.triangles.push(prev.i);
				this.triangles.push(ear.i);
				this.triangles.push(next.i);
				ear.next.prev = ear.prev;
				ear.prev.next = ear.next;
				if(ear.prevZ != null) {
					ear.prevZ.nextZ = ear.nextZ;
				}
				if(ear.nextZ != null) {
					ear.nextZ.prevZ = ear.prevZ;
				}
				ear = next.next;
				stop = next.next;
				continue;
			}
			ear = next;
			if(ear == stop) {
				switch(pass) {
				case 0:
					this.earcutLinked(this.filterPoints(ear),1);
					break;
				case 1:
					ear = this.cureLocalIntersections(ear);
					this.earcutLinked(ear,2);
					break;
				case 2:
					this.splitEarcut(ear);
					break;
				}
				break;
			}
		}
	}
	,isEar: function(ear) {
		var a = ear.prev;
		var b = ear;
		var c = ear.next;
		if((b.y - a.y) * (c.x - b.x) - (b.x - a.x) * (c.y - b.y) >= 0) {
			return false;
		}
		var p = ear.next.next;
		while(p != ear.prev) {
			var tmp;
			var ax = a.x;
			var ay = a.y;
			var bx = b.x;
			var by = b.y;
			var cx = c.x;
			var cy = c.y;
			var px = p.x;
			var py = p.y;
			if((cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0) {
				var p1 = p.prev;
				var r = p.next;
				tmp = (p.y - p1.y) * (r.x - p.x) - (p.x - p1.x) * (r.y - p.y) >= 0;
			} else {
				tmp = false;
			}
			if(tmp) {
				return false;
			}
			p = p.next;
		}
		return true;
	}
	,isEarHashed: function(ear) {
		var a = ear.prev;
		var b = ear;
		var c = ear.next;
		if((b.y - a.y) * (c.x - b.x) - (b.x - a.x) * (c.y - b.y) >= 0) {
			return false;
		}
		var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x;
		var minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y;
		var maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x;
		var maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
		var x = 32767 * (minTX - this.minX) / this.size | 0;
		var y = 32767 * (minTY - this.minY) / this.size | 0;
		x = (x | x << 8) & 16711935;
		x = (x | x << 4) & 252645135;
		x = (x | x << 2) & 858993459;
		x = (x | x << 1) & 1431655765;
		y = (y | y << 8) & 16711935;
		y = (y | y << 4) & 252645135;
		y = (y | y << 2) & 858993459;
		y = (y | y << 1) & 1431655765;
		var minZ = x | y << 1;
		var x = 32767 * (maxTX - this.minX) / this.size | 0;
		var y = 32767 * (maxTY - this.minY) / this.size | 0;
		x = (x | x << 8) & 16711935;
		x = (x | x << 4) & 252645135;
		x = (x | x << 2) & 858993459;
		x = (x | x << 1) & 1431655765;
		y = (y | y << 8) & 16711935;
		y = (y | y << 4) & 252645135;
		y = (y | y << 2) & 858993459;
		y = (y | y << 1) & 1431655765;
		var maxZ = x | y << 1;
		var p = ear.nextZ;
		while(p != null && p.z <= maxZ) {
			var tmp;
			var tmp1;
			if(p != ear.prev && p != ear.next) {
				var ax = a.x;
				var ay = a.y;
				var bx = b.x;
				var by = b.y;
				var cx = c.x;
				var cy = c.y;
				var px = p.x;
				var py = p.y;
				tmp1 = (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
			} else {
				tmp1 = false;
			}
			if(tmp1) {
				var p1 = p.prev;
				var r = p.next;
				tmp = (p.y - p1.y) * (r.x - p.x) - (p.x - p1.x) * (r.y - p.y) >= 0;
			} else {
				tmp = false;
			}
			if(tmp) {
				return false;
			}
			p = p.nextZ;
		}
		p = ear.prevZ;
		while(p != null && p.z >= minZ) {
			var tmp;
			var tmp1;
			if(p != ear.prev && p != ear.next) {
				var ax = a.x;
				var ay = a.y;
				var bx = b.x;
				var by = b.y;
				var cx = c.x;
				var cy = c.y;
				var px = p.x;
				var py = p.y;
				tmp1 = (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
			} else {
				tmp1 = false;
			}
			if(tmp1) {
				var p1 = p.prev;
				var r = p.next;
				tmp = (p.y - p1.y) * (r.x - p.x) - (p.x - p1.x) * (r.y - p.y) >= 0;
			} else {
				tmp = false;
			}
			if(tmp) {
				return false;
			}
			p = p.prevZ;
		}
		return true;
	}
	,cureLocalIntersections: function(start) {
		var p = start;
		do {
			var a = p.prev;
			var b = p.next.next;
			var tmp;
			var tmp1;
			var p2 = p.next;
			if((p.y - a.y) * (p2.x - p.x) - (p.x - a.x) * (p2.y - p.y) > 0 != (p.y - a.y) * (b.x - p.x) - (p.x - a.x) * (b.y - p.y) > 0 && (b.y - p2.y) * (a.x - b.x) - (b.x - p2.x) * (a.y - b.y) > 0 != (b.y - p2.y) * (p.x - b.x) - (b.x - p2.x) * (p.y - b.y) > 0) {
				var p1 = a.prev;
				var r = a.next;
				if((a.y - p1.y) * (r.x - a.x) - (a.x - p1.x) * (r.y - a.y) < 0) {
					var r1 = a.next;
					if((b.y - a.y) * (r1.x - b.x) - (b.x - a.x) * (r1.y - b.y) >= 0) {
						var q = a.prev;
						tmp1 = (q.y - a.y) * (b.x - q.x) - (q.x - a.x) * (b.y - q.y) >= 0;
					} else {
						tmp1 = false;
					}
				} else {
					var r2 = a.prev;
					if(!((b.y - a.y) * (r2.x - b.x) - (b.x - a.x) * (r2.y - b.y) < 0)) {
						var q1 = a.next;
						tmp1 = (q1.y - a.y) * (b.x - q1.x) - (q1.x - a.x) * (b.y - q1.y) < 0;
					} else {
						tmp1 = true;
					}
				}
			} else {
				tmp1 = false;
			}
			if(tmp1) {
				var p3 = b.prev;
				var r3 = b.next;
				if((b.y - p3.y) * (r3.x - b.x) - (b.x - p3.x) * (r3.y - b.y) < 0) {
					var r4 = b.next;
					if((a.y - b.y) * (r4.x - a.x) - (a.x - b.x) * (r4.y - a.y) >= 0) {
						var q2 = b.prev;
						tmp = (q2.y - b.y) * (a.x - q2.x) - (q2.x - b.x) * (a.y - q2.y) >= 0;
					} else {
						tmp = false;
					}
				} else {
					var r5 = b.prev;
					if(!((a.y - b.y) * (r5.x - a.x) - (a.x - b.x) * (r5.y - a.y) < 0)) {
						var q3 = b.next;
						tmp = (q3.y - b.y) * (a.x - q3.x) - (q3.x - b.x) * (a.y - q3.y) < 0;
					} else {
						tmp = true;
					}
				}
			} else {
				tmp = false;
			}
			if(tmp) {
				this.triangles.push(a.i);
				this.triangles.push(p.i);
				this.triangles.push(b.i);
				p.next.prev = p.prev;
				p.prev.next = p.next;
				if(p.prevZ != null) {
					p.prevZ.nextZ = p.nextZ;
				}
				if(p.nextZ != null) {
					p.nextZ.prevZ = p.prevZ;
				}
				var p4 = p.next;
				p4.next.prev = p4.prev;
				p4.prev.next = p4.next;
				if(p4.prevZ != null) {
					p4.prevZ.nextZ = p4.nextZ;
				}
				if(p4.nextZ != null) {
					p4.nextZ.prevZ = p4.prevZ;
				}
				start = b;
				p = start;
			}
			p = p.next;
		} while(p != start);
		return p;
	}
	,splitEarcut: function(start) {
		var a = start;
		do {
			var b = a.next.next;
			while(b != a.prev) {
				if(a.i != b.i && this.isValidDiagonal(a,b)) {
					var c = this.splitPolygon(a,b);
					a = this.filterPoints(a,a.next);
					c = this.filterPoints(c,c.next);
					this.earcutLinked(a);
					this.earcutLinked(c);
					return;
				}
				b = b.next;
			}
			a = a.next;
		} while(a != start);
	}
	,splitPolygon: function(a,b) {
		var i = a.i;
		var x = a.x;
		var y = a.y;
		var last = null;
		var n = this.cache;
		if(n == null) {
			n = new hxd_earcut_EarNode();
			n.allocNext = this.allocated;
			this.allocated = n;
		} else {
			this.cache = n.next;
		}
		n.i = i;
		n.z = -1;
		n.x = x;
		n.y = y;
		n.next = null;
		n.prev = last;
		n.steiner = false;
		n.prevZ = null;
		n.nextZ = null;
		if(last != null) {
			last.next = n;
		}
		var a2 = n;
		var i = b.i;
		var x = b.x;
		var y = b.y;
		var last = null;
		var n = this.cache;
		if(n == null) {
			n = new hxd_earcut_EarNode();
			n.allocNext = this.allocated;
			this.allocated = n;
		} else {
			this.cache = n.next;
		}
		n.i = i;
		n.z = -1;
		n.x = x;
		n.y = y;
		n.next = null;
		n.prev = last;
		n.steiner = false;
		n.prevZ = null;
		n.nextZ = null;
		if(last != null) {
			last.next = n;
		}
		var b2 = n;
		var an = a.next;
		var bp = b.prev;
		a.next = b;
		b.prev = a;
		a2.next = an;
		an.prev = a2;
		b2.next = a2;
		a2.prev = b2;
		bp.next = b2;
		b2.prev = bp;
		return b2;
	}
	,pointInTriangle: function(ax,ay,bx,by,cx,cy,px,py) {
		if((cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0) {
			return (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
		} else {
			return false;
		}
	}
	,isValidDiagonal: function(a,b) {
		if(!(a.x == b.x && a.y == b.y)) {
			var tmp;
			var tmp1;
			if(a.next.i != b.i && a.prev.i != b.i && !this.intersectsPolygon(a,b)) {
				var p = a.prev;
				var r = a.next;
				if((a.y - p.y) * (r.x - a.x) - (a.x - p.x) * (r.y - a.y) < 0) {
					var r = a.next;
					if((b.y - a.y) * (r.x - b.x) - (b.x - a.x) * (r.y - b.y) >= 0) {
						var q = a.prev;
						tmp1 = (q.y - a.y) * (b.x - q.x) - (q.x - a.x) * (b.y - q.y) >= 0;
					} else {
						tmp1 = false;
					}
				} else {
					var r = a.prev;
					if(!((b.y - a.y) * (r.x - b.x) - (b.x - a.x) * (r.y - b.y) < 0)) {
						var q = a.next;
						tmp1 = (q.y - a.y) * (b.x - q.x) - (q.x - a.x) * (b.y - q.y) < 0;
					} else {
						tmp1 = true;
					}
				}
			} else {
				tmp1 = false;
			}
			if(tmp1) {
				var p = b.prev;
				var r = b.next;
				if((b.y - p.y) * (r.x - b.x) - (b.x - p.x) * (r.y - b.y) < 0) {
					var r = b.next;
					if((a.y - b.y) * (r.x - a.x) - (a.x - b.x) * (r.y - a.y) >= 0) {
						var q = b.prev;
						tmp = (q.y - b.y) * (a.x - q.x) - (q.x - b.x) * (a.y - q.y) >= 0;
					} else {
						tmp = false;
					}
				} else {
					var r = b.prev;
					if(!((a.y - b.y) * (r.x - a.x) - (a.x - b.x) * (r.y - a.y) < 0)) {
						var q = b.next;
						tmp = (q.y - b.y) * (a.x - q.x) - (q.x - b.x) * (a.y - q.y) < 0;
					} else {
						tmp = true;
					}
				}
			} else {
				tmp = false;
			}
			if(tmp) {
				return this.middleInside(a,b);
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	,middleInside: function(a,b) {
		var p = a;
		var inside = false;
		var px = (a.x + b.x) / 2;
		var py = (a.y + b.y) / 2;
		do {
			if(p.y > py != p.next.y > py && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) {
				inside = !inside;
			}
			p = p.next;
		} while(p != a);
		return inside;
	}
	,intersectsPolygon: function(a,b) {
		var p = a;
		do {
			var tmp;
			if(p.i != a.i && p.next.i != a.i && p.i != b.i && p.next.i != b.i) {
				var q1 = p.next;
				tmp = (q1.y - p.y) * (a.x - q1.x) - (q1.x - p.x) * (a.y - q1.y) > 0 != (q1.y - p.y) * (b.x - q1.x) - (q1.x - p.x) * (b.y - q1.y) > 0 && (b.y - a.y) * (p.x - b.x) - (b.x - a.x) * (p.y - b.y) > 0 != (b.y - a.y) * (q1.x - b.x) - (b.x - a.x) * (q1.y - b.y) > 0;
			} else {
				tmp = false;
			}
			if(tmp) {
				return true;
			}
			p = p.next;
		} while(p != a);
		return false;
	}
	,zOrder: function(px,py) {
		var x = 32767 * (px - this.minX) / this.size | 0;
		var y = 32767 * (py - this.minY) / this.size | 0;
		x = (x | x << 8) & 16711935;
		x = (x | x << 4) & 252645135;
		x = (x | x << 2) & 858993459;
		x = (x | x << 1) & 1431655765;
		y = (y | y << 8) & 16711935;
		y = (y | y << 4) & 252645135;
		y = (y | y << 2) & 858993459;
		y = (y | y << 1) & 1431655765;
		return x | y << 1;
	}
	,indexCurve: function(start) {
		var p = start;
		do {
			if(p.z < 0) {
				var x = 32767 * (p.x - this.minX) / this.size | 0;
				var y = 32767 * (p.y - this.minY) / this.size | 0;
				x = (x | x << 8) & 16711935;
				x = (x | x << 4) & 252645135;
				x = (x | x << 2) & 858993459;
				x = (x | x << 1) & 1431655765;
				y = (y | y << 8) & 16711935;
				y = (y | y << 4) & 252645135;
				y = (y | y << 2) & 858993459;
				y = (y | y << 1) & 1431655765;
				p.z = x | y << 1;
			}
			p.prevZ = p.prev;
			p.nextZ = p.next;
			p = p.next;
		} while(p != start);
		p.prevZ.nextZ = null;
		p.prevZ = null;
		this.sortLinked(p);
	}
	,sortLinked: function(list) {
		var p;
		var q;
		var e;
		var tail;
		var numMerges;
		var pSize;
		var qSize;
		var inSize = 1;
		do {
			p = list;
			list = null;
			tail = null;
			numMerges = 0;
			while(p != null) {
				++numMerges;
				q = p;
				pSize = 0;
				var _g = 0;
				var _g1 = inSize;
				while(_g < _g1) {
					var i = _g++;
					++pSize;
					q = q.nextZ;
					if(q == null) {
						break;
					}
				}
				qSize = inSize;
				while(pSize > 0 || qSize > 0 && q != null) {
					if(pSize == 0) {
						e = q;
						q = q.nextZ;
						--qSize;
					} else if(qSize == 0 || q == null) {
						e = p;
						p = p.nextZ;
						--pSize;
					} else if(p.z <= q.z) {
						e = p;
						p = p.nextZ;
						--pSize;
					} else {
						e = q;
						q = q.nextZ;
						--qSize;
					}
					if(tail != null) {
						tail.nextZ = e;
					} else {
						list = e;
					}
					e.prevZ = tail;
					tail = e;
				}
				p = q;
			}
			tail.nextZ = null;
			inSize *= 2;
		} while(numMerges > 1);
		return list;
	}
	,__class__: hxd_earcut_Earcut
};
var hxd_fmt_bfnt_FontParser = function() { };
$hxClasses["hxd.fmt.bfnt.FontParser"] = hxd_fmt_bfnt_FontParser;
hxd_fmt_bfnt_FontParser.__name__ = "hxd.fmt.bfnt.FontParser";
hxd_fmt_bfnt_FontParser.parse = function(bytes,path,resolveTile) {
	var tile = null;
	var font = new h2d_Font(null,0);
	var glyphs = font.glyphs;
	font.baseLine = 0;
	var _g = bytes.getInt32(0);
	switch(_g) {
	case 54938946:
		var bytes1 = new haxe_io_BytesInput(bytes);
		bytes1.set_position(bytes1.pos + 4);
		var pageCount = 0;
		while(bytes1.pos < bytes1.totlen) {
			var id = bytes1.readByte();
			var length = bytes1.readInt32();
			var pos = bytes1.pos;
			switch(id) {
			case 1:
				font.size = font.initSize = bytes1.readInt16();
				bytes1.set_position(bytes1.pos + 12);
				font.name = bytes1.readUntil(0);
				break;
			case 2:
				font.lineHeight = bytes1.readUInt16();
				font.baseLine = bytes1.readUInt16();
				bytes1.set_position(bytes1.pos + 4);
				pageCount = bytes1.readUInt16();
				if(pageCount != 1) {
					haxe_Log.trace("Warning: BMF format only supports one page at the moment.",{ fileName : "hxd/fmt/bfnt/FontParser.hx", lineNumber : 220, className : "hxd.fmt.bfnt.FontParser", methodName : "parse"});
				}
				break;
			case 3:
				var name = bytes1.readUntil(0);
				try {
					font.tilePath = name;
					tile = resolveTile(haxe_io_Path.join([haxe_io_Path.directory(path),name]));
				} catch( _g1 ) {
					haxe_Log.trace("Warning: Could not find referenced font texture at \"" + name + "\", trying to resolve same name as fnt!",{ fileName : "hxd/fmt/bfnt/FontParser.hx", lineNumber : 26, className : "hxd.fmt.bfnt.FontParser", methodName : "parse"});
					font.tilePath = new haxe_io_Path(path).file + ".png";
					tile = resolveTile(haxe_io_Path.withExtension(path,"png"));
				}
				break;
			case 4:
				var count = length / 20 | 0;
				while(count > 0) {
					var cid = bytes1.readInt32();
					var t = tile.sub(bytes1.readUInt16(),bytes1.readUInt16(),bytes1.readUInt16(),bytes1.readUInt16(),bytes1.readInt16(),bytes1.readInt16());
					var fc = new h2d_FontChar(t,bytes1.readInt16());
					glyphs.h[cid] = fc;
					bytes1.set_position(bytes1.pos + 2);
					--count;
				}
				break;
			case 5:
				var count1 = length / 10 | 0;
				while(count1 > 0) {
					var first = bytes1.readInt32();
					var key = bytes1.readInt32();
					var fc1 = glyphs.h[key];
					if(fc1 != null) {
						fc1.addKerning(first,bytes1.readInt16());
					} else {
						bytes1.set_position(bytes1.pos + 2);
					}
					--count1;
				}
				break;
			}
			bytes1.set_position(pos + length);
		}
		break;
	case 1414415938:
		return new hxd_fmt_bfnt_Reader(new haxe_io_BytesInput(bytes)).read(function(tp) {
			try {
				font.tilePath = tp;
				tile = resolveTile(haxe_io_Path.join([haxe_io_Path.directory(path),tp]));
			} catch( _g ) {
				haxe_Log.trace("Warning: Could not find referenced font texture at \"" + tp + "\", trying to resolve same name as fnt!",{ fileName : "hxd/fmt/bfnt/FontParser.hx", lineNumber : 26, className : "hxd.fmt.bfnt.FontParser", methodName : "parse"});
				font.tilePath = new haxe_io_Path(path).file + ".png";
				tile = resolveTile(haxe_io_Path.withExtension(path,"png"));
			}
			return tile;
		});
	case 1836597052:case 1852794428:
		var xml = Xml.parse(bytes.toString());
		var x = xml.firstElement();
		if(x.nodeType != Xml.Document && x.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Invalid nodeType " + (x.nodeType == null ? "null" : XmlType.toString(x.nodeType)));
		}
		var xml = x;
		if(haxe_xml__$Access_HasNodeAccess.resolve(xml,"info")) {
			var tmp = haxe_xml__$Access_NodeAccess.resolve(xml,"info");
			font.name = haxe_xml__$Access_AttribAccess.resolve(tmp,"face");
			var tmp = haxe_xml__$Access_AttribAccess.resolve(haxe_xml__$Access_NodeAccess.resolve(xml,"info"),"size");
			font.size = font.initSize = Std.parseInt(tmp);
			var tmp = haxe_xml__$Access_AttribAccess.resolve(haxe_xml__$Access_NodeAccess.resolve(xml,"common"),"lineHeight");
			font.lineHeight = Std.parseInt(tmp);
			var tmp = haxe_xml__$Access_AttribAccess.resolve(haxe_xml__$Access_NodeAccess.resolve(xml,"common"),"base");
			font.baseLine = Std.parseInt(tmp);
			var p = haxe_xml__$Access_NodeAccess.resolve(xml,"pages").elements();
			while(p.hasNext()) {
				var p1 = p.next();
				if(haxe_xml__$Access_AttribAccess.resolve(p1,"id") == "0") {
					var tilePath = haxe_xml__$Access_AttribAccess.resolve(p1,"file");
					try {
						font.tilePath = tilePath;
						tile = resolveTile(haxe_io_Path.join([haxe_io_Path.directory(path),tilePath]));
					} catch( _g1 ) {
						haxe_Log.trace("Warning: Could not find referenced font texture at \"" + tilePath + "\", trying to resolve same name as fnt!",{ fileName : "hxd/fmt/bfnt/FontParser.hx", lineNumber : 26, className : "hxd.fmt.bfnt.FontParser", methodName : "parse"});
						font.tilePath = new haxe_io_Path(path).file + ".png";
						tile = resolveTile(haxe_io_Path.withExtension(path,"png"));
					}
				} else {
					haxe_Log.trace("Warning: BMF format only supports one page at the moment.",{ fileName : "hxd/fmt/bfnt/FontParser.hx", lineNumber : 62, className : "hxd.fmt.bfnt.FontParser", methodName : "parse"});
				}
			}
			var chars = haxe_xml__$Access_NodeAccess.resolve(xml,"chars").elements();
			var c = chars;
			while(c.hasNext()) {
				var c1 = c.next();
				var t = tile.sub(Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(c1,"x")),Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(c1,"y")),Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(c1,"width")),Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(c1,"height")),Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(c1,"xoffset")),Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(c1,"yoffset")));
				var fc = new h2d_FontChar(t,Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(c1,"xadvance")));
				var kerns = haxe_xml__$Access_NodeAccess.resolve(xml,"kernings").elements();
				var k = kerns;
				while(k.hasNext()) {
					var k1 = k.next();
					if(haxe_xml__$Access_AttribAccess.resolve(k1,"second") == haxe_xml__$Access_AttribAccess.resolve(c1,"id")) {
						fc.addKerning(Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(k1,"first")),Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(k1,"amount")));
					}
				}
				var key = Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(c1,"id"));
				glyphs.h[key] = fc;
			}
		} else {
			font.tilePath = new haxe_io_Path(path).file + ".png";
			tile = resolveTile(haxe_io_Path.withExtension(path,"png"));
			font.name = haxe_xml__$Access_AttribAccess.resolve(xml,"family");
			var tmp = haxe_xml__$Access_AttribAccess.resolve(xml,"size");
			font.size = font.initSize = Std.parseInt(tmp);
			var tmp = haxe_xml__$Access_AttribAccess.resolve(xml,"height");
			font.lineHeight = Std.parseInt(tmp);
			var kernings = [];
			var c = xml.elements();
			while(c.hasNext()) {
				var c1 = c.next();
				var r = haxe_xml__$Access_AttribAccess.resolve(c1,"rect").split(" ");
				var o = haxe_xml__$Access_AttribAccess.resolve(c1,"offset").split(" ");
				var t = tile.sub(Std.parseInt(r[0]),Std.parseInt(r[1]),Std.parseInt(r[2]),Std.parseInt(r[3]),Std.parseInt(o[0]),Std.parseInt(o[1]));
				var fc = new h2d_FontChar(t,Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(c1,"width")));
				var code = haxe_xml__$Access_AttribAccess.resolve(c1,"code");
				var code1 = StringTools.startsWith(code,"&#") ? Std.parseInt(HxOverrides.substr(code,2,code.length - 3)) : HxOverrides.cca(code,0);
				var k = c1.elements();
				while(k.hasNext()) {
					var k1 = k.next();
					var code2 = haxe_xml__$Access_AttribAccess.resolve(k1,"id");
					var next = StringTools.startsWith(code2,"&#") ? Std.parseInt(HxOverrides.substr(code2,2,code2.length - 3)) : HxOverrides.cca(code2,0);
					var adv = Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(k1,"advance"));
					if(glyphs.h.hasOwnProperty(next)) {
						glyphs.h[next].addKerning(code1,adv);
					} else {
						kernings.push({ prev : code1, next : next, adv : adv});
					}
				}
				glyphs.h[code1] = fc;
			}
			var _g1 = 0;
			while(_g1 < kernings.length) {
				var k = kernings[_g1];
				++_g1;
				var g = glyphs.h[k.next];
				if(g == null) {
					continue;
				}
				g.addKerning(k.prev,k.adv);
			}
		}
		break;
	case 1868983913:
		var lines = bytes.toString().split("\n");
		var reg = new EReg(" *?([0-9a-zA-Z]+)=(\"[^\"]+\"|.+?)(?:[ \r]|$)","");
		var idx;
		var pageCount = 0;
		var _g1 = 0;
		while(_g1 < lines.length) {
			var line = lines[_g1];
			++_g1;
			idx = line.indexOf(" ");
			switch(HxOverrides.substr(line,0,idx)) {
			case "char":
				var id = 0;
				var x = 0;
				var y = 0;
				var width = 0;
				var height = 0;
				var xoffset = 0;
				var yoffset = 0;
				var xadvance = 0;
				while(idx < line.length && reg.matchSub(line,idx)) {
					switch(reg.matched(1)) {
					case "height":
						var v = reg.matched(2);
						height = Std.parseInt(HxOverrides.cca(v,0) == 34 ? v.substring(1,v.length - 1) : v);
						break;
					case "id":
						var v1 = reg.matched(2);
						id = Std.parseInt(HxOverrides.cca(v1,0) == 34 ? v1.substring(1,v1.length - 1) : v1);
						break;
					case "width":
						var v2 = reg.matched(2);
						width = Std.parseInt(HxOverrides.cca(v2,0) == 34 ? v2.substring(1,v2.length - 1) : v2);
						break;
					case "x":
						var v3 = reg.matched(2);
						x = Std.parseInt(HxOverrides.cca(v3,0) == 34 ? v3.substring(1,v3.length - 1) : v3);
						break;
					case "xadvance":
						var v4 = reg.matched(2);
						xadvance = Std.parseInt(HxOverrides.cca(v4,0) == 34 ? v4.substring(1,v4.length - 1) : v4);
						break;
					case "xoffset":
						var v5 = reg.matched(2);
						xoffset = Std.parseInt(HxOverrides.cca(v5,0) == 34 ? v5.substring(1,v5.length - 1) : v5);
						break;
					case "y":
						var v6 = reg.matched(2);
						y = Std.parseInt(HxOverrides.cca(v6,0) == 34 ? v6.substring(1,v6.length - 1) : v6);
						break;
					case "yoffset":
						var v7 = reg.matched(2);
						yoffset = Std.parseInt(HxOverrides.cca(v7,0) == 34 ? v7.substring(1,v7.length - 1) : v7);
						break;
					}
					var pos = reg.matchedPos();
					idx = pos.pos + pos.len;
				}
				var t = tile.sub(x,y,width,height,xoffset,yoffset);
				var fc = new h2d_FontChar(t,xadvance);
				glyphs.h[id] = fc;
				break;
			case "common":
				while(idx < line.length && reg.matchSub(line,idx)) {
					switch(reg.matched(1)) {
					case "base":
						var v8 = reg.matched(2);
						font.baseLine = Std.parseInt(HxOverrides.cca(v8,0) == 34 ? v8.substring(1,v8.length - 1) : v8);
						break;
					case "lineHeight":
						var v9 = reg.matched(2);
						font.lineHeight = Std.parseInt(HxOverrides.cca(v9,0) == 34 ? v9.substring(1,v9.length - 1) : v9);
						break;
					case "pages":
						var v10 = reg.matched(2);
						pageCount = Std.parseInt(HxOverrides.cca(v10,0) == 34 ? v10.substring(1,v10.length - 1) : v10);
						if(pageCount != 1) {
							haxe_Log.trace("Warning: BMF format only supports one page at the moment.",{ fileName : "hxd/fmt/bfnt/FontParser.hx", lineNumber : 153, className : "hxd.fmt.bfnt.FontParser", methodName : "parse"});
						}
						break;
					}
					var pos1 = reg.matchedPos();
					idx = pos1.pos + pos1.len;
				}
				break;
			case "info":
				while(idx < line.length && reg.matchSub(line,idx)) {
					switch(reg.matched(1)) {
					case "face":
						var v11 = reg.matched(2);
						font.name = HxOverrides.cca(v11,0) == 34 ? v11.substring(1,v11.length - 1) : v11;
						break;
					case "size":
						var v12 = reg.matched(2);
						font.size = font.initSize = Std.parseInt(HxOverrides.cca(v12,0) == 34 ? v12.substring(1,v12.length - 1) : v12);
						break;
					}
					var pos2 = reg.matchedPos();
					idx = pos2.pos + pos2.len;
				}
				break;
			case "kerning":
				var first = 0;
				var second = 0;
				var advance = 0;
				while(idx < line.length && reg.matchSub(line,idx)) {
					switch(reg.matched(1)) {
					case "amount":
						var v13 = reg.matched(2);
						advance = Std.parseInt(HxOverrides.cca(v13,0) == 34 ? v13.substring(1,v13.length - 1) : v13);
						break;
					case "first":
						var v14 = reg.matched(2);
						first = Std.parseInt(HxOverrides.cca(v14,0) == 34 ? v14.substring(1,v14.length - 1) : v14);
						break;
					case "second":
						var v15 = reg.matched(2);
						second = Std.parseInt(HxOverrides.cca(v15,0) == 34 ? v15.substring(1,v15.length - 1) : v15);
						break;
					}
					var pos3 = reg.matchedPos();
					idx = pos3.pos + pos3.len;
				}
				var fc1 = glyphs.h[second];
				if(fc1 != null) {
					fc1.addKerning(first,advance);
				}
				break;
			case "page":
				while(idx < line.length && reg.matchSub(line,idx)) {
					if(reg.matched(1) == "file") {
						var v16 = reg.matched(2);
						var tilePath = HxOverrides.cca(v16,0) == 34 ? v16.substring(1,v16.length - 1) : v16;
						try {
							font.tilePath = tilePath;
							tile = resolveTile(haxe_io_Path.join([haxe_io_Path.directory(path),tilePath]));
						} catch( _g2 ) {
							haxe_Log.trace("Warning: Could not find referenced font texture at \"" + tilePath + "\", trying to resolve same name as fnt!",{ fileName : "hxd/fmt/bfnt/FontParser.hx", lineNumber : 26, className : "hxd.fmt.bfnt.FontParser", methodName : "parse"});
							font.tilePath = new haxe_io_Path(path).file + ".png";
							tile = resolveTile(haxe_io_Path.withExtension(path,"png"));
						}
					}
					var pos4 = reg.matchedPos();
					idx = pos4.pos + pos4.len;
				}
				break;
			}
		}
		break;
	default:
		var sign = _g;
		throw haxe_Exception.thrown("Unknown font signature " + StringTools.hex(sign,8));
	}
	if(glyphs.h[32] == null) {
		var value = new h2d_FontChar(tile.sub(0,0,0,0),font.size >> 1);
		glyphs.h[32] = value;
	}
	font.tile = tile;
	if(font.baseLine == 0) {
		font.baseLine = font.calcBaseLine();
	}
	var fallback = glyphs.h[65533];
	if(fallback == null) {
		fallback = glyphs.h[9633];
	}
	if(fallback == null) {
		fallback = glyphs.h[63];
	}
	if(fallback != null) {
		font.defaultChar = fallback;
	}
	return font;
};
var hxd_fmt_bfnt_Reader = function(i) {
	this.i = i;
};
$hxClasses["hxd.fmt.bfnt.Reader"] = hxd_fmt_bfnt_Reader;
hxd_fmt_bfnt_Reader.__name__ = "hxd.fmt.bfnt.Reader";
hxd_fmt_bfnt_Reader.parse = function(bytes,resolveTile) {
	return new hxd_fmt_bfnt_Reader(new haxe_io_BytesInput(bytes)).read(resolveTile);
};
hxd_fmt_bfnt_Reader.prototype = {
	read: function(resolveTile) {
		if(this.i.readString(4) != "BFNT" || this.i.readByte() != 0) {
			throw haxe_Exception.thrown("Not a BFNT file!");
		}
		var font = null;
		var _g = this.i.readByte();
		if(_g == 1) {
			font = new h2d_Font(this.i.readString(this.i.readUInt16()),this.i.readInt16());
			font.tilePath = this.i.readString(this.i.readUInt16());
			var tile = font.tile = resolveTile(font.tilePath);
			font.lineHeight = this.i.readInt16();
			font.baseLine = this.i.readInt16();
			var defaultChar = this.i.readInt32();
			var id;
			while(true) {
				id = this.i.readInt32();
				if(!(id != 0)) {
					break;
				}
				var t = tile.sub(this.i.readUInt16(),this.i.readUInt16(),this.i.readUInt16(),this.i.readUInt16(),this.i.readInt16(),this.i.readInt16());
				var glyph = new h2d_FontChar(t,this.i.readInt16());
				font.glyphs.h[id] = glyph;
				if(id == defaultChar) {
					font.defaultChar = glyph;
				}
				var prevChar;
				while(true) {
					prevChar = this.i.readInt32();
					if(!(prevChar != 0)) {
						break;
					}
					glyph.addKerning(prevChar,this.i.readInt16());
				}
			}
		} else {
			var ver = _g;
			throw haxe_Exception.thrown("Unknown BFNT version: " + ver);
		}
		return font;
	}
	,__class__: hxd_fmt_bfnt_Reader
};
var hxd_fmt_hdr_Reader = function() { };
$hxClasses["hxd.fmt.hdr.Reader"] = hxd_fmt_hdr_Reader;
hxd_fmt_hdr_Reader.__name__ = "hxd.fmt.hdr.Reader";
hxd_fmt_hdr_Reader.decode = function(bytes,sRGB) {
	var f = new haxe_io_BytesInput(bytes);
	var width = 0;
	var height = 0;
	var keys_h = Object.create(null);
	while(true) {
		var line = f.readLine();
		if(line == "") {
			break;
		}
		if(HxOverrides.cca(line,0) == 35) {
			continue;
		}
		var nameValue = line.split("=");
		if(nameValue.length > 1) {
			keys_h[nameValue.shift()] = nameValue.join("=");
		}
	}
	var parts = f.readLine().split(" ");
	height = Std.parseInt(parts[1]);
	width = Std.parseInt(parts[3]);
	var gamma = keys_h["GAMMA"] == "1";
	var data = new haxe_io_Bytes(new ArrayBuffer(width * height * 4 * 4));
	var exposure = 1.0;
	var exp = keys_h["EXPOSURE"];
	if(exp != null) {
		var exp1 = parseFloat(exp);
		if(exp1 < 1e-12 || exp1 < 1e12) {
			exposure = exp1;
		}
	}
	var gammaCorrect = sRGB ? 1 : 0.45454545454545453;
	var _g = [];
	var _g1 = 0;
	while(_g1 < 256) {
		var e = _g1++;
		_g.push(Math.pow(e,gammaCorrect));
	}
	var gammaVals = _g;
	var _g = [];
	var _g1 = 0;
	while(_g1 < 256) {
		var e = _g1++;
		_g.push(Math.pow(Math.pow(2,e - 128) / (256 * exposure),gammaCorrect));
	}
	var exps = _g;
	var _g = keys_h["FORMAT"];
	if(_g == null) {
		var fmt = _g;
		throw haxe_Exception.thrown("Unsupported HDR format " + fmt);
	} else if(_g == "32-bit_rle_rgbe") {
		var dataPos = f.pos;
		var scanLen = width * 4;
		var scanLine = new haxe_io_Bytes(new ArrayBuffer(scanLen));
		var widthBE = width >> 8 | (width & 255) << 8;
		var _g1 = 0;
		var _g2 = height;
		while(_g1 < _g2) {
			var y = _g1++;
			var h = bytes.getInt32(dataPos);
			if((h & 65535) != 514 || h >>> 16 != widthBE) {
				scanLine.blit(0,bytes,dataPos,width * 4);
				dataPos += width * 4;
			} else {
				dataPos += 4;
				var p = 0;
				var end = width * 4;
				while(p < end) {
					var len = bytes.b[dataPos++];
					if(len > 128) {
						len -= 128;
						scanLine.fill(p,len,bytes.b[dataPos++]);
					} else {
						scanLine.blit(p,bytes,dataPos,len);
						dataPos += len;
					}
					p += len;
				}
			}
			var pos = y * width * 16;
			var _g3 = 0;
			var _g4 = width;
			while(_g3 < _g4) {
				var x = _g3++;
				var e = exps[scanLine.b[x + width * 3]];
				data.setFloat(pos,gammaVals[scanLine.b[x]] * e);
				pos += 4;
				data.setFloat(pos,gammaVals[scanLine.b[x + width]] * e);
				pos += 4;
				data.setFloat(pos,gammaVals[scanLine.b[x + (width << 1)]] * e);
				pos += 4;
				data.setFloat(pos,1.0);
				pos += 4;
			}
		}
	} else {
		var fmt = _g;
		throw haxe_Exception.thrown("Unsupported HDR format " + fmt);
	}
	return { width : width, height : height, bytes : data, gamma : gamma};
};
var hxd_fmt_hmd_Property = $hxEnums["hxd.fmt.hmd.Property"] = { __ename__:true,__constructs__:null
	,CameraFOVY: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"hxd.fmt.hmd.Property",toString:$estr}; },$_._hx_name="CameraFOVY",$_.__params__ = ["v"],$_)
	,Unused_HasMaterialFlags: {_hx_name:"Unused_HasMaterialFlags",_hx_index:1,__enum__:"hxd.fmt.hmd.Property",toString:$estr}
	,HasExtraTextures: {_hx_name:"HasExtraTextures",_hx_index:2,__enum__:"hxd.fmt.hmd.Property",toString:$estr}
	,FourBonesByVertex: {_hx_name:"FourBonesByVertex",_hx_index:3,__enum__:"hxd.fmt.hmd.Property",toString:$estr}
	,HasLod: {_hx_name:"HasLod",_hx_index:4,__enum__:"hxd.fmt.hmd.Property",toString:$estr}
	,HasCollider: {_hx_name:"HasCollider",_hx_index:5,__enum__:"hxd.fmt.hmd.Property",toString:$estr}
};
hxd_fmt_hmd_Property.__constructs__ = [hxd_fmt_hmd_Property.CameraFOVY,hxd_fmt_hmd_Property.Unused_HasMaterialFlags,hxd_fmt_hmd_Property.HasExtraTextures,hxd_fmt_hmd_Property.FourBonesByVertex,hxd_fmt_hmd_Property.HasLod,hxd_fmt_hmd_Property.HasCollider];
hxd_fmt_hmd_Property.__empty_constructs__ = [hxd_fmt_hmd_Property.Unused_HasMaterialFlags,hxd_fmt_hmd_Property.HasExtraTextures,hxd_fmt_hmd_Property.FourBonesByVertex,hxd_fmt_hmd_Property.HasLod,hxd_fmt_hmd_Property.HasCollider];
var hxd_fmt_hmd_Position = function() {
};
$hxClasses["hxd.fmt.hmd.Position"] = hxd_fmt_hmd_Position;
hxd_fmt_hmd_Position.__name__ = "hxd.fmt.hmd.Position";
hxd_fmt_hmd_Position.prototype = {
	loadQuaternion: function(q) {
		q.x = this.qx;
		q.y = this.qy;
		q.z = this.qz;
		q.w = this.get_qw();
	}
	,get_qw: function() {
		var qw = 1 - (this.qx * this.qx + this.qy * this.qy + this.qz * this.qz);
		if(qw < 0) {
			return -Math.sqrt(-qw);
		} else {
			return Math.sqrt(qw);
		}
	}
	,toMatrix: function(postScale) {
		if(postScale == null) {
			postScale = false;
		}
		var m = new h3d_MatrixImpl();
		var q = hxd_fmt_hmd_Position.QTMP;
		q.x = this.qx;
		q.y = this.qy;
		q.z = this.qz;
		q.w = this.get_qw();
		q.toMatrix(m);
		if(postScale) {
			m.translate(this.x,this.y,this.z);
			m.scale(this.sx,this.sy,this.sz);
		} else {
			m._11 *= this.sx;
			m._12 *= this.sx;
			m._13 *= this.sx;
			m._21 *= this.sy;
			m._22 *= this.sy;
			m._23 *= this.sy;
			m._31 *= this.sz;
			m._32 *= this.sz;
			m._33 *= this.sz;
			m.translate(this.x,this.y,this.z);
		}
		return m;
	}
	,__class__: hxd_fmt_hmd_Position
};
var hxd_fmt_hmd_Geometry = function() {
};
$hxClasses["hxd.fmt.hmd.Geometry"] = hxd_fmt_hmd_Geometry;
hxd_fmt_hmd_Geometry.__name__ = "hxd.fmt.hmd.Geometry";
hxd_fmt_hmd_Geometry.prototype = {
	get_indexCount: function() {
		var k = 0;
		var _g = 0;
		var _g1 = this.indexCounts;
		while(_g < _g1.length) {
			var i = _g1[_g];
			++_g;
			k += i;
		}
		return k;
	}
	,__class__: hxd_fmt_hmd_Geometry
};
var hxd_fmt_hmd_BlendShape = function() {
};
$hxClasses["hxd.fmt.hmd.BlendShape"] = hxd_fmt_hmd_BlendShape;
hxd_fmt_hmd_BlendShape.__name__ = "hxd.fmt.hmd.BlendShape";
hxd_fmt_hmd_BlendShape.prototype = {
	__class__: hxd_fmt_hmd_BlendShape
};
var hxd_fmt_hmd_Collider = function() {
};
$hxClasses["hxd.fmt.hmd.Collider"] = hxd_fmt_hmd_Collider;
hxd_fmt_hmd_Collider.__name__ = "hxd.fmt.hmd.Collider";
hxd_fmt_hmd_Collider.prototype = {
	__class__: hxd_fmt_hmd_Collider
};
var hxd_fmt_hmd_Material = function() {
};
$hxClasses["hxd.fmt.hmd.Material"] = hxd_fmt_hmd_Material;
hxd_fmt_hmd_Material.__name__ = "hxd.fmt.hmd.Material";
hxd_fmt_hmd_Material.prototype = {
	__class__: hxd_fmt_hmd_Material
};
var hxd_fmt_hmd_SkinJoint = function() {
};
$hxClasses["hxd.fmt.hmd.SkinJoint"] = hxd_fmt_hmd_SkinJoint;
hxd_fmt_hmd_SkinJoint.__name__ = "hxd.fmt.hmd.SkinJoint";
hxd_fmt_hmd_SkinJoint.prototype = {
	__class__: hxd_fmt_hmd_SkinJoint
};
var hxd_fmt_hmd_SkinSplit = function() {
};
$hxClasses["hxd.fmt.hmd.SkinSplit"] = hxd_fmt_hmd_SkinSplit;
hxd_fmt_hmd_SkinSplit.__name__ = "hxd.fmt.hmd.SkinSplit";
hxd_fmt_hmd_SkinSplit.prototype = {
	__class__: hxd_fmt_hmd_SkinSplit
};
var hxd_fmt_hmd_Skin = function() {
};
$hxClasses["hxd.fmt.hmd.Skin"] = hxd_fmt_hmd_Skin;
hxd_fmt_hmd_Skin.__name__ = "hxd.fmt.hmd.Skin";
hxd_fmt_hmd_Skin.prototype = {
	__class__: hxd_fmt_hmd_Skin
};
var hxd_fmt_hmd_Model = function() {
};
$hxClasses["hxd.fmt.hmd.Model"] = hxd_fmt_hmd_Model;
hxd_fmt_hmd_Model.__name__ = "hxd.fmt.hmd.Model";
hxd_fmt_hmd_Model.prototype = {
	getObjectName: function() {
		if(this.name == null) {
			return this.name;
		}
		var reg_r = new RegExp("_*-*LOD0","".split("u").join(""));
		return this.name.replace(reg_r,"");
	}
	,isLOD: function() {
		return this.name.indexOf("LOD0") < 0;
	}
	,isLOD0: function(modelName) {
		if(this.name != null && this.name.indexOf(modelName) != -1) {
			return this.name.indexOf("LOD0") != -1;
		} else {
			return false;
		}
	}
	,getLODInfos: function() {
		var keyword = "LOD";
		if(this.name == null || this.name.length <= keyword.length) {
			return { lodLevel : -1, modelName : null};
		}
		if(HxOverrides.substr(this.name,0,keyword.length) == keyword) {
			var parsedInt = Std.parseInt(HxOverrides.substr(this.name,keyword.length,1));
			if(parsedInt != null) {
				if(Std.parseInt(HxOverrides.substr(this.name,keyword.length + 1,1)) != null) {
					throw haxe_Exception.thrown("Did not expect a second number after LOD in " + this.name);
				}
				return { lodLevel : parsedInt, modelName : HxOverrides.substr(this.name,keyword.length,null)};
			}
		}
		var maxCursor = this.name.length - keyword.length - 1;
		if(HxOverrides.substr(this.name,maxCursor,keyword.length) == keyword) {
			var parsedInt = Std.parseInt(this.name.charAt(this.name.length - 1));
			if(parsedInt != null) {
				return { lodLevel : parsedInt, modelName : HxOverrides.substr(this.name,0,maxCursor)};
			}
		}
		return { lodLevel : -1, modelName : null};
	}
	,__class__: hxd_fmt_hmd_Model
};
var hxd_fmt_hmd_AnimationFlag = $hxEnums["hxd.fmt.hmd.AnimationFlag"] = { __ename__:true,__constructs__:null
	,HasPosition: {_hx_name:"HasPosition",_hx_index:0,__enum__:"hxd.fmt.hmd.AnimationFlag",toString:$estr}
	,HasRotation: {_hx_name:"HasRotation",_hx_index:1,__enum__:"hxd.fmt.hmd.AnimationFlag",toString:$estr}
	,HasScale: {_hx_name:"HasScale",_hx_index:2,__enum__:"hxd.fmt.hmd.AnimationFlag",toString:$estr}
	,HasUV: {_hx_name:"HasUV",_hx_index:3,__enum__:"hxd.fmt.hmd.AnimationFlag",toString:$estr}
	,HasAlpha: {_hx_name:"HasAlpha",_hx_index:4,__enum__:"hxd.fmt.hmd.AnimationFlag",toString:$estr}
	,SingleFrame: {_hx_name:"SingleFrame",_hx_index:5,__enum__:"hxd.fmt.hmd.AnimationFlag",toString:$estr}
	,HasProps: {_hx_name:"HasProps",_hx_index:6,__enum__:"hxd.fmt.hmd.AnimationFlag",toString:$estr}
	,Reserved: {_hx_name:"Reserved",_hx_index:7,__enum__:"hxd.fmt.hmd.AnimationFlag",toString:$estr}
};
hxd_fmt_hmd_AnimationFlag.__constructs__ = [hxd_fmt_hmd_AnimationFlag.HasPosition,hxd_fmt_hmd_AnimationFlag.HasRotation,hxd_fmt_hmd_AnimationFlag.HasScale,hxd_fmt_hmd_AnimationFlag.HasUV,hxd_fmt_hmd_AnimationFlag.HasAlpha,hxd_fmt_hmd_AnimationFlag.SingleFrame,hxd_fmt_hmd_AnimationFlag.HasProps,hxd_fmt_hmd_AnimationFlag.Reserved];
hxd_fmt_hmd_AnimationFlag.__empty_constructs__ = [hxd_fmt_hmd_AnimationFlag.HasPosition,hxd_fmt_hmd_AnimationFlag.HasRotation,hxd_fmt_hmd_AnimationFlag.HasScale,hxd_fmt_hmd_AnimationFlag.HasUV,hxd_fmt_hmd_AnimationFlag.HasAlpha,hxd_fmt_hmd_AnimationFlag.SingleFrame,hxd_fmt_hmd_AnimationFlag.HasProps,hxd_fmt_hmd_AnimationFlag.Reserved];
var hxd_fmt_hmd_AnimationObject = function() {
};
$hxClasses["hxd.fmt.hmd.AnimationObject"] = hxd_fmt_hmd_AnimationObject;
hxd_fmt_hmd_AnimationObject.__name__ = "hxd.fmt.hmd.AnimationObject";
hxd_fmt_hmd_AnimationObject.prototype = {
	getStride: function() {
		var stride = 0;
		if((this.flags & 1 << hxd_fmt_hmd_AnimationFlag.HasPosition._hx_index) != 0) {
			stride += 3;
		}
		if((this.flags & 1 << hxd_fmt_hmd_AnimationFlag.HasRotation._hx_index) != 0) {
			stride += 3;
		}
		if((this.flags & 1 << hxd_fmt_hmd_AnimationFlag.HasScale._hx_index) != 0) {
			stride += 3;
		}
		if((this.flags & 1 << hxd_fmt_hmd_AnimationFlag.HasUV._hx_index) != 0) {
			stride += 2;
		}
		if((this.flags & 1 << hxd_fmt_hmd_AnimationFlag.HasAlpha._hx_index) != 0) {
			++stride;
		}
		if((this.flags & 1 << hxd_fmt_hmd_AnimationFlag.HasProps._hx_index) != 0) {
			stride += this.props.length;
		}
		return stride;
	}
	,__class__: hxd_fmt_hmd_AnimationObject
};
var hxd_fmt_hmd_AnimationEvent = function() {
};
$hxClasses["hxd.fmt.hmd.AnimationEvent"] = hxd_fmt_hmd_AnimationEvent;
hxd_fmt_hmd_AnimationEvent.__name__ = "hxd.fmt.hmd.AnimationEvent";
hxd_fmt_hmd_AnimationEvent.prototype = {
	__class__: hxd_fmt_hmd_AnimationEvent
};
var hxd_fmt_hmd_Animation = function() {
};
$hxClasses["hxd.fmt.hmd.Animation"] = hxd_fmt_hmd_Animation;
hxd_fmt_hmd_Animation.__name__ = "hxd.fmt.hmd.Animation";
hxd_fmt_hmd_Animation.prototype = {
	__class__: hxd_fmt_hmd_Animation
};
var hxd_fmt_hmd_Data = function() {
};
$hxClasses["hxd.fmt.hmd.Data"] = hxd_fmt_hmd_Data;
hxd_fmt_hmd_Data.__name__ = "hxd.fmt.hmd.Data";
hxd_fmt_hmd_Data.prototype = {
	__class__: hxd_fmt_hmd_Data
};
var hxd_fmt_hmd__$Library_FormatMap = function(size,offset,def,prec) {
	this.size = size;
	this.offset = offset;
	this.precision = prec;
	this.def = def;
};
$hxClasses["hxd.fmt.hmd._Library.FormatMap"] = hxd_fmt_hmd__$Library_FormatMap;
hxd_fmt_hmd__$Library_FormatMap.__name__ = "hxd.fmt.hmd._Library.FormatMap";
hxd_fmt_hmd__$Library_FormatMap.prototype = {
	__class__: hxd_fmt_hmd__$Library_FormatMap
};
var hxd_fmt_hmd_GeometryBuffer = function() {
};
$hxClasses["hxd.fmt.hmd.GeometryBuffer"] = hxd_fmt_hmd_GeometryBuffer;
hxd_fmt_hmd_GeometryBuffer.__name__ = "hxd.fmt.hmd.GeometryBuffer";
hxd_fmt_hmd_GeometryBuffer.prototype = {
	__class__: hxd_fmt_hmd_GeometryBuffer
};
var hxd_fmt_hmd_Library = function(res,header) {
	this.resource = res;
	this.header = header;
	this.cachedPrimitives = [];
	this.cachedAnimations = new haxe_ds_StringMap();
	this.cachedSkin = new haxe_ds_StringMap();
};
$hxClasses["hxd.fmt.hmd.Library"] = hxd_fmt_hmd_Library;
hxd_fmt_hmd_Library.__name__ = "hxd.fmt.hmd.Library";
hxd_fmt_hmd_Library.prototype = {
	getData: function() {
		var entry = this.resource.entry;
		var b = new haxe_io_Bytes(new ArrayBuffer(entry.get_size() - this.header.dataPosition));
		entry.readFull(b,this.header.dataPosition,b.length);
		return b;
	}
	,getDefaultFormat: function(stride) {
		var format = [new hxd_BufferInput("position",3)];
		var defs = [null];
		if(stride > 3) {
			format.push(new hxd_BufferInput("normal",3));
			defs.push(null);
		}
		if(stride > 6) {
			format.push(new hxd_BufferInput("uv",2));
			defs.push(null);
		}
		if(stride > 8) {
			format.push(new hxd_BufferInput("color",3));
			var x = 1;
			var y = 1;
			var z = 1;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			defs.push(new h3d_VectorImpl(x,y,z));
		}
		if(stride > 11) {
			throw haxe_Exception.thrown("Unsupported stride");
		}
		return { format : hxd_BufferFormat.make(format), defs : defs};
	}
	,load: function(format,defaults,modelIndex) {
		if(modelIndex == null) {
			modelIndex = -1;
		}
		var x = 0.;
		var y = 0.;
		var z = 0.;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var vtmp_x = x;
		var vtmp_y = y;
		var vtmp_z = z;
		var models = modelIndex < 0 ? this.header.models : [this.header.models[modelIndex]];
		var outVertex = hxd__$FloatBuffer_Float32Expand._new(0);
		var outIndex = new Array(0);
		var stride = format.stride;
		var mid = -1;
		var _g = 0;
		while(_g < models.length) {
			var m = models[_g];
			++_g;
			var geom = this.header.geometries[m.geometry];
			if(geom == null) {
				continue;
			}
			var _g1 = 0;
			var _g2 = m.materials;
			while(_g1 < _g2.length) {
				var mat = _g2[_g1];
				++_g1;
				if(mid < 0) {
					mid = mat;
				}
				if(mid != mat) {
					throw haxe_Exception.thrown("Models have several materials");
				}
			}
			var pos = m.position.toMatrix();
			var data = this.getBuffers(geom,format,defaults);
			var start = outVertex.pos / stride | 0;
			var _g3 = 0;
			var _g4 = data.vertexes.length / stride | 0;
			while(_g3 < _g4) {
				var i = _g3++;
				var p = i * stride;
				vtmp_x = data.vertexes[p++];
				vtmp_y = data.vertexes[p++];
				vtmp_z = data.vertexes[p++];
				var px = vtmp_x * pos._11 + vtmp_y * pos._21 + vtmp_z * pos._31 + pos._41;
				var py = vtmp_x * pos._12 + vtmp_y * pos._22 + vtmp_z * pos._32 + pos._42;
				var pz = vtmp_x * pos._13 + vtmp_y * pos._23 + vtmp_z * pos._33 + pos._43;
				vtmp_x = px;
				vtmp_y = py;
				vtmp_z = pz;
				if(outVertex.pos == outVertex.array.length) {
					var newSize = outVertex.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					var newArray = new Float32Array(newSize);
					newArray.set(outVertex.array);
					outVertex.array = newArray;
				}
				outVertex.array[outVertex.pos++] = vtmp_x;
				if(outVertex.pos == outVertex.array.length) {
					var newSize1 = outVertex.array.length << 1;
					if(newSize1 < 128) {
						newSize1 = 128;
					}
					var newArray1 = new Float32Array(newSize1);
					newArray1.set(outVertex.array);
					outVertex.array = newArray1;
				}
				outVertex.array[outVertex.pos++] = vtmp_y;
				if(outVertex.pos == outVertex.array.length) {
					var newSize2 = outVertex.array.length << 1;
					if(newSize2 < 128) {
						newSize2 = 128;
					}
					var newArray2 = new Float32Array(newSize2);
					newArray2.set(outVertex.array);
					outVertex.array = newArray2;
				}
				outVertex.array[outVertex.pos++] = vtmp_z;
				var _g5 = 0;
				var _g6 = stride - 3;
				while(_g5 < _g6) {
					var j = _g5++;
					var v = data.vertexes[p++];
					if(outVertex.pos == outVertex.array.length) {
						var newSize3 = outVertex.array.length << 1;
						if(newSize3 < 128) {
							newSize3 = 128;
						}
						var newArray3 = new Float32Array(newSize3);
						newArray3.set(outVertex.array);
						outVertex.array = newArray3;
					}
					outVertex.array[outVertex.pos++] = v;
				}
			}
			var _g7 = 0;
			var _g8 = data.indexes;
			while(_g7 < _g8.length) {
				var idx = _g8[_g7];
				++_g7;
				outIndex.push(idx + start);
			}
		}
		return { vertex : outVertex, index : outIndex};
	}
	,getBuffers: function(geom,format,defaults,material) {
		if(material == 0 && geom.indexCounts.length == 1) {
			material = null;
		}
		var maps = [];
		var index = 0;
		var stride = 0;
		var lowPrec = false;
		var _g_current = 0;
		var _g_array = format.inputs;
		while(_g_current < _g_array.length) {
			var i = _g_array[_g_current++];
			var i2 = geom.vertexFormat.getInput(i.name);
			var map;
			if(i2 == null) {
				var def = defaults == null ? null : defaults[index];
				if(def == null) {
					throw haxe_Exception.thrown("Missing required " + i.name);
				}
				map = new hxd_fmt_hmd__$Library_FormatMap(i.type & 7,0,def,0);
			} else {
				if(i2.type != i.type) {
					throw haxe_Exception.thrown("Requested " + i.name + " " + (i.type == null ? "null" : hxd_InputFormat.toString(i.type)) + " but found " + (i2.type == null ? "null" : hxd_InputFormat.toString(i2.type)));
				}
				map = new hxd_fmt_hmd__$Library_FormatMap(i.type & 7,geom.vertexFormat.calculateInputOffset(i2.name),null,i2.precision);
				if(i2.precision != 0) {
					lowPrec = true;
				}
			}
			maps.push(map);
			stride += i.type & 7;
			++index;
		}
		var geomStride = geom.vertexFormat.strideBytes;
		var vsize = geom.vertexCount * geomStride;
		var vbuf = new haxe_io_Bytes(new ArrayBuffer(vsize));
		var entry = this.resource.entry;
		entry.readFull(vbuf,this.header.dataPosition + geom.vertexPosition,vsize);
		var dataPos = this.header.dataPosition + geom.indexPosition;
		var isSmall = geom.vertexCount <= 65536;
		var imult = isSmall ? 2 : 4;
		var isize;
		if(material == null) {
			isize = geom.get_indexCount() * imult;
		} else {
			var ipos = 0;
			var _g = 0;
			var _g1 = material;
			while(_g < _g1) {
				var i = _g++;
				ipos += geom.indexCounts[i];
			}
			dataPos += ipos * imult;
			isize = geom.indexCounts[material] * imult;
		}
		var ibuf = new haxe_io_Bytes(new ArrayBuffer(isize));
		entry.readFull(ibuf,dataPos,isize);
		var buf = new hxd_fmt_hmd_GeometryBuffer();
		if(material == null) {
			buf.vertexes = new Array(stride * geom.vertexCount);
			buf.indexes = new Array(geom.get_indexCount());
			var w = 0;
			var _g = 0;
			var _g1 = geom.vertexCount;
			while(_g < _g1) {
				var vid = _g++;
				var _g2 = 0;
				while(_g2 < maps.length) {
					var m = maps[_g2];
					++_g2;
					if(m.def == null) {
						var _g3 = 0;
						var _g4 = m.size;
						while(_g3 < _g4) {
							var i = _g3++;
							var this1 = buf.vertexes;
							var index = w++;
							var val;
							if(lowPrec) {
								switch(m.precision) {
								case 0:
									val = vbuf.getFloat(vid * geomStride + (i << 2) + m.offset);
									break;
								case 1:
									val = hxd_BufferFormat.float16to32(vbuf.getUInt16(vid * geomStride + (i << 1) + m.offset));
									break;
								case 2:
									val = (vbuf.b[vid * geomStride + i + m.offset] & 255) / 255;
									break;
								case 3:
									val = hxd_BufferFormat.floatS8to32(vbuf.b[vid * geomStride + i + m.offset]);
									break;
								}
							} else {
								val = vbuf.getFloat(vid * geomStride + (i << 2) + m.offset);
							}
							this1[index] = val;
						}
					} else {
						switch(m.size) {
						case 1:
							buf.vertexes[w++] = m.def.x;
							break;
						case 2:
							buf.vertexes[w++] = m.def.x;
							buf.vertexes[w++] = m.def.y;
							break;
						case 3:
							buf.vertexes[w++] = m.def.x;
							buf.vertexes[w++] = m.def.y;
							buf.vertexes[w++] = m.def.z;
							break;
						default:
							buf.vertexes[w++] = m.def.x;
							buf.vertexes[w++] = m.def.y;
							buf.vertexes[w++] = m.def.z;
							buf.vertexes[w++] = m.def.w;
						}
					}
				}
			}
			if(isSmall) {
				var r = 0;
				var _g = 0;
				var _g1 = buf.indexes.length;
				while(_g < _g1) {
					var i = _g++;
					buf.indexes[i] = ibuf.b[r++] | ibuf.b[r++] << 8;
				}
			} else {
				var _g = 0;
				var _g1 = buf.indexes.length;
				while(_g < _g1) {
					var i = _g++;
					buf.indexes[i] = ibuf.getInt32(i << 2);
				}
			}
		} else {
			var icount = geom.indexCounts[material];
			var vmap = new Array(geom.vertexCount);
			var vertexes = hxd__$FloatBuffer_Float32Expand._new(0);
			buf.indexes = new Array(icount);
			var r = 0;
			var vcount = 0;
			var _g = 0;
			var _g1 = buf.indexes.length;
			while(_g < _g1) {
				var i = _g++;
				var vid = isSmall ? ibuf.b[r++] | ibuf.b[r++] << 8 : ibuf.getInt32(i << 2);
				var rid = vmap[vid];
				if(rid == 0) {
					++vcount;
					rid = vcount;
					vmap[vid] = rid;
					var _g2 = 0;
					while(_g2 < maps.length) {
						var m = maps[_g2];
						++_g2;
						if(m.def == null) {
							var _g3 = 0;
							var _g4 = m.size;
							while(_g3 < _g4) {
								var i1 = _g3++;
								var v;
								if(lowPrec) {
									switch(m.precision) {
									case 0:
										v = vbuf.getFloat(vid * geomStride + (i1 << 2) + m.offset);
										break;
									case 1:
										v = hxd_BufferFormat.float16to32(vbuf.getUInt16(vid * geomStride + (i1 << 1) + m.offset));
										break;
									case 2:
										v = (vbuf.b[vid * geomStride + i1 + m.offset] & 255) / 255;
										break;
									case 3:
										v = hxd_BufferFormat.floatS8to32(vbuf.b[vid * geomStride + i1 + m.offset]);
										break;
									}
								} else {
									v = vbuf.getFloat(vid * geomStride + (i1 << 2) + m.offset);
								}
								if(vertexes.pos == vertexes.array.length) {
									var newSize = vertexes.array.length << 1;
									if(newSize < 128) {
										newSize = 128;
									}
									var newArray = new Float32Array(newSize);
									newArray.set(vertexes.array);
									vertexes.array = newArray;
								}
								vertexes.array[vertexes.pos++] = v;
							}
						} else {
							switch(m.size) {
							case 1:
								var v1 = m.def.x;
								if(vertexes.pos == vertexes.array.length) {
									var newSize1 = vertexes.array.length << 1;
									if(newSize1 < 128) {
										newSize1 = 128;
									}
									var newArray1 = new Float32Array(newSize1);
									newArray1.set(vertexes.array);
									vertexes.array = newArray1;
								}
								vertexes.array[vertexes.pos++] = v1;
								break;
							case 2:
								var v2 = m.def.x;
								if(vertexes.pos == vertexes.array.length) {
									var newSize2 = vertexes.array.length << 1;
									if(newSize2 < 128) {
										newSize2 = 128;
									}
									var newArray2 = new Float32Array(newSize2);
									newArray2.set(vertexes.array);
									vertexes.array = newArray2;
								}
								vertexes.array[vertexes.pos++] = v2;
								var v3 = m.def.y;
								if(vertexes.pos == vertexes.array.length) {
									var newSize3 = vertexes.array.length << 1;
									if(newSize3 < 128) {
										newSize3 = 128;
									}
									var newArray3 = new Float32Array(newSize3);
									newArray3.set(vertexes.array);
									vertexes.array = newArray3;
								}
								vertexes.array[vertexes.pos++] = v3;
								break;
							case 3:
								var v4 = m.def.x;
								if(vertexes.pos == vertexes.array.length) {
									var newSize4 = vertexes.array.length << 1;
									if(newSize4 < 128) {
										newSize4 = 128;
									}
									var newArray4 = new Float32Array(newSize4);
									newArray4.set(vertexes.array);
									vertexes.array = newArray4;
								}
								vertexes.array[vertexes.pos++] = v4;
								var v5 = m.def.y;
								if(vertexes.pos == vertexes.array.length) {
									var newSize5 = vertexes.array.length << 1;
									if(newSize5 < 128) {
										newSize5 = 128;
									}
									var newArray5 = new Float32Array(newSize5);
									newArray5.set(vertexes.array);
									vertexes.array = newArray5;
								}
								vertexes.array[vertexes.pos++] = v5;
								var v6 = m.def.z;
								if(vertexes.pos == vertexes.array.length) {
									var newSize6 = vertexes.array.length << 1;
									if(newSize6 < 128) {
										newSize6 = 128;
									}
									var newArray6 = new Float32Array(newSize6);
									newArray6.set(vertexes.array);
									vertexes.array = newArray6;
								}
								vertexes.array[vertexes.pos++] = v6;
								break;
							default:
								var v7 = m.def.x;
								if(vertexes.pos == vertexes.array.length) {
									var newSize7 = vertexes.array.length << 1;
									if(newSize7 < 128) {
										newSize7 = 128;
									}
									var newArray7 = new Float32Array(newSize7);
									newArray7.set(vertexes.array);
									vertexes.array = newArray7;
								}
								vertexes.array[vertexes.pos++] = v7;
								var v8 = m.def.y;
								if(vertexes.pos == vertexes.array.length) {
									var newSize8 = vertexes.array.length << 1;
									if(newSize8 < 128) {
										newSize8 = 128;
									}
									var newArray8 = new Float32Array(newSize8);
									newArray8.set(vertexes.array);
									vertexes.array = newArray8;
								}
								vertexes.array[vertexes.pos++] = v8;
								var v9 = m.def.z;
								if(vertexes.pos == vertexes.array.length) {
									var newSize9 = vertexes.array.length << 1;
									if(newSize9 < 128) {
										newSize9 = 128;
									}
									var newArray9 = new Float32Array(newSize9);
									newArray9.set(vertexes.array);
									vertexes.array = newArray9;
								}
								vertexes.array[vertexes.pos++] = v9;
								var v10 = m.def.w;
								if(vertexes.pos == vertexes.array.length) {
									var newSize10 = vertexes.array.length << 1;
									if(newSize10 < 128) {
										newSize10 = 128;
									}
									var newArray10 = new Float32Array(newSize10);
									newArray10.set(vertexes.array);
									vertexes.array = newArray10;
								}
								vertexes.array[vertexes.pos++] = v10;
							}
						}
					}
				}
				buf.indexes[i] = rid - 1;
			}
			var this1 = vertexes;
			var _g = [];
			var _g1 = 0;
			var _g2 = this1.pos;
			while(_g1 < _g2) {
				var i = _g1++;
				_g.push(this1.array[i]);
			}
			buf.vertexes = _g;
		}
		return buf;
	}
	,makePrimitive: function(model) {
		var id = model.geometry;
		var p = this.cachedPrimitives[id];
		if(p != null) {
			return p;
		}
		var lods = null;
		var hasLod = model.lods != null;
		if(hasLod) {
			if(model.isLOD()) {
				return null;
			}
			var _g = [];
			var _g1 = 0;
			var _g2 = model.lods;
			while(_g1 < _g2.length) {
				var lod = _g2[_g1];
				++_g1;
				_g.push(this.header.models[lod]);
			}
			lods = _g;
			this.patchLodsMaterials(model,lods);
		} else {
			var lodInfos = model.getLODInfos();
			if(lodInfos.lodLevel > 0) {
				var _g = 0;
				var _g1 = this.header.models;
				while(_g < _g1.length) {
					var m = _g1[_g];
					++_g;
					if(m.isLOD0(lodInfos.modelName)) {
						return null;
					}
				}
				throw haxe_Exception.thrown("No LOD0 found for " + lodInfos.modelName + " in " + this.resource.entry.name);
			}
			if(lodInfos.lodLevel == 0) {
				lods = this.findLODs(lodInfos.modelName,model);
				this.patchLodsMaterials(model,lods);
				hasLod = true;
			}
		}
		p = new h3d_prim_HMDModel(this.header.geometries[id],this.header.dataPosition,this,lods);
		p.incref();
		this.cachedPrimitives[id] = p;
		return p;
	}
	,dispose: function() {
		var _g = 0;
		var _g1 = this.cachedPrimitives;
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			if(p != null) {
				p.decref();
			}
		}
		this.cachedPrimitives = [];
	}
	,makeMaterial: function(model,mid,loadTexture) {
		var m = this.header.materials[mid];
		var mat = h3d_mat_MaterialSetup.current.createMaterial();
		mat.name = m.name;
		mat.model = this.resource;
		mat.set_blendMode(m.blendMode);
		var props = h3d_mat_MaterialSetup.current.loadMaterialProps(mat);
		if(props == null) {
			props = mat.getDefaultModelProps();
		}
		if(m.diffuseTexture != null) {
			mat.set_texture(loadTexture(m.diffuseTexture));
			if(mat.get_texture() == null) {
				mat.set_texture(h3d_mat_Texture.fromColor(16711935));
			}
		}
		if(m.specularTexture != null) {
			mat.set_specularTexture(loadTexture(m.specularTexture));
		}
		if(m.normalMap != null) {
			mat.set_normalMap(loadTexture(m.normalMap));
		}
		mat.set_props(props);
		return mat;
	}
	,makeSkin: function(skin,geom) {
		var s = this.cachedSkin.h[skin.name];
		if(s != null) {
			return s;
		}
		s = new h3d_anim_Skin(skin.name,0,geom.props != null && geom.props.indexOf(hxd_fmt_hmd_Property.FourBonesByVertex) >= 0 ? 4 : 3);
		s.namedJoints = new haxe_ds_StringMap();
		s.allJoints = [];
		s.boundJoints = [];
		s.rootJoints = [];
		var _g = 0;
		var _g1 = skin.joints;
		while(_g < _g1.length) {
			var joint = _g1[_g];
			++_g;
			var j = new h3d_anim_Joint();
			j.name = joint.name;
			j.index = s.allJoints.length;
			j.defMat = joint.position.toMatrix();
			if(joint.bind >= 0) {
				j.bindIndex = joint.bind;
				j.transPos = joint.transpos.toMatrix(true);
				s.boundJoints[j.bindIndex] = j;
			}
			if(joint.parent >= 0) {
				var p = s.allJoints[joint.parent];
				p.subs.push(j);
				j.parent = p;
			} else {
				s.rootJoints.push(j);
			}
			s.allJoints.push(j);
			s.namedJoints.h[j.name] = j;
		}
		if(skin.split != null) {
			s.splitJoints = [];
			var _g = 0;
			var _g1 = skin.split;
			while(_g < _g1.length) {
				var ss = _g1[_g];
				++_g;
				var s1 = s.splitJoints;
				var ss1 = ss.materialIndex;
				var _g2 = [];
				var _g3 = 0;
				var _g4 = ss.joints;
				while(_g3 < _g4.length) {
					var j = _g4[_g3];
					++_g3;
					_g2.push(s.allJoints[j]);
				}
				s1.push({ material : ss1, joints : _g2});
			}
		}
		this.cachedSkin.h[skin.name] = s;
		return s;
	}
	,getModelProperty: function(objName,p,def) {
		var _g = 0;
		var _g1 = this.header.models;
		while(_g < _g1.length) {
			var m = _g1[_g];
			++_g;
			if(m.name == objName) {
				if(m.props != null) {
					var _g2 = 0;
					var _g3 = m.props;
					while(_g2 < _g3.length) {
						var pr = _g3[_g2];
						++_g2;
						if(pr._hx_index == p._hx_index) {
							return Type.enumParameters(pr)[0];
						}
					}
				}
				return def;
			}
		}
		if(def == null) {
			throw haxe_Exception.thrown("Model " + objName + " not found");
		}
		return def;
	}
	,findLODs: function(modelName,lod0) {
		if(modelName == null) {
			return null;
		}
		var lods = [];
		var _g = 0;
		var _g1 = this.header.models;
		while(_g < _g1.length) {
			var curModel = _g1[_g];
			++_g;
			var lodInfos = curModel.getLODInfos();
			if(lodInfos.lodLevel < 1) {
				continue;
			}
			if(lodInfos.modelName == modelName) {
				if(lods[lodInfos.lodLevel - 1] != null) {
					throw haxe_Exception.thrown("Multiple LODs with the same level : " + curModel.name);
				}
				lods[lodInfos.lodLevel - 1] = curModel;
			}
		}
		return lods;
	}
	,patchLodsMaterials: function(lod0,lods) {
		var _g = 0;
		while(_g < lods.length) {
			var model = lods[_g];
			++_g;
			var _g1 = 0;
			var _g2 = model.materials;
			while(_g1 < _g2.length) {
				var m = _g2[_g1];
				++_g1;
				if(lod0.materials.indexOf(m) != -1) {
					continue;
				}
				throw haxe_Exception.thrown("Model " + model.name + " has a material that isn't used by " + lod0.name + ". This is not supported.");
			}
			var geom = this.header.geometries[model.geometry];
			var indexCounts = [];
			var j = 0;
			var _g3 = 0;
			var _g4 = lod0.materials.length;
			while(_g3 < _g4) {
				var i = _g3++;
				if(lod0.materials[i] == model.materials[j]) {
					indexCounts[i] = geom.indexCounts[j];
					++j;
				} else {
					indexCounts[i] = 0;
				}
			}
			geom.indexCounts = indexCounts;
		}
	}
	,makeObject: function(loadTexture) {
		if(loadTexture == null) {
			loadTexture = function(_) {
				return h3d_mat_Texture.fromColor(16711935);
			};
		}
		if(this.header.models.length == 0) {
			throw haxe_Exception.thrown("This file does not contain any model");
		}
		var objs = [];
		var _g = 0;
		var _g1 = this.header.models;
		while(_g < _g1.length) {
			var m = _g1[_g];
			++_g;
			var obj;
			if(m.geometry < 0) {
				obj = new h3d_scene_Object();
			} else {
				var prim = this.makePrimitive(m);
				if(prim == null) {
					continue;
				}
				if(m.skin != null) {
					var skinData = this.makeSkin(m.skin,this.header.geometries[m.geometry]);
					skinData.primitive = prim;
					var _g2 = [];
					var _g3 = 0;
					var _g4 = m.materials;
					while(_g3 < _g4.length) {
						var mat = _g4[_g3];
						++_g3;
						_g2.push(this.makeMaterial(m,mat,loadTexture));
					}
					obj = new h3d_scene_Skin(skinData,_g2);
				} else if(m.materials.length == 1) {
					obj = new h3d_scene_Mesh(prim,this.makeMaterial(m,m.materials[0],loadTexture));
				} else {
					var _g5 = [];
					var _g6 = 0;
					var _g7 = m.materials;
					while(_g6 < _g7.length) {
						var mat1 = _g7[_g6];
						++_g6;
						_g5.push(this.makeMaterial(m,mat1,loadTexture));
					}
					obj = new h3d_scene_MultiMaterial(prim,_g5);
				}
			}
			obj.name = m.getObjectName();
			var v = m.position.toMatrix();
			obj.defaultTransform = v;
			var f = 1;
			var b = true;
			if(b) {
				obj.flags |= f;
			} else {
				obj.flags &= ~f;
			}
			var c = b;
			if(c && (obj.flags & 131072) != 0) {
				var f1 = 262144;
				obj.flags |= f1;
			}
			objs.push(obj);
			var p = objs[m.parent];
			if(p != null) {
				p.addChild(obj);
			}
			var modelData = this.resource.entry.get_directory();
			var tmp = ((obj) instanceof h3d_scene_Mesh) ? obj : null;
			var value = tmp != null ? tmp.primitive : null;
			var modelData1 = { resourceDirectory : modelData, resourceName : this.resource.entry.name, objectName : obj.name, hmd : ((value) instanceof h3d_prim_HMDModel) ? value : null, skin : ((obj) instanceof h3d_scene_Skin) ? obj : null};
			h3d_prim_ModelDatabase.current.loadModelProps(modelData1);
		}
		var o = objs[0];
		if(o != null) {
			var f = 256;
			o.flags |= f;
		}
		return o;
	}
	,loadAnimation: function(name) {
		var a = this.cachedAnimations.h[name == null ? "" : name];
		if(a != null) {
			return a;
		}
		var a = null;
		if(name == null) {
			if(this.header.animations.length == 0) {
				return null;
			}
			a = this.header.animations[0];
		} else {
			var _g = 0;
			var _g1 = this.header.animations;
			while(_g < _g1.length) {
				var a2 = _g1[_g];
				++_g;
				if(a2.name == name) {
					a = a2;
					break;
				}
			}
			if(a == null) {
				throw haxe_Exception.thrown("Animation " + name + " not found !");
			}
		}
		var l = this.header.version <= 2 ? this.makeLinearAnimation(a) : this.makeAnimation(a);
		l.speed = a.speed;
		l.loop = a.loop;
		if(a.events != null) {
			l.setEvents(a.events);
		}
		l.resourcePath = this.resource.entry.get_path();
		this.cachedAnimations.h[a.name] = l;
		if(name == null) {
			this.cachedAnimations.h[""] = l;
		}
		return l;
	}
	,makeAnimation: function(a) {
		var b = new h3d_anim_BufferAnimation(a.name,a.frames,a.sampling);
		var stride = 0;
		var singleFrames = [];
		var otherFrames = [];
		var _g = 0;
		var _g1 = a.objects;
		while(_g < _g1.length) {
			var o = _g1[_g];
			++_g;
			var c = b.addObject(o.name,0);
			var sm = 1;
			if((o.flags & 1 << hxd_fmt_hmd_AnimationFlag.SingleFrame._hx_index) != 0) {
				c.layout |= 1 << h3d_anim_DataLayout.SingleFrame._hx_index;
				singleFrames.push(c);
				sm = 0;
			} else {
				otherFrames.push(c);
			}
			if((o.flags & 1 << hxd_fmt_hmd_AnimationFlag.HasPosition._hx_index) != 0) {
				c.layout |= 1 << h3d_anim_DataLayout.Position._hx_index;
				stride += 3 * sm;
			}
			if((o.flags & 1 << hxd_fmt_hmd_AnimationFlag.HasRotation._hx_index) != 0) {
				c.layout |= 1 << h3d_anim_DataLayout.Rotation._hx_index;
				stride += 3 * sm;
			}
			if((o.flags & 1 << hxd_fmt_hmd_AnimationFlag.HasScale._hx_index) != 0) {
				c.layout |= 1 << h3d_anim_DataLayout.Scale._hx_index;
				stride += 3 * sm;
			}
			if((o.flags & 1 << hxd_fmt_hmd_AnimationFlag.HasUV._hx_index) != 0) {
				c.layout |= 1 << h3d_anim_DataLayout.UV._hx_index;
				stride += 2 * sm;
			}
			if((o.flags & 1 << hxd_fmt_hmd_AnimationFlag.HasAlpha._hx_index) != 0) {
				c.layout |= 1 << h3d_anim_DataLayout.Alpha._hx_index;
				stride += sm;
			}
			if((o.flags & 1 << hxd_fmt_hmd_AnimationFlag.HasProps._hx_index) != 0) {
				var _g2 = 0;
				var _g3 = o.props.length;
				while(_g2 < _g3) {
					var i = _g2++;
					var c1 = c;
					if(i > 0) {
						c1 = b.addObject(o.name,0);
						if(sm == 0) {
							singleFrames.push(c1);
						} else {
							otherFrames.push(c1);
						}
					}
					c1.layout |= 1 << h3d_anim_DataLayout.Property._hx_index;
					c1.propName = o.props[i];
					stride += sm;
				}
			}
		}
		var pos = 0;
		var _g = 0;
		while(_g < singleFrames.length) {
			var b1 = singleFrames[_g];
			++_g;
			b1.dataOffset = pos;
			pos += b1.getStride();
		}
		var singleStride = pos;
		var _g = 0;
		while(_g < otherFrames.length) {
			var b1 = otherFrames[_g];
			++_g;
			b1.dataOffset = pos;
			pos += b1.getStride();
		}
		var entry = this.resource.entry;
		var count = stride * a.frames + singleStride;
		var data = new haxe_io_Bytes(new ArrayBuffer(count * 4));
		entry.readFull(data,this.header.dataPosition + a.dataPosition,data.length);
		b.setData(new Float32Array(data.b.buffer),stride);
		return b;
	}
	,makeLinearAnimation: function(a) {
		var l = new h3d_anim_LinearAnimation(a.name,a.frames,a.sampling);
		var entry = this.resource.entry;
		var dataPos = this.header.dataPosition + a.dataPosition;
		var _g = 0;
		var _g1 = a.objects;
		while(_g < _g1.length) {
			var o = _g1[_g];
			++_g;
			var pos = (o.flags & 1 << hxd_fmt_hmd_AnimationFlag.HasPosition._hx_index) != 0;
			var rot = (o.flags & 1 << hxd_fmt_hmd_AnimationFlag.HasRotation._hx_index) != 0;
			var scale = (o.flags & 1 << hxd_fmt_hmd_AnimationFlag.HasScale._hx_index) != 0;
			if(pos || rot || scale) {
				var frameCount = a.frames;
				if((o.flags & 1 << hxd_fmt_hmd_AnimationFlag.SingleFrame._hx_index) != 0) {
					frameCount = 1;
				}
				var fl = new Array(frameCount);
				var size = ((pos ? 3 : 0) + (rot ? 3 : 0) + (scale ? 3 : 0)) * 4 * frameCount;
				var data = entry.fetchBytes(dataPos,size);
				dataPos += size;
				var p = 0;
				var _g2 = 0;
				var _g3 = frameCount;
				while(_g2 < _g3) {
					var i = _g2++;
					var f = new h3d_anim_LinearFrame();
					if(pos) {
						f.tx = data.getFloat(p);
						p += 4;
						f.ty = data.getFloat(p);
						p += 4;
						f.tz = data.getFloat(p);
						p += 4;
					} else {
						f.tx = 0;
						f.ty = 0;
						f.tz = 0;
					}
					if(rot) {
						f.qx = data.getFloat(p);
						p += 4;
						f.qy = data.getFloat(p);
						p += 4;
						f.qz = data.getFloat(p);
						p += 4;
						var qw = 1 - (f.qx * f.qx + f.qy * f.qy + f.qz * f.qz);
						f.qw = qw < 0 ? -Math.sqrt(-qw) : Math.sqrt(qw);
					} else {
						f.qx = 0;
						f.qy = 0;
						f.qz = 0;
						f.qw = 1;
					}
					if(scale) {
						f.sx = data.getFloat(p);
						p += 4;
						f.sy = data.getFloat(p);
						p += 4;
						f.sz = data.getFloat(p);
						p += 4;
					} else {
						f.sx = 1;
						f.sy = 1;
						f.sz = 1;
					}
					fl[i] = f;
				}
				l.addCurve(o.name,fl,true,rot,scale);
			}
			if((o.flags & 1 << hxd_fmt_hmd_AnimationFlag.HasUV._hx_index) != 0) {
				var fl1 = new Array(a.frames * 2);
				var size1 = 8 * a.frames;
				var data1 = entry.fetchBytes(dataPos,size1);
				dataPos += size1;
				var _g4 = 0;
				var _g5 = fl1.length;
				while(_g4 < _g5) {
					var i1 = _g4++;
					fl1[i1] = data1.getFloat(i1 * 4);
				}
				l.addUVCurve(o.name,fl1);
			}
			if((o.flags & 1 << hxd_fmt_hmd_AnimationFlag.HasAlpha._hx_index) != 0) {
				var fl2 = new Array(a.frames);
				var size2 = 4 * a.frames;
				var data2 = entry.fetchBytes(dataPos,size2);
				dataPos += size2;
				var _g6 = 0;
				var _g7 = fl2.length;
				while(_g6 < _g7) {
					var i2 = _g6++;
					fl2[i2] = data2.getFloat(i2 * 4);
				}
				l.addAlphaCurve(o.name,fl2);
			}
			if((o.flags & 1 << hxd_fmt_hmd_AnimationFlag.HasProps._hx_index) != 0) {
				var _g8 = 0;
				var _g9 = o.props;
				while(_g8 < _g9.length) {
					var p1 = _g9[_g8];
					++_g8;
					var fl3 = new Array(a.frames);
					var size3 = 4 * a.frames;
					var data3 = entry.fetchBytes(dataPos,size3);
					dataPos += size3;
					var _g10 = 0;
					var _g11 = fl3.length;
					while(_g10 < _g11) {
						var i3 = _g10++;
						fl3[i3] = data3.getFloat(i3 * 4);
					}
					l.addPropCurve(o.name,p1,fl3);
				}
			}
		}
		return l;
	}
	,loadSkin: function(geom,skin,optimize) {
		if(optimize == null) {
			optimize = true;
		}
		if(skin.vertexWeights != null) {
			return;
		}
		var bonesPerVertex = skin.bonesPerVertex;
		if(!(bonesPerVertex == 3 || bonesPerVertex == 4)) {
			throw haxe_Exception.thrown("assert");
		}
		var use4Bones = bonesPerVertex == 4;
		skin.vertexCount = geom.vertexCount;
		var format = hxd_BufferFormat.make([new hxd_BufferInput("position",3),new hxd_BufferInput("weights",3),new hxd_BufferInput("indexes",9)]);
		var data = this.getBuffers(geom,format);
		var formatStride = format.stride;
		skin.vertexWeights = new Array(skin.vertexCount * bonesPerVertex);
		skin.vertexJoints = new Array(skin.vertexCount * bonesPerVertex);
		var _g = 0;
		var _g1 = skin.boundJoints;
		while(_g < _g1.length) {
			var j = _g1[_g];
			++_g;
			j.offsets = new h3d_col_Bounds();
		}
		var vbuf = data.vertexes;
		var idx = 0;
		var bounds_xMin = 1e20;
		var bounds_xMax = -1e20;
		var bounds_yMin = 1e20;
		var bounds_yMax = -1e20;
		var bounds_zMin = 1e20;
		var bounds_zMax = -1e20;
		var out = NaN;
		var ranges;
		if(skin.splitJoints == null) {
			var jointsByBind = [];
			var _g = 0;
			var _g1 = skin.boundJoints;
			while(_g < _g1.length) {
				var j = _g1[_g];
				++_g;
				jointsByBind[j.bindIndex] = j;
			}
			ranges = [{ index : 0, pos : 0, count : data.indexes.length, joints : jointsByBind}];
		} else {
			var idx = 0;
			var triPos = [];
			var pos = 0;
			var _g = 0;
			var _g1 = geom.indexCounts;
			while(_g < _g1.length) {
				var n = _g1[_g];
				++_g;
				triPos.push(pos);
				pos += n;
			}
			var _g = [];
			var _g1 = 0;
			var _g2 = skin.splitJoints;
			while(_g1 < _g2.length) {
				var j = _g2[_g1];
				++_g1;
				_g.push({ index : idx, pos : triPos[idx], count : geom.indexCounts[idx++], joints : j.joints});
			}
			ranges = _g;
		}
		var _g = 0;
		while(_g < ranges.length) {
			var r = ranges[_g];
			++_g;
			var _g1 = r.pos;
			var _g2 = r.pos + r.count;
			while(_g1 < _g2) {
				var idx = _g1++;
				var vidx = data.indexes[idx];
				var p = vidx * formatStride;
				var x = vbuf[p];
				if(isNaN(x)) {
					continue;
				}
				vbuf[p++] = out;
				var y = vbuf[p++];
				var z = vbuf[p++];
				var w1 = vbuf[p++];
				var w2 = vbuf[p++];
				var w3 = vbuf[p++];
				var w4 = 0.0;
				var vout = vidx * bonesPerVertex;
				skin.vertexWeights[vout] = w1;
				skin.vertexWeights[vout + 1] = w2;
				skin.vertexWeights[vout + 2] = w3;
				if(use4Bones) {
					w4 = 1.0 - w1 - w2 - w3;
					skin.vertexWeights[vout + 3] = w4;
				}
				var w = (w1 == 0 ? 1 : 0) | (w2 == 0 ? 2 : 0) | (w3 == 0 ? 4 : 0) | (w4 == 0 ? 8 : 0);
				var idx1 = haxe_io_FPHelper.floatToI32(vbuf[p++]);
				if(x < bounds_xMin) {
					bounds_xMin = x;
				}
				if(x > bounds_xMax) {
					bounds_xMax = x;
				}
				if(y < bounds_yMin) {
					bounds_yMin = y;
				}
				if(y > bounds_yMax) {
					bounds_yMax = y;
				}
				if(z < bounds_zMin) {
					bounds_zMin = z;
				}
				if(z > bounds_zMax) {
					bounds_zMax = z;
				}
				var _g3 = 0;
				var _g4 = bonesPerVertex;
				while(_g3 < _g4) {
					var i = _g3++;
					if((w & 1 << i) != 0) {
						skin.vertexJoints[vout++] = -1;
						continue;
					}
					var idx2 = idx1 >> (i << 3) & 255;
					var j = r.joints[idx2];
					var _this = j.offsets;
					if(x < _this.xMin) {
						_this.xMin = x;
					}
					if(x > _this.xMax) {
						_this.xMax = x;
					}
					if(y < _this.yMin) {
						_this.yMin = y;
					}
					if(y > _this.yMax) {
						_this.yMax = y;
					}
					if(z < _this.zMin) {
						_this.zMin = z;
					}
					if(z > _this.zMax) {
						_this.zMax = z;
					}
					skin.vertexJoints[vout++] = j.bindIndex;
				}
			}
		}
		if(optimize) {
			var idx = skin.allJoints.length - 1;
			var optOut = 0;
			var refVolume = (bounds_xMax - bounds_xMin) * (bounds_yMax - bounds_yMin) * (bounds_zMax - bounds_zMin);
			while(idx >= 0) {
				var j = skin.allJoints[idx--];
				if(j.offsets == null || j.parent == null || j.parent.offsets == null) {
					continue;
				}
				var poff = j.parent.offsets;
				var _this = j.offsets;
				var dx = _this.xMax - _this.xMin;
				var dy = _this.yMax - _this.yMin;
				var dz = _this.zMax - _this.zMin;
				var x = (_this.xMin + _this.xMax) * 0.5;
				var y = (_this.yMin + _this.yMax) * 0.5;
				var z = (_this.zMin + _this.zMax) * 0.5;
				var r = Math.sqrt(dx * dx + dy * dy + dz * dz) * 0.5;
				if(r == null) {
					r = 1.;
				}
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var sx = x;
				var sy = y;
				var sz = z;
				var sr = r;
				if(sr == null) {
					sr = 0.;
				}
				if(sz == null) {
					sz = 0.;
				}
				if(sy == null) {
					sy = 0.;
				}
				if(sx == null) {
					sx = 0.;
				}
				var sp_x = sx;
				var sp_y = sy;
				var sp_z = sz;
				var sp_r = sr;
				if(poff.xMin <= sp_x - sp_r && poff.yMin <= sp_y - sp_r && poff.zMin <= sp_z - sp_r && poff.xMax >= sp_x + sp_r && poff.yMax >= sp_y + sp_r && poff.zMax >= sp_z + sp_r) {
					j.offsets = null;
					++optOut;
					continue;
				}
				var b = new h3d_col_Bounds();
				b.xMin = poff.xMin;
				b.xMax = poff.xMax;
				b.yMin = poff.yMin;
				b.yMax = poff.yMax;
				b.zMin = poff.zMin;
				b.zMax = poff.zMax;
				var pext = b;
				var x1 = sp_x;
				var y1 = sp_y;
				var z1 = sp_z;
				var r1 = sp_r;
				if(x1 - r1 < pext.xMin) {
					pext.xMin = x1 - r1;
				}
				if(x1 + r1 > pext.xMax) {
					pext.xMax = x1 + r1;
				}
				if(y1 - r1 < pext.yMin) {
					pext.yMin = y1 - r1;
				}
				if(y1 + r1 > pext.yMax) {
					pext.yMax = y1 + r1;
				}
				if(z1 - r1 < pext.zMin) {
					pext.zMin = z1 - r1;
				}
				if(z1 + r1 > pext.zMax) {
					pext.zMax = z1 + r1;
				}
				var ratio = Math.sqrt(refVolume * 1.5 / ((pext.xMax - pext.xMin) * (pext.yMax - pext.yMin) * (pext.zMax - pext.zMin)));
				var k = (pext.xMax - pext.xMin) * (pext.yMax - pext.yMin) * (pext.zMax - pext.zMin) / ((poff.xMax - poff.xMin) * (poff.yMax - poff.yMin) * (poff.zMax - poff.zMin));
				if(k < ratio) {
					j.parent.offsets = pext;
					j.offsets = null;
					++optOut;
					continue;
				}
			}
		}
		var _g = 0;
		var _g1 = skin.allJoints;
		while(_g < _g1.length) {
			var j = _g1[_g];
			++_g;
			if(j.offsets == null) {
				j.offsetRay = -1;
				continue;
			}
			var b = j.offsets;
			var pt1;
			var pt2;
			var x = (b.xMin + b.xMax) * 0.5;
			var y = (b.yMin + b.yMax) * 0.5;
			var z = (b.zMin + b.zMax) * 0.5;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var off_x = x1;
			var off_y = y1;
			var off_z = z1;
			var r;
			if(b.xMax - b.xMin > b.yMax - b.yMin && b.xMax - b.xMin > b.zMax - b.zMin) {
				var a = b.yMax - b.yMin;
				var b1 = b.zMax - b.zMin;
				r = (a < b1 ? b1 : a) * 0.5;
				var x2 = b.xMin + r;
				var y2 = off_y;
				var z2 = off_z;
				if(z2 == null) {
					z2 = 0.;
				}
				if(y2 == null) {
					y2 = 0.;
				}
				if(x2 == null) {
					x2 = 0.;
				}
				pt1 = new h3d_VectorImpl(x2,y2,z2);
				var x3 = b.xMax - r;
				var y3 = off_y;
				var z3 = off_z;
				if(z3 == null) {
					z3 = 0.;
				}
				if(y3 == null) {
					y3 = 0.;
				}
				if(x3 == null) {
					x3 = 0.;
				}
				pt2 = new h3d_VectorImpl(x3,y3,z3);
			} else if(b.yMax - b.yMin > b.zMax - b.zMin) {
				var a1 = b.xMax - b.xMin;
				var b2 = b.zMax - b.zMin;
				r = (a1 < b2 ? b2 : a1) * 0.5;
				var x4 = off_x;
				var y4 = b.yMin + r;
				var z4 = off_z;
				if(z4 == null) {
					z4 = 0.;
				}
				if(y4 == null) {
					y4 = 0.;
				}
				if(x4 == null) {
					x4 = 0.;
				}
				pt1 = new h3d_VectorImpl(x4,y4,z4);
				var x5 = off_x;
				var y5 = b.yMax - r;
				var z5 = off_z;
				if(z5 == null) {
					z5 = 0.;
				}
				if(y5 == null) {
					y5 = 0.;
				}
				if(x5 == null) {
					x5 = 0.;
				}
				pt2 = new h3d_VectorImpl(x5,y5,z5);
			} else {
				var a2 = b.xMax - b.xMin;
				var b3 = b.yMax - b.yMin;
				r = (a2 < b3 ? b3 : a2) * 0.5;
				var x6 = off_x;
				var y6 = off_y;
				var z6 = b.zMin + r;
				if(z6 == null) {
					z6 = 0.;
				}
				if(y6 == null) {
					y6 = 0.;
				}
				if(x6 == null) {
					x6 = 0.;
				}
				pt1 = new h3d_VectorImpl(x6,y6,z6);
				var x7 = off_x;
				var y7 = off_y;
				var z7 = b.zMax - r;
				if(z7 == null) {
					z7 = 0.;
				}
				if(y7 == null) {
					y7 = 0.;
				}
				if(x7 == null) {
					x7 = 0.;
				}
				pt2 = new h3d_VectorImpl(x7,y7,z7);
			}
			b.xMin = pt1.x;
			b.yMin = pt1.y;
			b.zMin = pt1.z;
			b.xMax = pt2.x;
			b.yMax = pt2.y;
			b.zMax = pt2.z;
			j.offsetRay = r;
		}
	}
	,__class__: hxd_fmt_hmd_Library
};
var hxd_fmt_hmd_Reader = function(i) {
	this.i = i;
};
$hxClasses["hxd.fmt.hmd.Reader"] = hxd_fmt_hmd_Reader;
hxd_fmt_hmd_Reader.__name__ = "hxd.fmt.hmd.Reader";
hxd_fmt_hmd_Reader.prototype = {
	readProperty: function() {
		var _g = this.i.readByte();
		switch(_g) {
		case 0:
			return hxd_fmt_hmd_Property.CameraFOVY(this.i.readFloat());
		case 1:
			throw haxe_Exception.thrown("Obsolete HasMaterialFlags");
		case 2:
			return hxd_fmt_hmd_Property.HasExtraTextures;
		case 3:
			return hxd_fmt_hmd_Property.FourBonesByVertex;
		case 4:
			return hxd_fmt_hmd_Property.HasLod;
		case 5:
			return hxd_fmt_hmd_Property.HasCollider;
		default:
			var unk = _g;
			throw haxe_Exception.thrown("Unknown property #" + unk);
		}
	}
	,readProps: function() {
		if(this.version == 1) {
			return null;
		}
		var n = this.i.readByte();
		if(n == 0) {
			return null;
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = n;
		while(_g1 < _g2) {
			var i = _g1++;
			_g.push(this.readProperty());
		}
		return _g;
	}
	,readName: function() {
		var b = this.i.readByte();
		if(b == 255) {
			return null;
		}
		return this.i.readString(b);
	}
	,readCachedName: function() {
		var name = this.readName();
		if(name == null) {
			return null;
		}
		if(hxd_fmt_hmd_Reader.HMD_STRINGS == null) {
			hxd_fmt_hmd_Reader.HMD_STRINGS = new haxe_ds_StringMap();
		}
		var n = hxd_fmt_hmd_Reader.HMD_STRINGS.h[name];
		if(n != null) {
			return n;
		}
		hxd_fmt_hmd_Reader.HMD_STRINGS.h[name] = name;
		return name;
	}
	,readPosition: function(hasScale) {
		if(hasScale == null) {
			hasScale = true;
		}
		var p = new hxd_fmt_hmd_Position();
		p.x = this.i.readFloat();
		p.y = this.i.readFloat();
		p.z = this.i.readFloat();
		p.qx = this.i.readFloat();
		p.qy = this.i.readFloat();
		p.qz = this.i.readFloat();
		if(hasScale) {
			p.sx = this.i.readFloat();
			p.sy = this.i.readFloat();
			p.sz = this.i.readFloat();
		} else {
			p.sx = 1;
			p.sy = 1;
			p.sz = 1;
		}
		return p;
	}
	,readBounds: function() {
		var b = new h3d_col_Bounds();
		b.xMin = this.i.readFloat();
		b.yMin = this.i.readFloat();
		b.zMin = this.i.readFloat();
		b.xMax = this.i.readFloat();
		b.yMax = this.i.readFloat();
		b.zMax = this.i.readFloat();
		return b;
	}
	,readSkin: function() {
		var name = this.readCachedName();
		if(name == null) {
			return null;
		}
		var s = new hxd_fmt_hmd_Skin();
		s.props = this.readProps();
		s.name = name;
		s.joints = [];
		var _g = 0;
		var _g1 = this.i.readUInt16();
		while(_g < _g1) {
			var k = _g++;
			var j = new hxd_fmt_hmd_SkinJoint();
			j.props = this.readProps();
			j.name = this.readCachedName();
			var pid = this.i.readUInt16();
			var hasScale = (pid & 32768) != 0;
			if(hasScale) {
				pid &= 32767;
			}
			j.parent = pid - 1;
			j.position = this.readPosition(hasScale);
			j.bind = this.i.readUInt16() - 1;
			if(j.bind >= 0) {
				j.transpos = this.readPosition(hasScale);
			}
			s.joints.push(j);
		}
		var count = this.i.readByte();
		if(count > 0) {
			s.split = [];
			var _g = 0;
			var _g1 = count;
			while(_g < _g1) {
				var k = _g++;
				var ss = new hxd_fmt_hmd_SkinSplit();
				ss.materialIndex = this.i.readByte();
				var _g2 = [];
				var _g3 = 0;
				var _g4 = this.i.readByte();
				while(_g3 < _g4) {
					var k1 = _g3++;
					_g2.push(this.i.readUInt16());
				}
				ss.joints = _g2;
				s.split.push(ss);
			}
		}
		return s;
	}
	,readLods: function() {
		var lodCount = this.i.readInt32();
		var _g = [];
		var _g1 = 0;
		var _g2 = lodCount;
		while(_g1 < _g2) {
			var _ = _g1++;
			_g.push(this.i.readInt32());
		}
		return _g;
	}
	,readHeader: function(fast) {
		if(fast == null) {
			fast = false;
		}
		var _gthis = this;
		var d = new hxd_fmt_hmd_Data();
		var h = this.i.readString(3);
		if(h != "HMD") {
			if(HxOverrides.cca(h,0) == 59) {
				throw haxe_Exception.thrown("FBX was not converted to HMD");
			}
			throw haxe_Exception.thrown("Invalid HMD header " + encodeURIComponent(h));
		}
		this.version = this.i.readByte();
		if(this.version > 4) {
			throw haxe_Exception.thrown("Can't read HMD v" + this.version);
		}
		d.version = this.version;
		d.geometries = [];
		d.dataPosition = this.i.readInt32();
		if(fast) {
			this.i = new haxe_io_BytesInput(this.i.read(d.dataPosition - 12));
		}
		d.props = this.readProps();
		var _g = 0;
		var _g1 = this.i.readInt32();
		while(_g < _g1) {
			var k = _g++;
			var g = new hxd_fmt_hmd_Geometry();
			g.props = this.readProps();
			g.vertexCount = this.i.readInt32();
			var stride = _gthis.i.readByte();
			var _g2 = [];
			var _g3 = 0;
			var _g4 = _gthis.i.readByte();
			while(_g3 < _g4) {
				var k1 = _g3++;
				var name = _gthis.readCachedName();
				var type = _gthis.i.readByte();
				_g2.push(new hxd_BufferInput(name,type & 15,type >> 4));
			}
			var format = hxd_BufferFormat.make(_g2);
			if(stride != format.stride) {
				throw haxe_Exception.thrown("assert");
			}
			g.vertexFormat = format;
			g.vertexPosition = this.i.readInt32();
			var subCount = this.i.readByte();
			if(subCount == 255) {
				subCount = this.i.readInt32();
			}
			var _g5 = [];
			var _g6 = 0;
			var _g7 = subCount;
			while(_g6 < _g7) {
				var k2 = _g6++;
				_g5.push(this.i.readInt32());
			}
			g.indexCounts = _g5;
			g.indexPosition = this.i.readInt32();
			g.bounds = this.readBounds();
			d.geometries.push(g);
		}
		d.materials = [];
		var _g = 0;
		var _g1 = this.i.readInt32();
		while(_g < _g1) {
			var k = _g++;
			var m = new hxd_fmt_hmd_Material();
			m.props = this.readProps();
			m.name = this.readName();
			m.diffuseTexture = this.readName();
			m.blendMode = hxd_fmt_hmd_Reader.BLEND[this.i.readByte()];
			this.i.readByte();
			this.i.readFloat();
			if(m.props != null && m.props.indexOf(hxd_fmt_hmd_Property.HasExtraTextures) >= 0) {
				m.specularTexture = this.readName();
				m.normalMap = this.readName();
			}
			d.materials.push(m);
		}
		d.models = [];
		var hasCollider = false;
		var _g = 0;
		var _g1 = this.i.readInt32();
		while(_g < _g1) {
			var k = _g++;
			var m = new hxd_fmt_hmd_Model();
			m.props = this.readProps();
			m.name = this.readCachedName();
			m.parent = this.i.readInt32() - 1;
			m.follow = this.readCachedName();
			m.position = this.readPosition();
			m.geometry = this.i.readInt32() - 1;
			d.models.push(m);
			if(m.geometry < 0) {
				continue;
			}
			m.materials = [];
			var matCount = this.i.readByte();
			if(matCount == 255) {
				matCount = this.i.readInt32();
			}
			var _g2 = 0;
			var _g3 = matCount;
			while(_g2 < _g3) {
				var k1 = _g2++;
				m.materials.push(this.i.readInt32());
			}
			m.skin = this.readSkin();
			if(m.props != null) {
				m.lods = m.props.indexOf(hxd_fmt_hmd_Property.HasLod) != -1 ? this.readLods() : null;
				if(m.props.indexOf(hxd_fmt_hmd_Property.HasCollider) != -1) {
					m.collider = this.i.readInt32();
					hasCollider = true;
				}
			}
		}
		d.animations = [];
		var _g = 0;
		var _g1 = this.i.readInt32();
		while(_g < _g1) {
			var k = _g++;
			var a = new hxd_fmt_hmd_Animation();
			a.props = this.readProps();
			a.name = this.readName();
			a.frames = this.i.readInt32();
			a.sampling = this.i.readFloat();
			a.speed = this.i.readFloat();
			var flags = this.i.readByte();
			a.loop = (flags & 1) != 0;
			a.dataPosition = this.i.readInt32();
			a.objects = [];
			var _g2 = 0;
			var _g3 = this.i.readInt32();
			while(_g2 < _g3) {
				var k1 = _g2++;
				var o = new hxd_fmt_hmd_AnimationObject();
				o.name = this.readCachedName();
				var i = this.i.readByte();
				if(i == null) {
					i = 0;
				}
				o.flags = i;
				a.objects.push(o);
				if((o.flags & 1 << hxd_fmt_hmd_AnimationFlag.HasProps._hx_index) != 0) {
					var _g4 = [];
					var _g5 = 0;
					var _g6 = this.i.readByte();
					while(_g5 < _g6) {
						var i1 = _g5++;
						_g4.push(this.readName());
					}
					o.props = _g4;
				}
			}
			if((flags & 2) != 0) {
				a.events = [];
				var _g7 = 0;
				var _g8 = this.i.readInt32();
				while(_g7 < _g8) {
					var k2 = _g7++;
					var e = new hxd_fmt_hmd_AnimationEvent();
					e.frame = this.i.readInt32();
					e.data = this.readCachedName();
					a.events.push(e);
				}
			}
			d.animations.push(a);
		}
		if(d.version >= 4) {
			var shapeLength = this.i.readInt32();
			d.shapes = [];
			var _g = 0;
			var _g1 = shapeLength;
			while(_g < _g1) {
				var k = _g++;
				var s = new hxd_fmt_hmd_BlendShape();
				s.name = this.readName();
				s.geom = this.i.readInt32() - 1;
				s.vertexCount = this.i.readInt32();
				var stride = _gthis.i.readByte();
				var _g2 = [];
				var _g3 = 0;
				var _g4 = _gthis.i.readByte();
				while(_g3 < _g4) {
					var k1 = _g3++;
					var name = _gthis.readCachedName();
					var type = _gthis.i.readByte();
					_g2.push(new hxd_BufferInput(name,type & 15,type >> 4));
				}
				var format = hxd_BufferFormat.make(_g2);
				if(stride != format.stride) {
					throw haxe_Exception.thrown("assert");
				}
				s.vertexFormat = format;
				s.vertexPosition = this.i.readInt32();
				s.indexCount = this.i.readInt32();
				s.remapPosition = this.i.readInt32();
				d.shapes.push(s);
			}
		}
		if(hasCollider) {
			d.colliders = [];
			var colliderLength = this.i.readInt32();
			var _g = 0;
			var _g1 = colliderLength;
			while(_g < _g1) {
				var k = _g++;
				var c = new hxd_fmt_hmd_Collider();
				var n = this.i.readInt32();
				var _g2 = [];
				var _g3 = 0;
				var _g4 = n;
				while(_g3 < _g4) {
					var v = _g3++;
					_g2.push(this.i.readInt32());
				}
				c.vertexCounts = _g2;
				c.vertexPosition = this.i.readInt32();
				var _g5 = [];
				var _g6 = 0;
				var _g7 = n;
				while(_g6 < _g7) {
					var v1 = _g6++;
					_g5.push(this.i.readInt32());
				}
				c.indexCounts = _g5;
				c.indexPosition = this.i.readInt32();
				d.colliders.push(c);
			}
		}
		return d;
	}
	,read: function() {
		var h = this.readHeader();
		h.data = this.i.read(this.i.readInt32());
		return h;
	}
	,__class__: hxd_fmt_hmd_Reader
};
var hxd_fs_FileEntry = function() { };
$hxClasses["hxd.fs.FileEntry"] = hxd_fs_FileEntry;
hxd_fs_FileEntry.__name__ = "hxd.fs.FileEntry";
hxd_fs_FileEntry.prototype = {
	getBytes: function() {
		return null;
	}
	,readBytes: function(out,outPos,pos,len) {
		throw haxe_Exception.thrown("readBytes() not implemented");
	}
	,fetchBytes: function(pos,len) {
		var bytes = hxd_fs_FileEntry.TMP_BYTES;
		if(bytes == null || bytes.length < len) {
			var allocSize = len + 65535 & -65536;
			bytes = new haxe_io_Bytes(new ArrayBuffer(allocSize));
			hxd_fs_FileEntry.TMP_BYTES = bytes;
		}
		this.readFull(bytes,pos,len);
		return bytes;
	}
	,readFull: function(bytes,pos,len) {
		if(this.readBytes(bytes,0,pos,len) < len) {
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
	}
	,getSign: function() {
		var bytes = this.fetchBytes(0,4);
		return bytes.b[0] | bytes.b[1] << 8 | bytes.b[2] << 16 | bytes.b[3] << 24;
	}
	,getText: function() {
		return this.getBytes().toString();
	}
	,open: function() {
		return new hxd_fs_FileInput(this);
	}
	,load: function(onReady) {
		if(!this.get_isAvailable()) {
			throw haxe_Exception.thrown("load() not implemented");
		} else if(onReady != null) {
			onReady();
		}
	}
	,loadBitmap: function(onLoaded) {
		throw haxe_Exception.thrown("loadBitmap() not implemented");
	}
	,watch: function(onChanged) {
	}
	,exists: function(name) {
		return false;
	}
	,get: function(name) {
		return null;
	}
	,iterator: function() {
		return null;
	}
	,get_isAvailable: function() {
		return true;
	}
	,get_isDirectory: function() {
		return false;
	}
	,get_size: function() {
		return 0;
	}
	,get_path: function() {
		throw haxe_Exception.thrown("path() not implemented");
	}
	,get_directory: function() {
		var idx = this.get_path().lastIndexOf("/");
		if(idx < 0) {
			return "";
		}
		return HxOverrides.substr(this.get_path(),0,idx);
	}
	,get_extension: function() {
		var idx = this.name.lastIndexOf(".");
		if(idx < 0) {
			return "";
		}
		return HxOverrides.substr(this.name,idx + 1,null).toLowerCase();
	}
	,__class__: hxd_fs_FileEntry
};
var hxd_fs_BytesFileEntry = function(path,bytes) {
	this.fullPath = path;
	this.name = path.split("/").pop();
	this.bytes = bytes;
};
$hxClasses["hxd.fs.BytesFileEntry"] = hxd_fs_BytesFileEntry;
hxd_fs_BytesFileEntry.__name__ = "hxd.fs.BytesFileEntry";
hxd_fs_BytesFileEntry.__super__ = hxd_fs_FileEntry;
hxd_fs_BytesFileEntry.prototype = $extend(hxd_fs_FileEntry.prototype,{
	get_path: function() {
		return this.fullPath;
	}
	,getBytes: function() {
		return this.bytes;
	}
	,readBytes: function(out,outPos,pos,len) {
		if(pos + len > this.bytes.length) {
			len = this.bytes.length - pos;
		}
		if(len < 0) {
			len = 0;
		}
		out.blit(outPos,this.bytes,pos,len);
		return len;
	}
	,load: function(onReady) {
		haxe_Timer.delay(onReady,1);
	}
	,loadBitmap: function(onLoaded) {
		var mime;
		switch(haxe_io_Path.extension(this.fullPath).toLowerCase()) {
		case "gif":
			mime = "image/gif";
			break;
		case "jpeg":case "jpg":
			mime = "image/jpeg";
			break;
		case "png":
			mime = "image/png";
			break;
		default:
			throw haxe_Exception.thrown("Cannot determine image encoding, try adding an extension to the resource path");
		}
		var img = new Image();
		img.onload = function() {
			onLoaded(img);
		};
		var tmp = haxe_crypto_Base64.encode(this.bytes);
		img.src = "data:" + mime + ";base64," + tmp;
	}
	,exists: function(name) {
		return false;
	}
	,get: function(name) {
		return null;
	}
	,iterator: function() {
		return new hxd_impl_ArrayIterator_$hxd_$fs_$FileEntry([]);
	}
	,get_size: function() {
		return this.bytes.length;
	}
	,__class__: hxd_fs_BytesFileEntry
});
var hxd_fs_FileSystem = function() { };
$hxClasses["hxd.fs.FileSystem"] = hxd_fs_FileSystem;
hxd_fs_FileSystem.__name__ = "hxd.fs.FileSystem";
hxd_fs_FileSystem.__isInterface__ = true;
hxd_fs_FileSystem.prototype = {
	__class__: hxd_fs_FileSystem
};
var hxd_fs_BytesFileSystem = function() {
};
$hxClasses["hxd.fs.BytesFileSystem"] = hxd_fs_BytesFileSystem;
hxd_fs_BytesFileSystem.__name__ = "hxd.fs.BytesFileSystem";
hxd_fs_BytesFileSystem.__interfaces__ = [hxd_fs_FileSystem];
hxd_fs_BytesFileSystem.prototype = {
	getRoot: function() {
		throw haxe_Exception.thrown("Not implemented");
	}
	,getBytes: function(path) {
		throw haxe_Exception.thrown("Not implemented");
	}
	,exists: function(path) {
		return this.getBytes(path) != null;
	}
	,get: function(path) {
		var bytes = this.getBytes(path);
		if(bytes == null) {
			throw haxe_Exception.thrown("Resource not found '" + path + "'");
		}
		return new hxd_fs_BytesFileEntry(path,bytes);
	}
	,dispose: function() {
	}
	,dir: function(path) {
		throw haxe_Exception.thrown("Not implemented");
	}
	,__class__: hxd_fs_BytesFileSystem
};
var hxd_fs__$EmbedFileSystem_EmbedEntry = function(fs,name,relPath,data) {
	this.fs = fs;
	this.name = name;
	this.relPath = relPath;
	this.data = data;
};
$hxClasses["hxd.fs._EmbedFileSystem.EmbedEntry"] = hxd_fs__$EmbedFileSystem_EmbedEntry;
hxd_fs__$EmbedFileSystem_EmbedEntry.__name__ = "hxd.fs._EmbedFileSystem.EmbedEntry";
hxd_fs__$EmbedFileSystem_EmbedEntry.__super__ = hxd_fs_FileEntry;
hxd_fs__$EmbedFileSystem_EmbedEntry.prototype = $extend(hxd_fs_FileEntry.prototype,{
	init: function() {
		if(this.bytes == null) {
			this.bytes = haxe_Resource.getBytes(this.data);
			if(this.bytes == null) {
				throw haxe_Exception.thrown("Missing resource " + this.data);
			}
		}
	}
	,getBytes: function() {
		if(this.bytes == null) {
			this.init();
		}
		return this.bytes;
	}
	,readBytes: function(out,outPos,pos,len) {
		if(this.bytes == null) {
			this.init();
		}
		if(pos + len > this.bytes.length) {
			len = this.bytes.length - pos;
		}
		if(len < 0) {
			len = 0;
		}
		out.blit(outPos,this.bytes,pos,len);
		return len;
	}
	,load: function(onReady) {
		if(onReady != null) {
			haxe_Timer.delay(onReady,1);
		}
	}
	,loadBitmap: function(onLoaded) {
		var rawData = null;
		var _g = 0;
		var _g1 = haxe_Resource.content;
		while(_g < _g1.length) {
			var res = _g1[_g];
			++_g;
			if(res.name == this.data) {
				rawData = res.data;
				break;
			}
		}
		if(rawData == null) {
			throw haxe_Exception.thrown("Missing resource " + this.data);
		}
		var image = new Image();
		image.onload = function(_) {
			onLoaded(image);
		};
		var extra = "";
		var bytes = rawData.length * 6 >> 3;
		var _g = 0;
		var _g1 = (3 - bytes * 4 % 3) % 3;
		while(_g < _g1) {
			var i = _g++;
			extra += "=";
		}
		var tmp = "data:image/" + this.get_extension() + ";base64," + rawData;
		image.src = tmp + extra;
	}
	,get_isDirectory: function() {
		return this.fs.isDirectory(this.relPath);
	}
	,get_path: function() {
		if(this.relPath == ".") {
			return "<root>";
		} else {
			return this.relPath;
		}
	}
	,exists: function(name) {
		return this.fs.exists(this.relPath == "." ? name : this.relPath + "/" + name);
	}
	,get: function(name) {
		return this.fs.get(this.relPath == "." ? name : this.relPath + "/" + name);
	}
	,get_size: function() {
		this.init();
		return this.bytes.length;
	}
	,iterator: function() {
		return new hxd_impl_ArrayIterator_$hxd_$fs_$FileEntry(this.fs.subFiles(this.relPath));
	}
	,__class__: hxd_fs__$EmbedFileSystem_EmbedEntry
});
var hxd_fs_EmbedFileSystem = function(root) {
	this.root = root;
};
$hxClasses["hxd.fs.EmbedFileSystem"] = hxd_fs_EmbedFileSystem;
hxd_fs_EmbedFileSystem.__name__ = "hxd.fs.EmbedFileSystem";
hxd_fs_EmbedFileSystem.__interfaces__ = [hxd_fs_FileSystem];
hxd_fs_EmbedFileSystem.resolve = function(path) {
	return "R_" + path.replace(hxd_fs_EmbedFileSystem.invalidChars.r,"_");
};
hxd_fs_EmbedFileSystem.prototype = {
	getRoot: function() {
		return new hxd_fs__$EmbedFileSystem_EmbedEntry(this,"root",".",null);
	}
	,splitPath: function(path) {
		if(path == ".") {
			return [];
		} else {
			return path.split("/");
		}
	}
	,subFiles: function(path) {
		var r = this.root;
		var _g = 0;
		var _g1 = this.splitPath(path);
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			r = Reflect.field(r,p);
		}
		if(r == null) {
			throw haxe_Exception.thrown(path + " is not a directory");
		}
		var fields = Reflect.fields(r);
		fields.sort(Reflect.compare);
		var _g = [];
		var _g1 = 0;
		while(_g1 < fields.length) {
			var name = fields[_g1];
			++_g1;
			_g.push(this.get(path == "." ? name : path + "/" + name));
		}
		return _g;
	}
	,isDirectory: function(path) {
		var r = this.root;
		var _g = 0;
		var _g1 = this.splitPath(path);
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			r = Reflect.field(r,p);
		}
		if(r != null) {
			return r != true;
		} else {
			return false;
		}
	}
	,exists: function(path) {
		var r = this.root;
		var _g = 0;
		var _g1 = this.splitPath(path);
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			r = Reflect.field(r,p);
			if(r == null) {
				return false;
			}
		}
		return true;
	}
	,get: function(path) {
		if(!this.exists(path)) {
			throw haxe_Exception.thrown(new hxd_fs_NotFound(path));
		}
		var id = hxd_fs_EmbedFileSystem.resolve(path);
		return new hxd_fs__$EmbedFileSystem_EmbedEntry(this,path.split("/").pop(),path,id);
	}
	,dispose: function() {
	}
	,dir: function(path) {
		return this.subFiles(path);
	}
	,__class__: hxd_fs_EmbedFileSystem
};
var hxd_fs_FileInput = function(entry) {
	this.nextReadPos = 0;
	this.cacheLen = 0;
	this.cachePos = 0;
	this.entry = entry;
};
$hxClasses["hxd.fs.FileInput"] = hxd_fs_FileInput;
hxd_fs_FileInput.__name__ = "hxd.fs.FileInput";
hxd_fs_FileInput.__super__ = haxe_io_Input;
hxd_fs_FileInput.prototype = $extend(haxe_io_Input.prototype,{
	fetch: function(dataSize) {
		if(dataSize == null) {
			dataSize = 256;
		}
		var prev = this.cache;
		if(this.cache == null || this.cache.length < dataSize) {
			this.cache = hxd_fs_FileInput.PREFETCH_CACHE;
			if(this.cache != null && this.cache.length >= dataSize) {
				hxd_fs_FileInput.PREFETCH_CACHE = null;
			} else {
				this.cache = new haxe_io_Bytes(new ArrayBuffer(dataSize));
			}
		}
		var startPos = 0;
		if(this.cacheLen > 0) {
			startPos = this.cacheLen;
			dataSize -= this.cacheLen;
			this.cache.blit(0,prev,this.cachePos,this.cacheLen);
		}
		var read = this.entry.readBytes(this.cache,startPos,this.nextReadPos,dataSize);
		this.cachePos = 0;
		this.cacheLen = startPos + read;
		this.nextReadPos += read;
		if(this.cacheLen == 0) {
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
	}
	,skip: function(nbytes) {
		if(this.cacheLen > 0) {
			var a = this.cacheLen;
			var k = a > nbytes ? nbytes : a;
			this.cachePos += k;
			this.cacheLen -= k;
			nbytes -= k;
		}
		this.nextReadPos += nbytes;
	}
	,readByte: function() {
		if(this.cacheLen == 0) {
			this.fetch();
		}
		var b = this.cache.b[this.cachePos++];
		this.cacheLen--;
		return b;
	}
	,readBytes: function(b,pos,len) {
		var tot = 0;
		if(len < 256 && this.cacheLen < len) {
			this.fetch();
		}
		if(this.cacheLen > 0) {
			var b1 = this.cacheLen;
			var k = len > b1 ? b1 : len;
			b.blit(pos,this.cache,this.cachePos,k);
			this.cachePos += k;
			this.cacheLen -= k;
			len -= k;
			if(len == 0) {
				return k;
			}
			pos += k;
			tot += k;
		}
		if(len > 0) {
			var k = this.entry.readBytes(b,pos,this.nextReadPos,len);
			this.nextReadPos += k;
			tot += k;
		}
		return tot;
	}
	,close: function() {
		if(this.cache != null && (hxd_fs_FileInput.PREFETCH_CACHE == null || hxd_fs_FileInput.PREFETCH_CACHE.length < this.cache.length)) {
			hxd_fs_FileInput.PREFETCH_CACHE = this.cache;
		}
		this.cache = null;
		this.cacheLen = 0;
	}
	,__class__: hxd_fs_FileInput
});
var hxd_fs_LoadedBitmap = {};
hxd_fs_LoadedBitmap._new = function(data) {
	return data;
};
hxd_fs_LoadedBitmap.toBitmap = function(this1) {
	var bmp = new hxd_BitmapData(this1.width,this1.height);
	bmp.ctx.drawImage(this1,0,0);
	return bmp;
};
hxd_fs_LoadedBitmap.toNative = function(this1) {
	return this1;
};
var hxd_fs_LocalFileSystem = function(dir) {
	throw haxe_Exception.thrown("Local file system is not supported for this platform");
};
$hxClasses["hxd.fs.LocalFileSystem"] = hxd_fs_LocalFileSystem;
hxd_fs_LocalFileSystem.__name__ = "hxd.fs.LocalFileSystem";
hxd_fs_LocalFileSystem.__interfaces__ = [hxd_fs_FileSystem];
hxd_fs_LocalFileSystem.prototype = {
	exists: function(path) {
		return false;
	}
	,get: function(path) {
		return null;
	}
	,getRoot: function() {
		return null;
	}
	,dispose: function() {
	}
	,dir: function(path) {
		return null;
	}
	,__class__: hxd_fs_LocalFileSystem
};
var hxd_fs_NotFound = function(path) {
	this.path = path;
};
$hxClasses["hxd.fs.NotFound"] = hxd_fs_NotFound;
hxd_fs_NotFound.__name__ = "hxd.fs.NotFound";
hxd_fs_NotFound.prototype = {
	toString: function() {
		return "Resource file not found '" + this.path + "'";
	}
	,__class__: hxd_fs_NotFound
};
var hxd_fs_SourceLoader = function() { };
$hxClasses["hxd.fs.SourceLoader"] = hxd_fs_SourceLoader;
hxd_fs_SourceLoader.__name__ = "hxd.fs.SourceLoader";
hxd_fs_SourceLoader.isActive = function() {
	return hxd_fs_SourceLoader.RELOAD_LFS.length > 0;
};
hxd_fs_SourceLoader.resolve = function(path) {
	var _g = 0;
	var _g1 = hxd_fs_SourceLoader.RELOAD_LFS;
	while(_g < _g1.length) {
		var fs = _g1[_g];
		++_g;
		try {
			return fs.get(path);
		} catch( _g2 ) {
			if(!((haxe_Exception.caught(_g2).unwrap()) instanceof hxd_fs_NotFound)) {
				throw _g2;
			}
		}
	}
	return null;
};
var hxd_impl_AllocPos = function() {
	this.stack = [];
	var curStack = haxe_CallStack.callStack();
	curStack.shift();
	var _g = 0;
	while(_g < curStack.length) {
		var s = curStack[_g];
		++_g;
		switch(s._hx_index) {
		case 0:
			break;
		case 1:
			var _g1 = s.m;
			break;
		case 2:
			var _g2 = s.s;
			var _g3 = s.column;
			var file = s.file;
			var line = s.line;
			var idx = file.indexOf("\\std/");
			if(idx > 0) {
				file = HxOverrides.substr(file,idx + 5,null);
			}
			var pos = file + ":" + line;
			this.stack.push(pos);
			if(this.position == null) {
				var p = file.indexOf("/");
				var pack = p < 0 ? "" : HxOverrides.substr(file,0,p);
				if(hxd_impl_AllocPos.ENGINE_PACKAGES.indexOf(pack) < 0) {
					this.position = pos;
				}
			}
			break;
		case 3:
			var cl = s.classname;
			var meth = s.method;
			break;
		case 4:
			var _g4 = s.v;
			break;
		}
	}
	if(this.position == null) {
		this.position = this.stack[0];
	}
};
$hxClasses["hxd.impl.AllocPos"] = hxd_impl_AllocPos;
hxd_impl_AllocPos.__name__ = "hxd.impl.AllocPos";
hxd_impl_AllocPos.make = function() {
	if(!hxd_impl_AllocPos.ENABLED) {
		return null;
	}
	return new hxd_impl_AllocPos();
};
hxd_impl_AllocPos.prototype = {
	__class__: hxd_impl_AllocPos
};
var hxd_impl_BufferFlags = {};
hxd_impl_BufferFlags.toInt = function(this1) {
	return this1;
};
var hxd_impl_Allocator = function() {
};
$hxClasses["hxd.impl.Allocator"] = hxd_impl_Allocator;
hxd_impl_Allocator.__name__ = "hxd.impl.Allocator";
hxd_impl_Allocator.set = function(a) {
	hxd_impl_Allocator.inst = a;
};
hxd_impl_Allocator.get = function() {
	if(hxd_impl_Allocator.inst == null) {
		hxd_impl_Allocator.inst = new hxd_impl_Allocator();
	}
	return hxd_impl_Allocator.inst;
};
hxd_impl_Allocator.prototype = {
	toBufferFlags: function(flags) {
		switch(flags) {
		case 0:
			return [h3d_BufferFlag.Dynamic];
		case 1:
			return null;
		case 2:
			return [h3d_BufferFlag.UniformBuffer,h3d_BufferFlag.Dynamic];
		case 3:
			return [h3d_BufferFlag.UniformBuffer,h3d_BufferFlag.ReadWriteBuffer];
		case 4:
			return [h3d_BufferFlag.UniformBuffer];
		}
	}
	,fromBufferFlags: function(flags) {
		if(flags == 0) {
			return 1;
		}
		if(flags == haxe_EnumFlags.from(h3d_BufferFlag.Dynamic)) {
			return 0;
		}
		var i = 1 << h3d_BufferFlag.UniformBuffer._hx_index | 1 << h3d_BufferFlag.Dynamic._hx_index;
		if(i == null) {
			i = 0;
		}
		if(flags == i) {
			return 2;
		}
		var i = 1 << h3d_BufferFlag.UniformBuffer._hx_index | 1 << h3d_BufferFlag.ReadWriteBuffer._hx_index;
		if(i == null) {
			i = 0;
		}
		if(flags == i) {
			return 3;
		}
		if(flags == haxe_EnumFlags.from(h3d_BufferFlag.UniformBuffer)) {
			return 4;
		}
		return 0;
	}
	,allocBuffer: function(vertices,format,flags) {
		if(flags == null) {
			flags = 0;
		}
		return new h3d_Buffer(vertices,format,this.toBufferFlags(flags));
	}
	,ofFloats: function(v,format,flags) {
		if(flags == null) {
			flags = 0;
		}
		var nvert = Math.ceil(v.pos / format.stride);
		return this.ofSubFloats(v,nvert,format,flags);
	}
	,ofSubFloats: function(v,vertices,format,flags) {
		if(flags == null) {
			flags = 0;
		}
		var b = this.allocBuffer(vertices,format,flags);
		b.uploadFloats(v,0,vertices);
		return b;
	}
	,disposeBuffer: function(b) {
		b.dispose();
	}
	,allocIndexBuffer: function(count) {
		return h3d_Indexes._new(count);
	}
	,ofIndexes: function(ib,length) {
		if(length == null) {
			length = -1;
		}
		if(length < 0 && ib != null) {
			length = ib.length;
		}
		var idx = this.allocIndexBuffer(length);
		h3d_Indexes.uploadIndexes(idx,ib,0,length);
		return idx;
	}
	,disposeIndexBuffer: function(i) {
		i.dispose();
	}
	,onContextLost: function() {
	}
	,allocFloats: function(count) {
		var length = count;
		if(length == null) {
			length = 0;
		}
		return hxd__$FloatBuffer_Float32Expand._new(length);
	}
	,disposeFloats: function(f) {
	}
	,allocIndexes: function(count) {
		var length = count;
		if(length == null) {
			length = 0;
		}
		return new Array(length);
	}
	,disposeIndexes: function(i) {
	}
	,__class__: hxd_impl_Allocator
};
var hxd_impl_ArrayIterator = function(a) {
	this.i = 0;
	this.a = a;
	this.l = this.a.length;
};
$hxClasses["hxd.impl.ArrayIterator"] = hxd_impl_ArrayIterator;
hxd_impl_ArrayIterator.__name__ = "hxd.impl.ArrayIterator";
hxd_impl_ArrayIterator.prototype = {
	hasNext: function() {
		return this.i < this.l;
	}
	,next: function() {
		return this.a[this.i++];
	}
	,__class__: hxd_impl_ArrayIterator
};
var hxd_impl_ArrayIterator_$h2d_$Object = function(a) {
	this.i = 0;
	this.a = a;
	this.l = this.a.length;
};
$hxClasses["hxd.impl.ArrayIterator_h2d_Object"] = hxd_impl_ArrayIterator_$h2d_$Object;
hxd_impl_ArrayIterator_$h2d_$Object.__name__ = "hxd.impl.ArrayIterator_h2d_Object";
hxd_impl_ArrayIterator_$h2d_$Object.prototype = {
	hasNext: function() {
		return this.i < this.l;
	}
	,next: function() {
		return this.a[this.i++];
	}
	,__class__: hxd_impl_ArrayIterator_$h2d_$Object
};
var hxd_impl_ArrayIterator_$h2d_$col_$IPoint = function(a) {
	this.i = 0;
	this.a = a;
	this.l = this.a.length;
};
$hxClasses["hxd.impl.ArrayIterator_h2d_col_IPoint"] = hxd_impl_ArrayIterator_$h2d_$col_$IPoint;
hxd_impl_ArrayIterator_$h2d_$col_$IPoint.__name__ = "hxd.impl.ArrayIterator_h2d_col_IPoint";
hxd_impl_ArrayIterator_$h2d_$col_$IPoint.prototype = {
	hasNext: function() {
		return this.i < this.l;
	}
	,next: function() {
		return this.a[this.i++];
	}
	,__class__: hxd_impl_ArrayIterator_$h2d_$col_$IPoint
};
var hxd_impl_ArrayIterator_$h2d_$col_$IPolygon = function(a) {
	this.i = 0;
	this.a = a;
	this.l = this.a.length;
};
$hxClasses["hxd.impl.ArrayIterator_h2d_col_IPolygon"] = hxd_impl_ArrayIterator_$h2d_$col_$IPolygon;
hxd_impl_ArrayIterator_$h2d_$col_$IPolygon.__name__ = "hxd.impl.ArrayIterator_h2d_col_IPolygon";
hxd_impl_ArrayIterator_$h2d_$col_$IPolygon.prototype = {
	hasNext: function() {
		return this.i < this.l;
	}
	,next: function() {
		return this.a[this.i++];
	}
	,__class__: hxd_impl_ArrayIterator_$h2d_$col_$IPolygon
};
var hxd_impl_ArrayIterator_$h2d_$col_$Point = function(a) {
	this.i = 0;
	this.a = a;
	this.l = this.a.length;
};
$hxClasses["hxd.impl.ArrayIterator_h2d_col_Point"] = hxd_impl_ArrayIterator_$h2d_$col_$Point;
hxd_impl_ArrayIterator_$h2d_$col_$Point.__name__ = "hxd.impl.ArrayIterator_h2d_col_Point";
hxd_impl_ArrayIterator_$h2d_$col_$Point.prototype = {
	hasNext: function() {
		return this.i < this.l;
	}
	,next: function() {
		return this.a[this.i++];
	}
	,__class__: hxd_impl_ArrayIterator_$h2d_$col_$Point
};
var hxd_impl_ArrayIterator_$h2d_$col_$Polygon = function(a) {
	this.i = 0;
	this.a = a;
	this.l = this.a.length;
};
$hxClasses["hxd.impl.ArrayIterator_h2d_col_Polygon"] = hxd_impl_ArrayIterator_$h2d_$col_$Polygon;
hxd_impl_ArrayIterator_$h2d_$col_$Polygon.__name__ = "hxd.impl.ArrayIterator_h2d_col_Polygon";
hxd_impl_ArrayIterator_$h2d_$col_$Polygon.prototype = {
	hasNext: function() {
		return this.i < this.l;
	}
	,next: function() {
		return this.a[this.i++];
	}
	,__class__: hxd_impl_ArrayIterator_$h2d_$col_$Polygon
};
var hxd_impl_ArrayIterator_$h2d_$col_$Segment = function(a) {
	this.i = 0;
	this.a = a;
	this.l = this.a.length;
};
$hxClasses["hxd.impl.ArrayIterator_h2d_col_Segment"] = hxd_impl_ArrayIterator_$h2d_$col_$Segment;
hxd_impl_ArrayIterator_$h2d_$col_$Segment.__name__ = "hxd.impl.ArrayIterator_h2d_col_Segment";
hxd_impl_ArrayIterator_$h2d_$col_$Segment.prototype = {
	hasNext: function() {
		return this.i < this.l;
	}
	,next: function() {
		return this.a[this.i++];
	}
	,__class__: hxd_impl_ArrayIterator_$h2d_$col_$Segment
};
var hxd_impl_ArrayIterator_$h3d_$scene_$Object = function(a) {
	this.i = 0;
	this.a = a;
	this.l = this.a.length;
};
$hxClasses["hxd.impl.ArrayIterator_h3d_scene_Object"] = hxd_impl_ArrayIterator_$h3d_$scene_$Object;
hxd_impl_ArrayIterator_$h3d_$scene_$Object.__name__ = "hxd.impl.ArrayIterator_h3d_scene_Object";
hxd_impl_ArrayIterator_$h3d_$scene_$Object.prototype = {
	hasNext: function() {
		return this.i < this.l;
	}
	,next: function() {
		return this.a[this.i++];
	}
	,__class__: hxd_impl_ArrayIterator_$h3d_$scene_$Object
};
var hxd_impl_ArrayIterator_$hxd_$fs_$FileEntry = function(a) {
	this.i = 0;
	this.a = a;
	this.l = this.a.length;
};
$hxClasses["hxd.impl.ArrayIterator_hxd_fs_FileEntry"] = hxd_impl_ArrayIterator_$hxd_$fs_$FileEntry;
hxd_impl_ArrayIterator_$hxd_$fs_$FileEntry.__name__ = "hxd.impl.ArrayIterator_hxd_fs_FileEntry";
hxd_impl_ArrayIterator_$hxd_$fs_$FileEntry.prototype = {
	hasNext: function() {
		return this.i < this.l;
	}
	,next: function() {
		return this.a[this.i++];
	}
	,__class__: hxd_impl_ArrayIterator_$hxd_$fs_$FileEntry
};
var hxd_impl_ArrayIterator_$hxd_$res_$Any = function(a) {
	this.i = 0;
	this.a = a;
	this.l = this.a.length;
};
$hxClasses["hxd.impl.ArrayIterator_hxd_res_Any"] = hxd_impl_ArrayIterator_$hxd_$res_$Any;
hxd_impl_ArrayIterator_$hxd_$res_$Any.__name__ = "hxd.impl.ArrayIterator_hxd_res_Any";
hxd_impl_ArrayIterator_$hxd_$res_$Any.prototype = {
	hasNext: function() {
		return this.i < this.l;
	}
	,next: function() {
		return this.a[this.i++];
	}
	,__class__: hxd_impl_ArrayIterator_$hxd_$res_$Any
};
var hxd_impl_ArrayIterator_$hxd_$snd_$Channel = function(a) {
	this.i = 0;
	this.a = a;
	this.l = this.a.length;
};
$hxClasses["hxd.impl.ArrayIterator_hxd_snd_Channel"] = hxd_impl_ArrayIterator_$hxd_$snd_$Channel;
hxd_impl_ArrayIterator_$hxd_$snd_$Channel.__name__ = "hxd.impl.ArrayIterator_hxd_snd_Channel";
hxd_impl_ArrayIterator_$hxd_$snd_$Channel.prototype = {
	hasNext: function() {
		return this.i < this.l;
	}
	,next: function() {
		return this.a[this.i++];
	}
	,__class__: hxd_impl_ArrayIterator_$hxd_$snd_$Channel
};
var hxd_impl_AsyncLoader = function() { };
$hxClasses["hxd.impl.AsyncLoader"] = hxd_impl_AsyncLoader;
hxd_impl_AsyncLoader.__name__ = "hxd.impl.AsyncLoader";
hxd_impl_AsyncLoader.__isInterface__ = true;
hxd_impl_AsyncLoader.prototype = {
	__class__: hxd_impl_AsyncLoader
};
var hxd_impl_BitSet = {};
hxd_impl_BitSet._new = function(count) {
	return new haxe_io_Bytes(new ArrayBuffer(count + 7 >> 3));
};
hxd_impl_BitSet.get = function(this1,index) {
	return (this1.b[index >> 3] & 1 << (index & 7)) != 0;
};
hxd_impl_BitSet.set = function(this1,index) {
	var p = index >> 3;
	this1.b[p] |= 1 << (index & 7);
};
hxd_impl_BitSet.unset = function(this1,index) {
	var p = index >> 3;
	this1.b[p] &= ~(1 << (index & 7));
};
hxd_impl_BitSet.toggle = function(this1,index,b) {
	var p = index >> 3;
	var v = this1.b[p];
	var mask = 1 << (index & 7);
	this1.b[p] = b ? v | mask : v & ~mask;
};
hxd_impl_BitSet.clear = function(this1,b) {
	if(b == null) {
		b = false;
	}
	this1.fill(0,this1.length,b ? 255 : 0);
};
var hxd_impl_MouseMode = $hxEnums["hxd.impl.MouseMode"] = { __ename__:true,__constructs__:null
	,Absolute: {_hx_name:"Absolute",_hx_index:0,__enum__:"hxd.impl.MouseMode",toString:$estr}
	,Relative: ($_=function(callback,restorePos) { return {_hx_index:1,callback:callback,restorePos:restorePos,__enum__:"hxd.impl.MouseMode",toString:$estr}; },$_._hx_name="Relative",$_.__params__ = ["callback","restorePos"],$_)
	,AbsoluteUnbound: ($_=function(restorePos) { return {_hx_index:2,restorePos:restorePos,__enum__:"hxd.impl.MouseMode",toString:$estr}; },$_._hx_name="AbsoluteUnbound",$_.__params__ = ["restorePos"],$_)
};
hxd_impl_MouseMode.__constructs__ = [hxd_impl_MouseMode.Absolute,hxd_impl_MouseMode.Relative,hxd_impl_MouseMode.AbsoluteUnbound];
hxd_impl_MouseMode.__empty_constructs__ = [hxd_impl_MouseMode.Absolute];
var hxd_impl_UncheckedBytes = {};
hxd_impl_UncheckedBytes._new = function(v) {
	return v;
};
hxd_impl_UncheckedBytes.get = function(this1,i) {
	return this1[i];
};
hxd_impl_UncheckedBytes.set = function(this1,i,v) {
	this1[i] = v;
	return v;
};
hxd_impl_UncheckedBytes.fromBytes = function(b) {
	return b.b;
};
var hxd_poly2tri_Edge = function(p1,p2) {
	if(p1 == null || p2 == null) {
		throw haxe_Exception.thrown("Edge::new p1 or p2 is null");
	}
	var swap = false;
	if(p1.y > p2.y) {
		swap = true;
	} else if(p1.y == p2.y) {
		if(p1.x == p2.x) {
			throw haxe_Exception.thrown("Edge::repeat points " + Std.string(p1));
		}
		swap = p1.x > p2.x;
	}
	if(swap) {
		this.q = p1;
		this.p = p2;
	} else {
		this.p = p1;
		this.q = p2;
	}
	this.q.get_edge_list().push(this);
};
$hxClasses["hxd.poly2tri.Edge"] = hxd_poly2tri_Edge;
hxd_poly2tri_Edge.__name__ = "hxd.poly2tri.Edge";
hxd_poly2tri_Edge.prototype = {
	toString: function() {
		return "Edge(" + Std.string(this.p) + ", " + Std.string(this.q) + ")";
	}
	,__class__: hxd_poly2tri_Edge
};
var hxd_poly2tri_Point = function(x,y) {
	this.x = x;
	this.y = y;
	this.id = hxd_poly2tri_Point.C_ID;
	hxd_poly2tri_Point.C_ID++;
};
$hxClasses["hxd.poly2tri.Point"] = hxd_poly2tri_Point;
hxd_poly2tri_Point.__name__ = "hxd.poly2tri.Point";
hxd_poly2tri_Point.sortPoints = function(points) {
	points.sort(hxd_poly2tri_Point.cmpPoints);
};
hxd_poly2tri_Point.cmpPoints = function(l,r) {
	var ret = l.y - r.y;
	if(ret == 0) {
		ret = l.x - r.x;
	}
	if(ret < 0) {
		return -1;
	}
	if(ret > 0) {
		return 1;
	}
	return 0;
};
hxd_poly2tri_Point.prototype = {
	get_edge_list: function() {
		if(this.edge_list == null) {
			this.edge_list = [];
		}
		return this.edge_list;
	}
	,equals: function(that) {
		if(this.x == that.x) {
			return this.y == that.y;
		} else {
			return false;
		}
	}
	,toString: function() {
		return "Point(" + this.x + ", " + this.y + ")";
	}
	,__class__: hxd_poly2tri_Point
};
var hxd_res__$Any_SingleFileSystem = function(path,bytes) {
	hxd_fs_BytesFileSystem.call(this);
	this.path = path;
	this.bytes = bytes;
};
$hxClasses["hxd.res._Any.SingleFileSystem"] = hxd_res__$Any_SingleFileSystem;
hxd_res__$Any_SingleFileSystem.__name__ = "hxd.res._Any.SingleFileSystem";
hxd_res__$Any_SingleFileSystem.__super__ = hxd_fs_BytesFileSystem;
hxd_res__$Any_SingleFileSystem.prototype = $extend(hxd_fs_BytesFileSystem.prototype,{
	getBytes: function(p) {
		if(p == this.path) {
			return this.bytes;
		} else {
			return null;
		}
	}
	,__class__: hxd_res__$Any_SingleFileSystem
});
var hxd_res_Resource = function(entry) {
	this.entry = entry;
};
$hxClasses["hxd.res.Resource"] = hxd_res_Resource;
hxd_res_Resource.__name__ = "hxd.res.Resource";
hxd_res_Resource.prototype = {
	get_name: function() {
		return this.entry.name;
	}
	,toString: function() {
		return this.entry.get_path();
	}
	,watch: function(onChanged) {
		if(hxd_res_Resource.LIVE_UPDATE) {
			this.entry.watch(onChanged);
		}
	}
	,__class__: hxd_res_Resource
};
var hxd_res_Any = function(loader,entry) {
	hxd_res_Resource.call(this,entry);
	this.loader = loader;
};
$hxClasses["hxd.res.Any"] = hxd_res_Any;
hxd_res_Any.__name__ = "hxd.res.Any";
hxd_res_Any.fromBytes = function(path,bytes) {
	var fs = new hxd_res__$Any_SingleFileSystem(path,bytes);
	return new hxd_res_Loader(fs).load(path);
};
hxd_res_Any.__super__ = hxd_res_Resource;
hxd_res_Any.prototype = $extend(hxd_res_Resource.prototype,{
	toModel: function() {
		return this.loader.loadCache(this.entry.get_path(),hxd_res_Model);
	}
	,toTexture: function() {
		return this.toImage().toTexture();
	}
	,toTile: function() {
		return this.toImage().toTile();
	}
	,toText: function() {
		return this.entry.getText();
	}
	,toImage: function() {
		return this.loader.loadCache(this.entry.get_path(),hxd_res_Image);
	}
	,toSound: function() {
		return this.loader.loadCache(this.entry.get_path(),hxd_res_Sound);
	}
	,toPrefab: function() {
		return this.loader.loadCache(this.entry.get_path(),hxd_res_Resource);
	}
	,toAnimGraph: function() {
		return this.loader.loadCache(this.entry.get_path(),hxd_res_Resource);
	}
	,to: function(c) {
		return this.loader.loadCache(this.entry.get_path(),c);
	}
	,iterator: function() {
		var _g = [];
		var _g1 = this.entry.iterator();
		while(_g1.i < _g1.l) {
			var f = _g1.a[_g1.i++];
			_g.push(new hxd_res_Any(this.loader,f));
		}
		return new hxd_impl_ArrayIterator_$hxd_$res_$Any(_g);
	}
	,__class__: hxd_res_Any
});
var hxd_res_BitmapFont = function(entry) {
	hxd_res_Resource.call(this,entry);
	this.loader = hxd_res_Loader.currentInstance;
};
$hxClasses["hxd.res.BitmapFont"] = hxd_res_BitmapFont;
hxd_res_BitmapFont.__name__ = "hxd.res.BitmapFont";
hxd_res_BitmapFont.__super__ = hxd_res_Resource;
hxd_res_BitmapFont.prototype = $extend(hxd_res_Resource.prototype,{
	toFont: function() {
		if(this.font == null) {
			this.font = hxd_fmt_bfnt_FontParser.parse(this.entry.getBytes(),this.entry.get_path(),$bind(this,this.resolveTile));
		}
		return this.font;
	}
	,toSdfFont: function(size,channel,alphaCutoff,smoothing) {
		if(smoothing == null) {
			smoothing = -1;
		}
		if(alphaCutoff == null) {
			alphaCutoff = 0.5;
		}
		if(channel == null) {
			channel = 0;
		}
		if(this.sdfFonts == null) {
			this.sdfFonts = [];
		}
		if(size == null) {
			size = this.toFont().size;
		}
		var _g = 0;
		var _g1 = this.sdfFonts;
		while(_g < _g1.length) {
			var font = _g1[_g];
			++_g;
			var _g2 = font.type;
			if(_g2._hx_index == 1) {
				var fchannel = _g2.channel;
				var falphaCutoff = _g2.alphaCutoff;
				var fsmoothing = _g2.smoothing;
				if(font.size == size && fchannel == channel && falphaCutoff == alphaCutoff && fsmoothing == smoothing) {
					return font;
				}
			}
		}
		var font = hxd_fmt_bfnt_FontParser.parse(this.entry.getBytes(),this.entry.get_path(),$bind(this,this.resolveSdfTile));
		font.type = h2d_FontType.SignedDistanceField(channel,alphaCutoff,smoothing);
		font.resizeTo(size);
		this.sdfFonts.push(font);
		return font;
	}
	,resolveSdfTile: function(path) {
		var tex = this.loader.load(path).toTexture();
		tex.set_filter(h3d_mat_Filter.Linear);
		return h2d_Tile.fromTexture(tex);
	}
	,resolveTile: function(path) {
		return this.loader.load(path).toTile();
	}
	,__class__: hxd_res_BitmapFont
});
var hxd_res_DefaultFont = function() { };
$hxClasses["hxd.res.DefaultFont"] = hxd_res_DefaultFont;
hxd_res_DefaultFont.__name__ = "hxd.res.DefaultFont";
hxd_res_DefaultFont.get = function() {
	var engine = h3d_Engine.CURRENT;
	var fnt = engine.resCache.h[hxd_res_DefaultFont.__id__];
	if(fnt == null) {
		var BYTES = hxd_res_Any.fromBytes("hxd/res/defaultFont.png",haxe_Unserializer.run("s3176:iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAOxAAADsQBlSsOGwAACPBJREFUeJztnelypDoMRp2p%:6v3PNjhrlCLX1aLIPBPlWppI03bCG0QOfn8:m0zbr8KupnS9FDqRKAzUOhAvBRfqO:tfrSZ86H:ET79o6Rhc%JzzNSD7Xn:XyEH9RPtP4X:6GDDj6ttR:Hb62d9pmX8b487StA4:DFlup5z5MSWS%tL:f6eG4BXDppGQdtApJEtPm0zkf427Oo1fAxtfO2hDIruGXCLgnAD:jNyzSsKxa18yBphyqQ1jqwBN1zHmgcU3V3jHui9xaArkS0%XzTohOX%jvGauzvjMrlUJXuqSeV07G0ekgTovWS1t61vr0CQAez7nkj7uFIELJqmdN7RWvzil7hnnXV5qLOzSMAmlcQub9ZRuEsaNoq0w5RZbN0rye1ASzplWyAiGEXQVK3kZOdRcgy9:FLoRogI02WNc7rRQw3jzsZAfWB7skR44%3jdo6Wv2qfr4rFuUCZlftrT1jjpezSih4b75ClQDMvrizz%82uA1wMCqsKvUv3YO045rxma2vjY3mpPUvuV1WKDzbLtqfNu9:AjA6tl69QM3Zn1Wfl1M8G:CUW4s6b%sWIEXWtM:omNeXrnaDRm:OyIsE1UOfQ1gCwMOLdFCqWnj8Grl5nsjVakRjHMj1DgnEcQvw%OV0AE0wGisfqTKrbBYrZ4BiB:T4ldE8dPsMxU2oEWgZZtoAyMCq2GxtLlWCFbEB%PGIYWv1kxECq0%TbDKITjpirVr9SW2zC:skqqKdUp%QwwbILKwlgZk2mkBlmUVgPPOI3IbL0GwASY2PiMdbPrfVF6:vVctIq5SoVqNdxtrvWXt1:EguYHVL:ZV4Q8F781%KVwD25r8UagTyYE4TjkllmfrU4udtI%XZdrRcm5c1T%3cPXjq9RqEYTewIrau1a%ODVSBomgeL4cLudedG%H2pah4KBQx8gSnWMC:8AvDKwS0fXU5n59Uf7gAXA1dfG1TtM1Bm2ZtKi%PCGaVlpXKrf67ngeI%uFXoW1WdvNH0ztuV3vNBvAOrC30wR0LG7kX0:p3MjoCqPYfiQNI3BK%BEhq31vfYtS5UkN5lCD%NGWMSBxAWyyeyKkAJYc2Z6JrfqpvGYF0IzxqNWoDoPrSeNJ8POMgtJg76rtSEyDNErGzUF5F3ZOq9wI2D%VtbuBsaFfkNGwBGMtUmy3BjUAtxs3x3LOk8mi7zWB6Xw7leCNlb%LRXkrk%wEOpESIlezxlvM%uSWuzQXNx1Ofjqd5Aah:qW5PGDfbjpZzRCGlbwZ5T0TqMHMVoLgCP56Nj0fqo7mhLOeMGoDPx4wE0sW64mRmXLSDaCZvxPjSeNnAGKx:hxcw8%a3Zkc7tTqjyWgbs:4d3w8wW:7AC42l3zF:dH9H9SGedwO9rmEEz4nMpCXuznFoSS5tf9x9e24ByFjqodKAQio6EjfP9C8duzLHoZ0r8oD%LzRyAZY1XN2umux8n0L3OkeygcdnDzMYTSvQvc47G7g4q3xL2EqE8jhbAN6H9YDJ6TaxBeCduJNy3AjkrghySay8QXOU84lZSQ8plj:ioYuIG%axvLUrcoRxHHGHXelgKzkTWSxtLK:7whM8UaGLzs3qJ7P5IxNI0axh%hbAgxhWMGJ01M%KVKIASXQcipVR7MEz524XboQNoKVwPZPNhkpRjD5yRdM53B0c0qKDvE4X9PVw78JYWPc7usEo9cm1TAa0%R:hh44n1UXz1sjaB0dbJATdGoB:R1Dv:c4DGktSez33TNqW96MZtVo:R53sPLQxvGseCWu7y2d7Kji70MgQRUIwM5nNb%1bc8HyK%MAHiMtq2q5ypaOS39rdTz9jMaac4kg87eDpSsp4%bx:iS3UZLOqMQPM44Y3jGuSoCVabERyaCsj:90qs7TG1soWePZbICViWharvnSgrfTwYsz0gjckvUApHcDOdwa9waDvIGjCFZ:2vwzfVeGj7W%qs4ns0ettbMASJvG:WfJ%JAGHOVvI6GSxtMEUfNENK%FH%NtNaz1qzif7B79mcC2AdbG8zVxyNqMtrGkTQqZWmHUqvJjDJg%BZ9Rf552I8qtY%a:jUMnEG3j9V1RvWgUryfqFyXql1etX2aP:vGER8JWCCLdxhME4OlMbWTdLQCRhA%qX1WegVrZEbtjCjQjsDnKM200Y8nLjDaAx%WdVgg8:zfQY%1620Q8grcxpRDcfQvwMN2ivYm7s4GSRkGZLuRvV5T3AP1tAe08q8qtY38KJo4Ejgglbxh3awCJQyL35l:AjAKwN:5CKozAqpRm7zibBBUCMDJFi:p5GlMKcJUbGAm4aIkdlPCpttK9xz1RxMhzAdVCkDmnE5H:GURPXLta7ypHcz248%GLWR6Q%cL7ZdHRVOddWHPt1VRWX6O1mERXuNt6HmBmooGXnlB178MX3vIr5nhCejkUbf7VhgyalyWwngcjqsorxxg5xy%oDeDZ:Du0Qub%2aP6M%XVfSFK90D6ihjranoC2pUgUVVe0VdUw2bmeEKyASx1OwvWfQ7dPqi1XlFe1Vd0nbu1C:%HEeEObuSH:LyRKzSW6QZKvjDXDNKxqvIsR19a:624vKKvW9Zy5nTw5swQO2zGbODmDNdmpWwBmJ%hNo7n7WAJ5L703FN4DD:Sr3RcK6uar0XVnHvHUbHeDqadawaLFA3jbTwW6tH2aC%5oqgfLXYRGcOab5SKOVvz8sY75AneZATyQd:qyt1ByFjkGoCrR6u8gXLtc2tn:51qD22s7Pwi5Z5jEryNtS6jy6U5qfS8HZwFTWp0ogWdj3Wu0nmPWJ8K3HO62gvoul:dhKbBPPWmp:fdwBXwXNGa8TY92ruBzVG%GpoqnUXtp9CeCdza4JvZLhDqyqb3hT8RRDtH5VmyavKKREn0XCW1f3WiDKWmpTpf7GTQc:F6OpCdC3guJdp5C8CzkTY9JAg8Ekh:bxaAPxVMf28WgP7XMMrWAovwhO8I2gxkC8DibAFYnC0Ai6OFgjeL4Pmm0M2L0dzAzSJY2cDNy:E8ELJ5MdsLWJwtAIuzBWBxtgAszhaAxdkCsDi:AYnqZwd25SoPAAAAAElFTkSuQmCC"));
		var DESC = hxd_res_Any.fromBytes("hxd/res/defaultFont.fnt",haxe_Unserializer.run("s14030:PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPEZvbnQgc2l6ZT0iMTIiIGZhbWlseT0iUGl4ZWwgT3BlcmF0b3IiIGhlaWdodD0iMTYiIHN0eWxlPSJSZWd1bGFyIj4KIDxDaGFyIHdpZHRoPSI0IiBvZmZzZXQ9IjAgMTMiIHJlY3Q9IjEgMTIgMCAwIiBjb2RlPSIgIi8%CiA8Q2hhciB3aWR0aD0iMyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjIgMyAxIDkiIGNvZGU9IiEiLz4KIDxDaGFyIHdpZHRoPSI1IiBvZmZzZXQ9IjEgNCIgcmVjdD0iNCAzIDMgMyIgY29kZT0iJnF1b3Q7Ii8%CiA8Q2hhciB3aWR0aD0iOCIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjggMyA2IDkiIGNvZGU9IiMiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgMiIgcmVjdD0iMTUgMSA1IDEzIiBjb2RlPSIkIi8%CiA8Q2hhciB3aWR0aD0iOSIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjIxIDMgNyA5IiBjb2RlPSIlIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjI5IDMgNSA5IiBjb2RlPSImYW1wOyIvPgogPENoYXIgd2lkdGg9IjMiIG9mZnNldD0iMSA0IiByZWN0PSIzNSAzIDEgMyIgY29kZT0iJyIvPgogPENoYXIgd2lkdGg9IjUiIG9mZnNldD0iMSA0IiByZWN0PSIzNyAzIDMgOSIgY29kZT0iKCIvPgogPENoYXIgd2lkdGg9IjUiIG9mZnNldD0iMSA0IiByZWN0PSI0MSAzIDMgOSIgY29kZT0iKSIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSI0NSAzIDUgNSIgY29kZT0iKiIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA2IiByZWN0PSI1MSA1IDUgNSIgY29kZT0iKyIvPgogPENoYXIgd2lkdGg9IjMiIG9mZnNldD0iMCAxMiIgcmVjdD0iNTcgMTEgMiAzIiBjb2RlPSIsIi8%CiA8Q2hhciB3aWR0aD0iNiIgb2Zmc2V0PSIxIDgiIHJlY3Q9IjYwIDcgNCAxIiBjb2RlPSItIi8%CiA8Q2hhciB3aWR0aD0iMyIgb2Zmc2V0PSIxIDEyIiByZWN0PSI2NSAxMSAxIDEiIGNvZGU9Ii4iLz4KIDxDaGFyIHdpZHRoPSI1IiBvZmZzZXQ9IjEgNCIgcmVjdD0iNjcgMyAzIDkiIGNvZGU9Ii8iLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iNzEgMyA1IDkiIGNvZGU9IjAiLz4KIDxDaGFyIHdpZHRoPSI1IiBvZmZzZXQ9IjEgNCIgcmVjdD0iNzcgMyAzIDkiIGNvZGU9IjEiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iODEgMyA1IDkiIGNvZGU9IjIiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iODcgMyA1IDkiIGNvZGU9IjMiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iOTMgMyA1IDkiIGNvZGU9IjQiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iOTkgMyA1IDkiIGNvZGU9IjUiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMTA1IDMgNSA5IiBjb2RlPSI2Ii8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjExMSAzIDUgOSIgY29kZT0iNyIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSIxMTcgMyA1IDkiIGNvZGU9IjgiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMSAxNSA1IDkiIGNvZGU9IjkiLz4KIDxDaGFyIHdpZHRoPSIzIiBvZmZzZXQ9IjEgNiIgcmVjdD0iNyAxNyAxIDciIGNvZGU9IjoiLz4KIDxDaGFyIHdpZHRoPSIzIiBvZmZzZXQ9IjAgNiIgcmVjdD0iOSAxNyAyIDkiIGNvZGU9IjsiLz4KIDxDaGFyIHdpZHRoPSI1IiBvZmZzZXQ9IjEgNiIgcmVjdD0iMTIgMTcgMyA1IiBjb2RlPSImbHQ7Ii8%CiA8Q2hhciB3aWR0aD0iNiIgb2Zmc2V0PSIxIDciIHJlY3Q9IjE2IDE4IDQgMyIgY29kZT0iPSIvPgogPENoYXIgd2lkdGg9IjUiIG9mZnNldD0iMSA2IiByZWN0PSIyMSAxNyAzIDUiIGNvZGU9Ij4iLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMjUgMTUgNSA5IiBjb2RlPSI:Ii8%CiA8Q2hhciB3aWR0aD0iOSIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjMxIDE1IDcgOSIgY29kZT0iQCIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSIzOSAxNSA1IDkiIGNvZGU9IkEiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iNDUgMTUgNSA5IiBjb2RlPSJCIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjUxIDE1IDUgOSIgY29kZT0iQyIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSI1NyAxNSA1IDkiIGNvZGU9IkQiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iNjMgMTUgNSA5IiBjb2RlPSJFIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjY5IDE1IDUgOSIgY29kZT0iRiIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSI3NSAxNSA1IDkiIGNvZGU9IkciLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iODEgMTUgNSA5IiBjb2RlPSJIIi8%CiA8Q2hhciB3aWR0aD0iMyIgb2Zmc2V0PSIxIDQiIHJlY3Q9Ijg3IDE1IDEgOSIgY29kZT0iSSIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSI4OSAxNSA1IDkiIGNvZGU9IkoiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iOTUgMTUgNSA5IiBjb2RlPSJLIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjEwMSAxNSA1IDkiIGNvZGU9IkwiLz4KIDxDaGFyIHdpZHRoPSI5IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMTA3IDE1IDcgOSIgY29kZT0iTSIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSIxMTUgMTUgNSA5IiBjb2RlPSJOIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjEyMSAxNSA1IDkiIGNvZGU9Ik8iLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMSAyNyA1IDkiIGNvZGU9IlAiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iNyAyNyA1IDkiIGNvZGU9IlEiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMTMgMjcgNSA5IiBjb2RlPSJSIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjE5IDI3IDUgOSIgY29kZT0iUyIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSIyNSAyNyA1IDkiIGNvZGU9IlQiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMzEgMjcgNSA5IiBjb2RlPSJVIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjM3IDI3IDUgOSIgY29kZT0iViIvPgogPENoYXIgd2lkdGg9IjkiIG9mZnNldD0iMSA0IiByZWN0PSI0MyAyNyA3IDkiIGNvZGU9IlciLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iNTEgMjcgNSA5IiBjb2RlPSJYIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjU3IDI3IDUgOSIgY29kZT0iWSIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSI2MyAyNyA1IDkiIGNvZGU9IloiLz4KIDxDaGFyIHdpZHRoPSI1IiBvZmZzZXQ9IjEgNCIgcmVjdD0iNjkgMjcgMyA5IiBjb2RlPSJbIi8%CiA8Q2hhciB3aWR0aD0iNSIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjczIDI3IDMgOSIgY29kZT0iXCIvPgogPENoYXIgd2lkdGg9IjUiIG9mZnNldD0iMSA0IiByZWN0PSI3NyAyNyAzIDkiIGNvZGU9Il0iLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iODEgMjcgNSAzIiBjb2RlPSJeIi8%CiA8Q2hhciB3aWR0aD0iNSIgb2Zmc2V0PSIwIDE0IiByZWN0PSI4NyAzNyA1IDEiIGNvZGU9Il8iLz4KIDxDaGFyIHdpZHRoPSIzIiBvZmZzZXQ9IjAgNCIgcmVjdD0iOTMgMjcgMiAyIiBjb2RlPSJgIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDYiIHJlY3Q9Ijk2IDI5IDUgNyIgY29kZT0iYSIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSIxMDIgMjcgNSA5IiBjb2RlPSJiIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDYiIHJlY3Q9IjEwOCAyOSA1IDciIGNvZGU9ImMiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMTE0IDI3IDUgOSIgY29kZT0iZCIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA2IiByZWN0PSIxMjAgMjkgNSA3IiBjb2RlPSJlIi8%CiA8Q2hhciB3aWR0aD0iNiIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjEgMzkgNSA5IiBjb2RlPSJmIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDYiIHJlY3Q9IjcgNDEgNSA5IiBjb2RlPSJnIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjEzIDM5IDUgOSIgY29kZT0iaCIvPgogPENoYXIgd2lkdGg9IjMiIG9mZnNldD0iMSA0IiByZWN0PSIxOSAzOSAxIDkiIGNvZGU9ImkiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMjEgMzkgNSAxMSIgY29kZT0iaiIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSIyNyAzOSA1IDkiIGNvZGU9ImsiLz4KIDxDaGFyIHdpZHRoPSIzIiBvZmZzZXQ9IjEgNCIgcmVjdD0iMzMgMzkgMSA5IiBjb2RlPSJsIi8%CiA8Q2hhciB3aWR0aD0iOSIgb2Zmc2V0PSIxIDYiIHJlY3Q9IjM1IDQxIDcgNyIgY29kZT0ibSIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA2IiByZWN0PSI0MyA0MSA1IDciIGNvZGU9Im4iLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNiIgcmVjdD0iNDkgNDEgNSA3IiBjb2RlPSJvIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDYiIHJlY3Q9IjU1IDQxIDUgOSIgY29kZT0icCIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA2IiByZWN0PSI2MSA0MSA1IDkiIGNvZGU9InEiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNiIgcmVjdD0iNjcgNDEgNSA3IiBjb2RlPSJyIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDYiIHJlY3Q9IjczIDQxIDUgNyIgY29kZT0icyIvPgogPENoYXIgd2lkdGg9IjYiIG9mZnNldD0iMSA1IiByZWN0PSI3OSA0MCA1IDgiIGNvZGU9InQiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNiIgcmVjdD0iODUgNDEgNSA3IiBjb2RlPSJ1Ii8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDYiIHJlY3Q9IjkxIDQxIDUgNyIgY29kZT0idiIvPgogPENoYXIgd2lkdGg9IjkiIG9mZnNldD0iMSA2IiByZWN0PSI5NyA0MSA3IDciIGNvZGU9InciLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNiIgcmVjdD0iMTA1IDQxIDUgNyIgY29kZT0ieCIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA2IiByZWN0PSIxMTEgNDEgNSA5IiBjb2RlPSJ5Ii8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDYiIHJlY3Q9IjExNyA0MSA1IDciIGNvZGU9InoiLz4KIDxDaGFyIHdpZHRoPSI2IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMSA1NCA0IDkiIGNvZGU9InsiLz4KIDxDaGFyIHdpZHRoPSIzIiBvZmZzZXQ9IjEgNCIgcmVjdD0iNiA1NCAxIDkiIGNvZGU9InwiLz4KIDxDaGFyIHdpZHRoPSI2IiBvZmZzZXQ9IjEgNCIgcmVjdD0iOCA1NCA0IDkiIGNvZGU9In0iLz4KIDxDaGFyIHdpZHRoPSI4IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMTMgNTQgNiAyIiBjb2RlPSJ%Ii8%CiA8Q2hhciB3aWR0aD0iMyIgb2Zmc2V0PSIxIDYiIHJlY3Q9IjIwIDU2IDEgOSIgY29kZT0iwqEiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMjIgNTQgNSAxMSIgY29kZT0iwqIiLz4KIDxDaGFyIHdpZHRoPSI4IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMjggNTQgNiA5IiBjb2RlPSLCoyIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSIzNSA1NCA1IDkiIGNvZGU9IsKlIi8%CiA8Q2hhciB3aWR0aD0iMyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjQxIDU0IDEgOSIgY29kZT0iwqYiLz4KIDxDaGFyIHdpZHRoPSI1IiBvZmZzZXQ9IjEgNCIgcmVjdD0iNDMgNTQgMyAxIiBjb2RlPSLCqCIvPgogPENoYXIgd2lkdGg9IjkiIG9mZnNldD0iMSA0IiByZWN0PSI0NyA1NCA3IDkiIGNvZGU9IsKpIi8%CiA8Q2hhciB3aWR0aD0iOCIgb2Zmc2V0PSIxIDYiIHJlY3Q9IjU1IDU2IDYgNSIgY29kZT0iwqsiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgOCIgcmVjdD0iNjIgNTggNSAzIiBjb2RlPSLCrCIvPgogPENoYXIgd2lkdGg9IjYiIG9mZnNldD0iMSA0IiByZWN0PSI2OCA1NCA0IDQiIGNvZGU9IsKwIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDYiIHJlY3Q9IjczIDU2IDUgNyIgY29kZT0iwrEiLz4KIDxDaGFyIHdpZHRoPSIzIiBvZmZzZXQ9IjEgNCIgcmVjdD0iNzkgNTQgMiAyIiBjb2RlPSLCtCIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA2IiByZWN0PSI4MiA1NiA1IDkiIGNvZGU9IsK1Ii8%CiA8Q2hhciB3aWR0aD0iOCIgb2Zmc2V0PSIxIDQiIHJlY3Q9Ijg4IDU0IDcgOSIgY29kZT0iwrYiLz4KIDxDaGFyIHdpZHRoPSIzIiBvZmZzZXQ9IjEgOCIgcmVjdD0iOTYgNTggMSAxIiBjb2RlPSLCtyIvPgogPENoYXIgd2lkdGg9IjUiIG9mZnNldD0iMCAxMyIgcmVjdD0iOTggNjMgMyAyIiBjb2RlPSLCuCIvPgogPENoYXIgd2lkdGg9IjgiIG9mZnNldD0iMSA2IiByZWN0PSIxMDIgNTYgNiA1IiBjb2RlPSLCuyIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA2IiByZWN0PSIxMDkgNTYgNSA5IiBjb2RlPSLCvyIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSAxIiByZWN0PSIxMTUgNTEgNSAxMiIgY29kZT0iw4AiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgMSIgcmVjdD0iMTIxIDUxIDUgMTIiIGNvZGU9IsOBIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDEiIHJlY3Q9IjEgNjcgNSAxMiIgY29kZT0iw4IiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgMSIgcmVjdD0iNyA2NyA2IDEyIiBjb2RlPSLDgyIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSAyIiByZWN0PSIxNCA2OCA1IDExIiBjb2RlPSLDhCIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSAwIiByZWN0PSIyMCA2NiA1IDEzIiBjb2RlPSLDhSIvPgogPENoYXIgd2lkdGg9IjExIiBvZmZzZXQ9IjEgNCIgcmVjdD0iMjYgNzAgOSA5IiBjb2RlPSLDhiIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSIzNiA3MCA1IDExIiBjb2RlPSLDhyIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSAxIiByZWN0PSI0MiA2NyA1IDEyIiBjb2RlPSLDiCIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSAxIiByZWN0PSI0OCA2NyA1IDEyIiBjb2RlPSLDiSIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSAxIiByZWN0PSI1NCA2NyA1IDEyIiBjb2RlPSLDiiIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSAyIiByZWN0PSI2MCA2OCA1IDExIiBjb2RlPSLDiyIvPgogPENoYXIgd2lkdGg9IjMiIG9mZnNldD0iMCAxIiByZWN0PSI2NiA2NyAyIDEyIiBjb2RlPSLDjCIvPgogPENoYXIgd2lkdGg9IjMiIG9mZnNldD0iMSAxIiByZWN0PSI2OSA2NyAyIDEyIiBjb2RlPSLDjSIvPgogPENoYXIgd2lkdGg9IjMiIG9mZnNldD0iMCAxIiByZWN0PSI3MiA2NyAzIDEyIiBjb2RlPSLDjiIvPgogPENoYXIgd2lkdGg9IjMiIG9mZnNldD0iMCAyIiByZWN0PSI3NiA2OCAzIDExIiBjb2RlPSLDjyIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMCA0IiByZWN0PSI4MCA3MCA2IDkiIGNvZGU9IsOQIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDEiIHJlY3Q9Ijg3IDY3IDYgMTIiIGNvZGU9IsORIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDEiIHJlY3Q9Ijk0IDY3IDUgMTIiIGNvZGU9IsOSIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDEiIHJlY3Q9IjEwMCA2NyA1IDEyIiBjb2RlPSLDkyIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSAxIiByZWN0PSIxMDYgNjcgNSAxMiIgY29kZT0iw5QiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgMSIgcmVjdD0iMTEyIDY3IDYgMTIiIGNvZGU9IsOVIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDIiIHJlY3Q9IjExOSA2OCA1IDExIiBjb2RlPSLDliIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA2IiByZWN0PSIxIDg3IDUgNSIgY29kZT0iw5ciLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjAgNCIgcmVjdD0iNyA4NSA3IDkiIGNvZGU9IsOYIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDEiIHJlY3Q9IjE1IDgyIDUgMTIiIGNvZGU9IsOZIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDEiIHJlY3Q9IjIxIDgyIDUgMTIiIGNvZGU9IsOaIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDEiIHJlY3Q9IjI3IDgyIDUgMTIiIGNvZGU9IsObIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDIiIHJlY3Q9IjMzIDgzIDUgMTEiIGNvZGU9IsOcIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDEiIHJlY3Q9IjM5IDgyIDUgMTIiIGNvZGU9IsOdIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjQ1IDg1IDUgOSIgY29kZT0iw54iLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iNTEgODUgNSA5IiBjb2RlPSLDnyIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSAzIiByZWN0PSI1NyA4NCA1IDEwIiBjb2RlPSLDoCIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSAzIiByZWN0PSI2MyA4NCA1IDEwIiBjb2RlPSLDoSIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSAzIiByZWN0PSI2OSA4NCA1IDEwIiBjb2RlPSLDoiIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSAzIiByZWN0PSI3NSA4NCA2IDEwIiBjb2RlPSLDoyIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSI4MiA4NSA1IDkiIGNvZGU9IsOkIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDIiIHJlY3Q9Ijg4IDgzIDUgMTEiIGNvZGU9IsOlIi8%CiA8Q2hhciB3aWR0aD0iMTEiIG9mZnNldD0iMSA2IiByZWN0PSI5NCA4NyA5IDciIGNvZGU9IsOmIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDYiIHJlY3Q9IjEwNCA4NyA1IDkiIGNvZGU9IsOnIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDMiIHJlY3Q9IjExMCA4NCA1IDEwIiBjb2RlPSLDqCIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSAzIiByZWN0PSIxMTYgODQgNSAxMCIgY29kZT0iw6kiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgMyIgcmVjdD0iMSA5NyA1IDEwIiBjb2RlPSLDqiIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSI3IDk4IDUgOSIgY29kZT0iw6siLz4KIDxDaGFyIHdpZHRoPSIzIiBvZmZzZXQ9IjAgMyIgcmVjdD0iMTMgOTcgMiAxMCIgY29kZT0iw6wiLz4KIDxDaGFyIHdpZHRoPSIzIiBvZmZzZXQ9IjEgMyIgcmVjdD0iMTYgOTcgMiAxMCIgY29kZT0iw60iLz4KIDxDaGFyIHdpZHRoPSIzIiBvZmZzZXQ9IjAgMyIgcmVjdD0iMTkgOTcgMyAxMCIgY29kZT0iw64iLz4KIDxDaGFyIHdpZHRoPSIzIiBvZmZzZXQ9IjAgNCIgcmVjdD0iMjMgOTggMyA5IiBjb2RlPSLDryIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSIyNyA5OCA2IDkiIGNvZGU9IsOwIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDMiIHJlY3Q9IjM0IDk3IDYgMTAiIGNvZGU9IsOxIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDMiIHJlY3Q9IjQxIDk3IDUgMTAiIGNvZGU9IsOyIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDMiIHJlY3Q9IjQ3IDk3IDUgMTAiIGNvZGU9IsOzIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDMiIHJlY3Q9IjUzIDk3IDUgMTAiIGNvZGU9IsO0Ii8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDMiIHJlY3Q9IjU5IDk3IDYgMTAiIGNvZGU9IsO1Ii8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjY2IDk4IDUgOSIgY29kZT0iw7YiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNiIgcmVjdD0iNzIgMTAwIDUgNSIgY29kZT0iw7ciLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjAgNiIgcmVjdD0iNzggMTAwIDcgNyIgY29kZT0iw7giLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgMyIgcmVjdD0iODYgOTcgNSAxMCIgY29kZT0iw7kiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgMyIgcmVjdD0iOTIgOTcgNSAxMCIgY29kZT0iw7oiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgMyIgcmVjdD0iOTggOTcgNSAxMCIgY29kZT0iw7siLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMTA0IDk4IDUgOSIgY29kZT0iw7wiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgMyIgcmVjdD0iMTEwIDk3IDUgMTIiIGNvZGU9IsO9Ii8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjExNiA5OCA1IDExIiBjb2RlPSLDviIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSIxIDExMCA1IDExIiBjb2RlPSLDvyIvPgo8L0ZvbnQ%Cg"));
		var bmp = new hxd_res_BitmapFont(DESC.entry);
		bmp.loader = BYTES.loader;
		fnt = bmp.toFont();
		engine.resCache.set(hxd_res_DefaultFont,fnt);
	}
	return fnt;
};
var hxd_res_Embed = function() { };
$hxClasses["hxd.res.Embed"] = hxd_res_Embed;
hxd_res_Embed.__name__ = "hxd.res.Embed";
var hxd_res_ImageFormat = {};
hxd_res_ImageFormat.get_useLoadBitmap = function(this1) {
	return this1 == 0;
};
hxd_res_ImageFormat.toInt = function(this1) {
	return this1;
};
hxd_res_ImageFormat.getName = function(this1) {
	switch(this1) {
	case 0:
		return "JPG";
	case 1:
		return "PNG";
	case 2:
		return "GIF";
	case 3:
		return "TGA";
	case 4:
		return "DDS";
	case 5:
		return "RAW";
	case 6:
		return "HDR";
	}
};
var hxd_res_ImageInfoFlag = $hxEnums["hxd.res.ImageInfoFlag"] = { __ename__:true,__constructs__:null
	,IsCube: {_hx_name:"IsCube",_hx_index:0,__enum__:"hxd.res.ImageInfoFlag",toString:$estr}
	,Dxt10Header: {_hx_name:"Dxt10Header",_hx_index:1,__enum__:"hxd.res.ImageInfoFlag",toString:$estr}
};
hxd_res_ImageInfoFlag.__constructs__ = [hxd_res_ImageInfoFlag.IsCube,hxd_res_ImageInfoFlag.Dxt10Header];
hxd_res_ImageInfoFlag.__empty_constructs__ = [hxd_res_ImageInfoFlag.IsCube,hxd_res_ImageInfoFlag.Dxt10Header];
var hxd_res_ImageInfo = function() {
	this.layerCount = 1;
	this.mipOffset = 0;
	this.mipLevels = 1;
	this.height = 0;
	this.width = 0;
	this.flags = 0;
};
$hxClasses["hxd.res.ImageInfo"] = hxd_res_ImageInfo;
hxd_res_ImageInfo.__name__ = "hxd.res.ImageInfo";
hxd_res_ImageInfo.prototype = {
	__class__: hxd_res_ImageInfo
};
var hxd_res_Image = function(entry) {
	hxd_res_Resource.call(this,entry);
};
$hxClasses["hxd.res.Image"] = hxd_res_Image;
hxd_res_Image.__name__ = "hxd.res.Image";
hxd_res_Image.customCheckInfo = function(i) {
};
hxd_res_Image.setupTextureFlags = function(tex) {
};
hxd_res_Image.__super__ = hxd_res_Resource;
hxd_res_Image.prototype = $extend(hxd_res_Resource.prototype,{
	getFormat: function() {
		return this.getInfo().dataFormat;
	}
	,getPixelFormat: function() {
		return this.getInfo().pixelFormat;
	}
	,getSize: function() {
		return this.getInfo();
	}
	,getInfo: function() {
		if(this.inf != null) {
			return this.inf;
		}
		this.inf = new hxd_res_ImageInfo();
		var f = this.entry.open();
		f.fetch(256);
		var head;
		try {
			head = f.readUInt16();
		} catch( _g ) {
			if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
				head = 0;
			} else {
				throw _g;
			}
		}
		switch(head) {
		case 16163:
			this.inf.dataFormat = 6;
			while(f.readLine() != "") {
			}
			var parts = f.readLine().split(" ");
			this.inf.pixelFormat = hxd_PixelFormat.RGBA32F;
			this.inf.height = Std.parseInt(parts[1]);
			this.inf.width = Std.parseInt(parts[3]);
			break;
		case 17476:
			this.inf.dataFormat = 4;
			f.skip(10);
			this.inf.height = f.readInt32();
			this.inf.width = f.readInt32();
			f.skip(8);
			this.inf.mipLevels = f.readInt32();
			f.skip(48);
			var caps = f.readInt32();
			var fourCC = f.readInt32();
			var bpp = f.readInt32();
			var rMask = f.readInt32();
			var gMask = f.readInt32();
			var bMask = f.readInt32();
			var aMask = f.readInt32();
			var caps2 = f.readInt32();
			var cubes = f.readInt32();
			if((cubes & 65024) == 65024) {
				this.inf.flags |= 1 << hxd_res_ImageInfoFlag.IsCube._hx_index;
			}
			switch(fourCC & 16777215) {
			case 0:
				if(fourCC == 808540228) {
					f.skip(12);
					this.inf.flags |= 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index;
					var dxgi = f.readInt32();
					var tmp;
					switch(dxgi) {
					case 28:
						tmp = hxd_PixelFormat.RGBA;
						break;
					case 71:
						tmp = hxd_PixelFormat.S3TC(1);
						break;
					case 74:
						tmp = hxd_PixelFormat.S3TC(2);
						break;
					case 77:
						tmp = hxd_PixelFormat.S3TC(3);
						break;
					case 95:
						tmp = hxd_PixelFormat.S3TC(6);
						break;
					case 98:
						tmp = hxd_PixelFormat.S3TC(7);
						break;
					default:
						throw haxe_Exception.thrown(this.entry.get_path() + " has unsupported DXGI format " + dxgi);
					}
					this.inf.pixelFormat = tmp;
					var imgType = f.readInt32();
					f.skip(4);
					this.inf.layerCount = f.readInt32();
				} else {
					switch(bpp) {
					case 16:
						if(rMask == 65535) {
							if(gMask == 0) {
								if(bMask == 0) {
									if(aMask == 0) {
										this.inf.pixelFormat = hxd_PixelFormat.R16U;
									} else {
										throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
									}
								} else {
									throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
								}
							} else {
								throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
							}
						} else {
							throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
						}
						break;
					case 32:
						switch(rMask) {
						case 255:
							if(gMask == 65280) {
								if(bMask == 16711680) {
									if(aMask == -16777216) {
										this.inf.pixelFormat = hxd_PixelFormat.RGBA;
									} else {
										throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
									}
								} else {
									throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
								}
							} else {
								throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
							}
							break;
						case 65535:
							if(gMask == -65536) {
								if(bMask == 0) {
									if(aMask == 0) {
										this.inf.pixelFormat = hxd_PixelFormat.RG16U;
									} else {
										throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
									}
								} else {
									throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
								}
							} else {
								throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
							}
							break;
						case 16711680:
							if(gMask == 65280) {
								if(bMask == 255) {
									if(aMask == -16777216) {
										this.inf.pixelFormat = hxd_PixelFormat.BGRA;
									} else {
										throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
									}
								} else {
									throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
								}
							} else {
								throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
							}
							break;
						default:
							throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
						}
						break;
					default:
						throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
					}
				}
				break;
			case 36:
				if(fourCC == 808540228) {
					f.skip(12);
					this.inf.flags |= 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index;
					var dxgi = f.readInt32();
					var tmp;
					switch(dxgi) {
					case 28:
						tmp = hxd_PixelFormat.RGBA;
						break;
					case 71:
						tmp = hxd_PixelFormat.S3TC(1);
						break;
					case 74:
						tmp = hxd_PixelFormat.S3TC(2);
						break;
					case 77:
						tmp = hxd_PixelFormat.S3TC(3);
						break;
					case 95:
						tmp = hxd_PixelFormat.S3TC(6);
						break;
					case 98:
						tmp = hxd_PixelFormat.S3TC(7);
						break;
					default:
						throw haxe_Exception.thrown(this.entry.get_path() + " has unsupported DXGI format " + dxgi);
					}
					this.inf.pixelFormat = tmp;
					var imgType = f.readInt32();
					f.skip(4);
					this.inf.layerCount = f.readInt32();
				} else {
					this.inf.pixelFormat = hxd_PixelFormat.RGBA16U;
				}
				break;
			case 111:
				if(fourCC == 808540228) {
					f.skip(12);
					this.inf.flags |= 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index;
					var dxgi = f.readInt32();
					var tmp;
					switch(dxgi) {
					case 28:
						tmp = hxd_PixelFormat.RGBA;
						break;
					case 71:
						tmp = hxd_PixelFormat.S3TC(1);
						break;
					case 74:
						tmp = hxd_PixelFormat.S3TC(2);
						break;
					case 77:
						tmp = hxd_PixelFormat.S3TC(3);
						break;
					case 95:
						tmp = hxd_PixelFormat.S3TC(6);
						break;
					case 98:
						tmp = hxd_PixelFormat.S3TC(7);
						break;
					default:
						throw haxe_Exception.thrown(this.entry.get_path() + " has unsupported DXGI format " + dxgi);
					}
					this.inf.pixelFormat = tmp;
					var imgType = f.readInt32();
					f.skip(4);
					this.inf.layerCount = f.readInt32();
				} else {
					this.inf.pixelFormat = hxd_PixelFormat.R16F;
				}
				break;
			case 112:
				if(fourCC == 808540228) {
					f.skip(12);
					this.inf.flags |= 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index;
					var dxgi = f.readInt32();
					var tmp;
					switch(dxgi) {
					case 28:
						tmp = hxd_PixelFormat.RGBA;
						break;
					case 71:
						tmp = hxd_PixelFormat.S3TC(1);
						break;
					case 74:
						tmp = hxd_PixelFormat.S3TC(2);
						break;
					case 77:
						tmp = hxd_PixelFormat.S3TC(3);
						break;
					case 95:
						tmp = hxd_PixelFormat.S3TC(6);
						break;
					case 98:
						tmp = hxd_PixelFormat.S3TC(7);
						break;
					default:
						throw haxe_Exception.thrown(this.entry.get_path() + " has unsupported DXGI format " + dxgi);
					}
					this.inf.pixelFormat = tmp;
					var imgType = f.readInt32();
					f.skip(4);
					this.inf.layerCount = f.readInt32();
				} else {
					this.inf.pixelFormat = hxd_PixelFormat.RG16F;
				}
				break;
			case 113:
				if(fourCC == 808540228) {
					f.skip(12);
					this.inf.flags |= 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index;
					var dxgi = f.readInt32();
					var tmp;
					switch(dxgi) {
					case 28:
						tmp = hxd_PixelFormat.RGBA;
						break;
					case 71:
						tmp = hxd_PixelFormat.S3TC(1);
						break;
					case 74:
						tmp = hxd_PixelFormat.S3TC(2);
						break;
					case 77:
						tmp = hxd_PixelFormat.S3TC(3);
						break;
					case 95:
						tmp = hxd_PixelFormat.S3TC(6);
						break;
					case 98:
						tmp = hxd_PixelFormat.S3TC(7);
						break;
					default:
						throw haxe_Exception.thrown(this.entry.get_path() + " has unsupported DXGI format " + dxgi);
					}
					this.inf.pixelFormat = tmp;
					var imgType = f.readInt32();
					f.skip(4);
					this.inf.layerCount = f.readInt32();
				} else {
					this.inf.pixelFormat = hxd_PixelFormat.RGBA16F;
				}
				break;
			case 114:
				if(fourCC == 808540228) {
					f.skip(12);
					this.inf.flags |= 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index;
					var dxgi = f.readInt32();
					var tmp;
					switch(dxgi) {
					case 28:
						tmp = hxd_PixelFormat.RGBA;
						break;
					case 71:
						tmp = hxd_PixelFormat.S3TC(1);
						break;
					case 74:
						tmp = hxd_PixelFormat.S3TC(2);
						break;
					case 77:
						tmp = hxd_PixelFormat.S3TC(3);
						break;
					case 95:
						tmp = hxd_PixelFormat.S3TC(6);
						break;
					case 98:
						tmp = hxd_PixelFormat.S3TC(7);
						break;
					default:
						throw haxe_Exception.thrown(this.entry.get_path() + " has unsupported DXGI format " + dxgi);
					}
					this.inf.pixelFormat = tmp;
					var imgType = f.readInt32();
					f.skip(4);
					this.inf.layerCount = f.readInt32();
				} else {
					this.inf.pixelFormat = hxd_PixelFormat.R32F;
				}
				break;
			case 115:
				if(fourCC == 808540228) {
					f.skip(12);
					this.inf.flags |= 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index;
					var dxgi = f.readInt32();
					var tmp;
					switch(dxgi) {
					case 28:
						tmp = hxd_PixelFormat.RGBA;
						break;
					case 71:
						tmp = hxd_PixelFormat.S3TC(1);
						break;
					case 74:
						tmp = hxd_PixelFormat.S3TC(2);
						break;
					case 77:
						tmp = hxd_PixelFormat.S3TC(3);
						break;
					case 95:
						tmp = hxd_PixelFormat.S3TC(6);
						break;
					case 98:
						tmp = hxd_PixelFormat.S3TC(7);
						break;
					default:
						throw haxe_Exception.thrown(this.entry.get_path() + " has unsupported DXGI format " + dxgi);
					}
					this.inf.pixelFormat = tmp;
					var imgType = f.readInt32();
					f.skip(4);
					this.inf.layerCount = f.readInt32();
				} else {
					this.inf.pixelFormat = hxd_PixelFormat.RG32F;
				}
				break;
			case 116:
				if(fourCC == 808540228) {
					f.skip(12);
					this.inf.flags |= 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index;
					var dxgi = f.readInt32();
					var tmp;
					switch(dxgi) {
					case 28:
						tmp = hxd_PixelFormat.RGBA;
						break;
					case 71:
						tmp = hxd_PixelFormat.S3TC(1);
						break;
					case 74:
						tmp = hxd_PixelFormat.S3TC(2);
						break;
					case 77:
						tmp = hxd_PixelFormat.S3TC(3);
						break;
					case 95:
						tmp = hxd_PixelFormat.S3TC(6);
						break;
					case 98:
						tmp = hxd_PixelFormat.S3TC(7);
						break;
					default:
						throw haxe_Exception.thrown(this.entry.get_path() + " has unsupported DXGI format " + dxgi);
					}
					this.inf.pixelFormat = tmp;
					var imgType = f.readInt32();
					f.skip(4);
					this.inf.layerCount = f.readInt32();
				} else {
					this.inf.pixelFormat = hxd_PixelFormat.RGBA32F;
				}
				break;
			case 4805697:
				var v = (fourCC >>> 24) - 48;
				var tmp;
				switch(v) {
				case 1:
					tmp = hxd_PixelFormat.S3TC(4);
					break;
				case 2:
					tmp = hxd_PixelFormat.S3TC(5);
					break;
				default:
					tmp = null;
				}
				this.inf.pixelFormat = tmp;
				break;
			case 5527620:
				var dxt = (fourCC >>> 24) - 48;
				var tmp;
				switch(dxt) {
				case 1:
					tmp = hxd_PixelFormat.S3TC(1);
					break;
				case 2:case 3:
					tmp = hxd_PixelFormat.S3TC(2);
					break;
				case 4:case 5:
					tmp = hxd_PixelFormat.S3TC(3);
					break;
				default:
					tmp = null;
				}
				this.inf.pixelFormat = tmp;
				break;
			default:
				if(fourCC == 808540228) {
					f.skip(12);
					this.inf.flags |= 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index;
					var dxgi = f.readInt32();
					var tmp;
					switch(dxgi) {
					case 28:
						tmp = hxd_PixelFormat.RGBA;
						break;
					case 71:
						tmp = hxd_PixelFormat.S3TC(1);
						break;
					case 74:
						tmp = hxd_PixelFormat.S3TC(2);
						break;
					case 77:
						tmp = hxd_PixelFormat.S3TC(3);
						break;
					case 95:
						tmp = hxd_PixelFormat.S3TC(6);
						break;
					case 98:
						tmp = hxd_PixelFormat.S3TC(7);
						break;
					default:
						throw haxe_Exception.thrown(this.entry.get_path() + " has unsupported DXGI format " + dxgi);
					}
					this.inf.pixelFormat = tmp;
					var imgType = f.readInt32();
					f.skip(4);
					this.inf.layerCount = f.readInt32();
				}
			}
			if(this.inf.pixelFormat == null) {
				var fid = String.fromCodePoint((fourCC & 255)) + String.fromCodePoint((fourCC >> 8 & 255)) + String.fromCodePoint((fourCC >> 16 & 255)) + String.fromCodePoint((fourCC >>> 24));
				if((fourCC & 255) == fourCC) {
					fid = "" + fourCC;
				}
				throw haxe_Exception.thrown(this.entry.get_path() + " has unsupported 4CC " + fid);
			}
			break;
		case 18759:
			this.inf.dataFormat = 2;
			this.inf.pixelFormat = hxd_PixelFormat.BGRA;
			f.readInt32();
			this.inf.width = f.readUInt16();
			this.inf.height = f.readUInt16();
			break;
		case 20617:
			this.inf.dataFormat = 1;
			f.set_bigEndian(true);
			f.skip(6);
			while(true) {
				var dataLen = f.readInt32();
				if(f.readInt32() == 1229472850) {
					this.inf.width = f.readInt32();
					this.inf.height = f.readInt32();
					var colbits = f.readByte();
					var colType = f.readByte();
					var tmp;
					switch(colbits) {
					case 8:
						tmp = hxd_PixelFormat.BGRA;
						break;
					case 16:
						switch(colType) {
						case 0:
							tmp = hxd_PixelFormat.R16U;
							break;
						case 2:
							tmp = hxd_PixelFormat.RGBA16U;
							break;
						case 4:
							tmp = hxd_PixelFormat.RG16U;
							break;
						case 6:
							tmp = hxd_PixelFormat.RGBA16U;
							break;
						default:
							throw haxe_Exception.thrown("Unsupported png format " + colbits + "/" + colType + "(" + this.entry.get_path() + ")");
						}
						break;
					default:
						throw haxe_Exception.thrown("Unsupported png format " + colbits + "/" + colType + "(" + this.entry.get_path() + ")");
					}
					this.inf.pixelFormat = tmp;
					break;
				}
				f.skip(dataLen + 4);
			}
			break;
		case 55551:
			this.inf.dataFormat = 0;
			this.inf.pixelFormat = hxd_PixelFormat.BGRA;
			f.set_bigEndian(true);
			_hx_loop3: while(true) switch(f.readUInt16()) {
			case 65472:case 65473:case 65474:
				var len = f.readUInt16();
				var prec = f.readByte();
				this.inf.height = f.readUInt16();
				this.inf.width = f.readUInt16();
				break _hx_loop3;
			default:
				f.skip(f.readUInt16() - 2);
			}
			break;
		default:
			if(this.entry.get_extension() == "tga") {
				this.inf.dataFormat = 3;
				this.inf.pixelFormat = hxd_PixelFormat.ARGB;
				f.skip(10);
				this.inf.width = f.readUInt16();
				this.inf.height = f.readUInt16();
			} else if(this.entry.get_extension() == "raw") {
				this.inf.dataFormat = 5;
				this.inf.pixelFormat = hxd_PixelFormat.R32F;
				var size = Math.sqrt(this.entry.get_size() >> 2) | 0;
				if(this.entry.get_size() != size * size * 4) {
					var size2 = Math.sqrt(this.entry.get_size() >> 1) | 0;
					if(this.entry.get_size() == size2 * size2 * 2) {
						this.inf.pixelFormat = hxd_PixelFormat.R16F;
						size = size2;
					} else {
						throw haxe_Exception.thrown("RAW format does not match 32 bit per components on " + size + "x" + size);
					}
				}
				this.inf.width = this.inf.height = size;
			} else {
				throw haxe_Exception.thrown("Unsupported texture format " + this.entry.get_path());
			}
		}
		f.close();
		if(this.inf.pixelFormat == null) {
			throw haxe_Exception.thrown("Unsupported internal format (" + this.entry.get_path() + ")");
		}
		if(hxd_res_Image.MIPMAP_MAX_SIZE != 0 && this.inf.mipLevels > 1) {
			while(((this.inf.width | this.inf.height) & 7) == 0 && this.inf.width >> 1 >= hxd_res_Image.MIPMAP_MAX_SIZE && this.inf.height >> 1 >= hxd_res_Image.MIPMAP_MAX_SIZE) {
				this.inf.width >>= 1;
				this.inf.height >>= 1;
				this.inf.mipLevels--;
				this.inf.mipOffset++;
			}
		}
		hxd_res_Image.customCheckInfo(this);
		return this.inf;
	}
	,getPixels: function(fmt,index) {
		var pixels;
		if(index == null) {
			index = 0;
		}
		switch(this.getInfo().dataFormat) {
		case 0:
			var bytes = this.entry.getBytes();
			if(this.inf.pixelFormat != hxd_PixelFormat.BGRA) {
				throw haxe_Exception.thrown("No support to decode " + Std.string(this.inf.pixelFormat) + " on this platform (" + this.entry.get_path() + ")");
			}
			var p;
			try {
				p = hxd_res_NanoJpeg.decode(bytes);
			} catch( _g ) {
				var e = haxe_Exception.caught(_g).unwrap();
				throw haxe_Exception.thrown("Failed to decode JPG " + this.entry.get_path() + " (" + Std.string(e) + ")");
			}
			pixels = new hxd_Pixels(p.width,p.height,p.pixels,hxd_PixelFormat.BGRA);
			break;
		case 1:
			var bytes = this.entry.getBytes();
			var png = new format_png_Reader(new haxe_io_BytesInput(bytes));
			png.checkCRC = false;
			pixels = hxd_Pixels.alloc(this.inf.width,this.inf.height,this.inf.pixelFormat);
			var pdata = png.read();
			switch(this.inf.pixelFormat._hx_index) {
			case 1:
				format_png_Tools.extract32(pdata,pixels.bytes,false);
				break;
			case 18:case 19:case 20:case 21:
				var pixels1 = pixels.bytes;
				var tmp;
				if(this.inf.pixelFormat == hxd_PixelFormat.RGBA16U) {
					var _g = format_png_Tools.getHeader(pdata).color;
					tmp = _g._hx_index == 1 && _g.alpha == false;
				} else {
					tmp = false;
				}
				format_png_Tools.extract(pdata,pixels1,tmp);
				break;
			default:
				throw haxe_Exception.thrown("No support to decode " + Std.string(this.inf.pixelFormat) + " on this platform (" + this.entry.get_path() + ")");
			}
			break;
		case 2:
			var bytes = this.entry.getBytes();
			var gif = new format_gif_Reader(new haxe_io_BytesInput(bytes)).read();
			if(fmt == hxd_PixelFormat.RGBA) {
				pixels = new hxd_Pixels(this.inf.width,this.inf.height,format_gif_Tools.extractFullRGBA(gif,0),hxd_PixelFormat.RGBA);
			} else {
				pixels = new hxd_Pixels(this.inf.width,this.inf.height,format_gif_Tools.extractFullBGRA(gif,0),hxd_PixelFormat.BGRA);
			}
			break;
		case 3:
			var bytes = this.entry.getBytes();
			var r = new format_tga_Reader(new haxe_io_BytesInput(bytes)).read();
			if(r.header.imageType != format_tga_ImageType.UncompressedTrueColor || r.header.bitsPerPixel != 32) {
				throw haxe_Exception.thrown("Not supported TGA " + Std.string(r.header.imageType) + "/" + r.header.bitsPerPixel);
			}
			var w = r.header.width;
			var h = r.header.height;
			if(fmt == hxd_PixelFormat.RGBA) {
				pixels = hxd_Pixels.alloc(w,h,hxd_PixelFormat.RGBA);
				var bytes = pixels.bytes;
				var _g = 0;
				var _g1 = w * h;
				while(_g < _g1) {
					var i = _g++;
					var c = r.imageData[i];
					c = c >>> 24 | c << 8;
					bytes.setInt32(i << 2,c);
				}
			} else {
				pixels = hxd_Pixels.alloc(w,h,hxd_PixelFormat.ARGB);
				var access = hxd_PixelsARGB.fromPixels(pixels);
				var p = 0;
				var _g = 0;
				var _g1 = h;
				while(_g < _g1) {
					var y = _g++;
					var _g2 = 0;
					var _g3 = w;
					while(_g2 < _g3) {
						var x = _g2++;
						var c = r.imageData[p++];
						access.bytes.setInt32((x + y * access.width << 2) + access.offset,c >>> 24 | c >> 8 & 65280 | c << 8 & 16711680 | c << 24);
					}
				}
			}
			switch(r.header.imageOrigin._hx_index) {
			case 0:
				pixels.flipY();
				break;
			case 2:
				break;
			default:
				throw haxe_Exception.thrown("Not supported " + Std.string(r.header.imageOrigin));
			}
			break;
		case 4:
			var pos = 128;
			var mipLevel = 0;
			if((this.inf.flags & 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index) != 0) {
				pos += 20;
			}
			index += this.inf.mipOffset;
			if(index > 0) {
				var totLevels = this.inf.mipLevels + this.inf.mipOffset;
				var bpp = hxd_Pixels.calcStride(1,this.inf.pixelFormat);
				var layer = index / totLevels | 0;
				mipLevel = index % totLevels;
				var totSize = 0;
				var _g = 0;
				var _g1 = totLevels;
				while(_g < _g1) {
					var i = _g++;
					var w = this.inf.width << this.inf.mipOffset >> i;
					var h = this.inf.height << this.inf.mipOffset >> i;
					if(w == 0) {
						w = 1;
					}
					if(h == 0) {
						h = 1;
					}
					var size = hxd_Pixels.calcDataSize(w,h,this.inf.pixelFormat);
					totSize += size;
					if(i < mipLevel) {
						pos += size;
					} else if(layer == 0) {
						break;
					}
				}
				pos += totSize * layer;
			}
			var bytes;
			var w = this.inf.width >> mipLevel - this.inf.mipOffset;
			var h = this.inf.height >> mipLevel - this.inf.mipOffset;
			if(w == 0) {
				w = 1;
			}
			if(h == 0) {
				h = 1;
			}
			if(this.inf.mipLevels + this.inf.mipOffset == 1 && (this.inf.flags & 1 << hxd_res_ImageInfoFlag.IsCube._hx_index) == 0) {
				bytes = this.entry.getBytes();
			} else {
				var size = hxd_Pixels.calcDataSize(w,h,this.inf.pixelFormat);
				bytes = new haxe_io_Bytes(new ArrayBuffer(size));
				this.entry.readFull(bytes,pos,size);
				pos = 0;
			}
			pixels = new hxd_Pixels(w,h,bytes,this.inf.pixelFormat,pos);
			break;
		case 5:
			var bytes = this.entry.getBytes();
			pixels = new hxd_Pixels(this.inf.width,this.inf.height,bytes,this.inf.pixelFormat);
			break;
		case 6:
			var data = hxd_fmt_hdr_Reader.decode(this.entry.getBytes(),false);
			pixels = new hxd_Pixels(data.width,data.height,data.bytes,this.inf.pixelFormat);
			break;
		}
		if(fmt != null) {
			pixels.convert(fmt);
		}
		return pixels;
	}
	,toBitmap: function() {
		this.getInfo();
		var bmp = new hxd_BitmapData(this.inf.width,this.inf.height);
		var pixels = this.getPixels();
		bmp.setPixels(pixels);
		pixels.dispose();
		return bmp;
	}
	,watchCallb: function() {
		var prevInfo = this.inf;
		this.inf = null;
		try {
			this.getInfo();
		} catch( _g ) {
			this.inf = prevInfo;
			return;
		}
		var s = this.getInfo();
		if(prevInfo.width != s.width || prevInfo.height != s.height) {
			this.tex.resize(s.width,s.height);
		}
		this.tex.realloc = null;
		this.loadTexture();
	}
	,asyncLoad: function(data) {
		var tmp;
		if(this.tex != null) {
			var _this = this.tex;
			tmp = _this.t == null && (_this.isDepth() || _this.realloc == null);
		} else {
			tmp = true;
		}
		if(tmp) {
			return;
		}
		this.tex.dispose();
		this.tex.flags &= -1 - (1 << h3d_mat_TextureFlags.Loading._hx_index);
		this.tex.format = this.inf.pixelFormat;
		this.tex.width = this.inf.width;
		this.tex.height = this.inf.height;
		this.loadTexture(data);
	}
	,loadTexture: function(asyncData) {
		var _gthis = this;
		if(this.getInfo().dataFormat == 0) {
			this.tex.flags |= 1 << h3d_mat_TextureFlags.Loading._hx_index;
			this.entry.loadBitmap(function(bmp) {
				var bmp1 = hxd_fs_LoadedBitmap.toBitmap(bmp);
				_gthis.tex.alloc();
				_gthis.tex.uploadBitmap(bmp1);
				bmp1.ctx = null;
				bmp1.pixel = null;
				_gthis.tex.realloc = function() {
					_gthis.loadTexture();
				};
				_gthis.tex.flags &= -1 - (1 << h3d_mat_TextureFlags.Loading._hx_index);
				if(_gthis.tex.waitLoads != null) {
					var arr = _gthis.tex.waitLoads;
					_gthis.tex.waitLoads = null;
					var _g = 0;
					while(_g < arr.length) {
						var f = arr[_g];
						++_g;
						f();
					}
				}
				if(hxd_res_Image.ENABLE_AUTO_WATCH) {
					_gthis.watch($bind(_gthis,_gthis.watchCallb));
				}
			});
			return;
		}
		var load = function() {
			if((_gthis.enableAsyncLoading || (_gthis.tex.flags & 1 << h3d_mat_TextureFlags.AsyncLoading._hx_index) != 0) && asyncData == null && hxd_res_Image.ASYNC_LOADER != null && hxd_res_Image.ASYNC_LOADER.isSupported(_gthis)) {
				_gthis.tex.dispose();
				_gthis.tex.format = hxd_PixelFormat.RGBA;
				_gthis.tex.width = 1;
				_gthis.tex.height = 1;
				_gthis.tex.customMipLevels = 1;
				_gthis.tex.flags |= 1 << h3d_mat_TextureFlags.Loading._hx_index;
				_gthis.tex.alloc();
				_gthis.tex.uploadPixels(hxd_res_Image.BLACK_1x1);
				_gthis.tex.width = _gthis.inf.width;
				_gthis.tex.height = _gthis.inf.height;
				hxd_res_Image.ASYNC_LOADER.load(_gthis);
				_gthis.tex.realloc = function() {
					_gthis.loadTexture();
				};
				return;
			}
			var t0 = HxOverrides.now() / 1000;
			_gthis.tex.customMipLevels = _gthis.inf.mipLevels;
			_gthis.tex.alloc();
			if(_gthis.inf.dataFormat == 4) {
				var pos = 128;
				if((_gthis.inf.flags & 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index) != 0) {
					pos += 20;
				}
				var _g = 0;
				var _g1 = _gthis.tex.get_layerCount();
				while(_g < _g1) {
					var layer = _g++;
					var _g2 = 0;
					var _g3 = _gthis.inf.mipOffset;
					while(_g2 < _g3) {
						var mip = _g2++;
						var w = _gthis.inf.width << _gthis.inf.mipOffset >> mip;
						var h = _gthis.inf.height << _gthis.inf.mipOffset >> mip;
						var size = hxd_Pixels.calcDataSize(w,h,_gthis.inf.pixelFormat);
						pos += size;
					}
					var _g4 = 0;
					var _g5 = _gthis.inf.mipLevels;
					while(_g4 < _g5) {
						var mip1 = _g4++;
						var w1 = _gthis.inf.width >> mip1;
						var h1 = _gthis.inf.height >> mip1;
						if(w1 == 0) {
							w1 = 1;
						}
						if(h1 == 0) {
							h1 = 1;
						}
						var size1 = hxd_Pixels.calcDataSize(w1,h1,_gthis.inf.pixelFormat);
						var bytes = asyncData == null ? _gthis.entry.fetchBytes(pos,size1) : asyncData;
						_gthis.tex.uploadPixels(new hxd_Pixels(w1,h1,bytes,_gthis.inf.pixelFormat,asyncData == null ? 0 : pos),mip1,layer);
						pos += size1;
					}
				}
			} else {
				var _g = 0;
				var _g1 = _gthis.tex.get_layerCount();
				while(_g < _g1) {
					var layer = _g++;
					var _g2 = 0;
					var _g3 = _gthis.inf.mipLevels;
					while(_g2 < _g3) {
						var mip = _g2++;
						var pixels = _gthis.getPixels(_gthis.tex.format,layer * _gthis.inf.mipLevels + mip);
						_gthis.tex.uploadPixels(pixels,mip,layer);
						pixels.dispose();
					}
				}
			}
			if(hxd_res_Image.LOG_TEXTURE_LOAD && asyncData == null) {
				var time = (HxOverrides.now() / 1000 - t0) * 1000.0;
				var _g = _gthis.inf.pixelFormat;
				var fmtStr;
				if(_g._hx_index == 22) {
					var _g1 = _g.v;
					fmtStr = true;
				} else {
					fmtStr = false;
				}
				var fmtStr1 = fmtStr ? "DXT" : hxd_res_ImageFormat.getName(_gthis.inf.dataFormat);
				haxe_Log.trace(fmtStr1 + " " + (time | 0) + "." + (time * 10 | 0) % 10 + "ms " + _gthis.inf.width + "x" + _gthis.inf.height + " " + _gthis.entry.get_path(),{ fileName : "hxd/res/Image.hx", lineNumber : 625, className : "hxd.res.Image", methodName : "loadTexture"});
			}
			_gthis.tex.realloc = function() {
				_gthis.loadTexture();
			};
			if(hxd_res_Image.ENABLE_AUTO_WATCH) {
				_gthis.watch($bind(_gthis,_gthis.watchCallb));
			}
		};
		if(this.entry.get_isAvailable()) {
			load();
		} else {
			this.entry.load(load);
		}
	}
	,toTexture: function() {
		var _gthis = this;
		if(this.tex != null) {
			return this.tex;
		}
		this.getInfo();
		var flags = [h3d_mat_TextureFlags.NoAlloc];
		var fmt = this.inf.pixelFormat;
		if(fmt == hxd_PixelFormat.BGRA || fmt == hxd_PixelFormat.ARGB || fmt == hxd_PixelFormat.RGBA) {
			fmt = h3d_mat_Texture.nativeFormat;
		}
		if((this.inf.flags & 1 << hxd_res_ImageInfoFlag.IsCube._hx_index) != 0) {
			flags.push(h3d_mat_TextureFlags.Cube);
		}
		if(this.inf.mipLevels > 1) {
			flags.push(h3d_mat_TextureFlags.MipMapped);
			flags.push(h3d_mat_TextureFlags.ManualMipMapGen);
		}
		if(this.inf.layerCount > 1) {
			this.tex = new h3d_mat_TextureArray(this.inf.width,this.inf.height,this.inf.layerCount,flags,fmt);
		} else {
			this.tex = new h3d_mat_Texture(this.inf.width,this.inf.height,flags,fmt);
		}
		if(hxd_res_Image.DEFAULT_FILTER != h3d_mat_Filter.Linear) {
			this.tex.set_filter(hxd_res_Image.DEFAULT_FILTER);
		}
		this.tex.setName(this.entry.get_path());
		hxd_res_Image.setupTextureFlags(this.tex);
		if((this.tex.flags & 1 << h3d_mat_TextureFlags.IsArray._hx_index) != 0 || (this.tex.flags & 1 << h3d_mat_TextureFlags.LazyLoading._hx_index) == 0) {
			this.loadTexture();
		} else {
			this.tex.realloc = function() {
				_gthis.loadTexture();
			};
		}
		return this.tex;
	}
	,toTile: function() {
		this.getInfo();
		return h2d_Tile.fromTexture(this.toTexture()).sub(0,0,this.inf.width,this.inf.height);
	}
	,__class__: hxd_res_Image
});
var hxd_res_Loader = function(fs) {
	this.fs = fs;
	this.cache = new haxe_ds_StringMap();
};
$hxClasses["hxd.res.Loader"] = hxd_res_Loader;
hxd_res_Loader.__name__ = "hxd.res.Loader";
hxd_res_Loader.prototype = {
	cleanCache: function() {
		this.cache = new haxe_ds_StringMap();
	}
	,dir: function(path) {
		var r = [];
		var entries = this.fs.dir(path);
		var _g = 0;
		while(_g < entries.length) {
			var e = entries[_g];
			++_g;
			r.push(new hxd_res_Any(this,e));
		}
		return r;
	}
	,exists: function(path) {
		return this.fs.exists(path);
	}
	,load: function(path) {
		return new hxd_res_Any(this,this.fs.get(path));
	}
	,loadCache: function(path,c) {
		var res = this.cache.h[path];
		if(res == null) {
			var entry = this.fs.get(path);
			var old = hxd_res_Loader.currentInstance;
			hxd_res_Loader.currentInstance = this;
			res = Type.createInstance(c,[entry]);
			hxd_res_Loader.currentInstance = old;
			this.cache.h[path] = res;
		} else if((js_Boot.__downcastCheck(res,c) ? res : null) == null) {
			throw haxe_Exception.thrown(path + " has been reintrepreted from " + Std.string(js_Boot.getClass(res)) + " to " + Std.string(c));
		}
		return res;
	}
	,dispose: function() {
		this.cleanCache();
		this.fs.dispose();
	}
	,__class__: hxd_res_Loader
};
var hxd_res_Model = function(entry) {
	hxd_res_Resource.call(this,entry);
};
$hxClasses["hxd.res.Model"] = hxd_res_Model;
hxd_res_Model.__name__ = "hxd.res.Model";
hxd_res_Model.__super__ = hxd_res_Resource;
hxd_res_Model.prototype = $extend(hxd_res_Resource.prototype,{
	toHmd: function() {
		var fs = this.entry.open();
		var hmd = new hxd_fmt_hmd_Reader(fs).readHeader();
		fs.close();
		return new hxd_fmt_hmd_Library(this,hmd);
	}
	,__class__: hxd_res_Model
});
var hxd_res_Filter = $hxEnums["hxd.res.Filter"] = { __ename__:true,__constructs__:null
	,Fast: {_hx_name:"Fast",_hx_index:0,__enum__:"hxd.res.Filter",toString:$estr}
	,Chromatic: {_hx_name:"Chromatic",_hx_index:1,__enum__:"hxd.res.Filter",toString:$estr}
};
hxd_res_Filter.__constructs__ = [hxd_res_Filter.Fast,hxd_res_Filter.Chromatic];
hxd_res_Filter.__empty_constructs__ = [hxd_res_Filter.Fast,hxd_res_Filter.Chromatic];
var hxd_res__$NanoJpeg_FastBytes = {};
hxd_res__$NanoJpeg_FastBytes._new = function(b) {
	return b;
};
hxd_res__$NanoJpeg_FastBytes.get = function(this1,i) {
	return this1.b[i];
};
hxd_res__$NanoJpeg_FastBytes.set = function(this1,i,v) {
	this1.b[i] = v;
};
var hxd_res__$NanoJpeg_Component = function() {
};
$hxClasses["hxd.res._NanoJpeg.Component"] = hxd_res__$NanoJpeg_Component;
hxd_res__$NanoJpeg_Component.__name__ = "hxd.res._NanoJpeg.Component";
hxd_res__$NanoJpeg_Component.prototype = {
	__class__: hxd_res__$NanoJpeg_Component
};
var hxd_res_NanoJpeg = function() {
	this.comps = [new hxd_res__$NanoJpeg_Component(),new hxd_res__$NanoJpeg_Component(),new hxd_res__$NanoJpeg_Component()].slice(0);
	this.qtab = [new Array(64),new Array(64),new Array(64),new Array(64)].slice(0);
	this.counts = new Array(16);
	this.block = new Array(64);
	this.njZZ = [0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,12,19,26,33,40,48,41,34,27,20,13,6,7,14,21,28,35,42,49,56,57,50,43,36,29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63].slice(0);
	this.vlctab = [null,null,null,null,null,null,null,null].slice(0);
};
$hxClasses["hxd.res.NanoJpeg"] = hxd_res_NanoJpeg;
hxd_res_NanoJpeg.__name__ = "hxd.res.NanoJpeg";
hxd_res_NanoJpeg.CF = function(x) {
	var x1 = x + 64 >> 7;
	if(x1 < 0) {
		return 0;
	} else if(x1 > 255) {
		return 255;
	} else {
		return x1;
	}
};
hxd_res_NanoJpeg.njClip = function(x) {
	if(x < 0) {
		return 0;
	} else if(x > 255) {
		return 255;
	} else {
		return x;
	}
};
hxd_res_NanoJpeg.decode = function(bytes,filter,position,size) {
	if(size == null) {
		size = -1;
	}
	if(position == null) {
		position = 0;
	}
	if(hxd_res_NanoJpeg.inst == null) {
		hxd_res_NanoJpeg.inst = new hxd_res_NanoJpeg();
	}
	hxd_res_NanoJpeg.inst.njInit(bytes,position,size,filter);
	return hxd_res_NanoJpeg.inst.njDecode();
};
hxd_res_NanoJpeg.prototype = {
	alloc: function(nbytes) {
		return new haxe_io_Bytes(new ArrayBuffer(nbytes));
	}
	,free: function(bytes) {
	}
	,njInit: function(bytes,pos,size,filter) {
		this.bytes = bytes;
		this.pos = pos;
		this.filter = filter == null ? hxd_res_Filter.Chromatic : filter;
		if(size < 0) {
			size = bytes.length - pos;
		}
		if(this.vlctab[0] == null) {
			this.vlctab[0] = new haxe_io_Bytes(new ArrayBuffer(131072));
		}
		if(this.vlctab[1] == null) {
			this.vlctab[1] = new haxe_io_Bytes(new ArrayBuffer(131072));
		}
		if(this.vlctab[2] == null) {
			this.vlctab[2] = new haxe_io_Bytes(new ArrayBuffer(131072));
		}
		if(this.vlctab[3] == null) {
			this.vlctab[3] = new haxe_io_Bytes(new ArrayBuffer(131072));
		}
		this.size = size;
		this.qtused = 0;
		this.qtavail = 0;
		this.rstinterval = 0;
		this.length = 0;
		this.buf = 0;
		this.bufbits = 0;
		this.progressive = false;
		this.comps[0].dcpred = 0;
		this.comps[1].dcpred = 0;
		this.comps[2].dcpred = 0;
	}
	,cleanup: function() {
		this.bytes = null;
		var _g = 0;
		var _g1 = this.comps;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			if(c.pixels != null) {
				c.pixels = null;
			}
		}
		if(this.vlctab[0] != null) {
			this.vlctab[0] = null;
		}
		if(this.vlctab[1] != null) {
			this.vlctab[1] = null;
		}
		if(this.vlctab[2] != null) {
			this.vlctab[2] = null;
		}
		if(this.vlctab[3] != null) {
			this.vlctab[3] = null;
		}
		if(this.vlctab[4] != null) {
			this.vlctab[4] = null;
		}
		if(this.vlctab[5] != null) {
			this.vlctab[5] = null;
		}
		if(this.vlctab[6] != null) {
			this.vlctab[6] = null;
		}
		if(this.vlctab[7] != null) {
			this.vlctab[7] = null;
		}
	}
	,njSkip: function(count) {
		this.pos += count;
		this.size -= count;
		this.length -= count;
		if(this.size < 0) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
	}
	,syntax: function(flag) {
		if(flag) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
	}
	,get: function(p) {
		return this.bytes.b[this.pos + p];
	}
	,njDecode16: function(p) {
		return this.bytes.b[this.pos + p] << 8 | this.bytes.b[this.pos + (p + 1)];
	}
	,njByteAlign: function() {
		this.bufbits &= 248;
	}
	,njShowBits: function(bits) {
		if(bits == 0) {
			return 0;
		}
		while(this.bufbits < bits) {
			if(this.size <= 0) {
				this.buf = this.buf << 8 | 255;
				this.bufbits += 8;
				continue;
			}
			var newbyte = this.bytes.b[this.pos];
			this.pos++;
			this.size--;
			this.bufbits += 8;
			this.buf = this.buf << 8 | newbyte;
			if(newbyte == 255) {
				if(this.size == 0) {
					throw haxe_Exception.thrown("Invalid JPEG file");
				}
				var marker = this.bytes.b[this.pos];
				this.pos++;
				this.size--;
				switch(marker) {
				case 217:
					this.size = 0;
					break;
				case 0:case 255:
					break;
				default:
					if((marker & 248) != 208) {
						throw haxe_Exception.thrown("Invalid JPEG file");
					}
					this.buf = this.buf << 8 | marker;
					this.bufbits += 8;
				}
			}
		}
		return this.buf >> this.bufbits - bits & (1 << bits) - 1;
	}
	,njSkipBits: function(bits) {
		if(this.bufbits < bits) {
			this.njShowBits(bits);
		}
		this.bufbits -= bits;
	}
	,njGetBits: function(bits) {
		var r = this.njShowBits(bits);
		this.bufbits -= bits;
		return r;
	}
	,njDecodeLength: function() {
		if(this.size < 2) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		this.length = this.bytes.b[this.pos] << 8 | this.bytes.b[this.pos + 1];
		if(this.length > this.size) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		this.pos += 2;
		this.size -= 2;
		this.length -= 2;
		if(this.size < 0) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
	}
	,njSkipMarker: function() {
		if(this.size < 2) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		this.length = this.bytes.b[this.pos] << 8 | this.bytes.b[this.pos + 1];
		if(this.length > this.size) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		this.pos += 2;
		this.size -= 2;
		this.length -= 2;
		if(this.size < 0) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		var count = this.length;
		this.pos += count;
		this.size -= count;
		this.length -= count;
		if(this.size < 0) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
	}
	,njDecodeSOF: function() {
		if(this.size < 2) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		this.length = this.bytes.b[this.pos] << 8 | this.bytes.b[this.pos + 1];
		if(this.length > this.size) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		this.pos += 2;
		this.size -= 2;
		this.length -= 2;
		if(this.size < 0) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		if(this.length < 9) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		if(this.bytes.b[this.pos] != 8) {
			this.notSupported();
		}
		this.height = this.bytes.b[this.pos + 1] << 8 | this.bytes.b[this.pos + 2];
		this.width = this.bytes.b[this.pos + 3] << 8 | this.bytes.b[this.pos + 4];
		this.ncomp = this.bytes.b[this.pos + 5];
		this.pos += 6;
		this.size -= 6;
		this.length -= 6;
		if(this.size < 0) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		switch(this.ncomp) {
		case 1:case 3:
			break;
		default:
			this.notSupported();
		}
		if(this.length < this.ncomp * 3) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		var ssxmax = 0;
		var ssymax = 0;
		var _g = 0;
		var _g1 = this.ncomp;
		while(_g < _g1) {
			var i = _g++;
			var c = this.comps[i];
			c.cid = this.bytes.b[this.pos];
			c.ssx = this.bytes.b[this.pos + 1] >> 4;
			if(c.ssx == 0) {
				throw haxe_Exception.thrown("Invalid JPEG file");
			}
			if((c.ssx & c.ssx - 1) != 0) {
				this.notSupported();
			}
			c.ssy = this.bytes.b[this.pos + 1] & 15;
			if(c.ssy == 0) {
				throw haxe_Exception.thrown("Invalid JPEG file");
			}
			if((c.ssy & c.ssy - 1) != 0) {
				this.notSupported();
			}
			c.qtsel = this.bytes.b[this.pos + 2];
			if((c.qtsel & 252) != 0) {
				throw haxe_Exception.thrown("Invalid JPEG file");
			}
			this.pos += 3;
			this.size -= 3;
			this.length -= 3;
			if(this.size < 0) {
				throw haxe_Exception.thrown("Invalid JPEG file");
			}
			this.qtused |= 1 << c.qtsel;
			if(c.ssx > ssxmax) {
				ssxmax = c.ssx;
			}
			if(c.ssy > ssymax) {
				ssymax = c.ssy;
			}
		}
		if(this.ncomp == 1) {
			var c = this.comps[0];
			ssymax = 1;
			ssxmax = ssymax;
			c.ssx = c.ssy = ssxmax;
		}
		this.mbsizex = ssxmax << 3;
		this.mbsizey = ssymax << 3;
		this.mbwidth = (this.width + this.mbsizex - 1) / this.mbsizex | 0;
		this.mbheight = (this.height + this.mbsizey - 1) / this.mbsizey | 0;
		var _g = 0;
		var _g1 = this.ncomp;
		while(_g < _g1) {
			var i = _g++;
			var c = this.comps[i];
			c.width = (this.width * c.ssx + ssxmax - 1) / ssxmax | 0;
			c.stride = c.width + 7 & 2147483640;
			c.height = (this.height * c.ssy + ssymax - 1) / ssymax | 0;
			c.stride = this.mbwidth * this.mbsizex * c.ssx / ssxmax | 0;
			if(c.width < 3 && c.ssx != ssxmax || c.height < 3 && c.ssy != ssymax) {
				this.notSupported();
			}
			c.pixels = new haxe_io_Bytes(new ArrayBuffer(c.stride * (this.mbheight * this.mbsizey * c.ssy / ssymax | 0)));
		}
		var count = this.length;
		this.pos += count;
		this.size -= count;
		this.length -= count;
		if(this.size < 0) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
	}
	,njDecodeDQT: function() {
		if(this.size < 2) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		this.length = this.bytes.b[this.pos] << 8 | this.bytes.b[this.pos + 1];
		if(this.length > this.size) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		this.pos += 2;
		this.size -= 2;
		this.length -= 2;
		if(this.size < 0) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		while(this.length >= 65) {
			var i = this.bytes.b[this.pos];
			if((i & 252) != 0) {
				throw haxe_Exception.thrown("Invalid JPEG file");
			}
			this.qtavail |= 1 << i;
			var t = this.qtab[i];
			var _g = 0;
			while(_g < 64) {
				var k = _g++;
				t[k] = this.bytes.b[this.pos + (k + 1)];
			}
			this.pos += 65;
			this.size -= 65;
			this.length -= 65;
			if(this.size < 0) {
				throw haxe_Exception.thrown("Invalid JPEG file");
			}
		}
		if(this.length != 0) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
	}
	,njDecodeDHT: function() {
		if(this.size < 2) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		this.length = this.bytes.b[this.pos] << 8 | this.bytes.b[this.pos + 1];
		if(this.length > this.size) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		this.pos += 2;
		this.size -= 2;
		this.length -= 2;
		if(this.size < 0) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		while(this.length >= 17) {
			var i = this.bytes.b[this.pos];
			if((i & 236) != 0) {
				throw haxe_Exception.thrown("Invalid JPEG file");
			}
			i = i >> 4 & 1 | (i & 3) << 1;
			this.counts[0] = this.bytes.b[this.pos + 1];
			this.counts[1] = this.bytes.b[this.pos + 2];
			this.counts[2] = this.bytes.b[this.pos + 3];
			this.counts[3] = this.bytes.b[this.pos + 4];
			this.counts[4] = this.bytes.b[this.pos + 5];
			this.counts[5] = this.bytes.b[this.pos + 6];
			this.counts[6] = this.bytes.b[this.pos + 7];
			this.counts[7] = this.bytes.b[this.pos + 8];
			this.counts[8] = this.bytes.b[this.pos + 9];
			this.counts[9] = this.bytes.b[this.pos + 10];
			this.counts[10] = this.bytes.b[this.pos + 11];
			this.counts[11] = this.bytes.b[this.pos + 12];
			this.counts[12] = this.bytes.b[this.pos + 13];
			this.counts[13] = this.bytes.b[this.pos + 14];
			this.counts[14] = this.bytes.b[this.pos + 15];
			this.counts[15] = this.bytes.b[this.pos + 16];
			this.pos += 17;
			this.size -= 17;
			this.length -= 17;
			if(this.size < 0) {
				throw haxe_Exception.thrown("Invalid JPEG file");
			}
			var vlc = this.vlctab[i];
			var vpos = 0;
			var remain = 65536;
			var spread = 65536;
			var _g = 1;
			while(_g < 17) {
				var codelen = _g++;
				spread >>= 1;
				var currcnt = this.counts[codelen - 1];
				if(currcnt == 0) {
					continue;
				}
				if(this.length < currcnt) {
					throw haxe_Exception.thrown("Invalid JPEG file");
				}
				remain -= currcnt << 16 - codelen;
				if(remain < 0) {
					throw haxe_Exception.thrown("Invalid JPEG file");
				}
				var _g1 = 0;
				var _g2 = currcnt;
				while(_g1 < _g2) {
					var i1 = _g1++;
					var code = this.bytes.b[this.pos + i1];
					var _g3 = 0;
					var _g4 = spread;
					while(_g3 < _g4) {
						var j = _g3++;
						vlc.b[vpos++] = codelen;
						vlc.b[vpos++] = code;
					}
				}
				this.pos += currcnt;
				this.size -= currcnt;
				this.length -= currcnt;
				if(this.size < 0) {
					throw haxe_Exception.thrown("Invalid JPEG file");
				}
			}
			while(remain-- != 0) {
				vlc.b[vpos] = 0;
				vpos += 2;
			}
		}
		if(this.length != 0) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
	}
	,njDecodeDRI: function() {
		if(this.size < 2) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		this.length = this.bytes.b[this.pos] << 8 | this.bytes.b[this.pos + 1];
		if(this.length > this.size) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		this.pos += 2;
		this.size -= 2;
		this.length -= 2;
		if(this.size < 0) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		if(this.length < 2) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		this.rstinterval = this.bytes.b[this.pos] << 8 | this.bytes.b[this.pos + 1];
		var count = this.length;
		this.pos += count;
		this.size -= count;
		this.length -= count;
		if(this.size < 0) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
	}
	,njGetVLC: function(vlc) {
		var value = this.njShowBits(16);
		var bits = vlc.b[value << 1];
		if(bits == 0) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		if(this.bufbits < bits) {
			this.njShowBits(bits);
		}
		this.bufbits -= bits;
		value = vlc.b[value << 1 | 1];
		this.vlcCode = value;
		bits = value & 15;
		if(bits == 0) {
			return 0;
		}
		var r = this.njShowBits(bits);
		this.bufbits -= bits;
		value = r;
		if(value < 1 << bits - 1) {
			value += (-1 << bits) + 1;
		}
		return value;
	}
	,njRowIDCT: function(bp) {
		var x1 = this.block[bp + 4] << 11;
		var x2 = this.block[bp + 6];
		var x3 = this.block[bp + 2];
		var x4 = this.block[bp + 1];
		var x5 = this.block[bp + 7];
		var x6 = this.block[bp + 5];
		var x7 = this.block[bp + 3];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var val = this.block[bp + 7] = this.block[bp] << 3;
			var val1 = this.block[bp + 6] = val;
			var val = this.block[bp + 5] = val1;
			var val1 = this.block[bp + 4] = val;
			var val = this.block[bp + 3] = val1;
			var val1 = this.block[bp + 2] = val;
			var val = this.block[bp + 1] = val1;
			this.block[bp] = val;
			return;
		}
		var x0 = (this.block[bp] << 11) + 128;
		var x8 = 565 * (x4 + x5);
		x4 = x8 + 2276 * x4;
		x5 = x8 - 3406 * x5;
		x8 = 2408 * (x6 + x7);
		x6 = x8 - 799 * x6;
		x7 = x8 - 4017 * x7;
		x8 = x0 + x1;
		x0 -= x1;
		x1 = 1108 * (x3 + x2);
		x2 = x1 - 3784 * x2;
		x3 = x1 + 1568 * x3;
		x1 = x4 + x6;
		x4 -= x6;
		x6 = x5 + x7;
		x5 -= x7;
		x7 = x8 + x3;
		x8 -= x3;
		x3 = x0 + x2;
		x0 -= x2;
		x2 = 181 * (x4 + x5) + 128 >> 8;
		x4 = 181 * (x4 - x5) + 128 >> 8;
		this.block[bp] = x7 + x1 >> 8;
		this.block[bp + 1] = x3 + x2 >> 8;
		this.block[bp + 2] = x0 + x4 >> 8;
		this.block[bp + 3] = x8 + x6 >> 8;
		this.block[bp + 4] = x8 - x6 >> 8;
		this.block[bp + 5] = x0 - x4 >> 8;
		this.block[bp + 6] = x3 - x2 >> 8;
		this.block[bp + 7] = x7 - x1 >> 8;
	}
	,njColIDCT: function(bp,out,po,stride) {
		var x1 = this.block[bp + 32] << 8;
		var x2 = this.block[bp + 48];
		var x3 = this.block[bp + 16];
		var x4 = this.block[bp + 8];
		var x5 = this.block[bp + 56];
		var x6 = this.block[bp + 40];
		var x7 = this.block[bp + 24];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var x = (this.block[bp] + 32 >> 6) + 128;
			x1 = x < 0 ? 0 : x > 255 ? 255 : x;
			out.b[po] = x1;
			po += stride;
			out.b[po] = x1;
			po += stride;
			out.b[po] = x1;
			po += stride;
			out.b[po] = x1;
			po += stride;
			out.b[po] = x1;
			po += stride;
			out.b[po] = x1;
			po += stride;
			out.b[po] = x1;
			po += stride;
			out.b[po] = x1;
			po += stride;
			return;
		}
		var x0 = (this.block[bp] << 8) + 8192;
		var x8 = 565 * (x4 + x5) + 4;
		x4 = x8 + 2276 * x4 >> 3;
		x5 = x8 - 3406 * x5 >> 3;
		x8 = 2408 * (x6 + x7) + 4;
		x6 = x8 - 799 * x6 >> 3;
		x7 = x8 - 4017 * x7 >> 3;
		x8 = x0 + x1;
		x0 -= x1;
		x1 = 1108 * (x3 + x2) + 4;
		x2 = x1 - 3784 * x2 >> 3;
		x3 = x1 + 1568 * x3 >> 3;
		x1 = x4 + x6;
		x4 -= x6;
		x6 = x5 + x7;
		x5 -= x7;
		x7 = x8 + x3;
		x8 -= x3;
		x3 = x0 + x2;
		x0 -= x2;
		x2 = 181 * (x4 + x5) + 128 >> 8;
		x4 = 181 * (x4 - x5) + 128 >> 8;
		var x = (x7 + x1 >> 14) + 128;
		out.b[po] = x < 0 ? 0 : x > 255 ? 255 : x;
		po += stride;
		var x = (x3 + x2 >> 14) + 128;
		out.b[po] = x < 0 ? 0 : x > 255 ? 255 : x;
		po += stride;
		var x = (x0 + x4 >> 14) + 128;
		out.b[po] = x < 0 ? 0 : x > 255 ? 255 : x;
		po += stride;
		var x = (x8 + x6 >> 14) + 128;
		out.b[po] = x < 0 ? 0 : x > 255 ? 255 : x;
		po += stride;
		var x = (x8 - x6 >> 14) + 128;
		out.b[po] = x < 0 ? 0 : x > 255 ? 255 : x;
		po += stride;
		var x = (x0 - x4 >> 14) + 128;
		out.b[po] = x < 0 ? 0 : x > 255 ? 255 : x;
		po += stride;
		var x = (x3 - x2 >> 14) + 128;
		out.b[po] = x < 0 ? 0 : x > 255 ? 255 : x;
		po += stride;
		var x = (x7 - x1 >> 14) + 128;
		out.b[po] = x < 0 ? 0 : x > 255 ? 255 : x;
	}
	,njDecodeBlock: function(c,po) {
		var out = c.pixels;
		var value;
		var coef = 0;
		var _g = 0;
		while(_g < 64) {
			var i = _g++;
			this.block[i] = 0;
		}
		var c1 = c;
		var c2 = c1.dcpred;
		var vlc = this.vlctab[c.dctabsel];
		var value1 = this.njShowBits(16);
		var bits = vlc.b[value1 << 1];
		if(bits == 0) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		if(this.bufbits < bits) {
			this.njShowBits(bits);
		}
		this.bufbits -= bits;
		value1 = vlc.b[value1 << 1 | 1];
		this.vlcCode = value1;
		bits = value1 & 15;
		var tmp;
		if(bits == 0) {
			tmp = 0;
		} else {
			var r = this.njShowBits(bits);
			this.bufbits -= bits;
			value1 = r;
			if(value1 < 1 << bits - 1) {
				value1 += (-1 << bits) + 1;
			}
			tmp = value1;
		}
		c1.dcpred = c2 + tmp;
		var qt = this.qtab[c.qtsel];
		var at = this.vlctab[c.actabsel];
		this.block[0] = c.dcpred * qt[0];
		do {
			var value1 = this.njShowBits(16);
			var bits = at.b[value1 << 1];
			if(bits == 0) {
				throw haxe_Exception.thrown("Invalid JPEG file");
			}
			if(this.bufbits < bits) {
				this.njShowBits(bits);
			}
			this.bufbits -= bits;
			value1 = at.b[value1 << 1 | 1];
			this.vlcCode = value1;
			bits = value1 & 15;
			if(bits == 0) {
				value = 0;
			} else {
				var r = this.njShowBits(bits);
				this.bufbits -= bits;
				value1 = r;
				if(value1 < 1 << bits - 1) {
					value1 += (-1 << bits) + 1;
				}
				value = value1;
			}
			if(this.vlcCode == 0) {
				break;
			}
			if((this.vlcCode & 15) == 0 && this.vlcCode != 240) {
				throw haxe_Exception.thrown("Invalid JPEG file");
			}
			coef += (this.vlcCode >> 4) + 1;
			if(coef > 63) {
				throw haxe_Exception.thrown("Invalid JPEG file");
			}
			this.block[this.njZZ[coef]] = value * qt[coef];
		} while(coef < 63);
		var bp = 0;
		var x0;
		var x8;
		var x1 = this.block[bp + 4] << 11;
		var x2 = this.block[bp + 6];
		var x3 = this.block[bp + 2];
		var x4 = this.block[bp + 1];
		var x5 = this.block[bp + 7];
		var x6 = this.block[bp + 5];
		var x7 = this.block[bp + 3];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var val = this.block[bp + 7] = this.block[bp] << 3;
			var val1 = this.block[bp + 6] = val;
			var val = this.block[bp + 5] = val1;
			var val1 = this.block[bp + 4] = val;
			var val = this.block[bp + 3] = val1;
			var val1 = this.block[bp + 2] = val;
			var val = this.block[bp + 1] = val1;
			this.block[bp] = val;
		} else {
			x0 = (this.block[bp] << 11) + 128;
			x8 = 565 * (x4 + x5);
			x4 = x8 + 2276 * x4;
			x5 = x8 - 3406 * x5;
			x8 = 2408 * (x6 + x7);
			x6 = x8 - 799 * x6;
			x7 = x8 - 4017 * x7;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2);
			x2 = x1 - 3784 * x2;
			x3 = x1 + 1568 * x3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			this.block[bp] = x7 + x1 >> 8;
			this.block[bp + 1] = x3 + x2 >> 8;
			this.block[bp + 2] = x0 + x4 >> 8;
			this.block[bp + 3] = x8 + x6 >> 8;
			this.block[bp + 4] = x8 - x6 >> 8;
			this.block[bp + 5] = x0 - x4 >> 8;
			this.block[bp + 6] = x3 - x2 >> 8;
			this.block[bp + 7] = x7 - x1 >> 8;
		}
		var bp = 8;
		var x0;
		var x8;
		var x1 = this.block[bp + 4] << 11;
		var x2 = this.block[bp + 6];
		var x3 = this.block[bp + 2];
		var x4 = this.block[bp + 1];
		var x5 = this.block[bp + 7];
		var x6 = this.block[bp + 5];
		var x7 = this.block[bp + 3];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var val = this.block[bp + 7] = this.block[bp] << 3;
			var val1 = this.block[bp + 6] = val;
			var val = this.block[bp + 5] = val1;
			var val1 = this.block[bp + 4] = val;
			var val = this.block[bp + 3] = val1;
			var val1 = this.block[bp + 2] = val;
			var val = this.block[bp + 1] = val1;
			this.block[bp] = val;
		} else {
			x0 = (this.block[bp] << 11) + 128;
			x8 = 565 * (x4 + x5);
			x4 = x8 + 2276 * x4;
			x5 = x8 - 3406 * x5;
			x8 = 2408 * (x6 + x7);
			x6 = x8 - 799 * x6;
			x7 = x8 - 4017 * x7;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2);
			x2 = x1 - 3784 * x2;
			x3 = x1 + 1568 * x3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			this.block[bp] = x7 + x1 >> 8;
			this.block[bp + 1] = x3 + x2 >> 8;
			this.block[bp + 2] = x0 + x4 >> 8;
			this.block[bp + 3] = x8 + x6 >> 8;
			this.block[bp + 4] = x8 - x6 >> 8;
			this.block[bp + 5] = x0 - x4 >> 8;
			this.block[bp + 6] = x3 - x2 >> 8;
			this.block[bp + 7] = x7 - x1 >> 8;
		}
		var bp = 16;
		var x0;
		var x8;
		var x1 = this.block[bp + 4] << 11;
		var x2 = this.block[bp + 6];
		var x3 = this.block[bp + 2];
		var x4 = this.block[bp + 1];
		var x5 = this.block[bp + 7];
		var x6 = this.block[bp + 5];
		var x7 = this.block[bp + 3];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var val = this.block[bp + 7] = this.block[bp] << 3;
			var val1 = this.block[bp + 6] = val;
			var val = this.block[bp + 5] = val1;
			var val1 = this.block[bp + 4] = val;
			var val = this.block[bp + 3] = val1;
			var val1 = this.block[bp + 2] = val;
			var val = this.block[bp + 1] = val1;
			this.block[bp] = val;
		} else {
			x0 = (this.block[bp] << 11) + 128;
			x8 = 565 * (x4 + x5);
			x4 = x8 + 2276 * x4;
			x5 = x8 - 3406 * x5;
			x8 = 2408 * (x6 + x7);
			x6 = x8 - 799 * x6;
			x7 = x8 - 4017 * x7;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2);
			x2 = x1 - 3784 * x2;
			x3 = x1 + 1568 * x3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			this.block[bp] = x7 + x1 >> 8;
			this.block[bp + 1] = x3 + x2 >> 8;
			this.block[bp + 2] = x0 + x4 >> 8;
			this.block[bp + 3] = x8 + x6 >> 8;
			this.block[bp + 4] = x8 - x6 >> 8;
			this.block[bp + 5] = x0 - x4 >> 8;
			this.block[bp + 6] = x3 - x2 >> 8;
			this.block[bp + 7] = x7 - x1 >> 8;
		}
		var bp = 24;
		var x0;
		var x8;
		var x1 = this.block[bp + 4] << 11;
		var x2 = this.block[bp + 6];
		var x3 = this.block[bp + 2];
		var x4 = this.block[bp + 1];
		var x5 = this.block[bp + 7];
		var x6 = this.block[bp + 5];
		var x7 = this.block[bp + 3];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var val = this.block[bp + 7] = this.block[bp] << 3;
			var val1 = this.block[bp + 6] = val;
			var val = this.block[bp + 5] = val1;
			var val1 = this.block[bp + 4] = val;
			var val = this.block[bp + 3] = val1;
			var val1 = this.block[bp + 2] = val;
			var val = this.block[bp + 1] = val1;
			this.block[bp] = val;
		} else {
			x0 = (this.block[bp] << 11) + 128;
			x8 = 565 * (x4 + x5);
			x4 = x8 + 2276 * x4;
			x5 = x8 - 3406 * x5;
			x8 = 2408 * (x6 + x7);
			x6 = x8 - 799 * x6;
			x7 = x8 - 4017 * x7;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2);
			x2 = x1 - 3784 * x2;
			x3 = x1 + 1568 * x3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			this.block[bp] = x7 + x1 >> 8;
			this.block[bp + 1] = x3 + x2 >> 8;
			this.block[bp + 2] = x0 + x4 >> 8;
			this.block[bp + 3] = x8 + x6 >> 8;
			this.block[bp + 4] = x8 - x6 >> 8;
			this.block[bp + 5] = x0 - x4 >> 8;
			this.block[bp + 6] = x3 - x2 >> 8;
			this.block[bp + 7] = x7 - x1 >> 8;
		}
		var bp = 32;
		var x0;
		var x8;
		var x1 = this.block[bp + 4] << 11;
		var x2 = this.block[bp + 6];
		var x3 = this.block[bp + 2];
		var x4 = this.block[bp + 1];
		var x5 = this.block[bp + 7];
		var x6 = this.block[bp + 5];
		var x7 = this.block[bp + 3];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var val = this.block[bp + 7] = this.block[bp] << 3;
			var val1 = this.block[bp + 6] = val;
			var val = this.block[bp + 5] = val1;
			var val1 = this.block[bp + 4] = val;
			var val = this.block[bp + 3] = val1;
			var val1 = this.block[bp + 2] = val;
			var val = this.block[bp + 1] = val1;
			this.block[bp] = val;
		} else {
			x0 = (this.block[bp] << 11) + 128;
			x8 = 565 * (x4 + x5);
			x4 = x8 + 2276 * x4;
			x5 = x8 - 3406 * x5;
			x8 = 2408 * (x6 + x7);
			x6 = x8 - 799 * x6;
			x7 = x8 - 4017 * x7;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2);
			x2 = x1 - 3784 * x2;
			x3 = x1 + 1568 * x3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			this.block[bp] = x7 + x1 >> 8;
			this.block[bp + 1] = x3 + x2 >> 8;
			this.block[bp + 2] = x0 + x4 >> 8;
			this.block[bp + 3] = x8 + x6 >> 8;
			this.block[bp + 4] = x8 - x6 >> 8;
			this.block[bp + 5] = x0 - x4 >> 8;
			this.block[bp + 6] = x3 - x2 >> 8;
			this.block[bp + 7] = x7 - x1 >> 8;
		}
		var bp = 40;
		var x0;
		var x8;
		var x1 = this.block[bp + 4] << 11;
		var x2 = this.block[bp + 6];
		var x3 = this.block[bp + 2];
		var x4 = this.block[bp + 1];
		var x5 = this.block[bp + 7];
		var x6 = this.block[bp + 5];
		var x7 = this.block[bp + 3];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var val = this.block[bp + 7] = this.block[bp] << 3;
			var val1 = this.block[bp + 6] = val;
			var val = this.block[bp + 5] = val1;
			var val1 = this.block[bp + 4] = val;
			var val = this.block[bp + 3] = val1;
			var val1 = this.block[bp + 2] = val;
			var val = this.block[bp + 1] = val1;
			this.block[bp] = val;
		} else {
			x0 = (this.block[bp] << 11) + 128;
			x8 = 565 * (x4 + x5);
			x4 = x8 + 2276 * x4;
			x5 = x8 - 3406 * x5;
			x8 = 2408 * (x6 + x7);
			x6 = x8 - 799 * x6;
			x7 = x8 - 4017 * x7;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2);
			x2 = x1 - 3784 * x2;
			x3 = x1 + 1568 * x3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			this.block[bp] = x7 + x1 >> 8;
			this.block[bp + 1] = x3 + x2 >> 8;
			this.block[bp + 2] = x0 + x4 >> 8;
			this.block[bp + 3] = x8 + x6 >> 8;
			this.block[bp + 4] = x8 - x6 >> 8;
			this.block[bp + 5] = x0 - x4 >> 8;
			this.block[bp + 6] = x3 - x2 >> 8;
			this.block[bp + 7] = x7 - x1 >> 8;
		}
		var bp = 48;
		var x0;
		var x8;
		var x1 = this.block[bp + 4] << 11;
		var x2 = this.block[bp + 6];
		var x3 = this.block[bp + 2];
		var x4 = this.block[bp + 1];
		var x5 = this.block[bp + 7];
		var x6 = this.block[bp + 5];
		var x7 = this.block[bp + 3];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var val = this.block[bp + 7] = this.block[bp] << 3;
			var val1 = this.block[bp + 6] = val;
			var val = this.block[bp + 5] = val1;
			var val1 = this.block[bp + 4] = val;
			var val = this.block[bp + 3] = val1;
			var val1 = this.block[bp + 2] = val;
			var val = this.block[bp + 1] = val1;
			this.block[bp] = val;
		} else {
			x0 = (this.block[bp] << 11) + 128;
			x8 = 565 * (x4 + x5);
			x4 = x8 + 2276 * x4;
			x5 = x8 - 3406 * x5;
			x8 = 2408 * (x6 + x7);
			x6 = x8 - 799 * x6;
			x7 = x8 - 4017 * x7;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2);
			x2 = x1 - 3784 * x2;
			x3 = x1 + 1568 * x3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			this.block[bp] = x7 + x1 >> 8;
			this.block[bp + 1] = x3 + x2 >> 8;
			this.block[bp + 2] = x0 + x4 >> 8;
			this.block[bp + 3] = x8 + x6 >> 8;
			this.block[bp + 4] = x8 - x6 >> 8;
			this.block[bp + 5] = x0 - x4 >> 8;
			this.block[bp + 6] = x3 - x2 >> 8;
			this.block[bp + 7] = x7 - x1 >> 8;
		}
		var bp = 56;
		var x0;
		var x8;
		var x1 = this.block[bp + 4] << 11;
		var x2 = this.block[bp + 6];
		var x3 = this.block[bp + 2];
		var x4 = this.block[bp + 1];
		var x5 = this.block[bp + 7];
		var x6 = this.block[bp + 5];
		var x7 = this.block[bp + 3];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var val = this.block[bp + 7] = this.block[bp] << 3;
			var val1 = this.block[bp + 6] = val;
			var val = this.block[bp + 5] = val1;
			var val1 = this.block[bp + 4] = val;
			var val = this.block[bp + 3] = val1;
			var val1 = this.block[bp + 2] = val;
			var val = this.block[bp + 1] = val1;
			this.block[bp] = val;
		} else {
			x0 = (this.block[bp] << 11) + 128;
			x8 = 565 * (x4 + x5);
			x4 = x8 + 2276 * x4;
			x5 = x8 - 3406 * x5;
			x8 = 2408 * (x6 + x7);
			x6 = x8 - 799 * x6;
			x7 = x8 - 4017 * x7;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2);
			x2 = x1 - 3784 * x2;
			x3 = x1 + 1568 * x3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			this.block[bp] = x7 + x1 >> 8;
			this.block[bp + 1] = x3 + x2 >> 8;
			this.block[bp + 2] = x0 + x4 >> 8;
			this.block[bp + 3] = x8 + x6 >> 8;
			this.block[bp + 4] = x8 - x6 >> 8;
			this.block[bp + 5] = x0 - x4 >> 8;
			this.block[bp + 6] = x3 - x2 >> 8;
			this.block[bp + 7] = x7 - x1 >> 8;
		}
		var po1 = po;
		var stride = c.stride;
		var x0;
		var x8;
		var x1 = this.block[32] << 8;
		var x2 = this.block[48];
		var x3 = this.block[16];
		var x4 = this.block[8];
		var x5 = this.block[56];
		var x6 = this.block[40];
		var x7 = this.block[24];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var x = (this.block[0] + 32 >> 6) + 128;
			x1 = x < 0 ? 0 : x > 255 ? 255 : x;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
		} else {
			x0 = (this.block[0] << 8) + 8192;
			x8 = 565 * (x4 + x5) + 4;
			x4 = x8 + 2276 * x4 >> 3;
			x5 = x8 - 3406 * x5 >> 3;
			x8 = 2408 * (x6 + x7) + 4;
			x6 = x8 - 799 * x6 >> 3;
			x7 = x8 - 4017 * x7 >> 3;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2) + 4;
			x2 = x1 - 3784 * x2 >> 3;
			x3 = x1 + 1568 * x3 >> 3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			var x = (x7 + x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 + x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 + x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 + x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 - x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 - x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 - x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x7 - x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
		}
		var po1 = 1 + po;
		var stride = c.stride;
		var x0;
		var x8;
		var x1 = this.block[33] << 8;
		var x2 = this.block[49];
		var x3 = this.block[17];
		var x4 = this.block[9];
		var x5 = this.block[57];
		var x6 = this.block[41];
		var x7 = this.block[25];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var x = (this.block[1] + 32 >> 6) + 128;
			x1 = x < 0 ? 0 : x > 255 ? 255 : x;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
		} else {
			x0 = (this.block[1] << 8) + 8192;
			x8 = 565 * (x4 + x5) + 4;
			x4 = x8 + 2276 * x4 >> 3;
			x5 = x8 - 3406 * x5 >> 3;
			x8 = 2408 * (x6 + x7) + 4;
			x6 = x8 - 799 * x6 >> 3;
			x7 = x8 - 4017 * x7 >> 3;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2) + 4;
			x2 = x1 - 3784 * x2 >> 3;
			x3 = x1 + 1568 * x3 >> 3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			var x = (x7 + x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 + x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 + x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 + x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 - x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 - x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 - x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x7 - x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
		}
		var po1 = 2 + po;
		var stride = c.stride;
		var x0;
		var x8;
		var x1 = this.block[34] << 8;
		var x2 = this.block[50];
		var x3 = this.block[18];
		var x4 = this.block[10];
		var x5 = this.block[58];
		var x6 = this.block[42];
		var x7 = this.block[26];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var x = (this.block[2] + 32 >> 6) + 128;
			x1 = x < 0 ? 0 : x > 255 ? 255 : x;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
		} else {
			x0 = (this.block[2] << 8) + 8192;
			x8 = 565 * (x4 + x5) + 4;
			x4 = x8 + 2276 * x4 >> 3;
			x5 = x8 - 3406 * x5 >> 3;
			x8 = 2408 * (x6 + x7) + 4;
			x6 = x8 - 799 * x6 >> 3;
			x7 = x8 - 4017 * x7 >> 3;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2) + 4;
			x2 = x1 - 3784 * x2 >> 3;
			x3 = x1 + 1568 * x3 >> 3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			var x = (x7 + x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 + x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 + x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 + x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 - x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 - x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 - x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x7 - x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
		}
		var po1 = 3 + po;
		var stride = c.stride;
		var x0;
		var x8;
		var x1 = this.block[35] << 8;
		var x2 = this.block[51];
		var x3 = this.block[19];
		var x4 = this.block[11];
		var x5 = this.block[59];
		var x6 = this.block[43];
		var x7 = this.block[27];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var x = (this.block[3] + 32 >> 6) + 128;
			x1 = x < 0 ? 0 : x > 255 ? 255 : x;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
		} else {
			x0 = (this.block[3] << 8) + 8192;
			x8 = 565 * (x4 + x5) + 4;
			x4 = x8 + 2276 * x4 >> 3;
			x5 = x8 - 3406 * x5 >> 3;
			x8 = 2408 * (x6 + x7) + 4;
			x6 = x8 - 799 * x6 >> 3;
			x7 = x8 - 4017 * x7 >> 3;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2) + 4;
			x2 = x1 - 3784 * x2 >> 3;
			x3 = x1 + 1568 * x3 >> 3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			var x = (x7 + x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 + x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 + x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 + x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 - x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 - x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 - x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x7 - x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
		}
		var po1 = 4 + po;
		var stride = c.stride;
		var x0;
		var x8;
		var x1 = this.block[36] << 8;
		var x2 = this.block[52];
		var x3 = this.block[20];
		var x4 = this.block[12];
		var x5 = this.block[60];
		var x6 = this.block[44];
		var x7 = this.block[28];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var x = (this.block[4] + 32 >> 6) + 128;
			x1 = x < 0 ? 0 : x > 255 ? 255 : x;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
		} else {
			x0 = (this.block[4] << 8) + 8192;
			x8 = 565 * (x4 + x5) + 4;
			x4 = x8 + 2276 * x4 >> 3;
			x5 = x8 - 3406 * x5 >> 3;
			x8 = 2408 * (x6 + x7) + 4;
			x6 = x8 - 799 * x6 >> 3;
			x7 = x8 - 4017 * x7 >> 3;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2) + 4;
			x2 = x1 - 3784 * x2 >> 3;
			x3 = x1 + 1568 * x3 >> 3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			var x = (x7 + x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 + x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 + x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 + x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 - x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 - x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 - x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x7 - x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
		}
		var po1 = 5 + po;
		var stride = c.stride;
		var x0;
		var x8;
		var x1 = this.block[37] << 8;
		var x2 = this.block[53];
		var x3 = this.block[21];
		var x4 = this.block[13];
		var x5 = this.block[61];
		var x6 = this.block[45];
		var x7 = this.block[29];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var x = (this.block[5] + 32 >> 6) + 128;
			x1 = x < 0 ? 0 : x > 255 ? 255 : x;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
		} else {
			x0 = (this.block[5] << 8) + 8192;
			x8 = 565 * (x4 + x5) + 4;
			x4 = x8 + 2276 * x4 >> 3;
			x5 = x8 - 3406 * x5 >> 3;
			x8 = 2408 * (x6 + x7) + 4;
			x6 = x8 - 799 * x6 >> 3;
			x7 = x8 - 4017 * x7 >> 3;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2) + 4;
			x2 = x1 - 3784 * x2 >> 3;
			x3 = x1 + 1568 * x3 >> 3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			var x = (x7 + x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 + x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 + x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 + x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 - x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 - x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 - x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x7 - x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
		}
		var po1 = 6 + po;
		var stride = c.stride;
		var x0;
		var x8;
		var x1 = this.block[38] << 8;
		var x2 = this.block[54];
		var x3 = this.block[22];
		var x4 = this.block[14];
		var x5 = this.block[62];
		var x6 = this.block[46];
		var x7 = this.block[30];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var x = (this.block[6] + 32 >> 6) + 128;
			x1 = x < 0 ? 0 : x > 255 ? 255 : x;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
		} else {
			x0 = (this.block[6] << 8) + 8192;
			x8 = 565 * (x4 + x5) + 4;
			x4 = x8 + 2276 * x4 >> 3;
			x5 = x8 - 3406 * x5 >> 3;
			x8 = 2408 * (x6 + x7) + 4;
			x6 = x8 - 799 * x6 >> 3;
			x7 = x8 - 4017 * x7 >> 3;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2) + 4;
			x2 = x1 - 3784 * x2 >> 3;
			x3 = x1 + 1568 * x3 >> 3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			var x = (x7 + x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 + x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 + x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 + x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 - x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 - x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 - x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x7 - x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
		}
		var po1 = 7 + po;
		var stride = c.stride;
		var x0;
		var x8;
		var x1 = this.block[39] << 8;
		var x2 = this.block[55];
		var x3 = this.block[23];
		var x4 = this.block[15];
		var x5 = this.block[63];
		var x6 = this.block[47];
		var x7 = this.block[31];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var x = (this.block[7] + 32 >> 6) + 128;
			x1 = x < 0 ? 0 : x > 255 ? 255 : x;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
		} else {
			x0 = (this.block[7] << 8) + 8192;
			x8 = 565 * (x4 + x5) + 4;
			x4 = x8 + 2276 * x4 >> 3;
			x5 = x8 - 3406 * x5 >> 3;
			x8 = 2408 * (x6 + x7) + 4;
			x6 = x8 - 799 * x6 >> 3;
			x7 = x8 - 4017 * x7 >> 3;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2) + 4;
			x2 = x1 - 3784 * x2 >> 3;
			x3 = x1 + 1568 * x3 >> 3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			var x = (x7 + x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 + x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 + x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 + x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 - x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 - x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 - x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x7 - x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
		}
	}
	,notSupported: function() {
		throw haxe_Exception.thrown("This JPG file is not supported");
	}
	,njDecodeScan: function() {
		if(this.size < 2) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		this.length = this.bytes.b[this.pos] << 8 | this.bytes.b[this.pos + 1];
		if(this.length > this.size) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		this.pos += 2;
		this.size -= 2;
		this.length -= 2;
		if(this.size < 0) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		if(this.length < 4 + 2 * this.ncomp) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		if(this.bytes.b[this.pos] != this.ncomp) {
			this.notSupported();
		}
		this.pos += 1;
		this.size -= 1;
		this.length -= 1;
		if(this.size < 0) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		var _g = 0;
		var _g1 = this.ncomp;
		while(_g < _g1) {
			var i = _g++;
			var c = this.comps[i];
			if(this.bytes.b[this.pos] != c.cid) {
				throw haxe_Exception.thrown("Invalid JPEG file");
			}
			if((this.bytes.b[this.pos + 1] & 236) != 0) {
				throw haxe_Exception.thrown("Invalid JPEG file");
			}
			c.dctabsel = this.bytes.b[this.pos + 1] >> 4 << 1;
			c.actabsel = (this.bytes.b[this.pos + 1] & 3) << 1 | 1;
			this.pos += 2;
			this.size -= 2;
			this.length -= 2;
			if(this.size < 0) {
				throw haxe_Exception.thrown("Invalid JPEG file");
			}
		}
		var start = this.bytes.b[this.pos];
		var count = this.bytes.b[this.pos + 1];
		var other = this.bytes.b[this.pos + 2];
		if(!this.progressive && start != 0 || count != 63 - start || other != 0) {
			this.notSupported();
		}
		var count = this.length;
		this.pos += count;
		this.size -= count;
		this.length -= count;
		if(this.size < 0) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		var mbx = 0;
		var mby = 0;
		var rstcount = this.rstinterval;
		var nextrst = 0;
		while(true) {
			var _g = 0;
			var _g1 = this.ncomp;
			while(_g < _g1) {
				var i = _g++;
				var c = this.comps[i];
				var _g2 = 0;
				var _g3 = c.ssy;
				while(_g2 < _g3) {
					var sby = _g2++;
					var _g4 = 0;
					var _g5 = c.ssx;
					while(_g4 < _g5) {
						var sbx = _g4++;
						this.njDecodeBlock(c,(mby * c.ssy + sby) * c.stride + mbx * c.ssx + sbx << 3);
					}
				}
			}
			if(++mbx >= this.mbwidth) {
				mbx = 0;
				if(++mby >= this.mbheight) {
					break;
				}
			}
			if(this.rstinterval != 0 && --rstcount == 0) {
				this.bufbits &= 248;
				var r = this.njShowBits(16);
				this.bufbits -= 16;
				var i1 = r;
				if((i1 & 65528) != 65488 || (i1 & 7) != nextrst) {
					throw haxe_Exception.thrown("Invalid JPEG file");
				}
				nextrst = nextrst + 1 & 7;
				rstcount = this.rstinterval;
				this.comps[0].dcpred = 0;
				this.comps[1].dcpred = 0;
				this.comps[2].dcpred = 0;
			}
		}
	}
	,njUpsampleH: function(c) {
		var xmax = c.width - 3;
		var cout = new haxe_io_Bytes(new ArrayBuffer(c.width * c.height << 1));
		var lout = cout;
		var lin = c.pixels;
		var pi = 0;
		var po = 0;
		var _g = 0;
		var _g1 = c.height;
		while(_g < _g1) {
			var y = _g++;
			var x = 139 * lin.b[pi] + -11 * lin.b[pi + 1] + 64 >> 7;
			lout.b[po] = x < 0 ? 0 : x > 255 ? 255 : x;
			var x1 = 104 * lin.b[pi] + 27 * lin.b[pi + 1] + -3 * lin.b[pi + 2] + 64 >> 7;
			lout.b[po + 1] = x1 < 0 ? 0 : x1 > 255 ? 255 : x1;
			var x2 = 28 * lin.b[pi] + 109 * lin.b[pi + 1] + -9 * lin.b[pi + 2] + 64 >> 7;
			lout.b[po + 2] = x2 < 0 ? 0 : x2 > 255 ? 255 : x2;
			var _g2 = 0;
			var _g3 = xmax;
			while(_g2 < _g3) {
				var x3 = _g2++;
				var x4 = -9 * lin.b[pi + x3] + 111 * lin.b[pi + x3 + 1] + 29 * lin.b[pi + x3 + 2] + -3 * lin.b[pi + x3 + 3] + 64 >> 7;
				lout.b[po + (x3 << 1) + 3] = x4 < 0 ? 0 : x4 > 255 ? 255 : x4;
				var x5 = -3 * lin.b[pi + x3] + 29 * lin.b[pi + x3 + 1] + 111 * lin.b[pi + x3 + 2] + -9 * lin.b[pi + x3 + 3] + 64 >> 7;
				lout.b[po + (x3 << 1) + 4] = x5 < 0 ? 0 : x5 > 255 ? 255 : x5;
			}
			pi += c.stride;
			po += c.width << 1;
			var x6 = 28 * lin.b[pi - 1] + 109 * lin.b[pi - 2] + -9 * lin.b[pi - 3] + 64 >> 7;
			lout.b[po - 3] = x6 < 0 ? 0 : x6 > 255 ? 255 : x6;
			var x7 = 104 * lin.b[pi - 1] + 27 * lin.b[pi - 2] + -3 * lin.b[pi - 3] + 64 >> 7;
			lout.b[po - 2] = x7 < 0 ? 0 : x7 > 255 ? 255 : x7;
			var x8 = 139 * lin.b[pi - 1] + -11 * lin.b[pi - 2] + 64 >> 7;
			lout.b[po - 1] = x8 < 0 ? 0 : x8 > 255 ? 255 : x8;
		}
		c.width <<= 1;
		c.stride = c.width;
		c.pixels = cout;
	}
	,njUpsampleV: function(c) {
		var w = c.width;
		var s1 = c.stride;
		var s2 = s1 + s1;
		var out = new haxe_io_Bytes(new ArrayBuffer(c.width * c.height << 1));
		var pi = 0;
		var po = 0;
		var cout = out;
		var cin = c.pixels;
		var _g = 0;
		var _g1 = w;
		while(_g < _g1) {
			var x = _g++;
			po = x;
			pi = po;
			var x1 = 139 * cin.b[pi] + -11 * cin.b[pi + s1] + 64 >> 7;
			cout.b[po] = x1 < 0 ? 0 : x1 > 255 ? 255 : x1;
			po += w;
			var x2 = 104 * cin.b[pi] + 27 * cin.b[pi + s1] + -3 * cin.b[pi + s2] + 64 >> 7;
			cout.b[po] = x2 < 0 ? 0 : x2 > 255 ? 255 : x2;
			po += w;
			var x3 = 28 * cin.b[pi] + 109 * cin.b[pi + s1] + -9 * cin.b[pi + s2] + 64 >> 7;
			cout.b[po] = x3 < 0 ? 0 : x3 > 255 ? 255 : x3;
			po += w;
			pi += s1;
			var _g2 = 0;
			var _g3 = c.height - 2;
			while(_g2 < _g3) {
				var y = _g2++;
				var x4 = -9 * cin.b[pi - s1] + 111 * cin.b[pi] + 29 * cin.b[pi + s1] + -3 * cin.b[pi + s2] + 64 >> 7;
				cout.b[po] = x4 < 0 ? 0 : x4 > 255 ? 255 : x4;
				po += w;
				var x5 = -3 * cin.b[pi - s1] + 29 * cin.b[pi] + 111 * cin.b[pi + s1] + -9 * cin.b[pi + s2] + 64 >> 7;
				cout.b[po] = x5 < 0 ? 0 : x5 > 255 ? 255 : x5;
				po += w;
				pi += s1;
			}
			pi += s1;
			var x6 = 28 * cin.b[pi] + 109 * cin.b[pi - s1] + -9 * cin.b[pi - s2] + 64 >> 7;
			cout.b[po] = x6 < 0 ? 0 : x6 > 255 ? 255 : x6;
			po += w;
			var x7 = 104 * cin.b[pi] + 27 * cin.b[pi - s1] + -3 * cin.b[pi - s2] + 64 >> 7;
			cout.b[po] = x7 < 0 ? 0 : x7 > 255 ? 255 : x7;
			po += w;
			var x8 = 139 * cin.b[pi] + -11 * cin.b[pi - s1] + 64 >> 7;
			cout.b[po] = x8 < 0 ? 0 : x8 > 255 ? 255 : x8;
		}
		c.height <<= 1;
		c.stride = c.width;
		c.pixels = out;
	}
	,njUpsample: function(c) {
		var xshift = 0;
		var yshift = 0;
		while(c.width < this.width) {
			c.width <<= 1;
			++xshift;
		}
		while(c.height < this.height) {
			c.height <<= 1;
			++yshift;
		}
		var out = new haxe_io_Bytes(new ArrayBuffer(c.width * c.height));
		var lin = c.pixels;
		var pout = 0;
		var lout = out;
		var _g = 0;
		var _g1 = c.height;
		while(_g < _g1) {
			var y = _g++;
			var pin = (y >> yshift) * c.stride;
			var _g2 = 0;
			var _g3 = c.width;
			while(_g2 < _g3) {
				var x = _g2++;
				lout.b[pout++] = lin.b[(x >> xshift) + pin];
			}
		}
		c.stride = c.width;
		c.pixels = out;
	}
	,njConvert: function() {
		var _g = 0;
		var _g1 = this.ncomp;
		while(_g < _g1) {
			var i = _g++;
			var c = this.comps[i];
			switch(this.filter._hx_index) {
			case 0:
				if(c.width < this.width || c.height < this.height) {
					this.njUpsample(c);
				}
				break;
			case 1:
				while(c.width < this.width || c.height < this.height) {
					if(c.width < this.width) {
						this.njUpsampleH(c);
					}
					if(c.height < this.height) {
						this.njUpsampleV(c);
					}
				}
				break;
			}
			if(c.width < this.width || c.height < this.height) {
				throw haxe_Exception.thrown("assert");
			}
		}
		var pixels = new haxe_io_Bytes(new ArrayBuffer(this.width * this.height * 4));
		if(this.ncomp == 3) {
			var py = this.comps[0].pixels;
			var pcb = this.comps[1].pixels;
			var pcr = this.comps[2].pixels;
			var pix = pixels;
			var k1 = 0;
			var k2 = 0;
			var k3 = 0;
			var out = 0;
			var _g = 0;
			var _g1 = this.height;
			while(_g < _g1) {
				var yy = _g++;
				var _g2 = 0;
				var _g3 = this.width;
				while(_g2 < _g3) {
					var x = _g2++;
					var y = py.b[k1++] << 8;
					var cb = pcb.b[k2++] - 128;
					var cr = pcr.b[k3++] - 128;
					var x1 = y + 359 * cr + 128 >> 8;
					var r = x1 < 0 ? 0 : x1 > 255 ? 255 : x1;
					var x2 = y - 88 * cb - 183 * cr + 128 >> 8;
					var g = x2 < 0 ? 0 : x2 > 255 ? 255 : x2;
					var x3 = y + 454 * cb + 128 >> 8;
					var b = x3 < 0 ? 0 : x3 > 255 ? 255 : x3;
					pix.b[out++] = b;
					pix.b[out++] = g;
					pix.b[out++] = r;
					pix.b[out++] = 255;
				}
				k1 += this.comps[0].stride - this.width;
				k2 += this.comps[1].stride - this.width;
				k3 += this.comps[2].stride - this.width;
			}
		} else {
			throw haxe_Exception.thrown("TODO");
		}
		return pixels;
	}
	,njDecode: function() {
		if(this.size < 2 || this.bytes.b[this.pos] != 255 || this.bytes.b[this.pos + 1] != 216) {
			throw haxe_Exception.thrown("This file is not a JPEG");
		}
		this.pos += 2;
		this.size -= 2;
		this.length -= 2;
		if(this.size < 0) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		_hx_loop1: while(true) {
			if(this.size < 2 || this.bytes.b[this.pos] != 255) {
				throw haxe_Exception.thrown("Invalid JPEG file");
			}
			this.pos += 2;
			this.size -= 2;
			this.length -= 2;
			if(this.size < 0) {
				throw haxe_Exception.thrown("Invalid JPEG file");
			}
			switch(this.bytes.b[this.pos + (-1)]) {
			case 192:
				this.njDecodeSOF();
				break;
			case 194:
				this.progressive = true;
				if(this.progressive) {
					throw haxe_Exception.thrown("Unsupported progressive JPG");
				}
				if(this.vlctab[4] == null) {
					this.vlctab[4] = new haxe_io_Bytes(new ArrayBuffer(131072));
				}
				if(this.vlctab[5] == null) {
					this.vlctab[5] = new haxe_io_Bytes(new ArrayBuffer(131072));
				}
				if(this.vlctab[6] == null) {
					this.vlctab[6] = new haxe_io_Bytes(new ArrayBuffer(131072));
				}
				if(this.vlctab[7] == null) {
					this.vlctab[7] = new haxe_io_Bytes(new ArrayBuffer(131072));
				}
				this.njDecodeSOF();
				break;
			case 195:
				throw haxe_Exception.thrown("Unsupported lossless JPG");
			case 196:
				this.njDecodeDHT();
				break;
			case 218:
				this.njDecodeScan();
				break _hx_loop1;
			case 219:
				this.njDecodeDQT();
				break;
			case 221:
				this.njDecodeDRI();
				break;
			case 254:
				if(this.size < 2) {
					throw haxe_Exception.thrown("Invalid JPEG file");
				}
				this.length = this.bytes.b[this.pos] << 8 | this.bytes.b[this.pos + 1];
				if(this.length > this.size) {
					throw haxe_Exception.thrown("Invalid JPEG file");
				}
				this.pos += 2;
				this.size -= 2;
				this.length -= 2;
				if(this.size < 0) {
					throw haxe_Exception.thrown("Invalid JPEG file");
				}
				var count = this.length;
				this.pos += count;
				this.size -= count;
				this.length -= count;
				if(this.size < 0) {
					throw haxe_Exception.thrown("Invalid JPEG file");
				}
				break;
			default:
				switch(this.bytes.b[this.pos + (-1)] & 240) {
				case 192:
					throw haxe_Exception.thrown("Unsupported jpeg type " + (this.bytes.b[this.pos + (-1)] & 15));
				case 224:
					if(this.size < 2) {
						throw haxe_Exception.thrown("Invalid JPEG file");
					}
					this.length = this.bytes.b[this.pos] << 8 | this.bytes.b[this.pos + 1];
					if(this.length > this.size) {
						throw haxe_Exception.thrown("Invalid JPEG file");
					}
					this.pos += 2;
					this.size -= 2;
					this.length -= 2;
					if(this.size < 0) {
						throw haxe_Exception.thrown("Invalid JPEG file");
					}
					var count1 = this.length;
					this.pos += count1;
					this.size -= count1;
					this.length -= count1;
					if(this.size < 0) {
						throw haxe_Exception.thrown("Invalid JPEG file");
					}
					break;
				default:
					throw haxe_Exception.thrown("Unsupported jpeg tag 0x" + StringTools.hex(this.bytes.b[this.pos + (-1)],2));
				}
			}
		}
		var pixels = this.njConvert();
		this.cleanup();
		return { pixels : pixels, width : this.width, height : this.height};
	}
	,__class__: hxd_res_NanoJpeg
};
var hxd_res_SoundFormat = $hxEnums["hxd.res.SoundFormat"] = { __ename__:true,__constructs__:null
	,Wav: {_hx_name:"Wav",_hx_index:0,__enum__:"hxd.res.SoundFormat",toString:$estr}
	,Mp3: {_hx_name:"Mp3",_hx_index:1,__enum__:"hxd.res.SoundFormat",toString:$estr}
	,OggVorbis: {_hx_name:"OggVorbis",_hx_index:2,__enum__:"hxd.res.SoundFormat",toString:$estr}
};
hxd_res_SoundFormat.__constructs__ = [hxd_res_SoundFormat.Wav,hxd_res_SoundFormat.Mp3,hxd_res_SoundFormat.OggVorbis];
hxd_res_SoundFormat.__empty_constructs__ = [hxd_res_SoundFormat.Wav,hxd_res_SoundFormat.Mp3,hxd_res_SoundFormat.OggVorbis];
var hxd_res_Sound = function(entry) {
	this.lastPlay = 0.;
	hxd_res_Resource.call(this,entry);
};
$hxClasses["hxd.res.Sound"] = hxd_res_Sound;
hxd_res_Sound.__name__ = "hxd.res.Sound";
hxd_res_Sound.supportedFormat = function(fmt) {
	switch(fmt._hx_index) {
	case 0:case 1:
		return true;
	case 2:
		return false;
	}
};
hxd_res_Sound.startWorker = function() {
	return false;
};
hxd_res_Sound.__super__ = hxd_res_Resource;
hxd_res_Sound.prototype = $extend(hxd_res_Resource.prototype,{
	getData: function() {
		if(this.data != null) {
			return this.data;
		}
		var bytes = this.entry.getBytes();
		switch(bytes.b[0]) {
		case 73:case 255:
			this.data = new hxd_snd_Mp3Data(bytes);
			break;
		case 79:
			throw haxe_Exception.thrown("OGG format requires -lib stb_ogg_sound (for " + this.entry.get_path() + ")");
		case 82:
			this.data = new hxd_snd_WavData(bytes);
			break;
		default:
		}
		if(this.data == null) {
			throw haxe_Exception.thrown("Unsupported sound format " + this.entry.get_path());
		}
		if(hxd_res_Sound.ENABLE_AUTO_WATCH) {
			this.watch($bind(this,this.watchCallb));
		}
		return this.data;
	}
	,dispose: function() {
		this.stop();
		this.data = null;
	}
	,stop: function() {
		if(this.channel != null) {
			this.channel.stop();
			this.channel = null;
		}
	}
	,play: function(loop,volume,channelGroup,soundGroup) {
		if(volume == null) {
			volume = 1.;
		}
		if(loop == null) {
			loop = false;
		}
		this.lastPlay = HxOverrides.now() / 1000;
		this.channel = hxd_snd_Manager.get().play(this,channelGroup,soundGroup);
		this.channel.loop = loop;
		this.channel.set_volume(volume);
		return this.channel;
	}
	,watchCallb: function() {
		var old = this.data;
		this.data = null;
		var data = this.getData();
		if(old != null) {
			if(old.channels != data.channels || old.samples != data.samples || old.sampleFormat != data.sampleFormat || old.samplingRate != data.samplingRate) {
				var manager = hxd_snd_Manager.get();
				var ch = manager.getAll(this);
				while(ch.hasNext()) {
					var ch1 = ch.next();
					ch1.duration = data.get_duration();
					ch1.set_position(ch1.position);
				}
			}
		}
	}
	,__class__: hxd_res_Sound
});
var hxd_snd_ChannelBase = function() {
	this.volume = 1.;
	this.bindedEffects = [];
	this.effects = [];
	this.mute = false;
	this.priority = 0.;
};
$hxClasses["hxd.snd.ChannelBase"] = hxd_snd_ChannelBase;
hxd_snd_ChannelBase.__name__ = "hxd.snd.ChannelBase";
hxd_snd_ChannelBase.prototype = {
	getEffect: function(etype) {
		if(this.effects == null) {
			return null;
		}
		var _g = 0;
		var _g1 = this.effects;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			var e1 = js_Boot.__downcastCheck(e,etype) ? e : null;
			if(e1 != null) {
				return e1;
			}
		}
		return null;
	}
	,set_volume: function(v) {
		this.currentFade = null;
		return this.volume = v;
	}
	,fadeTo: function(volume,time,onEnd) {
		if(time == null) {
			time = 1.;
		}
		this.currentFade = { start : HxOverrides.now() / 1000, duration : time, startVolume : this.volume, targetVolume : volume, onEnd : onEnd};
	}
	,updateCurrentVolume: function(now) {
		if(this.currentFade != null) {
			var f = this.currentFade;
			var dt = now - f.start;
			if(dt >= f.duration) {
				this.set_volume(f.targetVolume);
				if(f.onEnd != null) {
					f.onEnd();
				}
			} else {
				this.set_volume(f.startVolume + dt / f.duration * (f.targetVolume - f.startVolume));
				this.currentFade = f;
			}
		}
		this.currentVolume = this.volume;
	}
	,addEffect: function(e) {
		if(e == null) {
			throw haxe_Exception.thrown("Can't add null effect");
		}
		if(this.effects.indexOf(e) >= 0) {
			throw haxe_Exception.thrown("effect already added on this channel");
		}
		this.effects.push(e);
		return e;
	}
	,removeEffect: function(e) {
		HxOverrides.remove(this.effects,e);
	}
	,__class__: hxd_snd_ChannelBase
};
var hxd_snd_Channel = function() {
	this.queue = [];
	this.positionChanged = false;
	this.isLoading = false;
	this.isVirtual = false;
	this.lastStamp = 0.0;
	this.audibleVolume = 1.0;
	this.allowVirtual = true;
	this.loop = false;
	this.pause = false;
	this.position = 0.0;
	hxd_snd_ChannelBase.call(this);
	this.id = hxd_snd_Channel.ID++;
};
$hxClasses["hxd.snd.Channel"] = hxd_snd_Channel;
hxd_snd_Channel.__name__ = "hxd.snd.Channel";
hxd_snd_Channel.__super__ = hxd_snd_ChannelBase;
hxd_snd_Channel.prototype = $extend(hxd_snd_ChannelBase.prototype,{
	onEnd: function() {
	}
	,set_position: function(v) {
		this.lastStamp = HxOverrides.now() / 1000;
		this.positionChanged = true;
		if(v > this.duration) {
			v = this.duration;
		} else if(v < 0) {
			v = 0;
		}
		return this.position = v;
	}
	,set_pause: function(v) {
		if(!v) {
			this.lastStamp = HxOverrides.now() / 1000;
		}
		return this.pause = v;
	}
	,updateCurrentVolume: function(now) {
		if(this.pause && this.currentFade != null) {
			var f = this.currentFade;
			this.currentFade = null;
			this.updateCurrentVolume(now);
			this.currentFade = f;
		}
		hxd_snd_ChannelBase.prototype.updateCurrentVolume.call(this,now);
		this.channelGroup.updateCurrentVolume(now);
		this.currentVolume *= this.channelGroup.currentVolume * this.soundGroup.volume;
		if(this.manager != null) {
			var _g = 0;
			var _g1 = this.channelGroup.effects;
			while(_g < _g1.length) {
				var e = _g1[_g];
				++_g;
				this.currentVolume *= e.getVolumeModifier();
			}
			var _g = 0;
			var _g1 = this.effects;
			while(_g < _g1.length) {
				var e = _g1[_g];
				++_g;
				this.currentVolume *= e.getVolumeModifier();
			}
		}
	}
	,calcAudibleVolume: function(now) {
		this.updateCurrentVolume(now);
		this.audibleVolume = this.currentVolume;
		if(this.manager != null) {
			var _g = 0;
			var _g1 = this.channelGroup.effects;
			while(_g < _g1.length) {
				var e = _g1[_g];
				++_g;
				this.audibleVolume = e.applyAudibleVolumeModifier(this.audibleVolume);
			}
			var _g = 0;
			var _g1 = this.effects;
			while(_g < _g1.length) {
				var e = _g1[_g];
				++_g;
				this.audibleVolume = e.applyAudibleVolumeModifier(this.audibleVolume);
			}
		}
	}
	,queueSound: function(sound) {
		this.queue.push(sound);
	}
	,stop: function() {
		if(this.manager != null) {
			this.manager.releaseChannel(this);
		}
	}
	,isReleased: function() {
		return this.manager == null;
	}
	,__class__: hxd_snd_Channel
});
var hxd_snd_ChannelGroup = function(name) {
	hxd_snd_ChannelBase.call(this);
	this.name = name;
};
$hxClasses["hxd.snd.ChannelGroup"] = hxd_snd_ChannelGroup;
hxd_snd_ChannelGroup.__name__ = "hxd.snd.ChannelGroup";
hxd_snd_ChannelGroup.__super__ = hxd_snd_ChannelBase;
hxd_snd_ChannelGroup.prototype = $extend(hxd_snd_ChannelBase.prototype,{
	__class__: hxd_snd_ChannelGroup
});
var hxd_snd_SampleFormat = $hxEnums["hxd.snd.SampleFormat"] = { __ename__:true,__constructs__:null
	,UI8: {_hx_name:"UI8",_hx_index:0,__enum__:"hxd.snd.SampleFormat",toString:$estr}
	,I16: {_hx_name:"I16",_hx_index:1,__enum__:"hxd.snd.SampleFormat",toString:$estr}
	,F32: {_hx_name:"F32",_hx_index:2,__enum__:"hxd.snd.SampleFormat",toString:$estr}
};
hxd_snd_SampleFormat.__constructs__ = [hxd_snd_SampleFormat.UI8,hxd_snd_SampleFormat.I16,hxd_snd_SampleFormat.F32];
hxd_snd_SampleFormat.__empty_constructs__ = [hxd_snd_SampleFormat.UI8,hxd_snd_SampleFormat.I16,hxd_snd_SampleFormat.F32];
var hxd_snd_Data = function() { };
$hxClasses["hxd.snd.Data"] = hxd_snd_Data;
hxd_snd_Data.__name__ = "hxd.snd.Data";
hxd_snd_Data.formatBytes = function(format) {
	switch(format._hx_index) {
	case 0:
		return 1;
	case 1:
		return 2;
	case 2:
		return 4;
	}
};
hxd_snd_Data.prototype = {
	isLoading: function() {
		return false;
	}
	,decode: function(out,outPos,sampleStart,sampleCount) {
		var bpp = this.getBytesPerSample();
		if(sampleStart < 0 || sampleCount < 0 || outPos < 0 || outPos + sampleCount * bpp > out.length) {
			var s = "sampleStart = " + sampleStart;
			s += " sampleCount = " + sampleCount;
			s += " outPos = " + outPos;
			s += " bpp = " + bpp;
			s += " out.length = " + out.length;
			throw haxe_Exception.thrown(s);
		}
		if(sampleStart + sampleCount >= this.samples) {
			var count = 0;
			if(sampleStart < this.samples) {
				count = this.samples - sampleStart;
				this.decodeBuffer(out,outPos,sampleStart,count);
			}
			out.fill(outPos + count * bpp,(sampleCount - count) * bpp,0);
			return;
		}
		this.decodeBuffer(out,outPos,sampleStart,sampleCount);
	}
	,resample: function(rate,format,channels) {
		if(this.sampleFormat == format && this.samplingRate == rate && this.channels == channels) {
			return this;
		}
		var newSamples = Math.ceil(this.samples * (rate / this.samplingRate));
		var bpp = this.getBytesPerSample();
		var data = new haxe_io_Bytes(new ArrayBuffer(bpp * this.samples));
		this.decodeBuffer(data,0,0,this.samples);
		var out = channels * newSamples;
		var out1;
		switch(format._hx_index) {
		case 0:
			out1 = 1;
			break;
		case 1:
			out1 = 2;
			break;
		case 2:
			out1 = 4;
			break;
		}
		var out2 = new haxe_io_Bytes(new ArrayBuffer(out * out1));
		this.resampleBuffer(out2,0,data,0,rate,format,channels,this.samples);
		var data = new hxd_snd_WavData(null);
		data.channels = channels;
		data.samples = newSamples;
		data.sampleFormat = format;
		data.samplingRate = rate;
		data.rawData = out2;
		return data;
	}
	,resampleBuffer: function(out,outPos,input,inPos,rate,format,channels,samples) {
		var bpp = this.getBytesPerSample();
		var newSamples = Math.ceil(samples * (rate / this.samplingRate));
		var resample = samples != newSamples;
		if(!resample && this.sampleFormat == hxd_snd_SampleFormat.I16 && format == hxd_snd_SampleFormat.I16 && channels == 1 && this.channels == 2) {
			var r = inPos;
			var w = outPos;
			var _g = 0;
			var _g1 = samples;
			while(_g < _g1) {
				var i = _g++;
				var sl = input.getUInt16(r);
				r += 2;
				var sr = input.getUInt16(r);
				r += 2;
				var s;
				if((sl ^ sr) >= 32768) {
					if((sl & 32768) != 0) {
						sl |= -65536;
					}
					if((sr & 32768) != 0) {
						sr |= -65536;
					}
					s = sl + sr >> 1 & 65535;
				} else {
					s = sl + sr >> 1;
				}
				out.setUInt16(w,s);
				w += 2;
			}
			return;
		}
		var srcChannels = this.channels;
		var commonChannels = channels < srcChannels ? channels : srcChannels;
		var extraChannels = channels - commonChannels;
		var sval = 0.;
		var ival = 0;
		var _g = 0;
		var _g1 = newSamples;
		while(_g < _g1) {
			var i = _g++;
			var targetSample = i / (newSamples - 1) * (samples - 1);
			var isample = targetSample | 0;
			var offset = targetSample - isample;
			var srcPos = inPos + isample * bpp;
			if(isample == samples - 1) {
				resample = false;
			}
			var _g2 = 0;
			var _g3 = commonChannels;
			while(_g2 < _g3) {
				var k = _g2++;
				var sval1;
				var sval2 = 0.;
				switch(this.sampleFormat._hx_index) {
				case 0:
					sval1 = input.b[srcPos] / 255;
					if(resample) {
						sval2 = input.b[srcPos + bpp] / 255;
					}
					++srcPos;
					break;
				case 1:
					var v = input.getUInt16(srcPos);
					sval1 = ((v & 32768) == 0 ? v : v | -65536) / 32768;
					if(resample) {
						var v1 = input.getUInt16(srcPos + bpp);
						sval2 = ((v1 & 32768) == 0 ? v1 : v1 | -65536) / 32768;
					}
					srcPos += 2;
					break;
				case 2:
					sval1 = input.getFloat(srcPos);
					if(resample) {
						sval2 = input.getFloat(srcPos + bpp);
					}
					srcPos += 4;
					break;
				}
				sval = resample ? sval1 + offset * (sval2 - sval1) : sval1;
				switch(format._hx_index) {
				case 0:
					ival = (sval + 1) * 128 | 0;
					if(ival > 255) {
						ival = 255;
					}
					out.b[outPos++] = ival;
					break;
				case 1:
					ival = sval * 32768 | 0;
					if(ival > 32767) {
						ival = 32767;
					}
					ival &= 65535;
					out.setUInt16(outPos,ival);
					outPos += 2;
					break;
				case 2:
					out.setFloat(outPos,sval);
					outPos += 4;
					break;
				}
			}
			var _g4 = 0;
			var _g5 = extraChannels;
			while(_g4 < _g5) {
				var i1 = _g4++;
				switch(format._hx_index) {
				case 0:
					out.b[outPos++] = ival;
					break;
				case 1:
					out.setUInt16(outPos,ival);
					outPos += 2;
					break;
				case 2:
					out.setFloat(outPos,sval);
					outPos += 4;
					break;
				}
			}
		}
	}
	,decodeBuffer: function(out,outPos,sampleStart,sampleCount) {
		throw haxe_Exception.thrown("Not implemented");
	}
	,getBytesPerSample: function() {
		var tmp;
		switch(this.sampleFormat._hx_index) {
		case 0:
			tmp = 1;
			break;
		case 1:
			tmp = 2;
			break;
		case 2:
			tmp = 4;
			break;
		}
		return this.channels * tmp;
	}
	,load: function(onEnd) {
		onEnd();
	}
	,get_duration: function() {
		return this.samples / this.samplingRate;
	}
	,__class__: hxd_snd_Data
};
var hxd_snd_EffectDriver = function() {
};
$hxClasses["hxd.snd.EffectDriver"] = hxd_snd_EffectDriver;
hxd_snd_EffectDriver.__name__ = "hxd.snd.EffectDriver";
hxd_snd_EffectDriver.prototype = {
	acquire: function() {
	}
	,release: function() {
	}
	,update: function(e) {
	}
	,bind: function(e,source) {
	}
	,apply: function(e,source) {
	}
	,unbind: function(e,source) {
	}
	,__class__: hxd_snd_EffectDriver
};
var hxd_snd_DriverFeature = $hxEnums["hxd.snd.DriverFeature"] = { __ename__:true,__constructs__:null
	,MasterVolume: {_hx_name:"MasterVolume",_hx_index:0,__enum__:"hxd.snd.DriverFeature",toString:$estr}
};
hxd_snd_DriverFeature.__constructs__ = [hxd_snd_DriverFeature.MasterVolume];
hxd_snd_DriverFeature.__empty_constructs__ = [hxd_snd_DriverFeature.MasterVolume];
var hxd_snd_Driver = function() { };
$hxClasses["hxd.snd.Driver"] = hxd_snd_Driver;
hxd_snd_Driver.__name__ = "hxd.snd.Driver";
hxd_snd_Driver.__isInterface__ = true;
hxd_snd_Driver.prototype = {
	__class__: hxd_snd_Driver
};
var hxd_snd_Effect = function(type) {
	this.refs = 0;
	this.priority = 0;
	this.retainTime = 0.0;
	this.lastStamp = 0.0;
	var managerDriver = hxd_snd_Manager.get().driver;
	if(managerDriver != null) {
		this.driver = managerDriver.getEffectDriver(type);
	}
};
$hxClasses["hxd.snd.Effect"] = hxd_snd_Effect;
hxd_snd_Effect.__name__ = "hxd.snd.Effect";
hxd_snd_Effect.prototype = {
	applyAudibleVolumeModifier: function(v) {
		return v;
	}
	,getVolumeModifier: function() {
		return 1;
	}
	,__class__: hxd_snd_Effect
};
var hxd_snd_Listener = function() {
	this.position = new h3d_VectorImpl(0.,0.,0.);
	this.velocity = new h3d_VectorImpl(0.,0.,0.);
	var x = 1;
	var y = 0;
	var z = 0;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.direction = new h3d_VectorImpl(x,y,z);
	var x = 0;
	var y = 0;
	var z = 1;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.up = new h3d_VectorImpl(x,y,z);
};
$hxClasses["hxd.snd.Listener"] = hxd_snd_Listener;
hxd_snd_Listener.__name__ = "hxd.snd.Listener";
hxd_snd_Listener.prototype = {
	syncCamera: function(cam) {
		var _this = this.position;
		var v = cam.pos;
		_this.x = v.x;
		_this.y = v.y;
		_this.z = v.z;
		var _this = this.direction;
		var x = cam.target.x - cam.pos.x;
		var y = cam.target.y - cam.pos.y;
		var z = cam.target.z - cam.pos.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		var _this = this.direction;
		var k = _this.x * _this.x + _this.y * _this.y + _this.z * _this.z;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		_this.x *= k;
		_this.y *= k;
		_this.z *= k;
		var _this = this.up;
		var v = cam.up;
		_this.x = v.x;
		_this.y = v.y;
		_this.z = v.z;
	}
	,__class__: hxd_snd_Listener
};
var hxd_snd_Source = function(driver) {
	this.start = 0;
	this.playing = false;
	this.volume = -1.0;
	this.id = hxd_snd_Source.ID++;
	this.handle = driver.createSource();
	this.buffers = [];
};
$hxClasses["hxd.snd.Source"] = hxd_snd_Source;
hxd_snd_Source.__name__ = "hxd.snd.Source";
hxd_snd_Source.prototype = {
	dispose: function() {
		hxd_snd_Manager.get().driver.destroySource(this.handle);
	}
	,__class__: hxd_snd_Source
};
var hxd_snd_Buffer = function(driver) {
	this.end = 0;
	this.handle = driver.createBuffer();
	this.refs = 0;
	this.lastStop = HxOverrides.now() / 1000;
};
$hxClasses["hxd.snd.Buffer"] = hxd_snd_Buffer;
hxd_snd_Buffer.__name__ = "hxd.snd.Buffer";
hxd_snd_Buffer.prototype = {
	dispose: function() {
		hxd_snd_Manager.get().driver.destroyBuffer(this.handle);
	}
	,__class__: hxd_snd_Buffer
};
var hxd_snd_Manager = function() {
	this.suspended = false;
	this.timeOffset = 0.;
	try {
		this.driver = new hxd_snd_webaudio_Driver();
	} catch( _g ) {
		if(typeof(haxe_Exception.caught(_g).unwrap()) == "string") {
			this.driver = null;
		} else {
			throw _g;
		}
	}
	this.masterVolume = 1.0;
	this.hasMasterVolume = this.driver == null ? true : this.driver.hasFeature(hxd_snd_DriverFeature.MasterVolume);
	this.masterSoundGroup = new hxd_snd_SoundGroup("master");
	this.masterChannelGroup = new hxd_snd_ChannelGroup("master");
	this.listener = new hxd_snd_Listener();
	this.soundBufferMap = new haxe_ds_StringMap();
	this.soundBufferKeys = [];
	this.freeStreamBuffers = [];
	this.effectGC = [];
	this.soundBufferCount = 0;
	if(this.driver != null) {
		this.sources = [];
		var _g = 0;
		var _g1 = hxd_snd_Manager.MAX_SOURCES;
		while(_g < _g1) {
			var i = _g++;
			this.sources.push(new hxd_snd_Source(this.driver));
		}
	}
	this.cachedBytes = new haxe_io_Bytes(new ArrayBuffer(24));
	this.resampleBytes = new haxe_io_Bytes(new ArrayBuffer(hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT * 2));
};
$hxClasses["hxd.snd.Manager"] = hxd_snd_Manager;
hxd_snd_Manager.__name__ = "hxd.snd.Manager";
hxd_snd_Manager.get = function() {
	if(hxd_snd_Manager.instance == null) {
		hxd_snd_Manager.instance = new hxd_snd_Manager();
		hxd_snd_Manager.instance.updateEvent = haxe_MainLoop.add(($_=hxd_snd_Manager.instance,$bind($_,$_.update)));
		hxd_snd_Manager.instance.updateEvent.isBlocking = false;
	}
	return hxd_snd_Manager.instance;
};
hxd_snd_Manager.regEffect = function(list,e) {
	var l = list;
	while(l != null) {
		if(l == e) {
			return list;
		}
		l = l.next;
	}
	e.next = list;
	return e;
};
hxd_snd_Manager.prototype = {
	getTmpBytes: function(size) {
		if(this.cachedBytes.length < size) {
			this.cachedBytes = new haxe_io_Bytes(new ArrayBuffer(size));
		}
		return this.cachedBytes;
	}
	,getResampleBytes: function(size) {
		if(this.resampleBytes.length < size) {
			this.resampleBytes = new haxe_io_Bytes(new ArrayBuffer(size));
		}
		return this.resampleBytes;
	}
	,stopAll: function() {
		while(this.channels != null) this.channels.stop();
	}
	,stopAllNotLooping: function() {
		var c = this.channels;
		while(c != null) {
			var n = c.next;
			if(!c.loop) {
				c.stop();
			}
			c = n;
		}
	}
	,stopByName: function(name) {
		var c = this.channels;
		while(c != null) {
			var n = c.next;
			if(c.soundGroup != null && c.soundGroup.name == name) {
				c.stop();
			}
			c = n;
		}
	}
	,getAll: function(sound) {
		var ch = this.channels;
		var result = [];
		while(ch != null) {
			if(ch.sound == sound) {
				result.push(ch);
			}
			ch = ch.next;
		}
		return new hxd_impl_ArrayIterator_$hxd_$snd_$Channel(result);
	}
	,cleanCache: function() {
		var i = 0;
		while(i < this.soundBufferKeys.length) {
			var k = this.soundBufferKeys[i];
			var b = this.soundBufferMap.h[k];
			++i;
			if(b.refs > 0) {
				continue;
			}
			var _this = this.soundBufferMap;
			if(Object.prototype.hasOwnProperty.call(_this.h,k)) {
				delete(_this.h[k]);
			}
			HxOverrides.remove(this.soundBufferKeys,k);
			--i;
			b.dispose();
			--this.soundBufferCount;
		}
	}
	,dispose: function() {
		this.stopAll();
		if(this.driver != null) {
			var _g = 0;
			var _g1 = this.sources;
			while(_g < _g1.length) {
				var s = _g1[_g];
				++_g;
				s.dispose();
			}
			var h = this.soundBufferMap.h;
			var b_h = h;
			var b_keys = Object.keys(h);
			var b_length = b_keys.length;
			var b_current = 0;
			while(b_current < b_length) {
				var b = b_h[b_keys[b_current++]];
				b.dispose();
			}
			var _g = 0;
			var _g1 = this.freeStreamBuffers;
			while(_g < _g1.length) {
				var b = _g1[_g];
				++_g;
				b.dispose();
			}
			var _g = 0;
			var _g1 = this.effectGC;
			while(_g < _g1.length) {
				var e = _g1[_g];
				++_g;
				e.driver.release();
			}
			this.driver.dispose();
		}
		this.sources = null;
		this.soundBufferMap = null;
		this.soundBufferKeys = null;
		this.freeStreamBuffers = null;
		this.effectGC = null;
		this.updateEvent.stop();
		hxd_snd_Manager.instance = null;
	}
	,play: function(sound,channelGroup,soundGroup) {
		if(soundGroup == null) {
			soundGroup = this.masterSoundGroup;
		}
		if(channelGroup == null) {
			channelGroup = this.masterChannelGroup;
		}
		var sdat = sound.getData();
		if(sdat.samples == 0) {
			throw haxe_Exception.thrown(Std.string(sound) + " has no samples");
		}
		var c = new hxd_snd_Channel();
		c.sound = sound;
		c.duration = sdat.get_duration();
		c.manager = this;
		c.soundGroup = soundGroup;
		c.channelGroup = channelGroup;
		c.next = this.channels;
		c.isLoading = sdat.isLoading();
		c.isVirtual = this.driver == null;
		c.lastStamp = HxOverrides.now() / 1000;
		this.channels = c;
		return c;
	}
	,updateVirtualChannels: function(now) {
		var c = this.channels;
		while(c != null) {
			if(c.pause || !c.isVirtual || c.isLoading) {
				c = c.next;
				continue;
			}
			var a = now - c.lastStamp;
			c.set_position(c.position + (a < 0.0 ? 0.0 : a));
			c.lastStamp = now;
			var next = c.next;
			while(c.position >= c.duration) {
				c.set_position(c.position - c.duration);
				c.onEnd();
				if(next != null && next.manager == null) {
					next = null;
				}
				if(c.queue.length > 0) {
					c.sound = c.queue.shift();
					c.duration = c.sound.getData().get_duration();
				} else if(!c.loop) {
					this.releaseChannel(c);
					break;
				}
			}
			c = next;
		}
	}
	,update: function() {
		if(this.timeOffset != 0) {
			var c = this.channels;
			while(c != null) {
				c.lastStamp += this.timeOffset;
				if(c.currentFade != null) {
					c.currentFade.start += this.timeOffset;
				}
				c = c.next;
			}
			var _g = 0;
			var _g1 = this.sources;
			while(_g < _g1.length) {
				var s = _g1[_g];
				++_g;
				var _g2 = 0;
				var _g3 = s.buffers;
				while(_g2 < _g3.length) {
					var b = _g3[_g2];
					++_g2;
					b.lastStop += this.timeOffset;
				}
			}
			this.timeOffset = 0;
		}
		this.now = HxOverrides.now() / 1000;
		if(this.driver == null) {
			this.updateVirtualChannels(this.now);
			return;
		}
		var _g = 0;
		var _g1 = this.sources;
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			var c = s.channel;
			if(c == null) {
				continue;
			}
			if(c.positionChanged) {
				this.releaseSource(s);
				continue;
			}
			var lastBuffer = null;
			var count = this.driver.getProcessedBuffers(s.handle);
			var _g2 = 0;
			var _g3 = count;
			while(_g2 < _g3) {
				var i = _g2++;
				var b = this.unqueueBuffer(s);
				if(b == null) {
					continue;
				}
				lastBuffer = b;
				if(b.isEnd) {
					c.sound = b.sound;
					c.duration = b.sound.getData().get_duration();
					c.set_position(c.duration);
					c.positionChanged = false;
					c.onEnd();
					s.start = 0;
				}
			}
			if(s.buffers.length == 0) {
				if(!lastBuffer.isEnd) {
					c.set_position((lastBuffer.start + lastBuffer.samples) / lastBuffer.sampleRate);
					this.releaseSource(s);
				} else if(c.queue.length > 0) {
					c.sound = c.queue.shift();
					c.duration = c.sound.getData().get_duration();
					c.set_position(0);
					this.releaseSource(s);
				} else if(c.loop) {
					c.set_position(0);
					this.releaseSource(s);
				} else {
					this.releaseChannel(c);
				}
				continue;
			}
			c.sound = s.buffers[0].sound;
			c.duration = c.sound.getData().get_duration();
			var playedSamples = this.driver.getPlayedSampleCount(s.handle);
			if(playedSamples < 0) {
				haxe_Log.trace("playedSamples should positive : bug in driver",{ fileName : "hxd/snd/Manager.hx", lineNumber : 361, className : "hxd.snd.Manager", methodName : "update"});
				playedSamples = 0;
			}
			c.set_position(s.start / this.targetRate + playedSamples / s.buffers[0].sampleRate);
			c.positionChanged = false;
			if(s.buffers.length < hxd_snd_Manager.BUFFER_QUEUE_LENGTH) {
				var b1 = s.buffers[s.buffers.length - 1];
				if(!b1.isEnd) {
					this.queueBuffer(s,b1.sound,b1.start + b1.samples);
				} else if(c.queue.length > 0) {
					var snd = c.queue[0];
					if(this.queueBuffer(s,snd,0)) {
						c.queue.shift();
					}
				} else if(c.loop) {
					this.queueBuffer(s,b1.sound,0);
				}
			}
		}
		var c = this.channels;
		while(c != null) {
			c.calcAudibleVolume(this.now);
			if(c.isLoading && !c.sound.getData().isLoading()) {
				c.isLoading = false;
			}
			c.isVirtual = this.suspended || c.pause || c.mute || c.channelGroup.mute || c.allowVirtual && c.audibleVolume < hxd_snd_Manager.VIRTUAL_VOLUME_THRESHOLD || c.isLoading;
			c = c.next;
		}
		var list = this.channels;
		var cmp = $bind(this,this.sortChannel);
		var tmp;
		if(list == null) {
			tmp = null;
		} else {
			var insize = 1;
			var nmerges;
			var psize = 0;
			var qsize = 0;
			var p;
			var q;
			var e;
			var tail;
			while(true) {
				p = list;
				list = null;
				tail = null;
				nmerges = 0;
				while(p != null) {
					++nmerges;
					q = p;
					psize = 0;
					var _g = 0;
					var _g1 = insize;
					while(_g < _g1) {
						var i = _g++;
						++psize;
						q = q.next;
						if(q == null) {
							break;
						}
					}
					qsize = insize;
					while(psize > 0 || qsize > 0 && q != null) {
						if(psize == 0) {
							e = q;
							q = q.next;
							--qsize;
						} else if(qsize == 0 || q == null || cmp(p,q) <= 0) {
							e = p;
							p = p.next;
							--psize;
						} else {
							e = q;
							q = q.next;
							--qsize;
						}
						if(tail != null) {
							tail.next = e;
						} else {
							list = e;
						}
						tail = e;
					}
					p = q;
				}
				tail.next = null;
				if(nmerges <= 1) {
					break;
				}
				insize *= 2;
			}
			tmp = list;
		}
		this.channels = tmp;
		var audibleCount = 0;
		var c = this.channels;
		while(c != null && !c.isVirtual) {
			if(++audibleCount > this.sources.length) {
				c.isVirtual = true;
			} else if(c.soundGroup.maxAudible >= 0) {
				if(c.soundGroup.lastUpdate != this.now) {
					c.soundGroup.lastUpdate = this.now;
					c.soundGroup.numAudible = 0;
				}
				if(++c.soundGroup.numAudible > c.soundGroup.maxAudible) {
					c.isVirtual = true;
					--audibleCount;
				}
			}
			c = c.next;
		}
		var _g = 0;
		var _g1 = this.sources;
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			if(s.channel == null || !s.channel.isVirtual) {
				continue;
			}
			this.releaseSource(s);
		}
		var c = this.channels;
		while(c != null) {
			if(c.source != null || c.isVirtual) {
				c = c.next;
				continue;
			}
			var s = null;
			var _g = 0;
			var _g1 = this.sources;
			while(_g < _g1.length) {
				var s2 = _g1[_g];
				++_g;
				if(s2.channel == null) {
					s = s2;
					break;
				}
			}
			if(s == null) {
				throw haxe_Exception.thrown("could not get a source");
			}
			s.channel = c;
			c.source = s;
			this.checkTargetFormat(c.sound.getData(),c.soundGroup.mono);
			s.start = Math.floor(c.position * this.targetRate);
			if(s.start < 0) {
				s.start = 0;
			}
			this.queueBuffer(s,c.sound,s.start);
			c.positionChanged = false;
			c = c.next;
		}
		var usedEffects = null;
		var volume = this.hasMasterVolume ? 1. : this.masterVolume;
		var _g = 0;
		var _g1 = this.sources;
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			var c = s.channel;
			if(c == null) {
				continue;
			}
			var v = c.currentVolume * volume;
			if(s.volume != v) {
				if(v < 0) {
					v = 0;
				}
				s.volume = v;
				this.driver.setSourceVolume(s.handle,v);
			}
			if(!s.playing) {
				this.driver.playSource(s.handle);
				s.playing = true;
			}
			var i = c.bindedEffects.length;
			while(--i >= 0) {
				var e = c.bindedEffects[i];
				if(c.effects.indexOf(e) < 0 && c.channelGroup.effects.indexOf(e) < 0) {
					this.unbindEffect(c,s,e);
				}
			}
			var _g2 = 0;
			var _g3 = c.channelGroup.effects;
			while(_g2 < _g3.length) {
				var e1 = _g3[_g2];
				++_g2;
				if(c.bindedEffects.indexOf(e1) < 0) {
					this.bindEffect(c,s,e1);
				}
			}
			var _g4 = 0;
			var _g5 = c.effects;
			while(_g4 < _g5.length) {
				var e2 = _g5[_g4];
				++_g4;
				if(c.bindedEffects.indexOf(e2) < 0) {
					this.bindEffect(c,s,e2);
				}
			}
			var _g6 = 0;
			var _g7 = c.bindedEffects;
			while(_g6 < _g7.length) {
				var e3 = _g7[_g6];
				++_g6;
				usedEffects = hxd_snd_Manager.regEffect(usedEffects,e3);
			}
		}
		var list = usedEffects;
		var cmp = $bind(this,this.sortEffect);
		if(list == null) {
			usedEffects = null;
		} else {
			var insize = 1;
			var nmerges;
			var psize = 0;
			var qsize = 0;
			var p;
			var q;
			var e;
			var tail;
			while(true) {
				p = list;
				list = null;
				tail = null;
				nmerges = 0;
				while(p != null) {
					++nmerges;
					q = p;
					psize = 0;
					var _g = 0;
					var _g1 = insize;
					while(_g < _g1) {
						var i = _g++;
						++psize;
						q = q.next;
						if(q == null) {
							break;
						}
					}
					qsize = insize;
					while(psize > 0 || qsize > 0 && q != null) {
						if(psize == 0) {
							e = q;
							q = q.next;
							--qsize;
						} else if(qsize == 0 || q == null || cmp(p,q) <= 0) {
							e = p;
							p = p.next;
							--psize;
						} else {
							e = q;
							q = q.next;
							--qsize;
						}
						if(tail != null) {
							tail.next = e;
						} else {
							list = e;
						}
						tail = e;
					}
					p = q;
				}
				tail.next = null;
				if(nmerges <= 1) {
					break;
				}
				insize *= 2;
			}
			usedEffects = list;
		}
		var e = usedEffects;
		while(e != null) {
			e.driver.update(e);
			e = e.next;
		}
		var _g = 0;
		var _g1 = this.sources;
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			var c = s.channel;
			if(c == null) {
				continue;
			}
			var _g2 = 0;
			var _g3 = c.bindedEffects;
			while(_g2 < _g3.length) {
				var e = _g3[_g2];
				++_g2;
				e.driver.apply(e,s.handle);
			}
		}
		var _g = 0;
		var _g1 = this.effectGC;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			if(this.now - e.lastStamp > e.retainTime) {
				e.driver.release();
				HxOverrides.remove(this.effectGC,e);
				break;
			}
		}
		this.updateVirtualChannels(this.now);
		var _this = this.listener.direction;
		var k = _this.x * _this.x + _this.y * _this.y + _this.z * _this.z;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		_this.x *= k;
		_this.y *= k;
		_this.z *= k;
		var _this = this.listener.up;
		var k = _this.x * _this.x + _this.y * _this.y + _this.z * _this.z;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		_this.x *= k;
		_this.y *= k;
		_this.z *= k;
		if(this.hasMasterVolume) {
			this.driver.setMasterVolume(this.masterVolume);
		}
		this.driver.setListenerParams(this.listener.position,this.listener.direction,this.listener.up,this.listener.velocity);
		this.driver.update();
		if(this.soundBufferCount >= hxd_snd_Manager.SOUND_BUFFER_CACHE_SIZE) {
			var now = HxOverrides.now() / 1000;
			var i = 0;
			while(i < this.soundBufferKeys.length) {
				var k = this.soundBufferKeys[i];
				var b = this.soundBufferMap.h[k];
				++i;
				if(b.refs > 0 || b.lastStop + 60.0 > now) {
					continue;
				}
				var _this = this.soundBufferMap;
				if(Object.prototype.hasOwnProperty.call(_this.h,k)) {
					delete(_this.h[k]);
				}
				HxOverrides.remove(this.soundBufferKeys,k);
				--i;
				b.dispose();
				--this.soundBufferCount;
			}
		}
	}
	,progressiveDecodeBuffer: function(s,snd,start) {
		var data = snd.getData();
		var samples = Math.ceil(hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT / hxd_snd_Manager.BUFFER_STREAM_SPLIT);
		if(s.streamStart != start || s.streamSound != snd) {
			s.streamSound = snd;
			s.streamStart = start;
			s.streamPos = start;
		}
		var end = start + hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT;
		if(s.streamPos == end) {
			return true;
		}
		var bpp = data.getBytesPerSample();
		var reqSize = hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT * bpp;
		if(s.streamBuffer == null || s.streamBuffer.length < reqSize) {
			s.streamBuffer = new haxe_io_Bytes(new ArrayBuffer(reqSize));
			s.streamPos = start;
		}
		var remain = end - s.streamPos;
		if(remain > samples) {
			remain = samples;
		}
		data.decode(s.streamBuffer,(s.streamPos - start) * bpp,s.streamPos,remain);
		s.streamPos += remain;
		return s.streamPos == end;
	}
	,queueBuffer: function(s,snd,start) {
		var data = snd.getData();
		var sgroup = s.channel.soundGroup;
		var b = null;
		if(data.get_duration() <= hxd_snd_Manager.STREAM_DURATION) {
			b = this.getSoundBuffer(snd,sgroup);
			this.driver.queueBuffer(s.handle,b.handle,start,true);
		} else {
			if(s.buffers.length > 0 && hxd_snd_Manager.BUFFER_STREAM_SPLIT > 1 && !this.progressiveDecodeBuffer(s,snd,start)) {
				return false;
			}
			b = this.getStreamBuffer(s,snd,sgroup,start);
			this.driver.queueBuffer(s.handle,b.handle,0,b.isEnd);
		}
		s.buffers.push(b);
		return true;
	}
	,unqueueBuffer: function(s) {
		var b = s.buffers.shift();
		if(b == null) {
			return null;
		}
		this.driver.unqueueBuffer(s.handle,b.handle);
		if(b.isStream) {
			this.freeStreamBuffers.unshift(b);
		} else if(--b.refs == 0) {
			b.lastStop = HxOverrides.now() / 1000;
		}
		return b;
	}
	,bindEffect: function(c,s,e) {
		if(e.refs == 0 && !HxOverrides.remove(this.effectGC,e)) {
			e.driver.acquire();
		}
		++e.refs;
		e.driver.bind(e,s.handle);
		c.bindedEffects.push(e);
	}
	,unbindEffect: function(c,s,e) {
		e.driver.unbind(e,s.handle);
		HxOverrides.remove(c.bindedEffects,e);
		if(--e.refs == 0) {
			e.lastStamp = this.now;
			this.effectGC.push(e);
		}
	}
	,releaseSource: function(s) {
		if(s.channel != null) {
			var _g = 0;
			var _g1 = s.channel.bindedEffects.slice();
			while(_g < _g1.length) {
				var e = _g1[_g];
				++_g;
				this.unbindEffect(s.channel,s,e);
			}
			s.channel.bindedEffects = [];
			s.channel.source = null;
			s.channel = null;
		}
		if(s.playing) {
			s.playing = false;
			this.driver.stopSource(s.handle);
			s.volume = -1.0;
		}
		while(s.buffers.length > 0) this.unqueueBuffer(s);
	}
	,checkTargetFormat: function(dat,forceMono) {
		if(forceMono == null) {
			forceMono = false;
		}
		this.targetRate = dat.samplingRate;
		this.targetChannels = forceMono || dat.channels == 1 ? 1 : 2;
		var tmp;
		switch(dat.sampleFormat._hx_index) {
		case 0:
			tmp = hxd_snd_SampleFormat.UI8;
			break;
		case 1:
			tmp = hxd_snd_SampleFormat.I16;
			break;
		case 2:
			tmp = hxd_snd_SampleFormat.F32;
			break;
		}
		this.targetFormat = tmp;
		if(this.targetChannels == dat.channels && this.targetFormat == dat.sampleFormat) {
			return this.targetRate == dat.samplingRate;
		} else {
			return false;
		}
	}
	,getSoundBuffer: function(snd,grp) {
		var _gthis = this;
		var data = snd.getData();
		var mono = grp.mono;
		var key = snd.entry.get_path();
		if(mono && data.channels != 1) {
			key += "mono";
		}
		var b = this.soundBufferMap.h[key];
		if(b == null) {
			b = new hxd_snd_Buffer(this.driver);
			b.isStream = false;
			b.isEnd = true;
			b.sound = snd;
			data.load(function() {
				_gthis.fillSoundBuffer(b,data,mono);
			});
			this.soundBufferMap.h[key] = b;
			this.soundBufferKeys.push(key);
			++this.soundBufferCount;
		}
		++b.refs;
		return b;
	}
	,fillSoundBuffer: function(buf,dat,forceMono) {
		if(forceMono == null) {
			forceMono = false;
		}
		if(!this.checkTargetFormat(dat,forceMono)) {
			dat = dat.resample(this.targetRate,this.targetFormat,this.targetChannels);
		}
		var length = dat.samples * dat.getBytesPerSample();
		var bytes = this.getTmpBytes(length);
		dat.decode(bytes,0,0,dat.samples);
		this.driver.setBufferData(buf.handle,bytes,length,this.targetFormat,this.targetChannels,this.targetRate);
		buf.sampleRate = this.targetRate;
		buf.samples = dat.samples;
	}
	,getStreamBuffer: function(src,snd,grp,start) {
		var data = snd.getData();
		var b = this.freeStreamBuffers.shift();
		if(b == null) {
			b = new hxd_snd_Buffer(this.driver);
			b.isStream = true;
		}
		var samples = hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT;
		if(start + samples >= data.samples) {
			samples = data.samples - start;
			b.isEnd = true;
		} else {
			b.isEnd = false;
		}
		b.sound = snd;
		b.samples = samples;
		b.start = start;
		var size = samples * data.getBytesPerSample();
		var bytes;
		if(src.streamSound == snd && src.streamStart == start) {
			while(!this.progressiveDecodeBuffer(src,snd,start)) {
			}
			bytes = src.streamBuffer;
		} else {
			bytes = this.getTmpBytes(size);
			data.decode(bytes,0,start,samples);
		}
		if(!this.checkTargetFormat(data,grp.mono)) {
			var size1 = Math.ceil(samples * (this.targetRate / data.samplingRate)) * this.targetChannels;
			var size2;
			switch(this.targetFormat._hx_index) {
			case 0:
				size2 = 1;
				break;
			case 1:
				size2 = 2;
				break;
			case 2:
				size2 = 4;
				break;
			}
			size = size1 * size2;
			var resampleBytes = this.getResampleBytes(size);
			data.resampleBuffer(resampleBytes,0,bytes,0,this.targetRate,this.targetFormat,this.targetChannels,samples);
			bytes = resampleBytes;
		}
		this.driver.setBufferData(b.handle,bytes,size,this.targetFormat,this.targetChannels,this.targetRate);
		b.sampleRate = this.targetRate;
		return b;
	}
	,sortChannel: function(a,b) {
		if(a.isVirtual != b.isVirtual) {
			if(a.isVirtual) {
				return 1;
			} else {
				return -1;
			}
		}
		if(a.channelGroup.priority != b.channelGroup.priority) {
			if(a.channelGroup.priority < b.channelGroup.priority) {
				return 1;
			} else {
				return -1;
			}
		}
		if(a.priority != b.priority) {
			if(a.priority < b.priority) {
				return 1;
			} else {
				return -1;
			}
		}
		if(a.audibleVolume != b.audibleVolume) {
			if(a.audibleVolume < b.audibleVolume) {
				return 1;
			} else {
				return -1;
			}
		}
		if(a.id < b.id) {
			return 1;
		} else {
			return -1;
		}
	}
	,sortEffect: function(a,b) {
		return b.priority - a.priority;
	}
	,releaseChannel: function(c) {
		if(c.manager == null) {
			return;
		}
		if(this.channels == c) {
			this.channels = c.next;
		} else {
			var prev = this.channels;
			while(prev.next != c) prev = prev.next;
			prev.next = c.next;
		}
		var _g = 0;
		var _g1 = c.effects;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			c.removeEffect(e);
		}
		if(c.source != null) {
			this.releaseSource(c.source);
		}
		c.next = null;
		c.manager = null;
		c.effects = null;
		c.bindedEffects = null;
		c.currentFade = null;
		var snd = c.sound;
		if(snd != null && snd.channel == c) {
			snd.channel = null;
		}
	}
	,__class__: hxd_snd_Manager
};
var hxd_snd_Mp3Data = function(bytes) {
	var mp = new format_mp3_Reader(new haxe_io_BytesInput(bytes)).read();
	this.samples = mp.sampleCount;
	var frame = mp.frames[0].data;
	var lame = -1;
	var _g = 0;
	var _g1 = frame.length - 24;
	while(_g < _g1) {
		var i = _g++;
		if(frame.b[i] == 76 && frame.b[i + 1] == 65 && frame.b[i + 2] == 77 && frame.b[i + 3] == 69) {
			lame = i;
			break;
		}
	}
	if(lame >= 0) {
		var startEnd = frame.b[lame + 21] << 16 | frame.b[lame + 22] << 8 | frame.b[lame + 23];
		var start = startEnd >> 12;
		var end = startEnd & 4095;
		this.samples -= start + end + 1152;
	}
	var header = mp.frames[0].header;
	this.sampleFormat = hxd_snd_SampleFormat.F32;
	this.samplingRate = format_mp3_MPEG.srEnum2Num(header.samplingRate);
	this.channels = header.channelMode == format_mp3_ChannelMode.Mono ? 1 : 2;
	var ctx = hxd_snd_webaudio_Context.get();
	if(ctx == null) {
		return;
	}
	ctx.decodeAudioData(bytes.b.bufferValue,$bind(this,this.processBuffer));
	var decodedRate = ctx.sampleRate | 0;
	this.samples = Math.ceil(this.samples * decodedRate / this.samplingRate);
	this.samplingRate = decodedRate;
};
$hxClasses["hxd.snd.Mp3Data"] = hxd_snd_Mp3Data;
hxd_snd_Mp3Data.__name__ = "hxd.snd.Mp3Data";
hxd_snd_Mp3Data.__super__ = hxd_snd_Data;
hxd_snd_Mp3Data.prototype = $extend(hxd_snd_Data.prototype,{
	isLoading: function() {
		return this.buffer == null;
	}
	,load: function(onEnd) {
		if(this.buffer != null) {
			onEnd();
		} else {
			this.onEnd = onEnd;
		}
	}
	,processBuffer: function(buf) {
		var left = buf.getChannelData(0);
		this.samples = buf.length;
		if(this.channels == 1) {
			this.buffer = haxe_io_Bytes.ofData(left.buffer);
			return;
		}
		var right = buf.numberOfChannels < 2 ? left : buf.getChannelData(1);
		var join = new Float32Array(left.length * 2);
		var w = 0;
		var _g = 0;
		var _g1 = buf.length;
		while(_g < _g1) {
			var i = _g++;
			join[w++] = left[i];
			join[w++] = right[i];
		}
		this.buffer = haxe_io_Bytes.ofData(join.buffer);
		if(this.onEnd != null) {
			this.onEnd();
			this.onEnd = null;
		}
	}
	,decodeBuffer: function(out,outPos,sampleStart,sampleCount) {
		if(this.buffer == null) {
			out.fill(outPos,sampleCount * 4 * this.channels,0);
		} else {
			out.blit(outPos,this.buffer,sampleStart * 4 * this.channels,sampleCount * 4 * this.channels);
		}
	}
	,__class__: hxd_snd_Mp3Data
});
var hxd_snd_SoundGroup = function(name) {
	this.name = name;
	this.maxAudible = -1;
	this.volume = 1;
	this.mono = false;
};
$hxClasses["hxd.snd.SoundGroup"] = hxd_snd_SoundGroup;
hxd_snd_SoundGroup.__name__ = "hxd.snd.SoundGroup";
hxd_snd_SoundGroup.prototype = {
	__class__: hxd_snd_SoundGroup
};
var hxd_snd_WavData = function(bytes) {
	if(bytes != null) {
		this.init(new format_wav_Reader(new haxe_io_BytesInput(bytes)).read());
	}
};
$hxClasses["hxd.snd.WavData"] = hxd_snd_WavData;
hxd_snd_WavData.__name__ = "hxd.snd.WavData";
hxd_snd_WavData.__super__ = hxd_snd_Data;
hxd_snd_WavData.prototype = $extend(hxd_snd_Data.prototype,{
	init: function(d) {
		var h = d.header;
		this.samplingRate = h.samplingRate;
		this.channels = h.channels;
		var tmp;
		switch(h.bitsPerSample) {
		case 8:
			tmp = hxd_snd_SampleFormat.UI8;
			break;
		case 16:
			tmp = hxd_snd_SampleFormat.I16;
			break;
		default:
			throw haxe_Exception.thrown("Unsupported WAV " + h.bitsPerSample + " bits");
		}
		this.sampleFormat = tmp;
		this.rawData = d.data;
		this.samples = this.rawData.length / this.getBytesPerSample() | 0;
	}
	,decodeBuffer: function(out,outPos,sampleStart,sampleCount) {
		var bpp = this.getBytesPerSample();
		out.blit(outPos,this.rawData,sampleStart * bpp,sampleCount * bpp);
	}
	,__class__: hxd_snd_WavData
});
var hxd_snd_effect_LowPass = function() {
	hxd_snd_Effect.call(this,"lowpass");
	this.priority = 100;
	this.gainHF = 1.0;
};
$hxClasses["hxd.snd.effect.LowPass"] = hxd_snd_effect_LowPass;
hxd_snd_effect_LowPass.__name__ = "hxd.snd.effect.LowPass";
hxd_snd_effect_LowPass.__super__ = hxd_snd_Effect;
hxd_snd_effect_LowPass.prototype = $extend(hxd_snd_Effect.prototype,{
	__class__: hxd_snd_effect_LowPass
});
var hxd_snd_effect_Pitch = function(value) {
	if(value == null) {
		value = 1.0;
	}
	hxd_snd_Effect.call(this,"pitch");
	this.value = value;
};
$hxClasses["hxd.snd.effect.Pitch"] = hxd_snd_effect_Pitch;
hxd_snd_effect_Pitch.__name__ = "hxd.snd.effect.Pitch";
hxd_snd_effect_Pitch.__super__ = hxd_snd_Effect;
hxd_snd_effect_Pitch.prototype = $extend(hxd_snd_Effect.prototype,{
	__class__: hxd_snd_effect_Pitch
});
var hxd_snd_effect_Spatialization = function() {
	hxd_snd_Effect.call(this,"spatialization");
	this.position = new h3d_VectorImpl(0.,0.,0.);
	this.velocity = new h3d_VectorImpl(0.,0.,0.);
	this.direction = new h3d_VectorImpl(0.,0.,0.);
	this.referenceDistance = 1.0;
	this.rollOffFactor = 1.0;
};
$hxClasses["hxd.snd.effect.Spatialization"] = hxd_snd_effect_Spatialization;
hxd_snd_effect_Spatialization.__name__ = "hxd.snd.effect.Spatialization";
hxd_snd_effect_Spatialization.__super__ = hxd_snd_Effect;
hxd_snd_effect_Spatialization.prototype = $extend(hxd_snd_Effect.prototype,{
	getVolumeModifier: function() {
		if(this.fadeDistance == null) {
			return 1.;
		}
		var _this = hxd_snd_Manager.get().listener.position;
		var v = this.position;
		var dx = v.x - _this.x;
		var dy = v.y - _this.y;
		var dz = v.z - _this.z;
		var dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
		if(this.maxDistance != null) {
			dist -= this.maxDistance;
		} else {
			dist -= this.referenceDistance;
		}
		var volume = 1 - dist / this.fadeDistance;
		if(volume > 1) {
			volume = 1;
		}
		if(volume < 0) {
			volume = 0;
		}
		return volume;
	}
	,applyAudibleVolumeModifier: function(v) {
		var _this = hxd_snd_Manager.get().listener.position;
		var v1 = this.position;
		var dx = v1.x - _this.x;
		var dy = v1.y - _this.y;
		var dz = v1.z - _this.z;
		var dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
		var b = this.referenceDistance;
		if(dist < b) {
			dist = b;
		}
		if(this.maxDistance != null) {
			var b = this.maxDistance;
			if(dist > b) {
				dist = b;
			}
		}
		var volume = this.referenceDistance / (this.referenceDistance + this.rollOffFactor * (dist - this.referenceDistance));
		return v * volume;
	}
	,__class__: hxd_snd_effect_Spatialization
});
var hxd_snd_webaudio_BufferHandle = function() {
};
$hxClasses["hxd.snd.webaudio.BufferHandle"] = hxd_snd_webaudio_BufferHandle;
hxd_snd_webaudio_BufferHandle.__name__ = "hxd.snd.webaudio.BufferHandle";
hxd_snd_webaudio_BufferHandle.prototype = {
	__class__: hxd_snd_webaudio_BufferHandle
};
var hxd_snd_webaudio_SourceHandle = function() {
	this.buffers = [];
	this.sampleOffset = 0;
	this.pitch = 1;
	this.firstPlay = true;
};
$hxClasses["hxd.snd.webaudio.SourceHandle"] = hxd_snd_webaudio_SourceHandle;
hxd_snd_webaudio_SourceHandle.__name__ = "hxd.snd.webaudio.SourceHandle";
hxd_snd_webaudio_SourceHandle.prototype = {
	updateDestination: function() {
		this.destination = this.gain;
		if(this.lowPass != null) {
			this.lowPass.connect(this.destination);
			this.destination = this.lowPass;
		}
		if(this.panner != null) {
			this.panner.connect(this.destination);
			this.destination = this.panner;
		}
		this.gain.connect(hxd_snd_webaudio_Context.destination);
		var _g = 0;
		var _g1 = this.buffers;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			if(b.node != null) {
				b.restart(this);
			}
		}
	}
	,applyPitch: function() {
		var t = 0.;
		var _g = 0;
		var _g1 = this.buffers;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			t = b.readjust(t,this);
		}
	}
	,__class__: hxd_snd_webaudio_SourceHandle
};
var hxd_snd_webaudio_BufferPlayback = function() {
};
$hxClasses["hxd.snd.webaudio.BufferPlayback"] = hxd_snd_webaudio_BufferPlayback;
hxd_snd_webaudio_BufferPlayback.__name__ = "hxd.snd.webaudio.BufferPlayback";
hxd_snd_webaudio_BufferPlayback.prototype = {
	get_currentSample: function() {
		if(this.consumed) {
			return this.buffer.samples;
		}
		if(this.node == null || !this.dirty || this.node.context.currentTime < this.lastTime) {
			return 0;
		}
		this.lastSamples += Math.floor((this.node.context.currentTime - this.lastTime) * this.buffer.inst.sampleRate * this.node.playbackRate.value);
		this.lastTime = this.node.context.currentTime;
		return this.lastSamples;
	}
	,set: function(buf,grainOffset) {
		this.buffer = buf;
		this.offset = isNaN(grainOffset) ? 0 : grainOffset;
		this.dirty = false;
		this.consumed = false;
		this.starts = 0;
		this.ends = 0;
	}
	,start: function(ctx,source,time) {
		this.dirty = true;
		this.consumed = false;
		if(this.node != null) {
			this.stop();
		}
		if(source.firstPlay && this.buffer.samples > 10) {
			source.firstPlay = false;
			var _g = [];
			var _g1 = 0;
			var _g2 = this.buffer.inst.numberOfChannels;
			while(_g1 < _g2) {
				var i = _g1++;
				_g.push(this.buffer.inst.getChannelData(i));
			}
			var channels = _g;
			var j = 0;
			var fade = 0.;
			while(j < 10) {
				var i = 0;
				while(i < channels.length) {
					channels[i][j] *= fade;
					++i;
				}
				++j;
				fade += 0.1;
				if(fade > 1) {
					fade = 1;
				}
			}
		}
		this.node = ctx.createBufferSource();
		this.node.buffer = this.buffer.inst;
		this.node.addEventListener("ended",$bind(this,this.onBufferConsumed));
		this.node.connect(source.destination);
		this.node.playbackRate.value = source.pitch;
		this.node.start(time,this.offset);
		this.lastSamples = 0;
		this.lastTime = time;
		this.starts = time;
		return this.ends = time + (this.buffer.inst.duration - this.offset) / source.pitch;
	}
	,readjust: function(time,source) {
		if(this.consumed || this.node == null) {
			return this.ends;
		}
		var ctx = source.driver.ctx;
		var shiftTime = ctx.currentTime;
		this.node.playbackRate.setValueAtTime(source.pitch,shiftTime);
		var elapsed = shiftTime - this.starts;
		if(elapsed < 0) {
			return this.start(ctx,source,time == 0 ? shiftTime : time);
		}
		this.starts = shiftTime - elapsed / source.pitch;
		return this.ends = this.starts + (this.buffer.inst.duration - this.offset) / source.pitch;
	}
	,restart: function(source) {
		if(this.consumed || this.node == null) {
			return;
		}
		var ctx = hxd_snd_webaudio_Context.get();
		if(ctx.currentTime > this.starts) {
			this.offset += (ctx.currentTime - this.starts) * source.pitch;
			this.start(ctx,source,ctx.currentTime);
		} else {
			this.start(ctx,source,this.starts);
		}
	}
	,stop: function(immediate) {
		if(immediate == null) {
			immediate = true;
		}
		if(this.node != null) {
			this.node.removeEventListener("ended",$bind(this,this.onBufferConsumed));
			if(immediate) {
				this.node.disconnect();
			} else {
				this.node.stop();
			}
			this.node = null;
		}
	}
	,onBufferConsumed: function(e) {
		this.node.removeEventListener("ended",$bind(this,this.onBufferConsumed));
		this.node.disconnect();
		this.node = null;
		this.consumed = true;
	}
	,clear: function() {
		this.buffer = null;
		this.node = null;
	}
	,__class__: hxd_snd_webaudio_BufferPlayback
};
var hxd_snd_webaudio_Context = function() { };
$hxClasses["hxd.snd.webaudio.Context"] = hxd_snd_webaudio_Context;
hxd_snd_webaudio_Context.__name__ = "hxd.snd.webaudio.Context";
hxd_snd_webaudio_Context.get = function() {
	if(hxd_snd_webaudio_Context.ctx == null) {
		try {
			hxd_snd_webaudio_Context.ctx = new AudioContext();
		} catch( _g ) {
			try {
				hxd_snd_webaudio_Context.ctx = new window.webkitAudioContext();
			} catch( _g1 ) {
				hxd_snd_webaudio_Context.ctx = null;
			}
		}
		if(hxd_snd_webaudio_Context.ctx == null) {
			throw haxe_Exception.thrown("WebAudio API not available in this browser!");
		}
		if(hxd_snd_webaudio_Context.ctx.state == "suspended") {
			hxd_snd_webaudio_Context.waitForPageInput();
		}
		hxd_snd_webaudio_Context.ctx.addEventListener("statechange",function(_) {
			if(hxd_snd_webaudio_Context.ctx.state == "suspended") {
				hxd_snd_webaudio_Context.waitForPageInput();
			}
		});
		hxd_snd_webaudio_Context.bufferPool = [];
		hxd_snd_webaudio_Context.gainPool = [];
		hxd_snd_webaudio_Context.masterGain = hxd_snd_webaudio_Context.ctx.createGain();
		hxd_snd_webaudio_Context.masterGain.connect(hxd_snd_webaudio_Context.ctx.destination);
		hxd_snd_webaudio_Context.destination = hxd_snd_webaudio_Context.masterGain;
	}
	return hxd_snd_webaudio_Context.ctx;
};
hxd_snd_webaudio_Context.getGain = function() {
	if(hxd_snd_webaudio_Context.gainPool.length != 0) {
		return hxd_snd_webaudio_Context.gainPool.pop();
	} else {
		return hxd_snd_webaudio_Context.ctx.createGain();
	}
};
hxd_snd_webaudio_Context.putGain = function(gain) {
	hxd_snd_webaudio_Context.gainPool.push(gain);
	gain.gain.value = 1;
};
hxd_snd_webaudio_Context.waitForPageInput = function() {
	if(!hxd_snd_webaudio_Context.suspended) {
		window.document.addEventListener("click",hxd_snd_webaudio_Context.resumeContext);
		window.document.addEventListener("keydown",hxd_snd_webaudio_Context.resumeContext);
		window.document.body.addEventListener("keydown",hxd_snd_webaudio_Context.resumeContext);
		window.document.body.addEventListener("touchend",hxd_snd_webaudio_Context.resumeContext);
		hxd_snd_webaudio_Context.suspended = true;
	}
};
hxd_snd_webaudio_Context.resumeContext = function(_) {
	if(hxd_snd_webaudio_Context.suspended) {
		if(hxd_snd_webaudio_Context.ctx != null) {
			hxd_snd_webaudio_Context.ctx.resume();
		}
		window.document.removeEventListener("click",hxd_snd_webaudio_Context.resumeContext);
		window.document.removeEventListener("keydown",hxd_snd_webaudio_Context.resumeContext);
		window.document.body.removeEventListener("keydown",hxd_snd_webaudio_Context.resumeContext);
		window.document.body.removeEventListener("touchend",hxd_snd_webaudio_Context.resumeContext);
		hxd_snd_webaudio_Context.suspended = false;
	}
};
hxd_snd_webaudio_Context.getBuffer = function(channels,sampleCount,rate) {
	var _g = 0;
	var _g1 = hxd_snd_webaudio_Context.bufferPool;
	while(_g < _g1.length) {
		var pool = _g1[_g];
		++_g;
		if(pool.channels == channels && pool.samples == sampleCount && pool.rate == rate) {
			if(pool.pool.length != 0) {
				return pool.pool.pop();
			} else {
				return hxd_snd_webaudio_Context.ctx.createBuffer(channels,sampleCount,rate);
			}
		}
	}
	var pool = new hxd_snd_webaudio__$Context_BufferPool(channels,sampleCount,rate);
	hxd_snd_webaudio_Context.bufferPool.push(pool);
	return hxd_snd_webaudio_Context.ctx.createBuffer(channels,sampleCount,rate);
};
hxd_snd_webaudio_Context.putBuffer = function(buf) {
	var rate = buf.sampleRate | 0;
	var _g = 0;
	var _g1 = hxd_snd_webaudio_Context.bufferPool;
	while(_g < _g1.length) {
		var pool = _g1[_g];
		++_g;
		if(pool.channels == buf.numberOfChannels && pool.samples == buf.length && pool.rate == rate) {
			pool.pool.push(buf);
			break;
		}
	}
};
var hxd_snd_webaudio__$Context_BufferPool = function(channels,samples,rate) {
	this.pool = [];
	this.channels = channels;
	this.samples = samples;
	this.rate = rate;
};
$hxClasses["hxd.snd.webaudio._Context.BufferPool"] = hxd_snd_webaudio__$Context_BufferPool;
hxd_snd_webaudio__$Context_BufferPool.__name__ = "hxd.snd.webaudio._Context.BufferPool";
hxd_snd_webaudio__$Context_BufferPool.prototype = {
	__class__: hxd_snd_webaudio__$Context_BufferPool
};
var hxd_snd_webaudio_Driver = function() {
	this.playbackPool = [];
	this.ctx = hxd_snd_webaudio_Context.get();
};
$hxClasses["hxd.snd.webaudio.Driver"] = hxd_snd_webaudio_Driver;
hxd_snd_webaudio_Driver.__name__ = "hxd.snd.webaudio.Driver";
hxd_snd_webaudio_Driver.__interfaces__ = [hxd_snd_Driver];
hxd_snd_webaudio_Driver.prototype = {
	getBuffer: function(channels,sampleCount,rate) {
		return hxd_snd_webaudio_Context.getBuffer(channels,sampleCount,rate);
	}
	,putBuffer: function(buf) {
		hxd_snd_webaudio_Context.putBuffer(buf);
	}
	,getGain: function() {
		if(hxd_snd_webaudio_Context.gainPool.length != 0) {
			return hxd_snd_webaudio_Context.gainPool.pop();
		} else {
			return hxd_snd_webaudio_Context.ctx.createGain();
		}
	}
	,putGain: function(gain) {
		hxd_snd_webaudio_Context.gainPool.push(gain);
		gain.gain.value = 1;
	}
	,hasFeature: function(d) {
		return true;
	}
	,setMasterVolume: function(value) {
		hxd_snd_webaudio_Context.masterGain.gain.value = value;
	}
	,setListenerParams: function(position,direction,up,velocity) {
		this.ctx.listener.setPosition(-position.x,position.y,position.z);
		this.ctx.listener.setOrientation(-direction.x,direction.y,direction.z,-up.x,up.y,up.z);
	}
	,createSource: function() {
		var s = new hxd_snd_webaudio_SourceHandle();
		s.driver = this;
		s.gain = hxd_snd_webaudio_Context.gainPool.length != 0 ? hxd_snd_webaudio_Context.gainPool.pop() : hxd_snd_webaudio_Context.ctx.createGain();
		s.updateDestination();
		return s;
	}
	,playSource: function(source) {
		if(!source.playing) {
			source.playing = true;
			if(source.buffers.length != 0) {
				var time = this.ctx.currentTime;
				var _g = 0;
				var _g1 = source.buffers;
				while(_g < _g1.length) {
					var b = _g1[_g];
					++_g;
					if(b.consumed) {
						continue;
					}
					time = b.start(this.ctx,source,time);
				}
			}
		}
	}
	,stopSource: function(source) {
		source.playing = false;
		source.sampleOffset = 0;
	}
	,setSourceVolume: function(source,value) {
		source.gain.gain.value = value;
	}
	,destroySource: function(source) {
		this.stopSource(source);
		source.gain.disconnect();
		source.driver = null;
		var gain = source.gain;
		hxd_snd_webaudio_Context.gainPool.push(gain);
		gain.gain.value = 1;
		source.gain = null;
		var _g = 0;
		var _g1 = source.buffers;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			b.stop();
			b.clear();
			this.playbackPool.push(b);
		}
		source.buffers = [];
	}
	,createBuffer: function() {
		var b = new hxd_snd_webaudio_BufferHandle();
		b.samples = 0;
		return b;
	}
	,setBufferData: function(buffer,data,size,format,channelCount,samplingRate) {
		var sampleCount;
		switch(format._hx_index) {
		case 0:
			sampleCount = 1;
			break;
		case 1:
			sampleCount = 2;
			break;
		case 2:
			sampleCount = 4;
			break;
		}
		var sampleCount1 = size / sampleCount / channelCount | 0;
		buffer.samples = sampleCount1;
		if(sampleCount1 == 0) {
			return;
		}
		if(buffer.inst == null) {
			buffer.inst = hxd_snd_webaudio_Context.getBuffer(channelCount,sampleCount1,samplingRate);
		} else if(buffer.inst.sampleRate != samplingRate || buffer.inst.numberOfChannels != channelCount || buffer.inst.length != sampleCount1) {
			hxd_snd_webaudio_Context.putBuffer(buffer.inst);
			buffer.inst = hxd_snd_webaudio_Context.getBuffer(channelCount,sampleCount1,samplingRate);
		}
		switch(format._hx_index) {
		case 0:
			var ui8 = new Uint8Array(data.b.bufferValue);
			if(channelCount == 1) {
				var chn = buffer.inst.getChannelData(0);
				var _g = 0;
				var _g1 = sampleCount1;
				while(_g < _g1) {
					var i = _g++;
					chn[i] = (ui8[i] - 128) / 128;
				}
			} else {
				var left = buffer.inst.getChannelData(0);
				var right = buffer.inst.getChannelData(1);
				var r = 0;
				var _g = 0;
				var _g1 = sampleCount1;
				while(_g < _g1) {
					var i = _g++;
					left[i] = (ui8[r] - 128) / 128;
					right[i] = (ui8[r + 1] - 128) / 128;
					r += channelCount;
				}
			}
			break;
		case 1:
			var i16 = new Int16Array(data.b.bufferValue);
			if(channelCount == 1) {
				var chn = buffer.inst.getChannelData(0);
				var _g = 0;
				var _g1 = sampleCount1;
				while(_g < _g1) {
					var i = _g++;
					chn[i] = i16[i] / 32768;
				}
			} else {
				var left = buffer.inst.getChannelData(0);
				var right = buffer.inst.getChannelData(1);
				var r = 0;
				var _g = 0;
				var _g1 = sampleCount1;
				while(_g < _g1) {
					var i = _g++;
					left[i] = i16[r] / 32768;
					right[i] = i16[r + 1] / 32768;
					r += channelCount;
				}
			}
			break;
		case 2:
			var f32 = new Float32Array(data.b.bufferValue);
			if(channelCount == 1) {
				var chn = buffer.inst.getChannelData(0);
				var _g = 0;
				var _g1 = sampleCount1;
				while(_g < _g1) {
					var i = _g++;
					chn[i] = f32[i];
				}
			} else {
				var left = buffer.inst.getChannelData(0);
				var right = buffer.inst.getChannelData(1);
				var r = 0;
				var _g = 0;
				var _g1 = sampleCount1;
				while(_g < _g1) {
					var i = _g++;
					left[i] = f32[r];
					right[i] = f32[r + 1];
					r += channelCount;
				}
			}
			break;
		}
	}
	,destroyBuffer: function(buffer) {
		if(buffer.inst != null) {
			hxd_snd_webaudio_Context.putBuffer(buffer.inst);
		}
		buffer.inst = null;
	}
	,queueBuffer: function(source,buffer,sampleStart,endOfStream) {
		var buf = this.playbackPool.length != 0 ? this.playbackPool.pop() : new hxd_snd_webaudio_BufferPlayback();
		if(buffer.inst == null) {
			return;
		}
		buf.set(buffer,sampleStart / buffer.inst.length * buffer.inst.duration);
		buffer.isEnd = endOfStream;
		source.buffers.push(buf);
		if(source.playing) {
			if(source.buffers.length != 1) {
				var t = source.buffers[source.buffers.length - 2].ends;
				var tmp = this.ctx;
				var tmp1;
				if(isFinite(t)) {
					var b = this.ctx.currentTime;
					tmp1 = t < b ? b : t;
				} else {
					tmp1 = this.ctx.currentTime;
				}
				buf.start(tmp,source,tmp1);
			} else {
				buf.start(this.ctx,source,this.ctx.currentTime);
			}
		}
	}
	,unqueueBuffer: function(source,buffer) {
		var i = 0;
		while(i < source.buffers.length) {
			var b = source.buffers[i];
			if(b.buffer == buffer) {
				source.buffers.splice(i,1);
				b.stop(!buffer.isEnd);
				b.clear();
				this.playbackPool.push(b);
				break;
			}
		}
		if(buffer.isEnd || !source.playing) {
			source.sampleOffset = 0;
		} else {
			source.sampleOffset += buffer.samples;
		}
	}
	,getProcessedBuffers: function(source) {
		var cnt = 0;
		var _g = 0;
		var _g1 = source.buffers;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			if(b.consumed) {
				++cnt;
			}
		}
		return cnt;
	}
	,getPlayedSampleCount: function(source) {
		var consumed = 0;
		var buf = null;
		var _g = 0;
		var _g1 = source.buffers;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			if(b.consumed) {
				consumed += b.buffer.samples;
			} else if(b.dirty) {
				buf = b;
				break;
			}
		}
		if(buf != null) {
			return source.sampleOffset + consumed + buf.get_currentSample();
		}
		return source.sampleOffset + consumed;
	}
	,update: function() {
	}
	,dispose: function() {
	}
	,getEffectDriver: function(type) {
		switch(type) {
		case "lowpass":
			return new hxd_snd_webaudio_LowPassDriver();
		case "pitch":
			return new hxd_snd_webaudio_PitchDriver();
		case "spatialization":
			return new hxd_snd_webaudio_SpatializationDriver();
		default:
			return new hxd_snd_EffectDriver();
		}
	}
	,get_masterGain: function() {
		return hxd_snd_webaudio_Context.masterGain;
	}
	,set_destination: function(node) {
		return hxd_snd_webaudio_Context.destination = node;
	}
	,get_destination: function() {
		return hxd_snd_webaudio_Context.destination;
	}
	,__class__: hxd_snd_webaudio_Driver
};
var hxd_snd_webaudio_LowPassDriver = function() {
	this.pool = [];
	hxd_snd_EffectDriver.call(this);
};
$hxClasses["hxd.snd.webaudio.LowPassDriver"] = hxd_snd_webaudio_LowPassDriver;
hxd_snd_webaudio_LowPassDriver.__name__ = "hxd.snd.webaudio.LowPassDriver";
hxd_snd_webaudio_LowPassDriver.__super__ = hxd_snd_EffectDriver;
hxd_snd_webaudio_LowPassDriver.prototype = $extend(hxd_snd_EffectDriver.prototype,{
	get: function(ctx) {
		if(this.pool.length != 0) {
			return this.pool.pop();
		}
		var node = ctx.createBiquadFilter();
		node.type = "lowpass";
		return node;
	}
	,bind: function(e,source) {
		source.lowPass = this.get(source.driver.ctx);
		source.updateDestination();
		this.apply(e,source);
	}
	,apply: function(e,source) {
		var min = 40;
		var max = source.driver.ctx.sampleRate / 2;
		var octaves = Math.log(max / min) / Math.LN2;
		source.lowPass.frequency.value = max * Math.pow(2,octaves * (e.gainHF - 1));
	}
	,unbind: function(e,source) {
		this.pool.push(source.lowPass);
		source.lowPass.disconnect();
		source.lowPass = null;
		if(source.driver != null) {
			source.updateDestination();
		}
	}
	,__class__: hxd_snd_webaudio_LowPassDriver
});
var hxd_snd_webaudio_PitchDriver = function() {
	hxd_snd_EffectDriver.call(this);
};
$hxClasses["hxd.snd.webaudio.PitchDriver"] = hxd_snd_webaudio_PitchDriver;
hxd_snd_webaudio_PitchDriver.__name__ = "hxd.snd.webaudio.PitchDriver";
hxd_snd_webaudio_PitchDriver.__super__ = hxd_snd_EffectDriver;
hxd_snd_webaudio_PitchDriver.prototype = $extend(hxd_snd_EffectDriver.prototype,{
	apply: function(e,source) {
		if(source.pitch != e.value) {
			source.pitch = e.value;
			source.applyPitch();
		}
	}
	,unbind: function(e,source) {
		source.pitch = 1;
		source.applyPitch();
	}
	,__class__: hxd_snd_webaudio_PitchDriver
});
var hxd_snd_webaudio_SpatializationDriver = function() {
	this.pool = [];
	hxd_snd_EffectDriver.call(this);
};
$hxClasses["hxd.snd.webaudio.SpatializationDriver"] = hxd_snd_webaudio_SpatializationDriver;
hxd_snd_webaudio_SpatializationDriver.__name__ = "hxd.snd.webaudio.SpatializationDriver";
hxd_snd_webaudio_SpatializationDriver.__super__ = hxd_snd_EffectDriver;
hxd_snd_webaudio_SpatializationDriver.prototype = $extend(hxd_snd_EffectDriver.prototype,{
	get: function(ctx) {
		if(this.pool.length != 0) {
			return this.pool.pop();
		}
		var node = ctx.createPanner();
		return node;
	}
	,bind: function(e,source) {
		source.panner = this.get(source.driver.ctx);
		source.updateDestination();
		this.apply(e,source);
	}
	,apply: function(e,source) {
		source.panner.setPosition(-e.position.x,e.position.y,e.position.z);
		source.panner.setOrientation(-e.direction.x,e.direction.y,e.direction.z);
		source.panner.rolloffFactor = e.rollOffFactor;
		source.panner.refDistance = e.referenceDistance;
		var maxDist = e.maxDistance == null ? 3.40282347e38 : e.maxDistance;
		source.panner.maxDistance = maxDist;
	}
	,unbind: function(e,source) {
		this.pool.push(source.panner);
		source.panner.disconnect();
		source.panner = null;
		if(source.driver != null) {
			source.updateDestination();
		}
	}
	,__class__: hxd_snd_webaudio_SpatializationDriver
});
var hxsl_BufferKind = $hxEnums["hxsl.BufferKind"] = { __ename__:true,__constructs__:null
	,Uniform: {_hx_name:"Uniform",_hx_index:0,__enum__:"hxsl.BufferKind",toString:$estr}
	,Storage: {_hx_name:"Storage",_hx_index:1,__enum__:"hxsl.BufferKind",toString:$estr}
	,RW: {_hx_name:"RW",_hx_index:2,__enum__:"hxsl.BufferKind",toString:$estr}
	,Partial: {_hx_name:"Partial",_hx_index:3,__enum__:"hxsl.BufferKind",toString:$estr}
	,StoragePartial: {_hx_name:"StoragePartial",_hx_index:4,__enum__:"hxsl.BufferKind",toString:$estr}
	,RWPartial: {_hx_name:"RWPartial",_hx_index:5,__enum__:"hxsl.BufferKind",toString:$estr}
};
hxsl_BufferKind.__constructs__ = [hxsl_BufferKind.Uniform,hxsl_BufferKind.Storage,hxsl_BufferKind.RW,hxsl_BufferKind.Partial,hxsl_BufferKind.StoragePartial,hxsl_BufferKind.RWPartial];
hxsl_BufferKind.__empty_constructs__ = [hxsl_BufferKind.Uniform,hxsl_BufferKind.Storage,hxsl_BufferKind.RW,hxsl_BufferKind.Partial,hxsl_BufferKind.StoragePartial,hxsl_BufferKind.RWPartial];
var hxsl_TexDimension = $hxEnums["hxsl.TexDimension"] = { __ename__:true,__constructs__:null
	,T1D: {_hx_name:"T1D",_hx_index:0,__enum__:"hxsl.TexDimension",toString:$estr}
	,T2D: {_hx_name:"T2D",_hx_index:1,__enum__:"hxsl.TexDimension",toString:$estr}
	,T3D: {_hx_name:"T3D",_hx_index:2,__enum__:"hxsl.TexDimension",toString:$estr}
	,TCube: {_hx_name:"TCube",_hx_index:3,__enum__:"hxsl.TexDimension",toString:$estr}
};
hxsl_TexDimension.__constructs__ = [hxsl_TexDimension.T1D,hxsl_TexDimension.T2D,hxsl_TexDimension.T3D,hxsl_TexDimension.TCube];
hxsl_TexDimension.__empty_constructs__ = [hxsl_TexDimension.T1D,hxsl_TexDimension.T2D,hxsl_TexDimension.T3D,hxsl_TexDimension.TCube];
var hxsl_Type = $hxEnums["hxsl.Type"] = { __ename__:true,__constructs__:null
	,TVoid: {_hx_name:"TVoid",_hx_index:0,__enum__:"hxsl.Type",toString:$estr}
	,TInt: {_hx_name:"TInt",_hx_index:1,__enum__:"hxsl.Type",toString:$estr}
	,TBool: {_hx_name:"TBool",_hx_index:2,__enum__:"hxsl.Type",toString:$estr}
	,TFloat: {_hx_name:"TFloat",_hx_index:3,__enum__:"hxsl.Type",toString:$estr}
	,TString: {_hx_name:"TString",_hx_index:4,__enum__:"hxsl.Type",toString:$estr}
	,TVec: ($_=function(size,t) { return {_hx_index:5,size:size,t:t,__enum__:"hxsl.Type",toString:$estr}; },$_._hx_name="TVec",$_.__params__ = ["size","t"],$_)
	,TMat3: {_hx_name:"TMat3",_hx_index:6,__enum__:"hxsl.Type",toString:$estr}
	,TMat4: {_hx_name:"TMat4",_hx_index:7,__enum__:"hxsl.Type",toString:$estr}
	,TMat3x4: {_hx_name:"TMat3x4",_hx_index:8,__enum__:"hxsl.Type",toString:$estr}
	,TBytes: ($_=function(size) { return {_hx_index:9,size:size,__enum__:"hxsl.Type",toString:$estr}; },$_._hx_name="TBytes",$_.__params__ = ["size"],$_)
	,TSampler: ($_=function(dim,isArray) { return {_hx_index:10,dim:dim,isArray:isArray,__enum__:"hxsl.Type",toString:$estr}; },$_._hx_name="TSampler",$_.__params__ = ["dim","isArray"],$_)
	,TRWTexture: ($_=function(dim,isArray,channels) { return {_hx_index:11,dim:dim,isArray:isArray,channels:channels,__enum__:"hxsl.Type",toString:$estr}; },$_._hx_name="TRWTexture",$_.__params__ = ["dim","isArray","channels"],$_)
	,TMat2: {_hx_name:"TMat2",_hx_index:12,__enum__:"hxsl.Type",toString:$estr}
	,TStruct: ($_=function(vl) { return {_hx_index:13,vl:vl,__enum__:"hxsl.Type",toString:$estr}; },$_._hx_name="TStruct",$_.__params__ = ["vl"],$_)
	,TFun: ($_=function(variants) { return {_hx_index:14,variants:variants,__enum__:"hxsl.Type",toString:$estr}; },$_._hx_name="TFun",$_.__params__ = ["variants"],$_)
	,TArray: ($_=function(t,size) { return {_hx_index:15,t:t,size:size,__enum__:"hxsl.Type",toString:$estr}; },$_._hx_name="TArray",$_.__params__ = ["t","size"],$_)
	,TBuffer: ($_=function(t,size,kind) { return {_hx_index:16,t:t,size:size,kind:kind,__enum__:"hxsl.Type",toString:$estr}; },$_._hx_name="TBuffer",$_.__params__ = ["t","size","kind"],$_)
	,TChannel: ($_=function(size) { return {_hx_index:17,size:size,__enum__:"hxsl.Type",toString:$estr}; },$_._hx_name="TChannel",$_.__params__ = ["size"],$_)
};
hxsl_Type.__constructs__ = [hxsl_Type.TVoid,hxsl_Type.TInt,hxsl_Type.TBool,hxsl_Type.TFloat,hxsl_Type.TString,hxsl_Type.TVec,hxsl_Type.TMat3,hxsl_Type.TMat4,hxsl_Type.TMat3x4,hxsl_Type.TBytes,hxsl_Type.TSampler,hxsl_Type.TRWTexture,hxsl_Type.TMat2,hxsl_Type.TStruct,hxsl_Type.TFun,hxsl_Type.TArray,hxsl_Type.TBuffer,hxsl_Type.TChannel];
hxsl_Type.__empty_constructs__ = [hxsl_Type.TVoid,hxsl_Type.TInt,hxsl_Type.TBool,hxsl_Type.TFloat,hxsl_Type.TString,hxsl_Type.TMat3,hxsl_Type.TMat4,hxsl_Type.TMat3x4,hxsl_Type.TMat2];
var hxsl_VecType = $hxEnums["hxsl.VecType"] = { __ename__:true,__constructs__:null
	,VInt: {_hx_name:"VInt",_hx_index:0,__enum__:"hxsl.VecType",toString:$estr}
	,VFloat: {_hx_name:"VFloat",_hx_index:1,__enum__:"hxsl.VecType",toString:$estr}
	,VBool: {_hx_name:"VBool",_hx_index:2,__enum__:"hxsl.VecType",toString:$estr}
};
hxsl_VecType.__constructs__ = [hxsl_VecType.VInt,hxsl_VecType.VFloat,hxsl_VecType.VBool];
hxsl_VecType.__empty_constructs__ = [hxsl_VecType.VInt,hxsl_VecType.VFloat,hxsl_VecType.VBool];
var hxsl_SizeDecl = $hxEnums["hxsl.SizeDecl"] = { __ename__:true,__constructs__:null
	,SConst: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"hxsl.SizeDecl",toString:$estr}; },$_._hx_name="SConst",$_.__params__ = ["v"],$_)
	,SVar: ($_=function(v) { return {_hx_index:1,v:v,__enum__:"hxsl.SizeDecl",toString:$estr}; },$_._hx_name="SVar",$_.__params__ = ["v"],$_)
};
hxsl_SizeDecl.__constructs__ = [hxsl_SizeDecl.SConst,hxsl_SizeDecl.SVar];
hxsl_SizeDecl.__empty_constructs__ = [];
var hxsl_Error = function(msg,pos) {
	this.msg = msg;
	this.pos = pos;
};
$hxClasses["hxsl.Error"] = hxsl_Error;
hxsl_Error.__name__ = "hxsl.Error";
hxsl_Error.t = function(msg,pos) {
	throw haxe_Exception.thrown(new hxsl_Error(msg,pos));
};
hxsl_Error.prototype = {
	toString: function() {
		return "Error(" + this.msg + ")@" + Std.string(this.pos);
	}
	,__class__: hxsl_Error
};
var hxsl_VarKind = $hxEnums["hxsl.VarKind"] = { __ename__:true,__constructs__:null
	,Global: {_hx_name:"Global",_hx_index:0,__enum__:"hxsl.VarKind",toString:$estr}
	,Input: {_hx_name:"Input",_hx_index:1,__enum__:"hxsl.VarKind",toString:$estr}
	,Param: {_hx_name:"Param",_hx_index:2,__enum__:"hxsl.VarKind",toString:$estr}
	,Var: {_hx_name:"Var",_hx_index:3,__enum__:"hxsl.VarKind",toString:$estr}
	,Local: {_hx_name:"Local",_hx_index:4,__enum__:"hxsl.VarKind",toString:$estr}
	,Output: {_hx_name:"Output",_hx_index:5,__enum__:"hxsl.VarKind",toString:$estr}
	,Function: {_hx_name:"Function",_hx_index:6,__enum__:"hxsl.VarKind",toString:$estr}
};
hxsl_VarKind.__constructs__ = [hxsl_VarKind.Global,hxsl_VarKind.Input,hxsl_VarKind.Param,hxsl_VarKind.Var,hxsl_VarKind.Local,hxsl_VarKind.Output,hxsl_VarKind.Function];
hxsl_VarKind.__empty_constructs__ = [hxsl_VarKind.Global,hxsl_VarKind.Input,hxsl_VarKind.Param,hxsl_VarKind.Var,hxsl_VarKind.Local,hxsl_VarKind.Output,hxsl_VarKind.Function];
var hxsl_VarQualifier = $hxEnums["hxsl.VarQualifier"] = { __ename__:true,__constructs__:null
	,Const: ($_=function(max) { return {_hx_index:0,max:max,__enum__:"hxsl.VarQualifier",toString:$estr}; },$_._hx_name="Const",$_.__params__ = ["max"],$_)
	,Private: {_hx_name:"Private",_hx_index:1,__enum__:"hxsl.VarQualifier",toString:$estr}
	,Nullable: {_hx_name:"Nullable",_hx_index:2,__enum__:"hxsl.VarQualifier",toString:$estr}
	,PerObject: {_hx_name:"PerObject",_hx_index:3,__enum__:"hxsl.VarQualifier",toString:$estr}
	,Name: ($_=function(n) { return {_hx_index:4,n:n,__enum__:"hxsl.VarQualifier",toString:$estr}; },$_._hx_name="Name",$_.__params__ = ["n"],$_)
	,Shared: {_hx_name:"Shared",_hx_index:5,__enum__:"hxsl.VarQualifier",toString:$estr}
	,Precision: ($_=function(p) { return {_hx_index:6,p:p,__enum__:"hxsl.VarQualifier",toString:$estr}; },$_._hx_name="Precision",$_.__params__ = ["p"],$_)
	,Range: ($_=function(min,max) { return {_hx_index:7,min:min,max:max,__enum__:"hxsl.VarQualifier",toString:$estr}; },$_._hx_name="Range",$_.__params__ = ["min","max"],$_)
	,Ignore: {_hx_name:"Ignore",_hx_index:8,__enum__:"hxsl.VarQualifier",toString:$estr}
	,PerInstance: ($_=function(v) { return {_hx_index:9,v:v,__enum__:"hxsl.VarQualifier",toString:$estr}; },$_._hx_name="PerInstance",$_.__params__ = ["v"],$_)
	,Doc: ($_=function(s) { return {_hx_index:10,s:s,__enum__:"hxsl.VarQualifier",toString:$estr}; },$_._hx_name="Doc",$_.__params__ = ["s"],$_)
	,Borrow: ($_=function(source) { return {_hx_index:11,source:source,__enum__:"hxsl.VarQualifier",toString:$estr}; },$_._hx_name="Borrow",$_.__params__ = ["source"],$_)
	,Sampler: ($_=function(name) { return {_hx_index:12,name:name,__enum__:"hxsl.VarQualifier",toString:$estr}; },$_._hx_name="Sampler",$_.__params__ = ["name"],$_)
	,Final: {_hx_name:"Final",_hx_index:13,__enum__:"hxsl.VarQualifier",toString:$estr}
	,Flat: {_hx_name:"Flat",_hx_index:14,__enum__:"hxsl.VarQualifier",toString:$estr}
};
hxsl_VarQualifier.__constructs__ = [hxsl_VarQualifier.Const,hxsl_VarQualifier.Private,hxsl_VarQualifier.Nullable,hxsl_VarQualifier.PerObject,hxsl_VarQualifier.Name,hxsl_VarQualifier.Shared,hxsl_VarQualifier.Precision,hxsl_VarQualifier.Range,hxsl_VarQualifier.Ignore,hxsl_VarQualifier.PerInstance,hxsl_VarQualifier.Doc,hxsl_VarQualifier.Borrow,hxsl_VarQualifier.Sampler,hxsl_VarQualifier.Final,hxsl_VarQualifier.Flat];
hxsl_VarQualifier.__empty_constructs__ = [hxsl_VarQualifier.Private,hxsl_VarQualifier.Nullable,hxsl_VarQualifier.PerObject,hxsl_VarQualifier.Shared,hxsl_VarQualifier.Ignore,hxsl_VarQualifier.Final,hxsl_VarQualifier.Flat];
var hxsl_Prec = $hxEnums["hxsl.Prec"] = { __ename__:true,__constructs__:null
	,Low: {_hx_name:"Low",_hx_index:0,__enum__:"hxsl.Prec",toString:$estr}
	,Medium: {_hx_name:"Medium",_hx_index:1,__enum__:"hxsl.Prec",toString:$estr}
	,High: {_hx_name:"High",_hx_index:2,__enum__:"hxsl.Prec",toString:$estr}
};
hxsl_Prec.__constructs__ = [hxsl_Prec.Low,hxsl_Prec.Medium,hxsl_Prec.High];
hxsl_Prec.__empty_constructs__ = [hxsl_Prec.Low,hxsl_Prec.Medium,hxsl_Prec.High];
var hxsl_Const = $hxEnums["hxsl.Const"] = { __ename__:true,__constructs__:null
	,CNull: {_hx_name:"CNull",_hx_index:0,__enum__:"hxsl.Const",toString:$estr}
	,CBool: ($_=function(b) { return {_hx_index:1,b:b,__enum__:"hxsl.Const",toString:$estr}; },$_._hx_name="CBool",$_.__params__ = ["b"],$_)
	,CInt: ($_=function(v) { return {_hx_index:2,v:v,__enum__:"hxsl.Const",toString:$estr}; },$_._hx_name="CInt",$_.__params__ = ["v"],$_)
	,CFloat: ($_=function(v) { return {_hx_index:3,v:v,__enum__:"hxsl.Const",toString:$estr}; },$_._hx_name="CFloat",$_.__params__ = ["v"],$_)
	,CString: ($_=function(v) { return {_hx_index:4,v:v,__enum__:"hxsl.Const",toString:$estr}; },$_._hx_name="CString",$_.__params__ = ["v"],$_)
};
hxsl_Const.__constructs__ = [hxsl_Const.CNull,hxsl_Const.CBool,hxsl_Const.CInt,hxsl_Const.CFloat,hxsl_Const.CString];
hxsl_Const.__empty_constructs__ = [hxsl_Const.CNull];
var hxsl_ExprDef = $hxEnums["hxsl.ExprDef"] = { __ename__:true,__constructs__:null
	,EConst: ($_=function(c) { return {_hx_index:0,c:c,__enum__:"hxsl.ExprDef",toString:$estr}; },$_._hx_name="EConst",$_.__params__ = ["c"],$_)
	,EIdent: ($_=function(i) { return {_hx_index:1,i:i,__enum__:"hxsl.ExprDef",toString:$estr}; },$_._hx_name="EIdent",$_.__params__ = ["i"],$_)
	,EParenthesis: ($_=function(e) { return {_hx_index:2,e:e,__enum__:"hxsl.ExprDef",toString:$estr}; },$_._hx_name="EParenthesis",$_.__params__ = ["e"],$_)
	,EField: ($_=function(e,f) { return {_hx_index:3,e:e,f:f,__enum__:"hxsl.ExprDef",toString:$estr}; },$_._hx_name="EField",$_.__params__ = ["e","f"],$_)
	,EBinop: ($_=function(op,e1,e2) { return {_hx_index:4,op:op,e1:e1,e2:e2,__enum__:"hxsl.ExprDef",toString:$estr}; },$_._hx_name="EBinop",$_.__params__ = ["op","e1","e2"],$_)
	,EUnop: ($_=function(op,e1) { return {_hx_index:5,op:op,e1:e1,__enum__:"hxsl.ExprDef",toString:$estr}; },$_._hx_name="EUnop",$_.__params__ = ["op","e1"],$_)
	,ECall: ($_=function(e,args) { return {_hx_index:6,e:e,args:args,__enum__:"hxsl.ExprDef",toString:$estr}; },$_._hx_name="ECall",$_.__params__ = ["e","args"],$_)
	,EBlock: ($_=function(el) { return {_hx_index:7,el:el,__enum__:"hxsl.ExprDef",toString:$estr}; },$_._hx_name="EBlock",$_.__params__ = ["el"],$_)
	,EVars: ($_=function(v) { return {_hx_index:8,v:v,__enum__:"hxsl.ExprDef",toString:$estr}; },$_._hx_name="EVars",$_.__params__ = ["v"],$_)
	,EFunction: ($_=function(f) { return {_hx_index:9,f:f,__enum__:"hxsl.ExprDef",toString:$estr}; },$_._hx_name="EFunction",$_.__params__ = ["f"],$_)
	,EIf: ($_=function(econd,eif,eelse) { return {_hx_index:10,econd:econd,eif:eif,eelse:eelse,__enum__:"hxsl.ExprDef",toString:$estr}; },$_._hx_name="EIf",$_.__params__ = ["econd","eif","eelse"],$_)
	,EDiscard: {_hx_name:"EDiscard",_hx_index:11,__enum__:"hxsl.ExprDef",toString:$estr}
	,EFor: ($_=function(v,loop,block) { return {_hx_index:12,v:v,loop:loop,block:block,__enum__:"hxsl.ExprDef",toString:$estr}; },$_._hx_name="EFor",$_.__params__ = ["v","loop","block"],$_)
	,EReturn: ($_=function(e) { return {_hx_index:13,e:e,__enum__:"hxsl.ExprDef",toString:$estr}; },$_._hx_name="EReturn",$_.__params__ = ["e"],$_)
	,EBreak: {_hx_name:"EBreak",_hx_index:14,__enum__:"hxsl.ExprDef",toString:$estr}
	,EContinue: {_hx_name:"EContinue",_hx_index:15,__enum__:"hxsl.ExprDef",toString:$estr}
	,EArray: ($_=function(e,eindex) { return {_hx_index:16,e:e,eindex:eindex,__enum__:"hxsl.ExprDef",toString:$estr}; },$_._hx_name="EArray",$_.__params__ = ["e","eindex"],$_)
	,EArrayDecl: ($_=function(el) { return {_hx_index:17,el:el,__enum__:"hxsl.ExprDef",toString:$estr}; },$_._hx_name="EArrayDecl",$_.__params__ = ["el"],$_)
	,ESwitch: ($_=function(e,cases,def) { return {_hx_index:18,e:e,cases:cases,def:def,__enum__:"hxsl.ExprDef",toString:$estr}; },$_._hx_name="ESwitch",$_.__params__ = ["e","cases","def"],$_)
	,EWhile: ($_=function(cond,loop,normalWhile) { return {_hx_index:19,cond:cond,loop:loop,normalWhile:normalWhile,__enum__:"hxsl.ExprDef",toString:$estr}; },$_._hx_name="EWhile",$_.__params__ = ["cond","loop","normalWhile"],$_)
	,EMeta: ($_=function(name,args,e) { return {_hx_index:20,name:name,args:args,e:e,__enum__:"hxsl.ExprDef",toString:$estr}; },$_._hx_name="EMeta",$_.__params__ = ["name","args","e"],$_)
};
hxsl_ExprDef.__constructs__ = [hxsl_ExprDef.EConst,hxsl_ExprDef.EIdent,hxsl_ExprDef.EParenthesis,hxsl_ExprDef.EField,hxsl_ExprDef.EBinop,hxsl_ExprDef.EUnop,hxsl_ExprDef.ECall,hxsl_ExprDef.EBlock,hxsl_ExprDef.EVars,hxsl_ExprDef.EFunction,hxsl_ExprDef.EIf,hxsl_ExprDef.EDiscard,hxsl_ExprDef.EFor,hxsl_ExprDef.EReturn,hxsl_ExprDef.EBreak,hxsl_ExprDef.EContinue,hxsl_ExprDef.EArray,hxsl_ExprDef.EArrayDecl,hxsl_ExprDef.ESwitch,hxsl_ExprDef.EWhile,hxsl_ExprDef.EMeta];
hxsl_ExprDef.__empty_constructs__ = [hxsl_ExprDef.EDiscard,hxsl_ExprDef.EBreak,hxsl_ExprDef.EContinue];
var hxsl_TExprDef = $hxEnums["hxsl.TExprDef"] = { __ename__:true,__constructs__:null
	,TConst: ($_=function(c) { return {_hx_index:0,c:c,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TConst",$_.__params__ = ["c"],$_)
	,TVar: ($_=function(v) { return {_hx_index:1,v:v,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TVar",$_.__params__ = ["v"],$_)
	,TGlobal: ($_=function(g) { return {_hx_index:2,g:g,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TGlobal",$_.__params__ = ["g"],$_)
	,TParenthesis: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TParenthesis",$_.__params__ = ["e"],$_)
	,TBlock: ($_=function(el) { return {_hx_index:4,el:el,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TBlock",$_.__params__ = ["el"],$_)
	,TBinop: ($_=function(op,e1,e2) { return {_hx_index:5,op:op,e1:e1,e2:e2,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TBinop",$_.__params__ = ["op","e1","e2"],$_)
	,TUnop: ($_=function(op,e1) { return {_hx_index:6,op:op,e1:e1,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TUnop",$_.__params__ = ["op","e1"],$_)
	,TVarDecl: ($_=function(v,init) { return {_hx_index:7,v:v,init:init,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TVarDecl",$_.__params__ = ["v","init"],$_)
	,TCall: ($_=function(e,args) { return {_hx_index:8,e:e,args:args,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TCall",$_.__params__ = ["e","args"],$_)
	,TSwiz: ($_=function(e,regs) { return {_hx_index:9,e:e,regs:regs,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TSwiz",$_.__params__ = ["e","regs"],$_)
	,TIf: ($_=function(econd,eif,eelse) { return {_hx_index:10,econd:econd,eif:eif,eelse:eelse,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TIf",$_.__params__ = ["econd","eif","eelse"],$_)
	,TDiscard: {_hx_name:"TDiscard",_hx_index:11,__enum__:"hxsl.TExprDef",toString:$estr}
	,TReturn: ($_=function(e) { return {_hx_index:12,e:e,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TReturn",$_.__params__ = ["e"],$_)
	,TFor: ($_=function(v,it,loop) { return {_hx_index:13,v:v,it:it,loop:loop,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TFor",$_.__params__ = ["v","it","loop"],$_)
	,TContinue: {_hx_name:"TContinue",_hx_index:14,__enum__:"hxsl.TExprDef",toString:$estr}
	,TBreak: {_hx_name:"TBreak",_hx_index:15,__enum__:"hxsl.TExprDef",toString:$estr}
	,TArray: ($_=function(e,index) { return {_hx_index:16,e:e,index:index,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TArray",$_.__params__ = ["e","index"],$_)
	,TArrayDecl: ($_=function(el) { return {_hx_index:17,el:el,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TArrayDecl",$_.__params__ = ["el"],$_)
	,TSwitch: ($_=function(e,cases,def) { return {_hx_index:18,e:e,cases:cases,def:def,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TSwitch",$_.__params__ = ["e","cases","def"],$_)
	,TWhile: ($_=function(e,loop,normalWhile) { return {_hx_index:19,e:e,loop:loop,normalWhile:normalWhile,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TWhile",$_.__params__ = ["e","loop","normalWhile"],$_)
	,TMeta: ($_=function(m,args,e) { return {_hx_index:20,m:m,args:args,e:e,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TMeta",$_.__params__ = ["m","args","e"],$_)
	,TField: ($_=function(e,name) { return {_hx_index:21,e:e,name:name,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TField",$_.__params__ = ["e","name"],$_)
	,TSyntax: ($_=function(target,code,args) { return {_hx_index:22,target:target,code:code,args:args,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TSyntax",$_.__params__ = ["target","code","args"],$_)
};
hxsl_TExprDef.__constructs__ = [hxsl_TExprDef.TConst,hxsl_TExprDef.TVar,hxsl_TExprDef.TGlobal,hxsl_TExprDef.TParenthesis,hxsl_TExprDef.TBlock,hxsl_TExprDef.TBinop,hxsl_TExprDef.TUnop,hxsl_TExprDef.TVarDecl,hxsl_TExprDef.TCall,hxsl_TExprDef.TSwiz,hxsl_TExprDef.TIf,hxsl_TExprDef.TDiscard,hxsl_TExprDef.TReturn,hxsl_TExprDef.TFor,hxsl_TExprDef.TContinue,hxsl_TExprDef.TBreak,hxsl_TExprDef.TArray,hxsl_TExprDef.TArrayDecl,hxsl_TExprDef.TSwitch,hxsl_TExprDef.TWhile,hxsl_TExprDef.TMeta,hxsl_TExprDef.TField,hxsl_TExprDef.TSyntax];
hxsl_TExprDef.__empty_constructs__ = [hxsl_TExprDef.TDiscard,hxsl_TExprDef.TContinue,hxsl_TExprDef.TBreak];
var hxsl_FunctionKind = $hxEnums["hxsl.FunctionKind"] = { __ename__:true,__constructs__:null
	,Vertex: {_hx_name:"Vertex",_hx_index:0,__enum__:"hxsl.FunctionKind",toString:$estr}
	,Fragment: {_hx_name:"Fragment",_hx_index:1,__enum__:"hxsl.FunctionKind",toString:$estr}
	,Init: {_hx_name:"Init",_hx_index:2,__enum__:"hxsl.FunctionKind",toString:$estr}
	,Helper: {_hx_name:"Helper",_hx_index:3,__enum__:"hxsl.FunctionKind",toString:$estr}
	,Main: {_hx_name:"Main",_hx_index:4,__enum__:"hxsl.FunctionKind",toString:$estr}
};
hxsl_FunctionKind.__constructs__ = [hxsl_FunctionKind.Vertex,hxsl_FunctionKind.Fragment,hxsl_FunctionKind.Init,hxsl_FunctionKind.Helper,hxsl_FunctionKind.Main];
hxsl_FunctionKind.__empty_constructs__ = [hxsl_FunctionKind.Vertex,hxsl_FunctionKind.Fragment,hxsl_FunctionKind.Init,hxsl_FunctionKind.Helper,hxsl_FunctionKind.Main];
var hxsl_TGlobal = $hxEnums["hxsl.TGlobal"] = { __ename__:true,__constructs__:null
	,Radians: {_hx_name:"Radians",_hx_index:0,__enum__:"hxsl.TGlobal",toString:$estr}
	,Degrees: {_hx_name:"Degrees",_hx_index:1,__enum__:"hxsl.TGlobal",toString:$estr}
	,Sin: {_hx_name:"Sin",_hx_index:2,__enum__:"hxsl.TGlobal",toString:$estr}
	,Cos: {_hx_name:"Cos",_hx_index:3,__enum__:"hxsl.TGlobal",toString:$estr}
	,Tan: {_hx_name:"Tan",_hx_index:4,__enum__:"hxsl.TGlobal",toString:$estr}
	,Asin: {_hx_name:"Asin",_hx_index:5,__enum__:"hxsl.TGlobal",toString:$estr}
	,Acos: {_hx_name:"Acos",_hx_index:6,__enum__:"hxsl.TGlobal",toString:$estr}
	,Atan: {_hx_name:"Atan",_hx_index:7,__enum__:"hxsl.TGlobal",toString:$estr}
	,Pow: {_hx_name:"Pow",_hx_index:8,__enum__:"hxsl.TGlobal",toString:$estr}
	,Exp: {_hx_name:"Exp",_hx_index:9,__enum__:"hxsl.TGlobal",toString:$estr}
	,Log: {_hx_name:"Log",_hx_index:10,__enum__:"hxsl.TGlobal",toString:$estr}
	,Exp2: {_hx_name:"Exp2",_hx_index:11,__enum__:"hxsl.TGlobal",toString:$estr}
	,Log2: {_hx_name:"Log2",_hx_index:12,__enum__:"hxsl.TGlobal",toString:$estr}
	,Sqrt: {_hx_name:"Sqrt",_hx_index:13,__enum__:"hxsl.TGlobal",toString:$estr}
	,Inversesqrt: {_hx_name:"Inversesqrt",_hx_index:14,__enum__:"hxsl.TGlobal",toString:$estr}
	,Abs: {_hx_name:"Abs",_hx_index:15,__enum__:"hxsl.TGlobal",toString:$estr}
	,Sign: {_hx_name:"Sign",_hx_index:16,__enum__:"hxsl.TGlobal",toString:$estr}
	,Floor: {_hx_name:"Floor",_hx_index:17,__enum__:"hxsl.TGlobal",toString:$estr}
	,Ceil: {_hx_name:"Ceil",_hx_index:18,__enum__:"hxsl.TGlobal",toString:$estr}
	,Fract: {_hx_name:"Fract",_hx_index:19,__enum__:"hxsl.TGlobal",toString:$estr}
	,Mod: {_hx_name:"Mod",_hx_index:20,__enum__:"hxsl.TGlobal",toString:$estr}
	,Min: {_hx_name:"Min",_hx_index:21,__enum__:"hxsl.TGlobal",toString:$estr}
	,Max: {_hx_name:"Max",_hx_index:22,__enum__:"hxsl.TGlobal",toString:$estr}
	,Clamp: {_hx_name:"Clamp",_hx_index:23,__enum__:"hxsl.TGlobal",toString:$estr}
	,Mix: {_hx_name:"Mix",_hx_index:24,__enum__:"hxsl.TGlobal",toString:$estr}
	,InvLerp: {_hx_name:"InvLerp",_hx_index:25,__enum__:"hxsl.TGlobal",toString:$estr}
	,Step: {_hx_name:"Step",_hx_index:26,__enum__:"hxsl.TGlobal",toString:$estr}
	,Smoothstep: {_hx_name:"Smoothstep",_hx_index:27,__enum__:"hxsl.TGlobal",toString:$estr}
	,Length: {_hx_name:"Length",_hx_index:28,__enum__:"hxsl.TGlobal",toString:$estr}
	,Distance: {_hx_name:"Distance",_hx_index:29,__enum__:"hxsl.TGlobal",toString:$estr}
	,Dot: {_hx_name:"Dot",_hx_index:30,__enum__:"hxsl.TGlobal",toString:$estr}
	,Cross: {_hx_name:"Cross",_hx_index:31,__enum__:"hxsl.TGlobal",toString:$estr}
	,Normalize: {_hx_name:"Normalize",_hx_index:32,__enum__:"hxsl.TGlobal",toString:$estr}
	,LReflect: {_hx_name:"LReflect",_hx_index:33,__enum__:"hxsl.TGlobal",toString:$estr}
	,Texture: {_hx_name:"Texture",_hx_index:34,__enum__:"hxsl.TGlobal",toString:$estr}
	,TextureLod: {_hx_name:"TextureLod",_hx_index:35,__enum__:"hxsl.TGlobal",toString:$estr}
	,Texel: {_hx_name:"Texel",_hx_index:36,__enum__:"hxsl.TGlobal",toString:$estr}
	,TextureSize: {_hx_name:"TextureSize",_hx_index:37,__enum__:"hxsl.TGlobal",toString:$estr}
	,ToInt: {_hx_name:"ToInt",_hx_index:38,__enum__:"hxsl.TGlobal",toString:$estr}
	,ToFloat: {_hx_name:"ToFloat",_hx_index:39,__enum__:"hxsl.TGlobal",toString:$estr}
	,ToBool: {_hx_name:"ToBool",_hx_index:40,__enum__:"hxsl.TGlobal",toString:$estr}
	,Vec2: {_hx_name:"Vec2",_hx_index:41,__enum__:"hxsl.TGlobal",toString:$estr}
	,Vec3: {_hx_name:"Vec3",_hx_index:42,__enum__:"hxsl.TGlobal",toString:$estr}
	,Vec4: {_hx_name:"Vec4",_hx_index:43,__enum__:"hxsl.TGlobal",toString:$estr}
	,IVec2: {_hx_name:"IVec2",_hx_index:44,__enum__:"hxsl.TGlobal",toString:$estr}
	,IVec3: {_hx_name:"IVec3",_hx_index:45,__enum__:"hxsl.TGlobal",toString:$estr}
	,IVec4: {_hx_name:"IVec4",_hx_index:46,__enum__:"hxsl.TGlobal",toString:$estr}
	,BVec2: {_hx_name:"BVec2",_hx_index:47,__enum__:"hxsl.TGlobal",toString:$estr}
	,BVec3: {_hx_name:"BVec3",_hx_index:48,__enum__:"hxsl.TGlobal",toString:$estr}
	,BVec4: {_hx_name:"BVec4",_hx_index:49,__enum__:"hxsl.TGlobal",toString:$estr}
	,Mat2: {_hx_name:"Mat2",_hx_index:50,__enum__:"hxsl.TGlobal",toString:$estr}
	,Mat3: {_hx_name:"Mat3",_hx_index:51,__enum__:"hxsl.TGlobal",toString:$estr}
	,Mat4: {_hx_name:"Mat4",_hx_index:52,__enum__:"hxsl.TGlobal",toString:$estr}
	,Mat3x4: {_hx_name:"Mat3x4",_hx_index:53,__enum__:"hxsl.TGlobal",toString:$estr}
	,Saturate: {_hx_name:"Saturate",_hx_index:54,__enum__:"hxsl.TGlobal",toString:$estr}
	,Pack: {_hx_name:"Pack",_hx_index:55,__enum__:"hxsl.TGlobal",toString:$estr}
	,Unpack: {_hx_name:"Unpack",_hx_index:56,__enum__:"hxsl.TGlobal",toString:$estr}
	,PackNormal: {_hx_name:"PackNormal",_hx_index:57,__enum__:"hxsl.TGlobal",toString:$estr}
	,UnpackNormal: {_hx_name:"UnpackNormal",_hx_index:58,__enum__:"hxsl.TGlobal",toString:$estr}
	,ScreenToUv: {_hx_name:"ScreenToUv",_hx_index:59,__enum__:"hxsl.TGlobal",toString:$estr}
	,UvToScreen: {_hx_name:"UvToScreen",_hx_index:60,__enum__:"hxsl.TGlobal",toString:$estr}
	,DFdx: {_hx_name:"DFdx",_hx_index:61,__enum__:"hxsl.TGlobal",toString:$estr}
	,DFdy: {_hx_name:"DFdy",_hx_index:62,__enum__:"hxsl.TGlobal",toString:$estr}
	,Fwidth: {_hx_name:"Fwidth",_hx_index:63,__enum__:"hxsl.TGlobal",toString:$estr}
	,ChannelRead: {_hx_name:"ChannelRead",_hx_index:64,__enum__:"hxsl.TGlobal",toString:$estr}
	,ChannelReadLod: {_hx_name:"ChannelReadLod",_hx_index:65,__enum__:"hxsl.TGlobal",toString:$estr}
	,ChannelFetch: {_hx_name:"ChannelFetch",_hx_index:66,__enum__:"hxsl.TGlobal",toString:$estr}
	,ChannelTextureSize: {_hx_name:"ChannelTextureSize",_hx_index:67,__enum__:"hxsl.TGlobal",toString:$estr}
	,Trace: {_hx_name:"Trace",_hx_index:68,__enum__:"hxsl.TGlobal",toString:$estr}
	,VertexID: {_hx_name:"VertexID",_hx_index:69,__enum__:"hxsl.TGlobal",toString:$estr}
	,InstanceID: {_hx_name:"InstanceID",_hx_index:70,__enum__:"hxsl.TGlobal",toString:$estr}
	,FragCoord: {_hx_name:"FragCoord",_hx_index:71,__enum__:"hxsl.TGlobal",toString:$estr}
	,FrontFacing: {_hx_name:"FrontFacing",_hx_index:72,__enum__:"hxsl.TGlobal",toString:$estr}
	,FloatBitsToInt: {_hx_name:"FloatBitsToInt",_hx_index:73,__enum__:"hxsl.TGlobal",toString:$estr}
	,FloatBitsToUint: {_hx_name:"FloatBitsToUint",_hx_index:74,__enum__:"hxsl.TGlobal",toString:$estr}
	,IntBitsToFloat: {_hx_name:"IntBitsToFloat",_hx_index:75,__enum__:"hxsl.TGlobal",toString:$estr}
	,UintBitsToFloat: {_hx_name:"UintBitsToFloat",_hx_index:76,__enum__:"hxsl.TGlobal",toString:$estr}
	,RoundEven: {_hx_name:"RoundEven",_hx_index:77,__enum__:"hxsl.TGlobal",toString:$estr}
	,SetLayout: {_hx_name:"SetLayout",_hx_index:78,__enum__:"hxsl.TGlobal",toString:$estr}
	,ImageStore: {_hx_name:"ImageStore",_hx_index:79,__enum__:"hxsl.TGlobal",toString:$estr}
	,ComputeVar_GlobalInvocation: {_hx_name:"ComputeVar_GlobalInvocation",_hx_index:80,__enum__:"hxsl.TGlobal",toString:$estr}
	,ComputeVar_LocalInvocation: {_hx_name:"ComputeVar_LocalInvocation",_hx_index:81,__enum__:"hxsl.TGlobal",toString:$estr}
	,ComputeVar_WorkGroup: {_hx_name:"ComputeVar_WorkGroup",_hx_index:82,__enum__:"hxsl.TGlobal",toString:$estr}
	,ComputeVar_LocalInvocationIndex: {_hx_name:"ComputeVar_LocalInvocationIndex",_hx_index:83,__enum__:"hxsl.TGlobal",toString:$estr}
	,AtomicAdd: {_hx_name:"AtomicAdd",_hx_index:84,__enum__:"hxsl.TGlobal",toString:$estr}
	,GroupMemoryBarrier: {_hx_name:"GroupMemoryBarrier",_hx_index:85,__enum__:"hxsl.TGlobal",toString:$estr}
	,UnpackSnorm4x8: {_hx_name:"UnpackSnorm4x8",_hx_index:86,__enum__:"hxsl.TGlobal",toString:$estr}
	,UnpackUnorm4x8: {_hx_name:"UnpackUnorm4x8",_hx_index:87,__enum__:"hxsl.TGlobal",toString:$estr}
};
hxsl_TGlobal.__constructs__ = [hxsl_TGlobal.Radians,hxsl_TGlobal.Degrees,hxsl_TGlobal.Sin,hxsl_TGlobal.Cos,hxsl_TGlobal.Tan,hxsl_TGlobal.Asin,hxsl_TGlobal.Acos,hxsl_TGlobal.Atan,hxsl_TGlobal.Pow,hxsl_TGlobal.Exp,hxsl_TGlobal.Log,hxsl_TGlobal.Exp2,hxsl_TGlobal.Log2,hxsl_TGlobal.Sqrt,hxsl_TGlobal.Inversesqrt,hxsl_TGlobal.Abs,hxsl_TGlobal.Sign,hxsl_TGlobal.Floor,hxsl_TGlobal.Ceil,hxsl_TGlobal.Fract,hxsl_TGlobal.Mod,hxsl_TGlobal.Min,hxsl_TGlobal.Max,hxsl_TGlobal.Clamp,hxsl_TGlobal.Mix,hxsl_TGlobal.InvLerp,hxsl_TGlobal.Step,hxsl_TGlobal.Smoothstep,hxsl_TGlobal.Length,hxsl_TGlobal.Distance,hxsl_TGlobal.Dot,hxsl_TGlobal.Cross,hxsl_TGlobal.Normalize,hxsl_TGlobal.LReflect,hxsl_TGlobal.Texture,hxsl_TGlobal.TextureLod,hxsl_TGlobal.Texel,hxsl_TGlobal.TextureSize,hxsl_TGlobal.ToInt,hxsl_TGlobal.ToFloat,hxsl_TGlobal.ToBool,hxsl_TGlobal.Vec2,hxsl_TGlobal.Vec3,hxsl_TGlobal.Vec4,hxsl_TGlobal.IVec2,hxsl_TGlobal.IVec3,hxsl_TGlobal.IVec4,hxsl_TGlobal.BVec2,hxsl_TGlobal.BVec3,hxsl_TGlobal.BVec4,hxsl_TGlobal.Mat2,hxsl_TGlobal.Mat3,hxsl_TGlobal.Mat4,hxsl_TGlobal.Mat3x4,hxsl_TGlobal.Saturate,hxsl_TGlobal.Pack,hxsl_TGlobal.Unpack,hxsl_TGlobal.PackNormal,hxsl_TGlobal.UnpackNormal,hxsl_TGlobal.ScreenToUv,hxsl_TGlobal.UvToScreen,hxsl_TGlobal.DFdx,hxsl_TGlobal.DFdy,hxsl_TGlobal.Fwidth,hxsl_TGlobal.ChannelRead,hxsl_TGlobal.ChannelReadLod,hxsl_TGlobal.ChannelFetch,hxsl_TGlobal.ChannelTextureSize,hxsl_TGlobal.Trace,hxsl_TGlobal.VertexID,hxsl_TGlobal.InstanceID,hxsl_TGlobal.FragCoord,hxsl_TGlobal.FrontFacing,hxsl_TGlobal.FloatBitsToInt,hxsl_TGlobal.FloatBitsToUint,hxsl_TGlobal.IntBitsToFloat,hxsl_TGlobal.UintBitsToFloat,hxsl_TGlobal.RoundEven,hxsl_TGlobal.SetLayout,hxsl_TGlobal.ImageStore,hxsl_TGlobal.ComputeVar_GlobalInvocation,hxsl_TGlobal.ComputeVar_LocalInvocation,hxsl_TGlobal.ComputeVar_WorkGroup,hxsl_TGlobal.ComputeVar_LocalInvocationIndex,hxsl_TGlobal.AtomicAdd,hxsl_TGlobal.GroupMemoryBarrier,hxsl_TGlobal.UnpackSnorm4x8,hxsl_TGlobal.UnpackUnorm4x8];
hxsl_TGlobal.__empty_constructs__ = [hxsl_TGlobal.Radians,hxsl_TGlobal.Degrees,hxsl_TGlobal.Sin,hxsl_TGlobal.Cos,hxsl_TGlobal.Tan,hxsl_TGlobal.Asin,hxsl_TGlobal.Acos,hxsl_TGlobal.Atan,hxsl_TGlobal.Pow,hxsl_TGlobal.Exp,hxsl_TGlobal.Log,hxsl_TGlobal.Exp2,hxsl_TGlobal.Log2,hxsl_TGlobal.Sqrt,hxsl_TGlobal.Inversesqrt,hxsl_TGlobal.Abs,hxsl_TGlobal.Sign,hxsl_TGlobal.Floor,hxsl_TGlobal.Ceil,hxsl_TGlobal.Fract,hxsl_TGlobal.Mod,hxsl_TGlobal.Min,hxsl_TGlobal.Max,hxsl_TGlobal.Clamp,hxsl_TGlobal.Mix,hxsl_TGlobal.InvLerp,hxsl_TGlobal.Step,hxsl_TGlobal.Smoothstep,hxsl_TGlobal.Length,hxsl_TGlobal.Distance,hxsl_TGlobal.Dot,hxsl_TGlobal.Cross,hxsl_TGlobal.Normalize,hxsl_TGlobal.LReflect,hxsl_TGlobal.Texture,hxsl_TGlobal.TextureLod,hxsl_TGlobal.Texel,hxsl_TGlobal.TextureSize,hxsl_TGlobal.ToInt,hxsl_TGlobal.ToFloat,hxsl_TGlobal.ToBool,hxsl_TGlobal.Vec2,hxsl_TGlobal.Vec3,hxsl_TGlobal.Vec4,hxsl_TGlobal.IVec2,hxsl_TGlobal.IVec3,hxsl_TGlobal.IVec4,hxsl_TGlobal.BVec2,hxsl_TGlobal.BVec3,hxsl_TGlobal.BVec4,hxsl_TGlobal.Mat2,hxsl_TGlobal.Mat3,hxsl_TGlobal.Mat4,hxsl_TGlobal.Mat3x4,hxsl_TGlobal.Saturate,hxsl_TGlobal.Pack,hxsl_TGlobal.Unpack,hxsl_TGlobal.PackNormal,hxsl_TGlobal.UnpackNormal,hxsl_TGlobal.ScreenToUv,hxsl_TGlobal.UvToScreen,hxsl_TGlobal.DFdx,hxsl_TGlobal.DFdy,hxsl_TGlobal.Fwidth,hxsl_TGlobal.ChannelRead,hxsl_TGlobal.ChannelReadLod,hxsl_TGlobal.ChannelFetch,hxsl_TGlobal.ChannelTextureSize,hxsl_TGlobal.Trace,hxsl_TGlobal.VertexID,hxsl_TGlobal.InstanceID,hxsl_TGlobal.FragCoord,hxsl_TGlobal.FrontFacing,hxsl_TGlobal.FloatBitsToInt,hxsl_TGlobal.FloatBitsToUint,hxsl_TGlobal.IntBitsToFloat,hxsl_TGlobal.UintBitsToFloat,hxsl_TGlobal.RoundEven,hxsl_TGlobal.SetLayout,hxsl_TGlobal.ImageStore,hxsl_TGlobal.ComputeVar_GlobalInvocation,hxsl_TGlobal.ComputeVar_LocalInvocation,hxsl_TGlobal.ComputeVar_WorkGroup,hxsl_TGlobal.ComputeVar_LocalInvocationIndex,hxsl_TGlobal.AtomicAdd,hxsl_TGlobal.GroupMemoryBarrier,hxsl_TGlobal.UnpackSnorm4x8,hxsl_TGlobal.UnpackUnorm4x8];
var hxsl_SyntaxArgAccess = $hxEnums["hxsl.SyntaxArgAccess"] = { __ename__:true,__constructs__:null
	,Read: {_hx_name:"Read",_hx_index:0,__enum__:"hxsl.SyntaxArgAccess",toString:$estr}
	,Write: {_hx_name:"Write",_hx_index:1,__enum__:"hxsl.SyntaxArgAccess",toString:$estr}
	,ReadWrite: {_hx_name:"ReadWrite",_hx_index:2,__enum__:"hxsl.SyntaxArgAccess",toString:$estr}
};
hxsl_SyntaxArgAccess.__constructs__ = [hxsl_SyntaxArgAccess.Read,hxsl_SyntaxArgAccess.Write,hxsl_SyntaxArgAccess.ReadWrite];
hxsl_SyntaxArgAccess.__empty_constructs__ = [hxsl_SyntaxArgAccess.Read,hxsl_SyntaxArgAccess.Write,hxsl_SyntaxArgAccess.ReadWrite];
var hxsl_Component = $hxEnums["hxsl.Component"] = { __ename__:true,__constructs__:null
	,X: {_hx_name:"X",_hx_index:0,__enum__:"hxsl.Component",toString:$estr}
	,Y: {_hx_name:"Y",_hx_index:1,__enum__:"hxsl.Component",toString:$estr}
	,Z: {_hx_name:"Z",_hx_index:2,__enum__:"hxsl.Component",toString:$estr}
	,W: {_hx_name:"W",_hx_index:3,__enum__:"hxsl.Component",toString:$estr}
};
hxsl_Component.__constructs__ = [hxsl_Component.X,hxsl_Component.Y,hxsl_Component.Z,hxsl_Component.W];
hxsl_Component.__empty_constructs__ = [hxsl_Component.X,hxsl_Component.Y,hxsl_Component.Z,hxsl_Component.W];
var hxsl_Tools = function() { };
$hxClasses["hxsl.Tools"] = hxsl_Tools;
hxsl_Tools.__name__ = "hxsl.Tools";
hxsl_Tools.allocVarId = function() {
	return ++hxsl_Tools.UID;
};
hxsl_Tools.getTexUVSize = function(dim,arr) {
	if(arr == null) {
		arr = false;
	}
	var size;
	switch(dim._hx_index) {
	case 0:
		size = 1;
		break;
	case 1:
		size = 2;
		break;
	case 2:case 3:
		size = 3;
		break;
	}
	if(arr) {
		++size;
	}
	return size;
};
hxsl_Tools.getDimSize = function(dim,arr) {
	if(arr == null) {
		arr = false;
	}
	var size;
	switch(dim._hx_index) {
	case 0:
		size = 1;
		break;
	case 2:
		size = 3;
		break;
	case 1:case 3:
		size = 2;
		break;
	}
	if(arr) {
		++size;
	}
	return size;
};
hxsl_Tools.getName = function(v) {
	if(v.qualifiers == null) {
		return v.name;
	}
	var _g = 0;
	var _g1 = v.qualifiers;
	while(_g < _g1.length) {
		var q = _g1[_g];
		++_g;
		if(q._hx_index == 4) {
			var n = q.n;
			return n;
		}
	}
	return v.name;
};
hxsl_Tools.getDoc = function(v) {
	if(v.qualifiers == null) {
		return null;
	}
	var _g = 0;
	var _g1 = v.qualifiers;
	while(_g < _g1.length) {
		var q = _g1[_g];
		++_g;
		if(q._hx_index == 10) {
			var s = q.s;
			return s;
		}
	}
	return null;
};
hxsl_Tools.getConstBits = function(v) {
	var _g = v.type;
	switch(_g._hx_index) {
	case 1:
		var _g1 = 0;
		var _g2 = v.qualifiers;
		while(_g1 < _g2.length) {
			var q = _g2[_g1];
			++_g1;
			if(q._hx_index == 0) {
				var n = q.max;
				if(n != null) {
					var bits = 0;
					while(n >= 1 << bits) ++bits;
					return bits;
				}
				return 8;
			}
		}
		break;
	case 2:
		return 1;
	case 16:
		var _g1 = _g.t;
		var _g1 = _g.size;
		switch(_g.kind._hx_index) {
		case 3:case 4:case 5:
			return hxsl_Tools.MAX_PARTIAL_MAPPINGS_BITS;
		default:
		}
		break;
	case 17:
		var _g1 = _g.size;
		return 3 + hxsl_Tools.MAX_CHANNELS_BITS;
	default:
	}
	return 0;
};
hxsl_Tools.isConst = function(v) {
	var _g = v.type;
	var tmp;
	switch(_g._hx_index) {
	case 16:
		var _g1 = _g.t;
		var _g1 = _g.size;
		switch(_g.kind._hx_index) {
		case 3:case 4:case 5:
			tmp = true;
			break;
		default:
			tmp = false;
		}
		break;
	case 17:
		var _g1 = _g.size;
		tmp = true;
		break;
	default:
		tmp = false;
	}
	if(tmp) {
		return true;
	}
	if(v.qualifiers != null) {
		var _g = 0;
		var _g1 = v.qualifiers;
		while(_g < _g1.length) {
			var q = _g1[_g];
			++_g;
			if(q._hx_index == 0) {
				var _g2 = q.max;
				return true;
			}
		}
	}
	return false;
};
hxsl_Tools.isStruct = function(v) {
	var _g = v.type;
	if(_g._hx_index == 13) {
		var _g1 = _g.vl;
		return true;
	} else {
		return false;
	}
};
hxsl_Tools.isArray = function(v) {
	var _g = v.type;
	if(_g._hx_index == 15) {
		var _g1 = _g.t;
		var _g1 = _g.size;
		return true;
	} else {
		return false;
	}
};
hxsl_Tools.hasQualifier = function(v,q) {
	if(v.qualifiers != null) {
		var _g = 0;
		var _g1 = v.qualifiers;
		while(_g < _g1.length) {
			var q2 = _g1[_g];
			++_g;
			if(q2 == q) {
				return true;
			}
		}
	}
	return false;
};
hxsl_Tools.hasBorrowQualifier = function(v,path) {
	if(v.qualifiers != null) {
		var _g = 0;
		var _g1 = v.qualifiers;
		while(_g < _g1.length) {
			var q = _g1[_g];
			++_g;
			if(q._hx_index == 11) {
				var s = q.source;
				return path == s;
			}
		}
	}
	return false;
};
hxsl_Tools.isTexture = function(t) {
	switch(t._hx_index) {
	case 10:
		var _g = t.dim;
		var _g = t.isArray;
		return true;
	case 11:
		var _g = t.dim;
		var _g = t.isArray;
		var _g = t.channels;
		return true;
	case 17:
		var _g = t.size;
		return true;
	default:
		return false;
	}
};
hxsl_Tools.toString = function(t) {
	switch(t._hx_index) {
	case 5:
		var size = t.size;
		var t1 = t.t;
		var prefix;
		switch(t1._hx_index) {
		case 0:
			prefix = "i";
			break;
		case 1:
			prefix = "";
			break;
		case 2:
			prefix = "b";
			break;
		}
		return prefix + "vec" + size;
	case 9:
		var n = t.size;
		return "Bytes" + n;
	case 10:
		var dim = t.dim;
		var arr = t.isArray;
		return "Sampler" + HxOverrides.substr($hxEnums[dim.__enum__].__constructs__[dim._hx_index]._hx_name,1,null) + (arr ? "Array" : "");
	case 11:
		var dim = t.dim;
		var arr = t.isArray;
		var dims = t.channels;
		return "RWTexture" + HxOverrides.substr($hxEnums[dim.__enum__].__constructs__[dim._hx_index]._hx_name,1,null) + (arr ? "Array" : "") + "<" + (dims == 1 ? "Float" : "Vec" + dims) + ">";
	case 13:
		var vl = t.vl;
		var _g = [];
		var _g1 = 0;
		while(_g1 < vl.length) {
			var v = vl[_g1];
			++_g1;
			_g.push(v.name + " : " + hxsl_Tools.toString(v.type));
		}
		return "{" + _g.join(",") + "}";
	case 15:
		var t1 = t.t;
		var s = t.size;
		var tmp = hxsl_Tools.toString(t1) + "[";
		var tmp1;
		switch(s._hx_index) {
		case 0:
			var i = s.v;
			tmp1 = "" + i;
			break;
		case 1:
			var v = s.v;
			tmp1 = v.name;
			break;
		}
		return tmp + tmp1 + "]";
	case 16:
		var t1 = t.t;
		var s = t.size;
		var k = t.kind;
		var prefix;
		switch(k._hx_index) {
		case 0:
			prefix = "Buffer";
			break;
		case 1:
			prefix = "StorageBuffer";
			break;
		case 2:
			prefix = "RWBuffer";
			break;
		case 3:
			prefix = "PartialBuffer";
			break;
		case 4:
			prefix = "StoragePartialBuffer";
			break;
		case 5:
			prefix = "RWPartialBuffer";
			break;
		}
		var tmp = prefix + " " + hxsl_Tools.toString(t1) + "[";
		var tmp1;
		switch(s._hx_index) {
		case 0:
			var i = s.v;
			tmp1 = "" + i;
			break;
		case 1:
			var v = s.v;
			tmp1 = v.name;
			break;
		}
		return tmp + tmp1 + "]";
	default:
		return HxOverrides.substr($hxEnums[t.__enum__].__constructs__[t._hx_index]._hx_name,1,null);
	}
};
hxsl_Tools.toType = function(t) {
	switch(t._hx_index) {
	case 0:
		return hxsl_Type.TInt;
	case 1:
		return hxsl_Type.TFloat;
	case 2:
		return hxsl_Type.TBool;
	}
};
hxsl_Tools.hasSideEffect = function(e) {
	var _g = e.e;
	switch(_g._hx_index) {
	case 0:
		var _g1 = _g.c;
		return false;
	case 1:
		var _g1 = _g.v;
		return false;
	case 2:
		var _g1 = _g.g;
		return false;
	case 3:
		var e = _g.e;
		return hxsl_Tools.hasSideEffect(e);
	case 4:
		var el = _g.el;
		var _g1 = 0;
		while(_g1 < el.length) {
			var e = el[_g1];
			++_g1;
			if(hxsl_Tools.hasSideEffect(e)) {
				return true;
			}
		}
		return false;
	case 5:
		var _g1 = _g.op;
		var _g2 = _g.e1;
		var _g3 = _g.e2;
		switch(_g1._hx_index) {
		case 4:
			return true;
		case 20:
			var _g4 = _g1.op;
			return true;
		default:
			var e1 = _g2;
			var e2 = _g3;
			if(!hxsl_Tools.hasSideEffect(e1)) {
				return hxsl_Tools.hasSideEffect(e2);
			} else {
				return true;
			}
		}
		break;
	case 6:
		var _g1 = _g.op;
		var e1 = _g.e1;
		return hxsl_Tools.hasSideEffect(e1);
	case 7:
		var _g1 = _g.v;
		var _g1 = _g.init;
		return true;
	case 8:
		var _g1 = _g.e;
		var _g2 = _g.args;
		var _g3 = _g1.e;
		var _g4 = _g1.p;
		var _g4 = _g1.t;
		if(_g3._hx_index == 2) {
			if(_g3.g._hx_index == 78) {
				return true;
			} else {
				var e = _g1;
				var pl = _g2;
				var _g3 = e.e;
				if(_g3._hx_index == 2) {
					var _g4 = _g3.g;
					switch(_g4._hx_index) {
					case 79:case 84:case 85:
						return true;
					default:
						var g = _g4;
					}
				} else {
					return true;
				}
				var _g3 = 0;
				while(_g3 < pl.length) {
					var p = pl[_g3];
					++_g3;
					if(hxsl_Tools.hasSideEffect(p)) {
						return true;
					}
				}
				return false;
			}
		} else {
			var e = _g1;
			var pl = _g2;
			var _g1 = e.e;
			if(_g1._hx_index == 2) {
				var _g2 = _g1.g;
				switch(_g2._hx_index) {
				case 79:case 84:case 85:
					return true;
				default:
					var g = _g2;
				}
			} else {
				return true;
			}
			var _g1 = 0;
			while(_g1 < pl.length) {
				var p = pl[_g1];
				++_g1;
				if(hxsl_Tools.hasSideEffect(p)) {
					return true;
				}
			}
			return false;
		}
		break;
	case 9:
		var _g1 = _g.regs;
		var e = _g.e;
		return hxsl_Tools.hasSideEffect(e);
	case 10:
		var econd = _g.econd;
		var eif = _g.eif;
		var eelse = _g.eelse;
		if(!(hxsl_Tools.hasSideEffect(econd) || hxsl_Tools.hasSideEffect(eif))) {
			if(eelse != null) {
				return hxsl_Tools.hasSideEffect(eelse);
			} else {
				return false;
			}
		} else {
			return true;
		}
		break;
	case 12:
		var _g1 = _g.e;
		return true;
	case 13:
		var _g1 = _g.v;
		var it = _g.it;
		var loop = _g.loop;
		if(!hxsl_Tools.hasSideEffect(it)) {
			return hxsl_Tools.hasSideEffect(loop);
		} else {
			return true;
		}
		break;
	case 11:case 14:case 15:
		return true;
	case 16:
		var e = _g.e;
		var index = _g.index;
		if(!hxsl_Tools.hasSideEffect(e)) {
			return hxsl_Tools.hasSideEffect(index);
		} else {
			return true;
		}
		break;
	case 17:
		var el = _g.el;
		var _g1 = 0;
		while(_g1 < el.length) {
			var e = el[_g1];
			++_g1;
			if(hxsl_Tools.hasSideEffect(e)) {
				return true;
			}
		}
		return false;
	case 18:
		var e = _g.e;
		var cases = _g.cases;
		var def = _g.def;
		var _g1 = 0;
		while(_g1 < cases.length) {
			var c = cases[_g1];
			++_g1;
			var _g2 = 0;
			var _g3 = c.values;
			while(_g2 < _g3.length) {
				var v = _g3[_g2];
				++_g2;
				if(hxsl_Tools.hasSideEffect(v)) {
					return true;
				}
			}
			if(hxsl_Tools.hasSideEffect(c.expr)) {
				return true;
			}
		}
		if(!hxsl_Tools.hasSideEffect(e)) {
			if(def != null) {
				return hxsl_Tools.hasSideEffect(def);
			} else {
				return false;
			}
		} else {
			return true;
		}
		break;
	case 19:
		var _g1 = _g.normalWhile;
		var e = _g.e;
		var loop = _g.loop;
		if(!hxsl_Tools.hasSideEffect(e)) {
			return hxsl_Tools.hasSideEffect(loop);
		} else {
			return true;
		}
		break;
	case 20:
		var _g1 = _g.m;
		var _g1 = _g.args;
		var e = _g.e;
		return hxsl_Tools.hasSideEffect(e);
	case 21:
		var _g1 = _g.name;
		var e = _g.e;
		return hxsl_Tools.hasSideEffect(e);
	case 22:
		var _g1 = _g.target;
		var _g1 = _g.code;
		var _g1 = _g.args;
		return true;
	}
};
hxsl_Tools.iter = function(e,f) {
	var _g = e.e;
	switch(_g._hx_index) {
	case 0:
		var _g1 = _g.c;
		break;
	case 1:
		var _g1 = _g.v;
		break;
	case 2:
		var _g1 = _g.g;
		break;
	case 3:
		var e = _g.e;
		f(e);
		break;
	case 4:
		var el = _g.el;
		var _g1 = 0;
		while(_g1 < el.length) {
			var e = el[_g1];
			++_g1;
			f(e);
		}
		break;
	case 5:
		var _g1 = _g.op;
		var e1 = _g.e1;
		var e2 = _g.e2;
		f(e1);
		f(e2);
		break;
	case 6:
		var _g1 = _g.op;
		var e1 = _g.e1;
		f(e1);
		break;
	case 7:
		var _g1 = _g.v;
		var init = _g.init;
		if(init != null) {
			f(init);
		}
		break;
	case 8:
		var e = _g.e;
		var args = _g.args;
		f(e);
		var _g1 = 0;
		while(_g1 < args.length) {
			var a = args[_g1];
			++_g1;
			f(a);
		}
		break;
	case 9:
		var _g1 = _g.regs;
		var e = _g.e;
		f(e);
		break;
	case 10:
		var econd = _g.econd;
		var eif = _g.eif;
		var eelse = _g.eelse;
		f(econd);
		f(eif);
		if(eelse != null) {
			f(eelse);
		}
		break;
	case 12:
		var e = _g.e;
		if(e != null) {
			f(e);
		}
		break;
	case 13:
		var _g1 = _g.v;
		var it = _g.it;
		var loop = _g.loop;
		f(it);
		f(loop);
		break;
	case 11:case 14:case 15:
		break;
	case 16:
		var e = _g.e;
		var index = _g.index;
		f(e);
		f(index);
		break;
	case 17:
		var el = _g.el;
		var _g1 = 0;
		while(_g1 < el.length) {
			var e = el[_g1];
			++_g1;
			f(e);
		}
		break;
	case 18:
		var e = _g.e;
		var cases = _g.cases;
		var def = _g.def;
		f(e);
		var _g1 = 0;
		while(_g1 < cases.length) {
			var c = cases[_g1];
			++_g1;
			var _g2 = 0;
			var _g3 = c.values;
			while(_g2 < _g3.length) {
				var v = _g3[_g2];
				++_g2;
				f(v);
			}
			f(c.expr);
		}
		if(def != null) {
			f(def);
		}
		break;
	case 19:
		var _g1 = _g.normalWhile;
		var e = _g.e;
		var loop = _g.loop;
		f(e);
		f(loop);
		break;
	case 20:
		var _g1 = _g.m;
		var _g1 = _g.args;
		var e = _g.e;
		f(e);
		break;
	case 21:
		var _g1 = _g.name;
		var e = _g.e;
		f(e);
		break;
	case 22:
		var _g1 = _g.target;
		var _g1 = _g.code;
		var args = _g.args;
		var _g = 0;
		while(_g < args.length) {
			var arg = args[_g];
			++_g;
			f(arg.e);
		}
		break;
	}
};
hxsl_Tools.map = function(e,f) {
	var ed;
	var _g = e.e;
	switch(_g._hx_index) {
	case 0:
		var _g1 = _g.c;
		ed = e.e;
		break;
	case 1:
		var _g1 = _g.v;
		ed = e.e;
		break;
	case 2:
		var _g1 = _g.g;
		ed = e.e;
		break;
	case 3:
		var e1 = _g.e;
		ed = hxsl_TExprDef.TParenthesis(f(e1));
		break;
	case 4:
		var el = _g.el;
		var _g1 = [];
		var _g2 = 0;
		while(_g2 < el.length) {
			var e1 = el[_g2];
			++_g2;
			_g1.push(f(e1));
		}
		ed = hxsl_TExprDef.TBlock(_g1);
		break;
	case 5:
		var op = _g.op;
		var e1 = _g.e1;
		var e2 = _g.e2;
		ed = hxsl_TExprDef.TBinop(op,f(e1),f(e2));
		break;
	case 6:
		var op = _g.op;
		var e1 = _g.e1;
		ed = hxsl_TExprDef.TUnop(op,f(e1));
		break;
	case 7:
		var v = _g.v;
		var init = _g.init;
		ed = hxsl_TExprDef.TVarDecl(v,init != null ? f(init) : null);
		break;
	case 8:
		var e1 = _g.e;
		var args = _g.args;
		var ed1 = f(e1);
		var _g1 = [];
		var _g2 = 0;
		while(_g2 < args.length) {
			var a = args[_g2];
			++_g2;
			_g1.push(f(a));
		}
		ed = hxsl_TExprDef.TCall(ed1,_g1);
		break;
	case 9:
		var e1 = _g.e;
		var c = _g.regs;
		ed = hxsl_TExprDef.TSwiz(f(e1),c);
		break;
	case 10:
		var econd = _g.econd;
		var eif = _g.eif;
		var eelse = _g.eelse;
		ed = hxsl_TExprDef.TIf(f(econd),f(eif),eelse != null ? f(eelse) : null);
		break;
	case 12:
		var e1 = _g.e;
		ed = hxsl_TExprDef.TReturn(e1 != null ? f(e1) : null);
		break;
	case 13:
		var v = _g.v;
		var it = _g.it;
		var loop = _g.loop;
		ed = hxsl_TExprDef.TFor(v,f(it),f(loop));
		break;
	case 11:case 14:case 15:
		ed = e.e;
		break;
	case 16:
		var e1 = _g.e;
		var index = _g.index;
		ed = hxsl_TExprDef.TArray(f(e1),f(index));
		break;
	case 17:
		var el = _g.el;
		var _g1 = [];
		var _g2 = 0;
		while(_g2 < el.length) {
			var e1 = el[_g2];
			++_g2;
			_g1.push(f(e1));
		}
		ed = hxsl_TExprDef.TArrayDecl(_g1);
		break;
	case 18:
		var e1 = _g.e;
		var cases = _g.cases;
		var def = _g.def;
		var ed1 = f(e1);
		var _g1 = [];
		var _g2 = 0;
		while(_g2 < cases.length) {
			var c = cases[_g2];
			++_g2;
			var _g3 = [];
			var _g4 = 0;
			var _g5 = c.values;
			while(_g4 < _g5.length) {
				var v = _g5[_g4];
				++_g4;
				_g3.push(f(v));
			}
			_g1.push({ values : _g3, expr : f(c.expr)});
		}
		ed = hxsl_TExprDef.TSwitch(ed1,_g1,def == null ? null : f(def));
		break;
	case 19:
		var e1 = _g.e;
		var loop = _g.loop;
		var normalWhile = _g.normalWhile;
		ed = hxsl_TExprDef.TWhile(f(e1),f(loop),normalWhile);
		break;
	case 20:
		var m = _g.m;
		var args = _g.args;
		var e1 = _g.e;
		ed = hxsl_TExprDef.TMeta(m,args,f(e1));
		break;
	case 21:
		var e1 = _g.e;
		var name = _g.name;
		ed = hxsl_TExprDef.TField(f(e1),name);
		break;
	case 22:
		var target = _g.target;
		var code = _g.code;
		var args = _g.args;
		var _g = [];
		var _g1 = 0;
		while(_g1 < args.length) {
			var arg = args[_g1];
			++_g1;
			_g.push({ e : f(arg.e), access : arg.access});
		}
		ed = hxsl_TExprDef.TSyntax(target,code,_g);
		break;
	}
	return { e : ed, t : e.t, p : e.p};
};
hxsl_Tools.size = function(t) {
	switch(t._hx_index) {
	case 0:
		return 0;
	case 1:case 3:
		return 1;
	case 2:case 4:
		return 0;
	case 5:
		var _g = t.t;
		var n = t.size;
		return n;
	case 6:
		return 9;
	case 7:
		return 16;
	case 8:
		return 12;
	case 9:
		var s = t.size;
		return s;
	case 10:
		var _g = t.dim;
		var _g = t.isArray;
		return 0;
	case 11:
		var _g = t.dim;
		var _g = t.isArray;
		var _g = t.channels;
		return 0;
	case 12:
		return 4;
	case 13:
		var vl = t.vl;
		var s = 0;
		var _g = 0;
		while(_g < vl.length) {
			var v = vl[_g];
			++_g;
			s += hxsl_Tools.size(v.type);
		}
		return s;
	case 14:
		var _g = t.variants;
		return 0;
	case 15:
		var _g = t.t;
		var _g1 = t.size;
		switch(_g1._hx_index) {
		case 0:
			var v = _g1.v;
			var t1 = _g;
			return hxsl_Tools.size(t1) * v;
		case 1:
			var _g = _g1.v;
			return 0;
		}
		break;
	case 16:
		var _g = t.size;
		var _g1 = t.kind;
		if(_g._hx_index == 0) {
			var v = _g.v;
			var t1 = t.t;
			return hxsl_Tools.size(t1) * v;
		} else {
			return 0;
		}
		break;
	case 17:
		var n = t.size;
		return n;
	}
};
hxsl_Tools.evalConst = function(e) {
	var _g = e.e;
	switch(_g._hx_index) {
	case 0:
		var c = _g.c;
		switch(c._hx_index) {
		case 0:
			return null;
		case 1:
			var b = c.b;
			return b;
		case 2:
			var i = c.v;
			return i;
		case 3:
			var f = c.v;
			return f;
		case 4:
			var s = c.v;
			return s;
		}
		break;
	case 8:
		var _g1 = _g.e;
		var _g2 = _g.args;
		var _g = _g1.e;
		var _g3 = _g1.p;
		var _g3 = _g1.t;
		if(_g._hx_index == 2) {
			switch(_g.g._hx_index) {
			case 41:case 42:
				var args = _g2;
				var _g = [];
				var _g1 = 0;
				while(_g1 < args.length) {
					var a = args[_g1];
					++_g1;
					_g.push(hxsl_Tools.evalConst(a));
				}
				var vals = _g;
				if(vals.length == 1) {
					var x = vals[0];
					var y = vals[0];
					var z = vals[0];
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					return new h3d_VectorImpl(x,y,z);
				}
				var x = vals[0];
				var y = vals[1];
				var z = vals[2];
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				return new h3d_VectorImpl(x,y,z);
			case 43:
				var args = _g2;
				var _g = [];
				var _g1 = 0;
				while(_g1 < args.length) {
					var a = args[_g1];
					++_g1;
					_g.push(hxsl_Tools.evalConst(a));
				}
				var vals = _g;
				if(vals.length == 1) {
					var x = vals[0];
					var y = vals[0];
					var z = vals[0];
					var w = vals[0];
					if(w == null) {
						w = 1.;
					}
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					return new h3d_Vector4Impl(x,y,z,w);
				}
				var x = vals[0];
				var y = vals[1];
				var z = vals[2];
				var w = vals[3];
				if(w == null) {
					w = 1.;
				}
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				return new h3d_Vector4Impl(x,y,z,w);
			default:
				throw haxe_Exception.thrown("Unhandled constant init " + hxsl_Printer.toString(e));
			}
		} else {
			throw haxe_Exception.thrown("Unhandled constant init " + hxsl_Printer.toString(e));
		}
		break;
	default:
		throw haxe_Exception.thrown("Unhandled constant init " + hxsl_Printer.toString(e));
	}
};
var hxsl_Tools2 = function() { };
$hxClasses["hxsl.Tools2"] = hxsl_Tools2;
hxsl_Tools2.__name__ = "hxsl.Tools2";
hxsl_Tools2.toString = function(g) {
	var n = $hxEnums[g.__enum__].__constructs__[g._hx_index]._hx_name;
	return n.charAt(0).toLowerCase() + HxOverrides.substr(n,1,null);
};
var hxsl_Tools3 = function() { };
$hxClasses["hxsl.Tools3"] = hxsl_Tools3;
hxsl_Tools3.__name__ = "hxsl.Tools3";
hxsl_Tools3.toString = function(s) {
	return hxsl_Printer.shaderToString(s);
};
var hxsl_Tools4 = function() { };
$hxClasses["hxsl.Tools4"] = hxsl_Tools4;
hxsl_Tools4.__name__ = "hxsl.Tools4";
hxsl_Tools4.toString = function(e) {
	return hxsl_Printer.toString(e);
};
var hxsl_BatchShader = function() {
	this.Batch_Count__ = 0;
	hxsl_Shader.call(this);
};
$hxClasses["hxsl.BatchShader"] = hxsl_BatchShader;
hxsl_BatchShader.__name__ = "hxsl.BatchShader";
hxsl_BatchShader.__super__ = hxsl_Shader;
hxsl_BatchShader.prototype = $extend(hxsl_Shader.prototype,{
	get_Batch_HasOffset: function() {
		return this.Batch_HasOffset__;
	}
	,set_Batch_HasOffset: function(_v) {
		this.constModified = true;
		return this.Batch_HasOffset__ = _v;
	}
	,get_Batch_UseStorage: function() {
		return this.Batch_UseStorage__;
	}
	,set_Batch_UseStorage: function(_v) {
		this.constModified = true;
		return this.Batch_UseStorage__ = _v;
	}
	,get_Batch_Count: function() {
		return this.Batch_Count__;
	}
	,set_Batch_Count: function(_v) {
		this.constModified = true;
		return this.Batch_Count__ = _v;
	}
	,get_Batch_Buffer: function() {
		return this.Batch_Buffer__;
	}
	,set_Batch_Buffer: function(_v) {
		return this.Batch_Buffer__ = _v;
	}
	,get_Batch_StorageBuffer: function() {
		return this.Batch_StorageBuffer__;
	}
	,set_Batch_StorageBuffer: function(_v) {
		return this.Batch_StorageBuffer__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		if(this.Batch_HasOffset__) {
			this.constBits |= 1;
		}
		if(this.Batch_UseStorage__) {
			this.constBits |= 2;
		}
		var v = this.Batch_Count__;
		if(v >>> 13 != 0) {
			throw haxe_Exception.thrown("Batch_Count" + " is out of range " + v + ">" + 8191 + ", consider using @const(MAX_VALUE)");
		}
		this.constBits |= v << 2;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.Batch_HasOffset__;
		case 1:
			return this.Batch_UseStorage__;
		case 2:
			return this.Batch_Count__;
		case 3:
			return this.Batch_Buffer__;
		case 4:
			return this.Batch_StorageBuffer__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		if(index == 2) {
			return this.Batch_Count__;
		}
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
		switch(index) {
		case 0:
			this.Batch_HasOffset__ = val;
			break;
		case 1:
			this.Batch_UseStorage__ = val;
			break;
		case 2:
			this.Batch_Count__ = val;
			break;
		case 3:
			this.Batch_Buffer__ = val;
			break;
		case 4:
			this.Batch_StorageBuffer__ = val;
			break;
		default:
		}
	}
	,setParamIndexFloatValue: function(index,val) {
	}
	,clone: function() {
		var s = Object.create(hxsl_BatchShader.prototype);
		s.shader = this.shader;
		s.Batch_HasOffset__ = this.Batch_HasOffset__;
		s.Batch_UseStorage__ = this.Batch_UseStorage__;
		s.Batch_Count__ = this.Batch_Count__;
		s.Batch_Buffer__ = this.Batch_Buffer__;
		s.Batch_StorageBuffer__ = this.Batch_StorageBuffer__;
		return s;
	}
	,__class__: hxsl_BatchShader
});
var hxsl_BatchInstanceParams = function(forcedPerInstance) {
	this.forcedPerInstance = forcedPerInstance;
};
$hxClasses["hxsl.BatchInstanceParams"] = hxsl_BatchInstanceParams;
hxsl_BatchInstanceParams.__name__ = "hxsl.BatchInstanceParams";
hxsl_BatchInstanceParams.prototype = {
	getSignature: function() {
		if(this.cachedSignature == null) {
			var _g = 0;
			var _g1 = this.forcedPerInstance;
			while(_g < _g1.length) {
				var fp = _g1[_g];
				++_g;
				fp.params.sort(Reflect.compare);
			}
			var _g = [];
			var _g1 = 0;
			var _g2 = this.forcedPerInstance;
			while(_g1 < _g2.length) {
				var s = _g2[_g1];
				++_g1;
				_g.push(s.shader + "=" + s.params.join(","));
			}
			this.cachedSignature = HxOverrides.substr(haxe_crypto_Md5.encode(_g.join(";")),0,8);
		}
		return this.cachedSignature;
	}
	,__class__: hxsl_BatchInstanceParams
};
var hxsl_SearchMap = function() {
	this.minId = 0;
	this.nexts = [];
};
$hxClasses["hxsl.SearchMap"] = hxsl_SearchMap;
hxsl_SearchMap.__name__ = "hxsl.SearchMap";
hxsl_SearchMap.prototype = {
	set: function(id,s) {
		if(this.minId == 0) {
			this.minId = id;
			this.nexts = [s];
			return;
		}
		var offset = id - this.minId;
		if(offset < 0) {
			var n = [];
			var _g = 0;
			var _g1 = this.nexts.length;
			while(_g < _g1) {
				var i = _g++;
				n[i - offset] = this.nexts[i];
			}
			this.nexts = n;
			this.minId += offset;
			offset = 0;
		}
		this.nexts[offset] = s;
	}
	,get: function(id) {
		return this.nexts[id - this.minId];
	}
	,__class__: hxsl_SearchMap
};
var hxsl_Cache = function() {
	this.linkCache = new hxsl_SearchMap();
	this.linkShaders = new haxe_ds_StringMap();
	this.batchShaders = new haxe_ds_ObjectMap();
	this.batchShadersParams = new haxe_ds_StringMap();
	this.byID = new haxe_ds_StringMap();
};
$hxClasses["hxsl.Cache"] = hxsl_Cache;
hxsl_Cache.__name__ = "hxsl.Cache";
hxsl_Cache.get = function() {
	var c = hxsl_Cache.INST;
	if(c == null) {
		c = new hxsl_Cache();
		hxsl_Cache.INST = c;
	}
	return c;
};
hxsl_Cache.set = function(c) {
	hxsl_Cache.INST = c;
};
hxsl_Cache.clear = function() {
	hxsl_Cache.INST = null;
};
hxsl_Cache.prototype = {
	getLinkShader: function(vars) {
		var _g = [];
		var _g1 = 0;
		while(_g1 < vars.length) {
			var v = vars[_g1];
			++_g1;
			_g.push(Std.string(v));
		}
		var key = _g.join(",");
		var shader = this.linkShaders.h[key];
		if(shader != null) {
			return shader;
		}
		var s = new hxsl_SharedShader("");
		var id = HxOverrides.substr(haxe_crypto_Md5.encode(key),0,8);
		s.data = { name : "shaderLinker_" + id, vars : [], funs : []};
		var pos = null;
		var outVars_h = Object.create(null);
		var outputCount = 0;
		var tvec4 = hxsl_Type.TVec(4,hxsl_VecType.VFloat);
		var makeVec = function(g,size,args,makeOutExpr) {
			var out = [];
			var rem = size;
			var _g = 0;
			var _g1 = args.length;
			while(_g < _g1) {
				var i = _g++;
				var e = makeOutExpr(args[args.length - 1 - i],rem - (args.length - 1 - i));
				rem -= hxsl_Tools.size(e.t);
				out.unshift(e);
			}
			return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(g), t : hxsl_Type.TVoid, p : pos},out), t : hxsl_Type.TVec(size,hxsl_VecType.VFloat), p : pos};
		};
		var makeVar = function(name,t,parent) {
			var path = parent == null ? name : hxsl_Tools.getName(parent) + "." + name;
			var v = outVars_h[path];
			if(v != null) {
				return v;
			}
			v = { id : hxsl_Tools.allocVarId(), name : name, type : t, kind : hxsl_VarKind.Var, parent : parent};
			if(parent == null) {
				s.data.vars.push(v);
			} else {
				var _g = parent.type;
				if(_g._hx_index == 13) {
					var vl = _g.vl;
					vl.push(v);
				} else {
					throw haxe_Exception.thrown("assert");
				}
			}
			outVars_h[path] = v;
			return v;
		};
		var makeOutExpr = null;
		makeOutExpr = function(v,rem) {
			switch(v._hx_index) {
			case 0:
				var v1 = v.v;
				return { e : hxsl_TExprDef.TConst(hxsl_Const.CFloat(v1)), t : hxsl_Type.TFloat, p : pos};
			case 1:
				var vname = v.v;
				var size = v.size;
				var v1 = outVars_h[vname];
				if(v1 != null) {
					return { e : hxsl_TExprDef.TVar(v1), t : v1.type, p : pos};
				}
				var path = vname.split(".");
				var parent = null;
				while(path.length > 1) parent = makeVar(path.shift(),hxsl_Type.TStruct([]),parent);
				if(size != null) {
					rem = size;
				}
				v1 = makeVar(path.shift(),rem == 1 ? hxsl_Type.TFloat : hxsl_Type.TVec(rem,hxsl_VecType.VFloat),parent);
				return { e : hxsl_TExprDef.TVar(v1), t : v1.type, p : pos};
			case 2:
				var v1 = v.v;
				return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.PackNormal), t : hxsl_Type.TVoid, p : pos},[makeOutExpr(v1,3)]), t : tvec4, p : pos};
			case 3:
				var v1 = v.v;
				return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Pack), t : hxsl_Type.TVoid, p : pos},[makeOutExpr(v1,1)]), t : tvec4, p : pos};
			case 4:
				var args = v.a;
				return makeVec(hxsl_TGlobal.Vec2,2,args,makeOutExpr);
			case 5:
				var args = v.a;
				return makeVec(hxsl_TGlobal.Vec3,3,args,makeOutExpr);
			case 6:
				var args = v.a;
				return makeVec(hxsl_TGlobal.Vec4,4,args,makeOutExpr);
			case 7:
				var v1 = v.a;
				var comps = v.swiz;
				return { e : hxsl_TExprDef.TSwiz(makeOutExpr(v1,4),comps), t : hxsl_Type.TVec(comps.length,hxsl_VecType.VFloat), p : pos};
			}
		};
		var makeOutput = function(v) {
			outputCount += 1;
			var ov = { id : hxsl_Tools.allocVarId(), type : tvec4, name : "OUTPUT" + (outputCount - 1), kind : hxsl_VarKind.Output};
			s.data.vars.push(ov);
			return { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssign,{ e : hxsl_TExprDef.TVar(ov), t : tvec4, p : pos},makeOutExpr(v,4)), t : hxsl_Type.TVoid, p : pos};
		};
		var defineFun = function(kind,vars) {
			var fv = { id : hxsl_Tools.allocVarId(), type : hxsl_Type.TFun([]), name : ("" + Std.string(kind)).toLowerCase(), kind : hxsl_VarKind.Function};
			var _g = [];
			var _g1 = 0;
			while(_g1 < vars.length) {
				var v = vars[_g1];
				++_g1;
				_g.push(makeOutput(v));
			}
			var f = { kind : kind, ref : fv, args : [], ret : hxsl_Type.TVoid, expr : { e : hxsl_TExprDef.TBlock(_g), p : pos, t : hxsl_Type.TVoid}};
			s.data.funs.push(f);
		};
		defineFun(hxsl_FunctionKind.Vertex,[hxsl_Output.Value("output.position")]);
		defineFun(hxsl_FunctionKind.Fragment,vars);
		shader = Object.create(hxsl_Shader.prototype);
		shader.shader = s;
		this.linkShaders.h[key] = shader;
		shader.updateConstantsFinal(null);
		return shader;
	}
	,link: function(shaders,mode) {
		var c = this.linkCache;
		var _g_l = shaders;
		var _g_last = null;
		while(_g_l != _g_last) {
			var s = _g_l.s;
			_g_l = _g_l.next;
			var s1 = s;
			var i = s1.instance;
			var cs = c.nexts[i.id - c.minId];
			if(cs == null) {
				cs = new hxsl_SearchMap();
				c.set(i.id,cs);
			}
			c = cs;
		}
		if(c.linked == null) {
			c.linked = this.compileRuntimeShader(shaders,mode);
		}
		return c.linked;
	}
	,compileRuntimeShader: function(shaders,mode) {
		var shaderDatas = [];
		var index = 0;
		var _g_l = shaders;
		var _g_last = null;
		while(_g_l != _g_last) {
			var s = _g_l.s;
			_g_l = _g_l.next;
			var s1 = s;
			var i = s1.instance;
			shaderDatas.push({ inst : i, p : s1.priority, index : index++});
		}
		shaderDatas.reverse();
		haxe_ds_ArraySort.sort(shaderDatas,function(s1,s2) {
			return s2.p - s1.p;
		});
		var _g = 0;
		while(_g < shaderDatas.length) {
			var s = shaderDatas[_g];
			++_g;
			hxsl_Printer.check(s.inst.shader);
		}
		var linker = new hxsl_Linker(mode);
		var s;
		try {
			var _g = [];
			var _g1 = 0;
			while(_g1 < shaderDatas.length) {
				var s1 = shaderDatas[_g1];
				++_g1;
				_g.push(s1.inst.shader);
			}
			s = linker.link(_g);
		} catch( _g ) {
			var _g1 = haxe_Exception.caught(_g).unwrap();
			if(((_g1) instanceof hxsl_Error)) {
				var e = _g1;
				var _g1 = [];
				var _g2 = 0;
				while(_g2 < shaderDatas.length) {
					var s1 = shaderDatas[_g2];
					++_g2;
					_g1.push(hxsl_Printer.shaderToString(s1.inst.shader));
				}
				var shaders1 = _g1;
				e.msg += "\n\nin\n\n" + shaders1.join("\n-----\n");
				throw haxe_Exception.thrown(e);
			} else {
				throw _g;
			}
		}
		if(mode == hxsl_LinkMode.Batch) {
			var checkRec = null;
			checkRec = function(v) {
				if(v.qualifiers != null && v.qualifiers.indexOf(hxsl_VarQualifier.PerObject) >= 0) {
					if(v.qualifiers.length == 1) {
						v.qualifiers = null;
					} else {
						v.qualifiers = v.qualifiers.slice();
						HxOverrides.remove(v.qualifiers,hxsl_VarQualifier.PerObject);
					}
					if(v.kind != hxsl_VarKind.Var) {
						v.kind = hxsl_VarKind.Local;
					}
				}
				var _g = v.type;
				if(_g._hx_index == 13) {
					var vl = _g.vl;
					var _g = 0;
					while(_g < vl.length) {
						var v = vl[_g];
						++_g;
						checkRec(v);
					}
				}
			};
			var _g = 0;
			var _g1 = s.vars;
			while(_g < _g1.length) {
				var v = _g1[_g];
				++_g;
				checkRec(v);
			}
		}
		var _g = [];
		var _g1 = 0;
		while(_g1 < shaderDatas.length) {
			var s1 = shaderDatas[_g1];
			++_g1;
			_g.push(s1.inst.shader);
		}
		hxsl_Printer.check(s,_g);
		var prev = s;
		var splitter = new hxsl_Splitter();
		var sl;
		try {
			sl = splitter.split(s,mode == hxsl_LinkMode.Batch);
		} catch( _g ) {
			var _g1 = haxe_Exception.caught(_g).unwrap();
			if(((_g1) instanceof hxsl_Error)) {
				var e = _g1;
				e.msg += "\n\nin\n\n" + hxsl_Printer.shaderToString(s);
				throw haxe_Exception.thrown(e);
			} else {
				throw _g;
			}
		}
		var paramVars = new haxe_ds_IntMap();
		var _g = 0;
		var _g1 = linker.allVars;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			if(v.v.kind == hxsl_VarKind.Param) {
				var _g2 = v.v.type;
				if(_g2._hx_index == 13) {
					var _g3 = _g2.vl;
					continue;
				}
				var inf = shaderDatas[v.instanceIndex];
				var nv = splitter.varMap.h[v.v.__id__];
				paramVars.h[nv == null ? v.id : nv.id] = { instance : inf.index, index : inf.inst.params.h[v.merged[0].id]};
			}
		}
		var _g = 0;
		while(_g < sl.length) {
			var s = sl[_g];
			++_g;
			hxsl_Printer.check(s,[prev]);
		}
		var prev = sl;
		var sl1 = new hxsl_Dce().dce(sl);
		var _g_current = 0;
		var _g_array = sl1;
		while(_g_current < _g_array.length) {
			var _g_value = _g_array[_g_current];
			var _g_key = _g_current++;
			var i = _g_key;
			var s = _g_value;
			hxsl_Printer.check(s,[prev[i]]);
		}
		var r = this.buildRuntimeShader(sl1,paramVars);
		r.mode = mode;
		var _g = [];
		var _g_l = shaders;
		var _g_last = null;
		while(_g_l != _g_last) {
			var s = _g_l.s;
			_g_l = _g_l.next;
			var s1 = s;
			_g.push(new hxsl_ShaderInstanceDesc(s1.shader,s1.constBits));
		}
		r.spec = { instances : _g, signature : null};
		var _g = 0;
		var _g1 = shaderDatas.length;
		while(_g < _g1) {
			var i = _g++;
			var s = shaderDatas[shaderDatas.length - 1 - i];
			r.spec.instances[s.index].index = i;
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = r.spec.instances;
		while(_g1 < _g2.length) {
			var i = _g2[_g1];
			++_g1;
			_g.push(i.shader.data.name + "_" + i.bits + "_" + i.index);
		}
		var signParts = _g;
		var tmp = signParts.join(":");
		r.spec.signature = haxe_crypto_Md5.encode(tmp);
		var _g = [];
		var _g1 = 0;
		var _g2 = r.getShaders();
		while(_g1 < _g2.length) {
			var s = _g2[_g1];
			++_g1;
			_g.push(hxsl_Printer.shaderToString(s.data));
		}
		r.signature = haxe_crypto_Md5.encode(_g.join(""));
		var r2 = this.byID.h[r.signature];
		if(r2 != null) {
			r.id = r2.id;
		} else {
			this.byID.h[r.signature] = r;
		}
		return r;
	}
	,buildRuntimeShader: function(shaders,paramVars) {
		var r = new hxsl_RuntimeShader();
		r.globals = new haxe_ds_IntMap();
		var _g = 0;
		while(_g < shaders.length) {
			var s = shaders[_g];
			++_g;
			var kind;
			switch(s.name) {
			case "fragment":
				kind = hxsl_FunctionKind.Fragment;
				break;
			case "main":
				kind = hxsl_FunctionKind.Main;
				break;
			case "vertex":
				kind = hxsl_FunctionKind.Vertex;
				break;
			default:
				throw haxe_Exception.thrown("assert");
			}
			var fl = this.flattenShader(s,kind,paramVars);
			fl.kind = kind;
			switch(kind._hx_index) {
			case 0:
				r.vertex = fl;
				break;
			case 1:
				r.fragment = fl;
				break;
			case 4:
				r.vertex = fl;
				break;
			default:
				throw haxe_Exception.thrown("assert");
			}
			this.initGlobals(r,fl);
			hxsl_Printer.check(fl.data,[s]);
		}
		return r;
	}
	,initGlobals: function(r,s) {
		var p = s.globals;
		while(p != null) {
			r.globals.h[p.gid] = true;
			p = p.next;
		}
		var p = s.params;
		while(p != null) {
			if(p.perObjectGlobal != null) {
				r.globals.h[p.perObjectGlobal.gid] = true;
			}
			p = p.next;
		}
	}
	,getPath: function(v) {
		if(v.parent == null) {
			return v.name;
		}
		return this.getPath(v.parent) + "." + v.name;
	}
	,flattenShader: function(s,kind,params) {
		var flat = new hxsl_Flatten();
		var c = new hxsl_RuntimeShaderData();
		var data = flat.flatten(s,kind);
		var textures = [];
		var buffers = [];
		c.texturesCount = 0;
		var g = flat.allocData.keys();
		while(g.hasNext()) {
			var g1 = g.next();
			var alloc = flat.allocData.h[g1.__id__];
			switch(g1.kind._hx_index) {
			case 0:
				var _g = [];
				var _g1 = 0;
				while(_g1 < alloc.length) {
					var a = alloc[_g1];
					++_g1;
					if(a.v != null) {
						_g.push(new hxsl_AllocGlobal(a.pos,this.getPath(a.v),a.v.type));
					}
				}
				var out = _g;
				var _g2 = 0;
				var _g3 = out.length - 1;
				while(_g2 < _g3) {
					var i = _g2++;
					out[i].next = out[i + 1];
				}
				var _g4 = g1.type;
				if(_g4._hx_index == 15) {
					var _g5 = _g4.t;
					var _g6 = _g4.size;
					if(_g5._hx_index == 5) {
						if(_g5.size == 4) {
							if(_g5.t._hx_index == 1) {
								if(_g6._hx_index == 0) {
									var size = _g6.v;
									c.globals = out[0];
									c.globalsSize = size;
								} else {
									throw haxe_Exception.thrown("assert");
								}
							} else {
								throw haxe_Exception.thrown("assert");
							}
						} else {
							throw haxe_Exception.thrown("assert");
						}
					} else {
						throw haxe_Exception.thrown("assert");
					}
				} else {
					throw haxe_Exception.thrown("assert");
				}
				break;
			case 2:
				var out1 = [];
				var count = 0;
				var _g7 = 0;
				while(_g7 < alloc.length) {
					var a1 = alloc[_g7];
					++_g7;
					if(a1.v == null) {
						continue;
					}
					var p = params.h[a1.v.id];
					if(p == null) {
						var ap = new hxsl_AllocParam(a1.v.name,a1.pos,-1,-1,a1.v.type);
						ap.perObjectGlobal = new hxsl_AllocGlobal(-1,this.getPath(a1.v),a1.v.type);
						out1.push(ap);
						++count;
						continue;
					}
					var ap1 = new hxsl_AllocParam(a1.v.name,a1.pos,p.instance,p.index,a1.v.type);
					var _g8 = a1.v.type;
					if(_g8._hx_index == 15) {
						var _g9 = _g8.size;
						var t = _g8.t;
						if(hxsl_Tools.isTexture(t)) {
							ap1.pos = -a1.size;
							count += a1.size;
						} else {
							++count;
						}
					} else {
						++count;
					}
					out1.push(ap1);
				}
				var _g10 = 0;
				var _g11 = out1.length - 1;
				while(_g10 < _g11) {
					var i1 = _g10++;
					out1[i1].next = out1[i1 + 1];
				}
				var _g12 = g1.type;
				if(_g12._hx_index == 15) {
					var _g13 = _g12.t;
					var _g14 = _g12.size;
					var t1 = _g13;
					if(hxsl_Tools.isTexture(t1)) {
						textures.push({ t : t1, all : out1});
						c.texturesCount += count;
					} else {
						switch(_g13._hx_index) {
						case 5:
							if(_g13.size == 4) {
								if(_g13.t._hx_index == 1) {
									if(_g14._hx_index == 0) {
										var size1 = _g14.v;
										c.params = out1[0];
										c.paramsSize = size1;
									} else {
										throw haxe_Exception.thrown("assert");
									}
								} else {
									throw haxe_Exception.thrown("assert");
								}
							} else {
								throw haxe_Exception.thrown("assert");
							}
							break;
						case 16:
							var _g15 = _g13.t;
							var _g16 = _g13.size;
							var kind = _g13.kind;
							var _g17 = 0;
							while(_g17 < out1.length) {
								var outBuf = out1[_g17];
								++_g17;
								if(outBuf != null) {
									buffers.push(outBuf);
								}
							}
							break;
						default:
							throw haxe_Exception.thrown("assert");
						}
					}
				} else {
					throw haxe_Exception.thrown("assert");
				}
				break;
			default:
				throw haxe_Exception.thrown("assert");
			}
		}
		if(textures.length > 0) {
			textures.sort(function(t1,t2) {
				var _g = t1.t;
				var _g1 = t2.t;
				switch(_g._hx_index) {
				case 10:
					if(_g1._hx_index == 10) {
						var t21 = _g1.dim;
						var a2 = _g1.isArray;
						var a1 = _g.isArray;
						var t11 = _g.dim;
						if(a1 != a2) {
							if(a1) {
								return 1;
							} else {
								return -1;
							}
						} else {
							return t11._hx_index - t21._hx_index;
						}
					} else {
						return t1.t._hx_index - t2.t._hx_index;
					}
					break;
				case 11:
					var _g2 = _g.channels;
					if(_g1._hx_index == 11) {
						var _g2 = _g1.channels;
						var t21 = _g1.dim;
						var a2 = _g1.isArray;
						var a1 = _g.isArray;
						var t11 = _g.dim;
						if(a1 != a2) {
							if(a1) {
								return 1;
							} else {
								return -1;
							}
						} else {
							return t11._hx_index - t21._hx_index;
						}
					} else {
						return t1.t._hx_index - t2.t._hx_index;
					}
					break;
				default:
					return t1.t._hx_index - t2.t._hx_index;
				}
			});
			c.textures = textures[0].all[0];
			var _g = 1;
			var _g1 = textures.length;
			while(_g < _g1) {
				var i = _g++;
				var prevAll = textures[i - 1].all;
				var prev = prevAll[prevAll.length - 1];
				prev.next = textures[i].all[0];
			}
		}
		if(buffers.length > 0) {
			buffers.sort(function(b1,b2) {
				var _g = b1.type;
				var _g1 = b2.type;
				if(_g._hx_index == 16) {
					var _g2 = _g.t;
					var _g2 = _g.size;
					if(_g1._hx_index == 16) {
						var _g2 = _g1.t;
						var _g2 = _g1.size;
						var k2 = _g1.kind;
						var k1 = _g.kind;
						return k1._hx_index - k2._hx_index;
					} else {
						return b1.type._hx_index - b2.type._hx_index;
					}
				} else {
					return b1.type._hx_index - b2.type._hx_index;
				}
			});
		}
		var p = null;
		var _g = 0;
		while(_g < buffers.length) {
			var b = buffers[_g];
			++_g;
			if(c.buffers == null) {
				c.buffers = b;
				p = c.buffers;
			} else {
				p.next = b;
				p = p.next;
			}
		}
		c.bufferCount = buffers.length;
		if(c.globals == null) {
			c.globalsSize = 0;
		}
		if(c.params == null) {
			c.paramsSize = 0;
		}
		c.data = data;
		return c;
	}
	,makeBatchShader: function(rt,shaders,params) {
		var batchMap;
		if(params == null) {
			batchMap = this.batchShaders;
		} else {
			var this1 = this.batchShadersParams;
			var key = params.getSignature();
			batchMap = this1.h[key];
			if(batchMap == null) {
				batchMap = new haxe_ds_ObjectMap();
				var this1 = this.batchShadersParams;
				var key = params.getSignature();
				this1.h[key] = batchMap;
			}
		}
		var sh = batchMap.h[rt.__id__];
		if(sh == null) {
			sh = this.createBatchShader(rt,shaders,params);
			batchMap.set(rt,sh);
		}
		var shader = Object.create(hxsl_BatchShader.prototype);
		shader.shader = sh.shader;
		shader.params = sh.params;
		shader.paramsSize = sh.size;
		return shader;
	}
	,isPerInstance: function(v) {
		if(v.qualifiers == null) {
			return false;
		}
		var _g = 0;
		var _g1 = v.qualifiers;
		while(_g < _g1.length) {
			var q = _g1[_g];
			++_g;
			var tmp;
			switch(q._hx_index) {
			case 3:
				tmp = true;
				break;
			case 9:
				var _g2 = q.v;
				tmp = true;
				break;
			default:
				tmp = false;
			}
			if(tmp) {
				return true;
			}
		}
		return false;
	}
	,createBatchShader: function(rt,shaders,params) {
		var _gthis = this;
		var s = new hxsl_SharedShader("");
		var id = HxOverrides.substr(params == null ? rt.spec.signature : haxe_crypto_Md5.encode(rt.spec.signature + params.getSignature()),0,8);
		var declVar = function(name,t,kind) {
			return { id : hxsl_Tools.allocVarId(), type : t, name : name, kind : kind};
		};
		var instancedParams = [];
		if(params != null) {
			var forcedPerInstance = params.forcedPerInstance;
			var instanceIndex = 1;
			var forcedIndex = forcedPerInstance.length - 1;
			var s1 = shaders;
			while(s1 != null && forcedIndex >= 0) {
				if(s1.s.shader.data.name == forcedPerInstance[forcedIndex].shader) {
					instancedParams[instanceIndex] = forcedPerInstance[forcedIndex].params;
					--forcedIndex;
				}
				++instanceIndex;
				s1 = s1.next;
			}
		}
		var pos = null;
		var hasOffset = declVar("Batch_HasOffset",hxsl_Type.TBool,hxsl_VarKind.Param);
		var inputOffset = declVar("Batch_Start",hxsl_Type.TFloat,hxsl_VarKind.Input);
		hasOffset.qualifiers = [hxsl_VarQualifier.Const()];
		inputOffset.qualifiers = [hxsl_VarQualifier.PerInstance(1)];
		var useStorage = declVar("Batch_UseStorage",hxsl_Type.TBool,hxsl_VarKind.Param);
		var vcount = declVar("Batch_Count",hxsl_Type.TInt,hxsl_VarKind.Param);
		var vuniformBuffer = declVar("Batch_Buffer",hxsl_Type.TBuffer(hxsl_Type.TVec(4,hxsl_VecType.VFloat),hxsl_SizeDecl.SVar(vcount),hxsl_BufferKind.Uniform),hxsl_VarKind.Param);
		var vstorageBuffer = declVar("Batch_StorageBuffer",hxsl_Type.TBuffer(hxsl_Type.TVec(4,hxsl_VecType.VFloat),hxsl_SizeDecl.SConst(0),hxsl_BufferKind.RW),hxsl_VarKind.Param);
		var voffset = declVar("Batch_Offset",hxsl_Type.TInt,hxsl_VarKind.Local);
		var euniformBuffer = { e : hxsl_TExprDef.TVar(vuniformBuffer), p : pos, t : vuniformBuffer.type};
		var estorageBuffer = { e : hxsl_TExprDef.TVar(vstorageBuffer), p : pos, t : vstorageBuffer.type};
		var eoffset = { e : hxsl_TExprDef.TVar(voffset), p : pos, t : voffset.type};
		var tvec4 = hxsl_Type.TVec(4,hxsl_VecType.VFloat);
		var countBits = 16;
		vcount.qualifiers = [hxsl_VarQualifier.Const(1 << countBits)];
		useStorage.qualifiers = [hxsl_VarQualifier.Const()];
		s.data = { name : "batchShader_" + id, vars : [vcount,hasOffset,useStorage,vuniformBuffer,vstorageBuffer,voffset,inputOffset], funs : []};
		var getVarRec = null;
		getVarRec = function(v,name,kind) {
			if(v.kind == kind && v.name == name) {
				return v;
			}
			var _g = v.type;
			if(_g._hx_index == 13) {
				var vl = _g.vl;
				var _g = 0;
				while(_g < vl.length) {
					var v = vl[_g];
					++_g;
					var v1 = getVarRec(v,name,kind);
					if(v1 != null) {
						return v1;
					}
				}
			}
			return null;
		};
		var getVar = function(p) {
			var s = shaders;
			if(p.perObjectGlobal != null) {
				var path = p.perObjectGlobal.path.split(".");
				while(s != null) {
					var _g = 0;
					var _g1 = s.s.shader.data.vars;
					while(_g < _g1.length) {
						var v = _g1[_g];
						++_g;
						if(v.name != path[0]) {
							continue;
						}
						var v1 = getVarRec(v,p.name,hxsl_VarKind.Global);
						if(v1 != null) {
							return v1;
						}
					}
					s = s.next;
				}
			} else {
				var i = p.instance - 1;
				while(i > 0) {
					--i;
					s = s.next;
				}
				var name = p.name;
				while(true) {
					var _g = 0;
					var _g1 = s.s.shader.data.vars;
					while(_g < _g1.length) {
						var v = _g1[_g];
						++_g;
						var v1 = getVarRec(v,name,hxsl_VarKind.Param);
						if(v1 != null) {
							return v1;
						}
					}
					var cc = HxOverrides.cca(name,name.length - 1);
					if(cc >= 48 && cc <= 57) {
						name = HxOverrides.substr(name,0,-1);
					} else {
						break;
					}
				}
			}
			throw haxe_Exception.thrown("Var not found " + p.name);
		};
		var params = null;
		var used = [];
		var added = [];
		var addParam = function(p) {
			var pid = p.perObjectGlobal != null ? -p.perObjectGlobal.gid : p.instance * 1024 + p.index;
			if(added.indexOf(pid) >= 0) {
				return;
			}
			added.push(pid);
			var size;
			var _g = p.type;
			switch(_g._hx_index) {
			case 3:
				size = 1;
				break;
			case 5:
				if(_g.t._hx_index == 1) {
					var n = _g.size;
					size = n;
				} else {
					throw haxe_Exception.thrown("Unsupported batch var type " + Std.string(p.type));
				}
				break;
			case 7:
				size = 16;
				break;
			default:
				throw haxe_Exception.thrown("Unsupported batch var type " + Std.string(p.type));
			}
			var index;
			if(size >= 4) {
				index = used.length << 2;
				var _g = 0;
				var _g1 = size >> 2;
				while(_g < _g1) {
					var i = _g++;
					used.push(15);
				}
			} else if(size == 1) {
				var best = -1;
				var _g = 0;
				var _g1 = used.length;
				while(_g < _g1) {
					var i = _g++;
					if(used[i] != 15 && (best < 0 || used[best] < used[i])) {
						best = i;
					}
				}
				if(best < 0) {
					best = used.length;
					used.push(0);
				}
				index = best << 2;
				var _g = 0;
				while(_g < 4) {
					var k = _g++;
					var bit = 3 - k;
					if((used[best] & 1 << bit) == 0) {
						used[best] |= 1 << bit;
						index += bit;
						break;
					}
				}
			} else {
				var k = size == 2 ? 3 : 7;
				var best = -1;
				var _g = 0;
				var _g1 = used.length;
				while(_g < _g1) {
					var i = _g++;
					if((used[i] & k) == 0) {
						used[i] |= k;
						best = i;
						break;
					}
				}
				if(best < 0) {
					best = used.length;
					used.push(k);
				}
				index = best << 2;
			}
			var p2 = new hxsl_AllocParam(p.name,index,p.instance,p.index,p.type);
			p2.perObjectGlobal = p.perObjectGlobal;
			p2.next = params;
			params = p2;
		};
		var p = rt.vertex.params;
		while(p != null) {
			var v = getVar(p);
			var params1 = instancedParams[p.instance];
			if(params1 != null && params1.indexOf(v.name) >= 0 ? true : _gthis.isPerInstance(v)) {
				addParam(p);
			}
			p = p.next;
		}
		var p = rt.fragment.params;
		while(p != null) {
			var v = getVar(p);
			var params1 = instancedParams[p.instance];
			if(params1 != null && params1.indexOf(v.name) >= 0 ? true : _gthis.isPerInstance(v)) {
				addParam(p);
			}
			p = p.next;
		}
		var parentVars = new haxe_ds_ObjectMap();
		var swiz = [[hxsl_Component.X],[hxsl_Component.Y],[hxsl_Component.Z],[hxsl_Component.W]];
		var readOffset = function(ebuffer,index) {
			return { e : hxsl_TExprDef.TArray(ebuffer,{ e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,eoffset,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TInt, p : pos}), t : tvec4, p : pos};
		};
		var declareLocalVar = function(v) {
			var vreal = declVar(v.name,v.type,hxsl_VarKind.Local);
			if(v.perObjectGlobal != null) {
				var path = v.perObjectGlobal.path.split(".");
				path.pop();
				var cur = vreal;
				while(path.length > 0) {
					var key = path.join(".");
					var name = path.pop();
					var vp = parentVars.h[path.__id__];
					if(vp == null) {
						vp = declVar(name,hxsl_Type.TStruct([]),hxsl_VarKind.Local);
						parentVars.set(path,vp);
					}
					var _g = vp.type;
					if(_g._hx_index == 13) {
						var vl = _g.vl;
						vl.push(cur);
					}
					cur.parent = vp;
					cur = vp;
				}
			}
			s.data.vars.push(vreal);
			return vreal;
		};
		var extractVar = function(vreal,ebuffer,v) {
			var index = v.pos >> 2;
			var extract;
			var _g = v.type;
			switch(_g._hx_index) {
			case 3:
				extract = { p : pos, t : v.type, e : hxsl_TExprDef.TSwiz(readOffset(ebuffer,index),swiz[v.pos & 3])};
				break;
			case 5:
				var _g1 = _g.t;
				switch(_g.size) {
				case 2:
					if(_g1._hx_index == 1) {
						var swiz1;
						switch(v.pos & 3) {
						case 0:
							swiz1 = [hxsl_Component.X,hxsl_Component.Y];
							break;
						case 1:
							swiz1 = [hxsl_Component.Y,hxsl_Component.Z];
							break;
						default:
							swiz1 = [hxsl_Component.Z,hxsl_Component.W];
						}
						extract = { p : pos, t : v.type, e : hxsl_TExprDef.TSwiz(readOffset(ebuffer,index),swiz1)};
					} else {
						throw haxe_Exception.thrown("assert");
					}
					break;
				case 3:
					if(_g1._hx_index == 1) {
						extract = { p : pos, t : v.type, e : hxsl_TExprDef.TSwiz(readOffset(ebuffer,index),(v.pos & 3) == 0 ? [hxsl_Component.X,hxsl_Component.Y,hxsl_Component.Z] : [hxsl_Component.Y,hxsl_Component.Z,hxsl_Component.W])};
					} else {
						throw haxe_Exception.thrown("assert");
					}
					break;
				case 4:
					if(_g1._hx_index == 1) {
						extract = readOffset(ebuffer,index);
					} else {
						throw haxe_Exception.thrown("assert");
					}
					break;
				default:
					throw haxe_Exception.thrown("assert");
				}
				break;
			case 7:
				extract = { p : pos, t : v.type, e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mat4), t : hxsl_Type.TVoid, p : pos},[readOffset(ebuffer,index),readOffset(ebuffer,index + 1),readOffset(ebuffer,index + 2),readOffset(ebuffer,index + 3)])};
				break;
			default:
				throw haxe_Exception.thrown("assert");
			}
			return { p : pos, e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssign,{ e : hxsl_TExprDef.TVar(vreal), p : pos, t : v.type},extract), t : hxsl_Type.TVoid};
		};
		var exprsUniform = [];
		var exprsStorage = [];
		var stride = used.length;
		var p = params;
		while(p != null) {
			var vreal = declareLocalVar(p);
			exprsUniform.push(extractVar(vreal,euniformBuffer,p));
			exprsStorage.push(extractVar(vreal,estorageBuffer,p));
			p = p.next;
		}
		var inits = [];
		inits.push({ p : pos, e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssign,eoffset,{ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.InstanceID), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVoid});
		inits.push({ p : pos, e : hxsl_TExprDef.TIf({ e : hxsl_TExprDef.TVar(hasOffset), t : hxsl_Type.TBool, p : pos},{ p : pos, e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpAdd),eoffset,{ e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.ToInt), t : hxsl_Type.TVoid, p : pos},[{ p : pos, t : hxsl_Type.TFloat, e : hxsl_TExprDef.TVar(inputOffset)}]), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVoid},null), t : hxsl_Type.TVoid});
		inits.push({ p : pos, t : hxsl_Type.TInt, e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpMult),eoffset,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(stride)), t : hxsl_Type.TInt, p : pos})});
		inits.push({ p : pos, e : hxsl_TExprDef.TIf({ e : hxsl_TExprDef.TVar(useStorage), t : hxsl_Type.TBool, p : pos},{ p : pos, e : hxsl_TExprDef.TBlock(exprsStorage), t : hxsl_Type.TVoid},{ p : pos, e : hxsl_TExprDef.TBlock(exprsUniform), t : hxsl_Type.TVoid}), t : hxsl_Type.TVoid});
		var fv = declVar("init",hxsl_Type.TFun([]),hxsl_VarKind.Function);
		var f = { kind : hxsl_FunctionKind.Init, ref : fv, args : [], ret : hxsl_Type.TVoid, expr : { e : hxsl_TExprDef.TBlock(inits), p : pos, t : hxsl_Type.TVoid}};
		s.data.funs.push(f);
		s.consts = new hxsl_ShaderConst(vcount,2,countBits + 1);
		s.consts.globalId = 0;
		s.consts.next = new hxsl_ShaderConst(hasOffset,0,1);
		s.consts.next.globalId = 0;
		s.consts.next.next = new hxsl_ShaderConst(useStorage,1,1);
		s.consts.next.next.globalId = 0;
		return { shader : s, params : params, size : stride};
	}
	,__class__: hxsl_Cache
};
var hxsl_Channel = $hxEnums["hxsl.Channel"] = { __ename__:true,__constructs__:null
	,Unknown: {_hx_name:"Unknown",_hx_index:0,__enum__:"hxsl.Channel",toString:$estr}
	,R: {_hx_name:"R",_hx_index:1,__enum__:"hxsl.Channel",toString:$estr}
	,G: {_hx_name:"G",_hx_index:2,__enum__:"hxsl.Channel",toString:$estr}
	,B: {_hx_name:"B",_hx_index:3,__enum__:"hxsl.Channel",toString:$estr}
	,A: {_hx_name:"A",_hx_index:4,__enum__:"hxsl.Channel",toString:$estr}
	,PackedFloat: {_hx_name:"PackedFloat",_hx_index:5,__enum__:"hxsl.Channel",toString:$estr}
	,PackedNormal: {_hx_name:"PackedNormal",_hx_index:6,__enum__:"hxsl.Channel",toString:$estr}
};
hxsl_Channel.__constructs__ = [hxsl_Channel.Unknown,hxsl_Channel.R,hxsl_Channel.G,hxsl_Channel.B,hxsl_Channel.A,hxsl_Channel.PackedFloat,hxsl_Channel.PackedNormal];
hxsl_Channel.__empty_constructs__ = [hxsl_Channel.Unknown,hxsl_Channel.R,hxsl_Channel.G,hxsl_Channel.B,hxsl_Channel.A,hxsl_Channel.PackedFloat,hxsl_Channel.PackedNormal];
var hxsl__$Checker_FieldAccess = $hxEnums["hxsl._Checker.FieldAccess"] = { __ename__:true,__constructs__:null
	,FField: ($_=function(e) { return {_hx_index:0,e:e,__enum__:"hxsl._Checker.FieldAccess",toString:$estr}; },$_._hx_name="FField",$_.__params__ = ["e"],$_)
	,FGlobal: ($_=function(g,arg,variants) { return {_hx_index:1,g:g,arg:arg,variants:variants,__enum__:"hxsl._Checker.FieldAccess",toString:$estr}; },$_._hx_name="FGlobal",$_.__params__ = ["g","arg","variants"],$_)
};
hxsl__$Checker_FieldAccess.__constructs__ = [hxsl__$Checker_FieldAccess.FField,hxsl__$Checker_FieldAccess.FGlobal];
hxsl__$Checker_FieldAccess.__empty_constructs__ = [];
var hxsl__$Checker_WithType = $hxEnums["hxsl._Checker.WithType"] = { __ename__:true,__constructs__:null
	,NoValue: {_hx_name:"NoValue",_hx_index:0,__enum__:"hxsl._Checker.WithType",toString:$estr}
	,Value: {_hx_name:"Value",_hx_index:1,__enum__:"hxsl._Checker.WithType",toString:$estr}
	,InBlock: {_hx_name:"InBlock",_hx_index:2,__enum__:"hxsl._Checker.WithType",toString:$estr}
	,With: ($_=function(t) { return {_hx_index:3,t:t,__enum__:"hxsl._Checker.WithType",toString:$estr}; },$_._hx_name="With",$_.__params__ = ["t"],$_)
};
hxsl__$Checker_WithType.__constructs__ = [hxsl__$Checker_WithType.NoValue,hxsl__$Checker_WithType.Value,hxsl__$Checker_WithType.InBlock,hxsl__$Checker_WithType.With];
hxsl__$Checker_WithType.__empty_constructs__ = [hxsl__$Checker_WithType.NoValue,hxsl__$Checker_WithType.Value,hxsl__$Checker_WithType.InBlock];
var hxsl_Checker = function() {
	this.globals = hxsl_Checker.initGlobals();
};
$hxClasses["hxsl.Checker"] = hxsl_Checker;
hxsl_Checker.__name__ = "hxsl.Checker";
hxsl_Checker.initGlobals = function() {
	var globals = hxsl_Checker.GLOBALS;
	if(hxsl_Checker.GLOBALS != null) {
		return hxsl_Checker.GLOBALS;
	}
	var globals = new haxe_ds_StringMap();
	var genType = [hxsl_Type.TFloat,hxsl_Checker.vec2,hxsl_Checker.vec3,hxsl_Checker.vec4];
	var genIType = [hxsl_Type.TInt,hxsl_Checker.ivec2,hxsl_Checker.ivec3,hxsl_Checker.ivec4];
	var baseType = [hxsl_Type.TFloat,hxsl_Type.TBool,hxsl_Type.TInt];
	var _g = [];
	var _g1 = 0;
	while(_g1 < genType.length) {
		var t = genType[_g1];
		++_g1;
		_g.push({ args : [{ name : "value", type : t}], ret : t});
	}
	var genFloat = _g;
	var _g = [];
	var _g1 = 0;
	while(_g1 < genType.length) {
		var t = genType[_g1];
		++_g1;
		_g.push({ args : [{ name : "a", type : t},{ name : "b", type : t}], ret : t});
	}
	var genFloat2 = _g;
	var _g = [];
	var _g1 = 0;
	while(_g1 < genType.length) {
		var t = genType[_g1];
		++_g1;
		_g.push({ args : [{ name : "a", type : t},{ name : "b", type : hxsl_Type.TFloat}], ret : t});
	}
	var genWithFloat = _g;
	var texDefs = [{ dim : hxsl_TexDimension.T1D, arr : false, uv : hxsl_Type.TFloat, iuv : hxsl_Type.TInt},{ dim : hxsl_TexDimension.T2D, arr : false, uv : hxsl_Checker.vec2, iuv : hxsl_Checker.ivec2},{ dim : hxsl_TexDimension.T3D, arr : false, uv : hxsl_Checker.vec3, iuv : hxsl_Checker.ivec3},{ dim : hxsl_TexDimension.TCube, arr : false, uv : hxsl_Checker.vec3, iuv : hxsl_Checker.ivec3},{ dim : hxsl_TexDimension.T1D, arr : true, uv : hxsl_Checker.vec2, iuv : hxsl_Checker.ivec2},{ dim : hxsl_TexDimension.T2D, arr : true, uv : hxsl_Checker.vec3, iuv : hxsl_Checker.ivec3},{ dim : hxsl_TexDimension.TCube, arr : true, uv : hxsl_Checker.vec4, iuv : hxsl_Checker.ivec4}];
	var gvars_h = Object.create(null);
	var _g = 0;
	var _g1 = hxsl_TGlobal.__empty_constructs__.slice();
	while(_g < _g1.length) {
		var g = _g1[_g];
		++_g;
		var def;
		switch(g._hx_index) {
		case 7:
			def = genFloat.concat(genFloat2);
			break;
		case 8:
			def = genFloat2;
			break;
		case 20:case 21:case 22:
			def = genFloat2.concat(genWithFloat);
			break;
		case 23:
			var r = [{ args : [{ name : "value", type : hxsl_Type.TInt},{ name : "min", type : hxsl_Type.TInt},{ name : "max", type : hxsl_Type.TInt}], ret : hxsl_Type.TInt}];
			var _g2 = 0;
			while(_g2 < genType.length) {
				var t = genType[_g2];
				++_g2;
				r.push({ args : [{ name : "value", type : t},{ name : "min", type : t},{ name : "max", type : t}], ret : t});
				if(t != hxsl_Type.TFloat) {
					r.push({ args : [{ name : "value", type : t},{ name : "min", type : hxsl_Type.TFloat},{ name : "max", type : hxsl_Type.TFloat}], ret : t});
				}
			}
			def = r;
			break;
		case 24:
			var r1 = [];
			var _g3 = 0;
			while(_g3 < genType.length) {
				var t1 = genType[_g3];
				++_g3;
				r1.push({ args : [{ name : "x", type : t1},{ name : "y", type : t1},{ name : "a", type : t1}], ret : t1});
				if(t1 != hxsl_Type.TFloat) {
					r1.push({ args : [{ name : "x", type : t1},{ name : "y", type : t1},{ name : "a", type : hxsl_Type.TFloat}], ret : t1});
				}
			}
			def = r1;
			break;
		case 25:
			def = [{ args : [{ name : "a", type : hxsl_Type.TFloat},{ name : "x", type : hxsl_Type.TFloat},{ name : "y", type : hxsl_Type.TFloat}], ret : hxsl_Type.TFloat}];
			break;
		case 26:
			var r2 = [];
			var _g4 = 0;
			while(_g4 < genType.length) {
				var t2 = genType[_g4];
				++_g4;
				r2.push({ args : [{ name : "edge", type : t2},{ name : "x", type : t2}], ret : t2});
				if(t2 != hxsl_Type.TFloat) {
					r2.push({ args : [{ name : "edge", type : hxsl_Type.TFloat},{ name : "x", type : t2}], ret : t2});
				}
			}
			def = r2;
			break;
		case 27:
			var r3 = [];
			var _g5 = 0;
			while(_g5 < genType.length) {
				var t3 = genType[_g5];
				++_g5;
				r3.push({ args : [{ name : "edge0", type : t3},{ name : "edge1", type : t3},{ name : "x", type : t3}], ret : t3});
				if(t3 != hxsl_Type.TFloat) {
					r3.push({ args : [{ name : "edge0", type : hxsl_Type.TFloat},{ name : "edge1", type : hxsl_Type.TFloat},{ name : "x", type : t3}], ret : t3});
				}
			}
			def = r3;
			break;
		case 28:
			var _g6 = [];
			var _g7 = 0;
			while(_g7 < genType.length) {
				var t4 = genType[_g7];
				++_g7;
				_g6.push({ args : [{ name : "value", type : t4}], ret : hxsl_Type.TFloat});
			}
			def = _g6;
			break;
		case 29:case 30:
			var _g8 = [];
			var _g9 = 0;
			while(_g9 < genType.length) {
				var t5 = genType[_g9];
				++_g9;
				_g8.push({ args : [{ name : "a", type : t5},{ name : "b", type : t5}], ret : hxsl_Type.TFloat});
			}
			def = _g8;
			break;
		case 31:
			def = [{ args : [{ name : "a", type : hxsl_Checker.vec3},{ name : "b", type : hxsl_Checker.vec3}], ret : hxsl_Checker.vec3}];
			break;
		case 32:
			def = genFloat;
			break;
		case 33:
			def = genFloat2;
			break;
		case 34:
			var _g10 = [];
			var _g11 = 0;
			while(_g11 < texDefs.length) {
				var t6 = texDefs[_g11];
				++_g11;
				_g10.push({ args : [{ name : "tex", type : hxsl_Type.TSampler(t6.dim,t6.arr)},{ name : "uv", type : t6.uv}], ret : hxsl_Checker.vec4});
			}
			def = _g10;
			break;
		case 35:
			var _g12 = [];
			var _g13 = 0;
			while(_g13 < texDefs.length) {
				var t7 = texDefs[_g13];
				++_g13;
				_g12.push({ args : [{ name : "tex", type : hxsl_Type.TSampler(t7.dim,t7.arr)},{ name : "uv", type : t7.uv},{ name : "lod", type : hxsl_Type.TFloat}], ret : hxsl_Checker.vec4});
			}
			def = _g12;
			break;
		case 36:
			var _g14 = [];
			var _g15 = 0;
			while(_g15 < texDefs.length) {
				var t8 = texDefs[_g15];
				++_g15;
				_g14.push({ args : [{ name : "tex", type : hxsl_Type.TSampler(t8.dim,t8.arr)},{ name : "pos", type : t8.iuv}], ret : hxsl_Checker.vec4});
			}
			def = _g14;
			break;
		case 37:
			def = [];
			break;
		case 38:
			var _g16 = [];
			var _g17 = 0;
			while(_g17 < baseType.length) {
				var t9 = baseType[_g17];
				++_g17;
				_g16.push({ args : [{ name : "value", type : t9}], ret : hxsl_Type.TInt});
			}
			def = _g16;
			break;
		case 39:
			var _g18 = [];
			var _g19 = 0;
			while(_g19 < baseType.length) {
				var t10 = baseType[_g19];
				++_g19;
				_g18.push({ args : [{ name : "value", type : t10}], ret : hxsl_Type.TFloat});
			}
			def = _g18;
			break;
		case 40:
			var _g20 = [];
			var _g21 = 0;
			while(_g21 < baseType.length) {
				var t11 = baseType[_g21];
				++_g21;
				_g20.push({ args : [{ name : "value", type : t11}], ret : hxsl_Type.TBool});
			}
			def = _g20;
			break;
		case 41:case 42:case 43:case 44:case 45:case 46:case 47:case 48:case 49:case 50:case 51:case 52:case 53:
			def = [];
			break;
		case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 9:case 10:case 11:case 12:case 13:case 14:case 15:case 16:case 17:case 18:case 19:case 54:case 77:
			def = genFloat;
			break;
		case 55:
			def = [{ args : [{ name : "value", type : hxsl_Type.TFloat}], ret : hxsl_Checker.vec4}];
			break;
		case 56:
			def = [{ args : [{ name : "value", type : hxsl_Checker.vec4}], ret : hxsl_Type.TFloat}];
			break;
		case 57:
			def = [{ args : [{ name : "value", type : hxsl_Checker.vec3}], ret : hxsl_Checker.vec4}];
			break;
		case 58:
			def = [{ args : [{ name : "value", type : hxsl_Checker.vec4}], ret : hxsl_Checker.vec3}];
			break;
		case 59:
			def = [{ args : [{ name : "screenPos", type : hxsl_Checker.vec2}], ret : hxsl_Checker.vec2}];
			break;
		case 60:
			def = [{ args : [{ name : "uv", type : hxsl_Checker.vec2}], ret : hxsl_Checker.vec2}];
			break;
		case 61:case 62:case 63:
			def = genFloat;
			break;
		case 64:
			def = [{ args : [{ name : "channel", type : hxsl_Type.TChannel(1)},{ name : "uv", type : hxsl_Checker.vec2}], ret : hxsl_Type.TFloat},{ args : [{ name : "channel", type : hxsl_Type.TChannel(2)},{ name : "uv", type : hxsl_Checker.vec2}], ret : hxsl_Checker.vec2},{ args : [{ name : "channel", type : hxsl_Type.TChannel(3)},{ name : "uv", type : hxsl_Checker.vec2}], ret : hxsl_Checker.vec3},{ args : [{ name : "channel", type : hxsl_Type.TChannel(4)},{ name : "uv", type : hxsl_Checker.vec2}], ret : hxsl_Checker.vec4}];
			break;
		case 65:
			def = [{ args : [{ name : "channel", type : hxsl_Type.TChannel(1)},{ name : "uv", type : hxsl_Checker.vec2},{ name : "lod", type : hxsl_Type.TFloat}], ret : hxsl_Type.TFloat},{ args : [{ name : "channel", type : hxsl_Type.TChannel(2)},{ name : "uv", type : hxsl_Checker.vec2},{ name : "lod", type : hxsl_Type.TFloat}], ret : hxsl_Checker.vec2},{ args : [{ name : "channel", type : hxsl_Type.TChannel(3)},{ name : "uv", type : hxsl_Checker.vec2},{ name : "lod", type : hxsl_Type.TFloat}], ret : hxsl_Checker.vec3},{ args : [{ name : "channel", type : hxsl_Type.TChannel(4)},{ name : "uv", type : hxsl_Checker.vec2},{ name : "lod", type : hxsl_Type.TFloat}], ret : hxsl_Checker.vec4}];
			break;
		case 66:
			def = [{ args : [{ name : "channel", type : hxsl_Type.TChannel(1)},{ name : "pos", type : hxsl_Checker.ivec2}], ret : hxsl_Type.TFloat},{ args : [{ name : "channel", type : hxsl_Type.TChannel(2)},{ name : "pos", type : hxsl_Checker.ivec2}], ret : hxsl_Checker.vec2},{ args : [{ name : "channel", type : hxsl_Type.TChannel(3)},{ name : "pos", type : hxsl_Checker.ivec2}], ret : hxsl_Checker.vec3},{ args : [{ name : "channel", type : hxsl_Type.TChannel(4)},{ name : "pos", type : hxsl_Checker.ivec2}], ret : hxsl_Checker.vec4},{ args : [{ name : "channel", type : hxsl_Type.TChannel(1)},{ name : "pos", type : hxsl_Checker.ivec2},{ name : "lod", type : hxsl_Type.TInt}], ret : hxsl_Type.TFloat},{ args : [{ name : "channel", type : hxsl_Type.TChannel(2)},{ name : "pos", type : hxsl_Checker.ivec2},{ name : "lod", type : hxsl_Type.TInt}], ret : hxsl_Checker.vec2},{ args : [{ name : "channel", type : hxsl_Type.TChannel(3)},{ name : "pos", type : hxsl_Checker.ivec2},{ name : "lod", type : hxsl_Type.TInt}], ret : hxsl_Checker.vec3},{ args : [{ name : "channel", type : hxsl_Type.TChannel(4)},{ name : "pos", type : hxsl_Checker.ivec2},{ name : "lod", type : hxsl_Type.TInt}], ret : hxsl_Checker.vec4}];
			break;
		case 67:
			def = [{ args : [{ name : "channel", type : hxsl_Type.TChannel(1)}], ret : hxsl_Checker.vec2},{ args : [{ name : "channel", type : hxsl_Type.TChannel(2)}], ret : hxsl_Checker.vec2},{ args : [{ name : "channel", type : hxsl_Type.TChannel(3)}], ret : hxsl_Checker.vec2},{ args : [{ name : "channel", type : hxsl_Type.TChannel(4)}], ret : hxsl_Checker.vec2},{ args : [{ name : "channel", type : hxsl_Type.TChannel(1)},{ name : "lod", type : hxsl_Type.TInt}], ret : hxsl_Checker.vec2},{ args : [{ name : "channel", type : hxsl_Type.TChannel(2)},{ name : "lod", type : hxsl_Type.TInt}], ret : hxsl_Checker.vec2},{ args : [{ name : "channel", type : hxsl_Type.TChannel(3)},{ name : "lod", type : hxsl_Type.TInt}], ret : hxsl_Checker.vec2},{ args : [{ name : "channel", type : hxsl_Type.TChannel(4)},{ name : "lod", type : hxsl_Type.TInt}], ret : hxsl_Checker.vec2}];
			break;
		case 69:case 70:case 71:case 72:
			def = null;
			break;
		case 73:case 74:
			var _g22 = [];
			var _g_current = 0;
			var _g_array = genType;
			while(_g_current < _g_array.length) {
				var _g_value = _g_array[_g_current];
				var _g_key = _g_current++;
				var i = _g_key;
				var t12 = _g_value;
				_g22.push({ args : [{ name : "x", type : t12}], ret : genIType[i]});
			}
			def = _g22;
			break;
		case 75:case 76:
			var _g23 = [];
			var _g_current1 = 0;
			var _g_array1 = genType;
			while(_g_current1 < _g_array1.length) {
				var _g_value1 = _g_array1[_g_current1];
				var _g_key1 = _g_current1++;
				var i1 = _g_key1;
				var t13 = _g_value1;
				_g23.push({ args : [{ name : "x", type : genIType[i1]}], ret : t13});
			}
			def = _g23;
			break;
		case 78:
			def = [{ args : [{ name : "x", type : hxsl_Type.TInt},{ name : "y", type : hxsl_Type.TInt},{ name : "z", type : hxsl_Type.TInt}], ret : hxsl_Type.TVoid},{ args : [{ name : "x", type : hxsl_Type.TInt},{ name : "y", type : hxsl_Type.TInt}], ret : hxsl_Type.TVoid},{ args : [{ name : "x", type : hxsl_Type.TInt}], ret : hxsl_Type.TVoid}];
			break;
		case 79:
			def = [];
			break;
		case 84:
			def = [{ args : [{ name : "buf", type : hxsl_Type.TBuffer(hxsl_Type.TInt,hxsl_SizeDecl.SConst(0),hxsl_BufferKind.RW)},{ name : "index", type : hxsl_Type.TInt},{ name : "data", type : hxsl_Type.TInt}], ret : hxsl_Type.TInt}];
			break;
		case 68:case 85:
			def = [];
			break;
		case 86:
			if($hxEnums[g.__enum__].__constructs__[g._hx_index]._hx_name.indexOf("_") > 0) {
				var name = $hxEnums[g.__enum__].__constructs__[g._hx_index]._hx_name;
				var idx = name.indexOf("_");
				var vname = HxOverrides.substr(name,0,idx);
				vname = vname.charAt(0).toLowerCase() + HxOverrides.substr(vname,1,null);
				var vl = gvars_h[vname];
				if(vl == null) {
					vl = [];
					gvars_h[vname] = vl;
				}
				var vt;
				switch(g._hx_index) {
				case 80:case 81:case 82:
					vt = hxsl_Checker.ivec3;
					break;
				case 83:
					vt = hxsl_Type.TInt;
					break;
				default:
					throw haxe_Exception.thrown("Unknown type for global var " + Std.string(g));
				}
				var fname = HxOverrides.substr(name,idx + 1,null);
				fname = fname.charAt(0).toLowerCase() + HxOverrides.substr(fname,1,null);
				vl.push({ name : fname, type : vt});
				def = null;
			} else {
				def = [{ args : [{ name : "value", type : hxsl_Type.TInt}], ret : hxsl_Checker.vec4}];
			}
			break;
		case 87:
			if($hxEnums[g.__enum__].__constructs__[g._hx_index]._hx_name.indexOf("_") > 0) {
				var name1 = $hxEnums[g.__enum__].__constructs__[g._hx_index]._hx_name;
				var idx1 = name1.indexOf("_");
				var vname1 = HxOverrides.substr(name1,0,idx1);
				vname1 = vname1.charAt(0).toLowerCase() + HxOverrides.substr(vname1,1,null);
				var vl1 = gvars_h[vname1];
				if(vl1 == null) {
					vl1 = [];
					gvars_h[vname1] = vl1;
				}
				var vt1;
				switch(g._hx_index) {
				case 80:case 81:case 82:
					vt1 = hxsl_Checker.ivec3;
					break;
				case 83:
					vt1 = hxsl_Type.TInt;
					break;
				default:
					throw haxe_Exception.thrown("Unknown type for global var " + Std.string(g));
				}
				var fname1 = HxOverrides.substr(name1,idx1 + 1,null);
				fname1 = fname1.charAt(0).toLowerCase() + HxOverrides.substr(fname1,1,null);
				vl1.push({ name : fname1, type : vt1});
				def = null;
			} else {
				def = [{ args : [{ name : "value", type : hxsl_Type.TInt}], ret : hxsl_Checker.vec4}];
			}
			break;
		default:
			if($hxEnums[g.__enum__].__constructs__[g._hx_index]._hx_name.indexOf("_") > 0) {
				var name2 = $hxEnums[g.__enum__].__constructs__[g._hx_index]._hx_name;
				var idx2 = name2.indexOf("_");
				var vname2 = HxOverrides.substr(name2,0,idx2);
				vname2 = vname2.charAt(0).toLowerCase() + HxOverrides.substr(vname2,1,null);
				var vl2 = gvars_h[vname2];
				if(vl2 == null) {
					vl2 = [];
					gvars_h[vname2] = vl2;
				}
				var vt2;
				switch(g._hx_index) {
				case 80:case 81:case 82:
					vt2 = hxsl_Checker.ivec3;
					break;
				case 83:
					vt2 = hxsl_Type.TInt;
					break;
				default:
					throw haxe_Exception.thrown("Unknown type for global var " + Std.string(g));
				}
				var fname2 = HxOverrides.substr(name2,idx2 + 1,null);
				fname2 = fname2.charAt(0).toLowerCase() + HxOverrides.substr(fname2,1,null);
				vl2.push({ name : fname2, type : vt2});
				def = null;
			} else {
				throw haxe_Exception.thrown("Unsupported global " + Std.string(g));
			}
		}
		if(def != null) {
			var key = hxsl_Tools2.toString(g);
			globals.h[key] = { t : hxsl_Type.TFun(def), g : g};
		}
	}
	globals.h["vertexID"] = { t : hxsl_Type.TInt, g : hxsl_TGlobal.VertexID};
	globals.h["instanceID"] = { t : hxsl_Type.TInt, g : hxsl_TGlobal.InstanceID};
	globals.h["fragCoord"] = { t : hxsl_Checker.vec4, g : hxsl_TGlobal.FragCoord};
	globals.h["frontFacing"] = { t : hxsl_Type.TBool, g : hxsl_TGlobal.FrontFacing};
	var h = gvars_h;
	var _g_h = h;
	var _g_keys = Object.keys(h);
	var _g_length = _g_keys.length;
	var _g_current = 0;
	while(_g_current < _g_length) {
		var key = _g_keys[_g_current++];
		var _g_key = key;
		var _g_value = _g_h[key];
		var gname = _g_key;
		var vl = _g_value;
		var _g = [];
		var _g1 = 0;
		while(_g1 < vl.length) {
			var v = vl[_g1];
			++_g1;
			_g.push({ name : v.name, kind : hxsl_VarKind.Global, type : v.type, id : 0});
		}
		globals.h[gname] = { t : hxsl_Type.TStruct(_g), g : null};
	}
	globals.h["int"] = globals.h["toInt"];
	globals.h["float"] = globals.h["toFloat"];
	globals.h["reflect"] = globals.h["lReflect"];
	globals.h["ivec" + 2] = globals.h["iVec" + 2];
	var key = "iVec" + 2;
	if(Object.prototype.hasOwnProperty.call(globals.h,key)) {
		delete(globals.h[key]);
	}
	globals.h["ivec" + 3] = globals.h["iVec" + 3];
	var key = "iVec" + 3;
	if(Object.prototype.hasOwnProperty.call(globals.h,key)) {
		delete(globals.h[key]);
	}
	globals.h["ivec" + 4] = globals.h["iVec" + 4];
	var key = "iVec" + 4;
	if(Object.prototype.hasOwnProperty.call(globals.h,key)) {
		delete(globals.h[key]);
	}
	if(Object.prototype.hasOwnProperty.call(globals.h,"lReflect")) {
		delete(globals.h["lReflect"]);
	}
	if(Object.prototype.hasOwnProperty.call(globals.h,"toInt")) {
		delete(globals.h["toInt"]);
	}
	if(Object.prototype.hasOwnProperty.call(globals.h,"toFloat")) {
		delete(globals.h["toFloat"]);
	}
	hxsl_Checker.GLOBALS = globals;
	return globals;
};
hxsl_Checker.prototype = {
	error: function(msg,pos) {
		return hxsl_Error.t(msg,pos);
	}
	,warning: function(msg,pos) {
	}
	,loadShader: function(path) {
		throw haxe_Exception.thrown("Not implemented");
	}
	,check: function(name,shader) {
		this.vars = new haxe_ds_StringMap();
		this.inits = [];
		this.inLoop = false;
		this.inWhile = false;
		var funs = [];
		this.checkExpr(shader,funs,false,false);
		var tfuns = [];
		var _g = 0;
		while(_g < funs.length) {
			var f = funs[_g];
			++_g;
			var pos = f.p;
			var f1 = f.f;
			var _g1 = [];
			var _g2 = 0;
			var _g3 = f1.args;
			while(_g2 < _g3.length) {
				var a = _g3[_g2];
				++_g2;
				if(a.type == null) {
					this.error("Argument type required",pos);
				}
				if(a.expr != null) {
					this.error("Optional argument not supported",pos);
				}
				if(a.kind == null) {
					a.kind = hxsl_VarKind.Local;
				}
				if(a.kind != hxsl_VarKind.Local) {
					this.error("Argument should be local",pos);
				}
				if(a.qualifiers.length != 0) {
					this.error("No qualifier allowed for argument",pos);
				}
				_g1.push({ id : hxsl_Tools.allocVarId(), name : a.name, kind : hxsl_VarKind.Local, type : a.type});
			}
			var args = _g1;
			var kind;
			switch(f1.name) {
			case "fragment":
				kind = hxsl_FunctionKind.Fragment;
				break;
			case "main":
				kind = hxsl_FunctionKind.Main;
				break;
			case "vertex":
				kind = hxsl_FunctionKind.Vertex;
				break;
			default:
				kind = StringTools.startsWith(f1.name,"__init__") ? hxsl_FunctionKind.Init : hxsl_FunctionKind.Helper;
			}
			if(args.length != 0 && kind != hxsl_FunctionKind.Helper) {
				this.error(Std.string(kind) + " function should have no argument",pos);
			}
			var fv = hxsl_Tools.allocVarId();
			var f2 = f1.name;
			var _g4 = [];
			var _g5 = 0;
			while(_g5 < args.length) {
				var a1 = args[_g5];
				++_g5;
				_g4.push({ type : a1.type, name : a1.name});
			}
			var fv1 = { id : fv, name : f2, kind : hxsl_VarKind.Function, type : hxsl_Type.TFun([{ args : _g4, ret : f1.ret == null ? hxsl_Type.TVoid : f1.ret}])};
			var f3 = { kind : kind, ref : fv1, args : args, ret : f1.ret == null ? hxsl_Type.TVoid : f1.ret, expr : null};
			if(Object.prototype.hasOwnProperty.call(this.vars.h,fv1.name)) {
				this.error("Duplicate function name",pos);
			}
			this.vars.h[fv1.name] = fv1;
			tfuns.push(f3);
		}
		var _g = 0;
		var _g1 = tfuns.length;
		while(_g < _g1) {
			var i = _g++;
			this.typeFun(tfuns[i],funs[i].f.expr);
		}
		var localInits = [];
		var _g = 0;
		var _g1 = this.inits.slice();
		while(_g < _g1.length) {
			var i = _g1[_g];
			++_g;
			if(i.v.kind == hxsl_VarKind.Local) {
				localInits.push({ e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssign,{ e : hxsl_TExprDef.TVar(i.v), p : i.e.p, t : i.v.type},i.e), p : i.e.p, t : i.v.type});
				HxOverrides.remove(this.inits,i);
			}
		}
		if(localInits.length > 0) {
			var fv = { id : hxsl_Tools.allocVarId(), name : "__init__consts__", kind : hxsl_VarKind.Function, type : hxsl_Type.TFun([{ args : [], ret : hxsl_Type.TVoid}])};
			if(Object.prototype.hasOwnProperty.call(this.vars.h,fv.name)) {
				this.error("assert",localInits[0].p);
			}
			this.vars.h[fv.name] = fv;
			tfuns.push({ kind : hxsl_FunctionKind.Init, ref : fv, args : [], ret : hxsl_Type.TVoid, expr : { e : hxsl_TExprDef.TBlock(localInits), p : localInits[0].p, t : hxsl_Type.TVoid}});
		}
		var vars = Lambda.array(this.vars);
		vars.sort(function(v1,v2) {
			return (v1.id < 0 ? -v1.id : v1.id) - (v2.id < 0 ? -v2.id : v2.id);
		});
		return { name : name, vars : vars, funs : tfuns};
	}
	,saveVars: function() {
		var old = new haxe_ds_StringMap();
		var h = this.vars.h;
		var v_h = h;
		var v_keys = Object.keys(h);
		var v_length = v_keys.length;
		var v_current = 0;
		while(v_current < v_length) {
			var v = v_keys[v_current++];
			old.h[v] = this.vars.h[v];
		}
		return old;
	}
	,typeFun: function(f,e) {
		var old = this.saveVars();
		var _g = 0;
		var _g1 = f.args;
		while(_g < _g1.length) {
			var a = _g1[_g];
			++_g;
			this.vars.h[a.name] = a;
		}
		this.curFun = f;
		f.expr = this.typeExpr(e,hxsl__$Checker_WithType.NoValue);
		this.vars = old;
	}
	,tryUnify: function(t1,t2) {
		if(Type.enumEq(t1,t2)) {
			return true;
		}
		switch(t1._hx_index) {
		case 5:
			if(t2._hx_index == 5) {
				var s2 = t2.size;
				var t21 = t2.t;
				var t11 = t1.t;
				var s1 = t1.size;
				if(s1 == s2 && t11 == t21) {
					return true;
				}
			}
			break;
		case 10:
			if(t2._hx_index == 10) {
				var dim2 = t2.dim;
				var arr2 = t2.isArray;
				var arr1 = t1.isArray;
				var dim1 = t1.dim;
				if(dim1 == dim2) {
					return arr1 == arr2;
				} else {
					return false;
				}
			}
			break;
		case 11:
			if(t2._hx_index == 11) {
				var dim2 = t2.dim;
				var arr2 = t2.isArray;
				var chans2 = t2.channels;
				var chans1 = t1.channels;
				var arr1 = t1.isArray;
				var dim1 = t1.dim;
				if(dim1 == dim2 && arr1 == arr2) {
					return chans1 == chans2;
				} else {
					return false;
				}
			}
			break;
		case 15:
			if(t2._hx_index == 15) {
				var t21 = t2.t;
				var size2 = t2.size;
				var size1 = t1.size;
				var t11 = t1.t;
				switch(size1._hx_index) {
				case 0:
					if(size2._hx_index == 0) {
						var b = size2.v;
						var a = size1.v;
						if(a != b) {
							return false;
						}
					} else {
						return false;
					}
					break;
				case 1:
					if(size2._hx_index == 1) {
						var v2 = size2.v;
						var v1 = size1.v;
						if(v1 != v2) {
							return false;
						}
					} else {
						return false;
					}
					break;
				default:
					return false;
				}
				return this.tryUnify(t11,t21);
			}
			break;
		case 17:
			if(t2._hx_index == 17) {
				var n2 = t2.size;
				var n1 = t1.size;
				if(n1 == n2) {
					return true;
				}
			}
			break;
		default:
		}
		return false;
	}
	,unify: function(t1,t2,p) {
		if(!this.tryUnify(t1,t2)) {
			this.error(hxsl_Tools.toString(t1) + " should be " + hxsl_Tools.toString(t2),p);
		}
	}
	,unifyExpr: function(e,t) {
		if(!this.tryUnify(e.t,t)) {
			if(e.t == hxsl_Type.TInt && t == hxsl_Type.TFloat) {
				this.toFloat(e);
				return;
			}
			this.error(hxsl_Tools.toString(e.t) + " should be " + hxsl_Tools.toString(t),e.p);
		}
	}
	,checkWrite: function(e) {
		var _g = e.e;
		switch(_g._hx_index) {
		case 1:
			var v = _g.v;
			switch(v.kind._hx_index) {
			case 2:
				var _g1 = v.type;
				var tmp;
				switch(_g1._hx_index) {
				case 11:
					var _g2 = _g1.dim;
					var _g2 = _g1.isArray;
					var _g2 = _g1.channels;
					tmp = true;
					break;
				case 16:
					var _g2 = _g1.t;
					var _g2 = _g1.size;
					switch(_g1.kind._hx_index) {
					case 2:case 5:
						tmp = true;
						break;
					default:
						tmp = false;
					}
					break;
				default:
					tmp = false;
				}
				if(tmp) {
					return;
				}
				break;
			case 4:
				if(v.qualifiers == null || v.qualifiers.indexOf(hxsl_VarQualifier.Final) < 0) {
					return;
				} else {
					var _g1 = v.type;
					var tmp;
					switch(_g1._hx_index) {
					case 11:
						var _g2 = _g1.dim;
						var _g2 = _g1.isArray;
						var _g2 = _g1.channels;
						tmp = true;
						break;
					case 16:
						var _g2 = _g1.t;
						var _g2 = _g1.size;
						switch(_g1.kind._hx_index) {
						case 2:case 5:
							tmp = true;
							break;
						default:
							tmp = false;
						}
						break;
					default:
						tmp = false;
					}
					if(tmp) {
						return;
					}
				}
				break;
			case 3:case 5:
				return;
			default:
			}
			break;
		case 9:
			var _g1 = _g.regs;
			var e1 = _g.e;
			this.checkWrite(e1);
			return;
		case 16:
			var _g1 = _g.index;
			var e1 = _g.e;
			this.checkWrite(e1);
			return;
		case 21:
			var _g1 = _g.name;
			var e1 = _g.e;
			this.checkWrite(e1);
			return;
		default:
		}
		this.error("This expression cannot be assigned",e.p);
	}
	,typeWith: function(e,t) {
		if(t == null) {
			return this.typeExpr(e,hxsl__$Checker_WithType.Value);
		}
		var e1 = this.typeExpr(e,hxsl__$Checker_WithType.With(t));
		this.unifyExpr(e1,t);
		return e1;
	}
	,typeExpr: function(e,$with) {
		var _gthis = this;
		var type = null;
		var ed;
		var _g = e.expr;
		switch(_g._hx_index) {
		case 0:
			var c = _g.c;
			switch(c._hx_index) {
			case 0:
				type = hxsl_Type.TVoid;
				break;
			case 1:
				var _g1 = c.b;
				type = hxsl_Type.TBool;
				break;
			case 2:
				var i = c.v;
				if($with._hx_index == 3) {
					if($with.t._hx_index == 3) {
						c = hxsl_Const.CFloat(i);
						type = hxsl_Type.TFloat;
					} else {
						type = hxsl_Type.TInt;
					}
				} else {
					type = hxsl_Type.TInt;
				}
				break;
			case 3:
				var _g1 = c.v;
				type = hxsl_Type.TFloat;
				break;
			case 4:
				var _g1 = c.v;
				type = hxsl_Type.TString;
				break;
			}
			ed = hxsl_TExprDef.TConst(c);
			break;
		case 1:
			var name = _g.i;
			var v = this.vars.h[name];
			if(v != null) {
				var canCall;
				switch(name) {
				case "fragment":case "main":case "vertex":
					canCall = false;
					break;
				default:
					canCall = !StringTools.startsWith(name,"__init__");
				}
				if(!canCall) {
					this.error("Function cannot be accessed",e.pos);
				}
				type = v.type;
				ed = hxsl_TExprDef.TVar(v);
			} else {
				var g = this.globals.h[name];
				if(g != null && g.g != null) {
					type = g.t;
					ed = hxsl_TExprDef.TGlobal(g.g);
				} else if(name == "PI") {
					type = hxsl_Type.TFloat;
					ed = hxsl_TExprDef.TConst(hxsl_Const.CFloat(Math.PI));
				} else {
					ed = this.error("Unknown identifier '" + name + "'",e.pos);
				}
			}
			break;
		case 2:
			var e1 = _g.e;
			var e2 = this.typeExpr(e1,$with);
			type = e2.t;
			ed = hxsl_TExprDef.TParenthesis(e2);
			break;
		case 3:
			var _g1 = _g.e;
			var _g2 = _g.f;
			var _g3 = _g1.expr;
			var _g4 = _g1.pos;
			if(_g3._hx_index == 1) {
				var name = _g3.i;
				var f = _g2;
				if(this.vars.h[name] == null && this.globals.h[name] != null && this.globals.h[name].g == null) {
					var _g3 = this.globals.h[name].t;
					if(_g3._hx_index == 13) {
						var vl = _g3.vl;
						var _g3 = 0;
						while(_g3 < vl.length) {
							var v = vl[_g3];
							++_g3;
							if(v.name == f) {
								var g = name.charAt(0).toUpperCase() + HxOverrides.substr(name,1,null) + "_" + f.charAt(0).toUpperCase() + HxOverrides.substr(f,1,null);
								return { e : hxsl_TExprDef.TGlobal(Type.createEnum(hxsl_TGlobal,g,null)), t : v.type, p : e.pos};
							}
						}
						var ed1 = name + " field should be ";
						var _g3 = [];
						var _g4 = 0;
						while(_g4 < vl.length) {
							var v = vl[_g4];
							++_g4;
							_g3.push(v.name);
						}
						ed = this.error(ed1 + _g3.join("|"),e.pos);
					} else {
						throw haxe_Exception.thrown("assert");
					}
				} else {
					var e1 = _g1;
					var f = _g2;
					var e11 = this.typeExpr(e1,hxsl__$Checker_WithType.Value);
					var ef = this.fieldAccess(e11,f,$with,e.pos);
					if(ef == null) {
						this.error(hxsl_Tools.toString(e11.t) + " has no field '" + f + "'",e.pos);
					}
					switch(ef._hx_index) {
					case 0:
						var ef1 = ef.e;
						type = ef1.t;
						ed = ef1.e;
						break;
					case 1:
						var _g3 = ef.g;
						var _g3 = ef.arg;
						var _g3 = ef.variants;
						ed = this.error("Global function must be called immediately",e.pos);
						break;
					}
				}
			} else {
				var e1 = _g1;
				var f = _g2;
				var e11 = this.typeExpr(e1,hxsl__$Checker_WithType.Value);
				var ef = this.fieldAccess(e11,f,$with,e.pos);
				if(ef == null) {
					this.error(hxsl_Tools.toString(e11.t) + " has no field '" + f + "'",e.pos);
				}
				switch(ef._hx_index) {
				case 0:
					var ef1 = ef.e;
					type = ef1.t;
					ed = ef1.e;
					break;
				case 1:
					var _g1 = ef.g;
					var _g1 = ef.arg;
					var _g1 = ef.variants;
					ed = this.error("Global function must be called immediately",e.pos);
					break;
				}
			}
			break;
		case 4:
			var op = _g.op;
			var e1 = _g.e1;
			var e2 = _g.e2;
			var e11 = this.typeExpr(e1,hxsl__$Checker_WithType.Value);
			var e21 = this.typeExpr(e2,hxsl__$Checker_WithType.With(e11.t));
			switch(op._hx_index) {
			case 4:
				this.checkWrite(e11);
				this.unify(e21.t,e11.t,e21.p);
				type = e11.t;
				break;
			case 20:
				var op1 = op.op;
				this.checkWrite(e11);
				this.unify(this.typeBinop(op1,e11,e21,e.pos),e11.t,e21.p);
				type = e11.t;
				break;
			default:
				type = this.typeBinop(op,e11,e21,e.pos);
			}
			ed = hxsl_TExprDef.TBinop(op,e11,e21);
			break;
		case 5:
			var op = _g.op;
			var e1 = _g.e1;
			var e11 = this.typeExpr(e1,hxsl__$Checker_WithType.Value);
			switch(op._hx_index) {
			case 0:case 1:
				switch(e11.t._hx_index) {
				case 1:case 3:
					break;
				default:
					this.error("Cannot increment " + hxsl_Tools.toString(e11.t),e.pos);
				}
				type = hxsl_Type.TVoid;
				ed = hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssignOp(op == haxe_macro_Unop.OpIncrement ? haxe_macro_Binop.OpAdd : haxe_macro_Binop.OpSub),e11,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(1)), t : hxsl_Type.TInt, p : e11.p});
				break;
			case 2:
				this.unifyExpr(e11,hxsl_Type.TBool);
				type = hxsl_Type.TBool;
				ed = hxsl_TExprDef.TUnop(op,e11);
				break;
			case 3:
				var _g1 = e11.t;
				switch(_g1._hx_index) {
				case 1:case 3:
					break;
				case 5:
					var _g2 = _g1.size;
					switch(_g1.t._hx_index) {
					case 0:case 1:
						break;
					default:
						this.error("Cannot negate " + hxsl_Tools.toString(e11.t),e.pos);
					}
					break;
				default:
					this.error("Cannot negate " + hxsl_Tools.toString(e11.t),e.pos);
				}
				type = e11.t;
				ed = hxsl_TExprDef.TUnop(op,e11);
				break;
			default:
				ed = this.error("Operation non supported",e.pos);
			}
			break;
		case 6:
			var _g1 = _g.e;
			var _g2 = _g.args;
			var _g3 = _g1.expr;
			var _g4 = _g1.pos;
			if(_g3._hx_index == 3) {
				var _g4 = _g3.e;
				var _g5 = _g4.expr;
				var _g6 = _g4.pos;
				if(_g5._hx_index == 1) {
					if(_g5.i == "Syntax") {
						var target = _g3.f;
						var args = _g2;
						if(args.length == 0) {
							this.error("Syntax." + target + " should have a string as first argument",e.pos);
						}
						var code;
						var _g3 = args[0].expr;
						if(_g3._hx_index == 0) {
							var _g4 = _g3.c;
							if(_g4._hx_index == 4) {
								var code1 = _g4.v;
								code = code1;
							} else {
								code = this.error("Syntax." + target + " should have a string as first argument",args[0].pos);
							}
						} else {
							code = this.error("Syntax." + target + " should have a string as first argument",args[0].pos);
						}
						var sargs = [];
						var _g3 = 1;
						var _g4 = args.length;
						while(_g3 < _g4) {
							var i = _g3++;
							var arg = args[i];
							var _g5 = arg.expr;
							if(_g5._hx_index == 20) {
								var _g6 = _g5.name;
								var _g7 = _g5.args;
								var _g8 = _g5.e;
								switch(_g6) {
								case "r":case "rw":case "w":
									var flags = _g6;
									var flaggedArg = _g8;
									var ed1 = this.typeExpr(flaggedArg,hxsl__$Checker_WithType.Value);
									var ed2;
									switch(flags) {
									case "r":
										ed2 = hxsl_SyntaxArgAccess.Read;
										break;
									case "rw":
										ed2 = hxsl_SyntaxArgAccess.ReadWrite;
										break;
									case "w":
										ed2 = hxsl_SyntaxArgAccess.Write;
										break;
									default:
										throw haxe_Exception.thrown("assert");
									}
									sargs.push({ e : ed1, access : ed2});
									break;
								default:
									this.error("Syntax." + target + " arguments should have an access meta of @r, @w or @rw",arg.pos);
								}
							} else {
								this.error("Syntax." + target + " arguments should have an access meta of @r, @w or @rw",arg.pos);
							}
						}
						return { e : hxsl_TExprDef.TSyntax(target,code,sargs), t : hxsl_Type.TVoid, p : e.pos};
					} else {
						var e1 = _g1;
						var args = _g2;
						var makeCall = function(e1) {
							var _g = e1.t;
							if(_g._hx_index == 14) {
								var variants = _g.variants;
								var e2 = _gthis.unifyCallParams(e1,args,variants,e.pos);
								type = e2.t;
								return e2.e;
							} else {
								return _gthis.error(hxsl_Tools.toString(e1.t) + " cannot be called",e.pos);
							}
						};
						var _g3 = e1.expr;
						if(_g3._hx_index == 3) {
							var e11 = _g3.e;
							var f = _g3.f;
							var e12 = this.typeExpr(e11,hxsl__$Checker_WithType.Value);
							var ef = this.fieldAccess(e12,f,$with,e.pos);
							if(ef == null) {
								this.error(hxsl_Tools.toString(e12.t) + " has no field '" + f + "'",e.pos);
							}
							switch(ef._hx_index) {
							case 0:
								var ef1 = ef.e;
								ed = makeCall(ef1);
								break;
							case 1:
								var g = ef.g;
								var arg = ef.arg;
								var variants = ef.variants;
								var eg = { e : hxsl_TExprDef.TGlobal(g), t : hxsl_Type.TFun(variants), p : e12.p};
								if(variants.length == 0) {
									var _g3 = [];
									var _g4 = 0;
									while(_g4 < args.length) {
										var a = args[_g4];
										++_g4;
										_g3.push(this.typeExpr(a,hxsl__$Checker_WithType.Value));
									}
									var args1 = _g3;
									args1.unshift(arg);
									var e2 = this.specialGlobal(g,eg,args1,e.pos);
									type = e2.t;
									ed = e2.e;
								} else {
									var e2 = this.unifyCallParams(eg,args,variants,e.pos);
									var _g3 = e2.e;
									var _g4 = eg.t;
									if(_g3._hx_index == 8) {
										var _g5 = _g3.e;
										if(_g4._hx_index == 14) {
											var _g5 = _g4.variants;
											if(_g5.length == 1) {
												var f = _g5[0];
												var args1 = _g3.args;
												args1.unshift(arg);
												f.args.unshift({ name : "_", type : arg.t});
											} else {
												throw haxe_Exception.thrown("assert");
											}
										} else {
											throw haxe_Exception.thrown("assert");
										}
									} else {
										throw haxe_Exception.thrown("assert");
									}
									type = e2.t;
									ed = e2.e;
								}
								break;
							}
						} else {
							ed = makeCall(this.typeExpr(e1,hxsl__$Checker_WithType.Value));
						}
					}
				} else {
					var e1 = _g1;
					var args1 = _g2;
					var makeCall1 = function(e1) {
						var _g = e1.t;
						if(_g._hx_index == 14) {
							var variants = _g.variants;
							var e2 = _gthis.unifyCallParams(e1,args1,variants,e.pos);
							type = e2.t;
							return e2.e;
						} else {
							return _gthis.error(hxsl_Tools.toString(e1.t) + " cannot be called",e.pos);
						}
					};
					var _g3 = e1.expr;
					if(_g3._hx_index == 3) {
						var e11 = _g3.e;
						var f = _g3.f;
						var e12 = this.typeExpr(e11,hxsl__$Checker_WithType.Value);
						var ef = this.fieldAccess(e12,f,$with,e.pos);
						if(ef == null) {
							this.error(hxsl_Tools.toString(e12.t) + " has no field '" + f + "'",e.pos);
						}
						switch(ef._hx_index) {
						case 0:
							var ef1 = ef.e;
							ed = makeCall1(ef1);
							break;
						case 1:
							var g = ef.g;
							var arg = ef.arg;
							var variants = ef.variants;
							var eg = { e : hxsl_TExprDef.TGlobal(g), t : hxsl_Type.TFun(variants), p : e12.p};
							if(variants.length == 0) {
								var _g3 = [];
								var _g4 = 0;
								while(_g4 < args1.length) {
									var a = args1[_g4];
									++_g4;
									_g3.push(this.typeExpr(a,hxsl__$Checker_WithType.Value));
								}
								var args2 = _g3;
								args2.unshift(arg);
								var e2 = this.specialGlobal(g,eg,args2,e.pos);
								type = e2.t;
								ed = e2.e;
							} else {
								var e2 = this.unifyCallParams(eg,args1,variants,e.pos);
								var _g3 = e2.e;
								var _g4 = eg.t;
								if(_g3._hx_index == 8) {
									var _g5 = _g3.e;
									if(_g4._hx_index == 14) {
										var _g5 = _g4.variants;
										if(_g5.length == 1) {
											var f = _g5[0];
											var args2 = _g3.args;
											args2.unshift(arg);
											f.args.unshift({ name : "_", type : arg.t});
										} else {
											throw haxe_Exception.thrown("assert");
										}
									} else {
										throw haxe_Exception.thrown("assert");
									}
								} else {
									throw haxe_Exception.thrown("assert");
								}
								type = e2.t;
								ed = e2.e;
							}
							break;
						}
					} else {
						ed = makeCall1(this.typeExpr(e1,hxsl__$Checker_WithType.Value));
					}
				}
			} else {
				var e1 = _g1;
				var args2 = _g2;
				var makeCall2 = function(e1) {
					var _g = e1.t;
					if(_g._hx_index == 14) {
						var variants = _g.variants;
						var e2 = _gthis.unifyCallParams(e1,args2,variants,e.pos);
						type = e2.t;
						return e2.e;
					} else {
						return _gthis.error(hxsl_Tools.toString(e1.t) + " cannot be called",e.pos);
					}
				};
				var _g1 = e1.expr;
				if(_g1._hx_index == 3) {
					var e11 = _g1.e;
					var f = _g1.f;
					var e12 = this.typeExpr(e11,hxsl__$Checker_WithType.Value);
					var ef = this.fieldAccess(e12,f,$with,e.pos);
					if(ef == null) {
						this.error(hxsl_Tools.toString(e12.t) + " has no field '" + f + "'",e.pos);
					}
					switch(ef._hx_index) {
					case 0:
						var ef1 = ef.e;
						ed = makeCall2(ef1);
						break;
					case 1:
						var g = ef.g;
						var arg = ef.arg;
						var variants = ef.variants;
						var eg = { e : hxsl_TExprDef.TGlobal(g), t : hxsl_Type.TFun(variants), p : e12.p};
						if(variants.length == 0) {
							var _g1 = [];
							var _g2 = 0;
							while(_g2 < args2.length) {
								var a = args2[_g2];
								++_g2;
								_g1.push(this.typeExpr(a,hxsl__$Checker_WithType.Value));
							}
							var args3 = _g1;
							args3.unshift(arg);
							var e2 = this.specialGlobal(g,eg,args3,e.pos);
							type = e2.t;
							ed = e2.e;
						} else {
							var e2 = this.unifyCallParams(eg,args2,variants,e.pos);
							var _g1 = e2.e;
							var _g2 = eg.t;
							if(_g1._hx_index == 8) {
								var _g3 = _g1.e;
								if(_g2._hx_index == 14) {
									var _g3 = _g2.variants;
									if(_g3.length == 1) {
										var f = _g3[0];
										var args3 = _g1.args;
										args3.unshift(arg);
										f.args.unshift({ name : "_", type : arg.t});
									} else {
										throw haxe_Exception.thrown("assert");
									}
								} else {
									throw haxe_Exception.thrown("assert");
								}
							} else {
								throw haxe_Exception.thrown("assert");
							}
							type = e2.t;
							ed = e2.e;
						}
						break;
					}
				} else {
					ed = makeCall2(this.typeExpr(e1,hxsl__$Checker_WithType.Value));
				}
			}
			break;
		case 7:
			var el = _g.el;
			var old = this.saveVars();
			var el1 = el.slice();
			var tl = [];
			$with = this.propagate($with);
			if(el1.length == 0 && $with != hxsl__$Checker_WithType.NoValue) {
				this.error("Value expected",e.pos);
			}
			while(true) {
				var e1 = el1.shift();
				if(e1 == null) {
					break;
				}
				var _g1 = e1.expr;
				if(_g1._hx_index == 8) {
					var vl = _g1.v;
					if(vl.length > 1) {
						var v0 = vl.shift();
						el1.unshift(e1);
						e1 = { expr : hxsl_ExprDef.EVars([v0]), pos : e1.pos};
					}
				}
				var ew;
				var _g2 = e1.expr;
				if(_g2._hx_index == 8) {
					var _g3 = _g2.v;
					ew = hxsl__$Checker_WithType.InBlock;
				} else {
					ew = el1.length == 0 ? $with : hxsl__$Checker_WithType.NoValue;
				}
				var et = this.typeExpr(e1,ew);
				if(el1.length != 0 && !hxsl_Tools.hasSideEffect(et)) {
					this.warning("This expression has no side effect",e1.pos);
				}
				tl.push(et);
			}
			this.vars = old;
			type = $with == hxsl__$Checker_WithType.NoValue ? hxsl_Type.TVoid : tl[tl.length - 1].t;
			ed = hxsl_TExprDef.TBlock(tl);
			break;
		case 8:
			var vl = _g.v;
			if($with != hxsl__$Checker_WithType.InBlock) {
				this.error("Cannot declare a variable outside of a block",e.pos);
			}
			if(vl.length != 1) {
				throw haxe_Exception.thrown("assert");
			}
			var v = vl[0];
			if(v.kind == null) {
				v.kind = hxsl_VarKind.Local;
			}
			if(v.kind != hxsl_VarKind.Local) {
				this.error("Should be local var",e.pos);
			}
			if(v.qualifiers.length != 0) {
				this.error("Unexpected qualifier",e.pos);
			}
			var tv = this.makeVar(vl[0],e.pos);
			var init = v.expr == null ? null : this.typeWith(v.expr,tv.type);
			if(tv.type == null) {
				if(init == null) {
					this.error("Type required for unitialized local var",e.pos);
				}
				tv.type = init.t;
			}
			this.vars.h[tv.name] = tv;
			type = hxsl_Type.TVoid;
			ed = hxsl_TExprDef.TVarDecl(tv,init);
			break;
		case 9:
			var _g1 = _g.f;
			throw haxe_Exception.thrown("assert");
		case 10:
			var cond = _g.econd;
			var e1 = _g.eif;
			var e2 = _g.eelse;
			$with = this.propagate($with);
			var cond1 = this.typeWith(cond,hxsl_Type.TBool);
			var e11 = this.typeExpr(e1,$with);
			var e21 = e2 == null ? null : this.typeExpr(e2,$with);
			if($with == hxsl__$Checker_WithType.NoValue) {
				type = hxsl_Type.TVoid;
				ed = hxsl_TExprDef.TIf(cond1,e11,e21);
			} else {
				if(e21 == null) {
					this.error("Missing else",e.pos);
				}
				if(this.tryUnify(e11.t,e21.t)) {
					type = e11.t;
				} else {
					this.unifyExpr(e21,e11.t);
					type = e21.t;
				}
				ed = hxsl_TExprDef.TIf(cond1,e11,e21);
			}
			break;
		case 11:
			type = hxsl_Type.TVoid;
			ed = hxsl_TExprDef.TDiscard;
			break;
		case 12:
			var v = _g.v;
			var it = _g.loop;
			var block = _g.block;
			type = hxsl_Type.TVoid;
			var it1 = this.typeExpr(it,hxsl__$Checker_WithType.Value);
			var _g1 = it1.t;
			if(_g1._hx_index == 15) {
				var _g2 = _g1.size;
				var t = _g1.t;
				var v1 = { id : hxsl_Tools.allocVarId(), name : v, type : t, kind : hxsl_VarKind.Local};
				var old = this.vars.h[v1.name];
				this.vars.h[v1.name] = v1;
				var oldL = this.inLoop;
				this.inLoop = true;
				var block1 = this.typeExpr(block,hxsl__$Checker_WithType.NoValue);
				this.inLoop = oldL;
				if(old == null) {
					var key = v1.name;
					var _this = this.vars;
					if(Object.prototype.hasOwnProperty.call(_this.h,key)) {
						delete(_this.h[key]);
					}
				} else {
					this.vars.h[v1.name] = old;
				}
				ed = hxsl_TExprDef.TFor(v1,it1,block1);
			} else {
				ed = this.error("Cannot iterate on " + hxsl_Tools.toString(it1.t),it1.p);
			}
			break;
		case 13:
			var e1 = _g.e;
			if(e1 == null != (this.curFun.ret == hxsl_Type.TVoid)) {
				this.error("This function should return " + hxsl_Tools.toString(this.curFun.ret),e.pos);
			}
			var e2 = e1 == null ? null : this.typeWith(e1,this.curFun.ret);
			type = hxsl_Type.TVoid;
			ed = hxsl_TExprDef.TReturn(e2);
			break;
		case 14:
			if(!this.inLoop) {
				this.error("Break outside loop",e.pos);
			}
			type = hxsl_Type.TVoid;
			ed = hxsl_TExprDef.TBreak;
			break;
		case 15:
			if(!this.inLoop) {
				this.error("Continue outside loop",e.pos);
			}
			type = hxsl_Type.TVoid;
			ed = hxsl_TExprDef.TContinue;
			break;
		case 16:
			var e1 = _g.e;
			var e2 = _g.eindex;
			var e11 = this.typeExpr(e1,hxsl__$Checker_WithType.Value);
			var e21 = this.typeExpr(e2,hxsl__$Checker_WithType.With(hxsl_Type.TInt));
			this.unify(e21.t,hxsl_Type.TInt,e21.p);
			var _g1 = e11.t;
			switch(_g1._hx_index) {
			case 5:
				var _g2 = _g1.size;
				switch(_g1.t._hx_index) {
				case 0:
					type = hxsl_Type.TInt;
					break;
				case 1:
					type = hxsl_Type.TFloat;
					break;
				default:
					this.error("Cannot index " + hxsl_Tools.toString(e11.t) + " : should be an array",e.pos);
				}
				break;
			case 6:
				type = hxsl_Checker.vec3;
				break;
			case 7:case 8:
				type = hxsl_Checker.vec4;
				break;
			case 12:
				type = hxsl_Checker.vec2;
				break;
			case 15:
				var t = _g1.t;
				var size = _g1.size;
				var _g2 = e21.e;
				if(size._hx_index == 0) {
					if(_g2._hx_index == 0) {
						var _g3 = _g2.c;
						if(_g3._hx_index == 2) {
							var _g4 = _g3.v;
							var i = _g4;
							var v = size.v;
							if(i >= v) {
								this.error("Indexing outside array bounds",e.pos);
							} else {
								var i = _g4;
								if(i < 0) {
									this.error("Cannot index with negative value",e.pos);
								}
							}
						}
					}
				} else if(_g2._hx_index == 0) {
					var _g3 = _g2.c;
					if(_g3._hx_index == 2) {
						var i = _g3.v;
						if(i < 0) {
							this.error("Cannot index with negative value",e.pos);
						}
					}
				}
				type = t;
				break;
			case 16:
				var _g2 = _g1.t;
				var _g3 = _g1.size;
				switch(_g1.kind._hx_index) {
				case 0:case 3:
					var size = _g3;
					var t = _g2;
					var _g1 = e21.e;
					if(size._hx_index == 0) {
						if(_g1._hx_index == 0) {
							var _g4 = _g1.c;
							if(_g4._hx_index == 2) {
								var _g5 = _g4.v;
								var i = _g5;
								var v = size.v;
								if(i >= v) {
									this.error("Indexing outside array bounds",e.pos);
								} else {
									var i = _g5;
									if(i < 0) {
										this.error("Cannot index with negative value",e.pos);
									}
								}
							}
						}
					} else if(_g1._hx_index == 0) {
						var _g4 = _g1.c;
						if(_g4._hx_index == 2) {
							var i = _g4.v;
							if(i < 0) {
								this.error("Cannot index with negative value",e.pos);
							}
						}
					}
					type = t;
					break;
				default:
					var size = _g3;
					var t = _g2;
					type = t;
				}
				break;
			default:
				this.error("Cannot index " + hxsl_Tools.toString(e11.t) + " : should be an array",e.pos);
			}
			ed = hxsl_TExprDef.TArray(e11,e21);
			break;
		case 17:
			var el = _g.el;
			if(el.length == 0) {
				this.error("Empty array not supported",e.pos);
			}
			var _g1 = [];
			var _g2 = 0;
			while(_g2 < el.length) {
				var e1 = el[_g2];
				++_g2;
				_g1.push(this.typeExpr(e1,hxsl__$Checker_WithType.Value));
			}
			var el = _g1;
			var t = el[0].t;
			var _g1 = 1;
			var _g2 = el.length;
			while(_g1 < _g2) {
				var i = _g1++;
				this.unifyExpr(el[i],t);
			}
			type = hxsl_Type.TArray(t,hxsl_SizeDecl.SConst(el.length));
			ed = hxsl_TExprDef.TArrayDecl(el);
			break;
		case 18:
			var e1 = _g.e;
			var cases = _g.cases;
			var def = _g.def;
			var et = this.typeExpr(e1,hxsl__$Checker_WithType.Value);
			var _g1 = [];
			var _g2 = 0;
			while(_g2 < cases.length) {
				var c = cases[_g2];
				++_g2;
				var _g3 = [];
				var _g4 = 0;
				var _g5 = c.values;
				while(_g4 < _g5.length) {
					var v = _g5[_g4];
					++_g4;
					_g3.push(this.typeWith(v,et.t));
				}
				_g1.push({ values : _g3, expr : this.typeExpr(c.expr,$with)});
			}
			var cases = _g1;
			var def1 = def == null ? null : this.typeExpr(def,$with);
			type = hxsl_Type.TVoid;
			ed = hxsl_TExprDef.TSwitch(et,cases,def1);
			break;
		case 19:
			var cond = _g.cond;
			var loop = _g.loop;
			var normalWhile = _g.normalWhile;
			type = hxsl_Type.TVoid;
			var cond1 = this.typeWith(cond,hxsl_Type.TBool);
			var oldL = this.inLoop;
			var oldW = this.inWhile;
			this.inLoop = true;
			this.inWhile = true;
			var loop1 = this.typeExpr(loop,hxsl__$Checker_WithType.NoValue);
			this.inLoop = oldL;
			this.inWhile = oldW;
			ed = hxsl_TExprDef.TWhile(cond1,loop1,normalWhile);
			break;
		case 20:
			var name = _g.name;
			var args3 = _g.args;
			var e1 = _g.e;
			var e2 = this.typeExpr(e1,$with);
			type = e2.t;
			var _g = [];
			var _g1 = 0;
			while(_g1 < args3.length) {
				var c = args3[_g1];
				++_g1;
				var _g2 = c.expr;
				var ed1;
				switch(_g2._hx_index) {
				case 0:
					var c1 = _g2.c;
					ed1 = c1;
					break;
				case 1:
					var i = _g2.i;
					ed1 = hxsl_Const.CString(i);
					break;
				default:
					ed1 = this.error("Metadata parameter should be constant",c.pos);
				}
				_g.push(ed1);
			}
			ed = hxsl_TExprDef.TMeta(name,_g,e2);
			break;
		}
		if(type == null) {
			throw haxe_Exception.thrown("assert");
		}
		return { e : ed, t : type, p : e.pos};
	}
	,propagate: function($with) {
		if($with._hx_index == 2) {
			return hxsl__$Checker_WithType.NoValue;
		} else {
			return $with;
		}
	}
	,checkExpr: function(e,funs,isImport,isExtends) {
		var _gthis = this;
		var _g = e.expr;
		switch(_g._hx_index) {
		case 6:
			var _g1 = _g.e;
			var _g2 = _g.args;
			var _g3 = _g1.expr;
			var _g4 = _g1.pos;
			if(_g3._hx_index == 1) {
				switch(_g3.i) {
				case "extends":
					if(_g2.length == 1) {
						var e1 = _g2[0];
						var path = [];
						var loop = null;
						loop = function(e) {
							var _g = e.expr;
							switch(_g._hx_index) {
							case 0:
								var _g1 = _g.c;
								if(_g1._hx_index == 4) {
									var s = _g1.v;
									path.push(s);
								} else {
									_gthis.error("Should be a shader type path",e.pos);
								}
								break;
							case 1:
								var n = _g.i;
								path.push(n);
								break;
							case 3:
								var e1 = _g.e;
								var f = _g.f;
								loop(e1);
								path.push(f);
								break;
							default:
								_gthis.error("Should be a shader type path",e.pos);
							}
						};
						loop(e1);
						var sexpr = null;
						try {
							sexpr = this.loadShader(path.join("."));
						} catch( _g1 ) {
							var _g3 = haxe_Exception.caught(_g1).unwrap();
							if(((_g3) instanceof hxsl_Error)) {
								var err = _g3;
								this.error(Std.string(err),e1.pos);
							} else {
								throw _g1;
							}
						}
						if(sexpr != null) {
							this.checkExpr(sexpr,funs,isImport,true);
						}
					} else {
						this.error("This expression is not allowed at shader declaration level",e.pos);
					}
					break;
				case "import":
					if(_g2.length == 1) {
						var e1 = _g2[0];
						var path1 = [];
						var loop1 = null;
						loop1 = function(e) {
							var _g = e.expr;
							switch(_g._hx_index) {
							case 1:
								var n = _g.i;
								path1.push(n);
								break;
							case 3:
								var e1 = _g.e;
								var f = _g.f;
								loop1(e1);
								path1.push(f);
								break;
							default:
								_gthis.error("Should be a shader type path",e.pos);
							}
						};
						loop1(e1);
						var sexpr = null;
						try {
							sexpr = this.loadShader(path1.join("."));
						} catch( _g1 ) {
							var _g2 = haxe_Exception.caught(_g1);
							var _g3 = _g2.unwrap();
							if(((_g2) instanceof haxe_macro_Error)) {
								var err = _g2;
								throw err;
							} else {
								var err = _g3;
								this.error(Std.string(err),e1.pos);
							}
						}
						if(sexpr != null) {
							this.checkExpr(sexpr,funs,true,isExtends);
						}
					} else {
						this.error("This expression is not allowed at shader declaration level",e.pos);
					}
					break;
				default:
					this.error("This expression is not allowed at shader declaration level",e.pos);
				}
			} else {
				this.error("This expression is not allowed at shader declaration level",e.pos);
			}
			break;
		case 7:
			var el = _g.el;
			var _g1 = 0;
			while(_g1 < el.length) {
				var e1 = el[_g1];
				++_g1;
				this.checkExpr(e1,funs,isImport,isExtends);
			}
			break;
		case 8:
			var vl = _g.v;
			var _g1 = 0;
			while(_g1 < vl.length) {
				var v = vl[_g1];
				++_g1;
				if(v.kind == null) {
					v.kind = hxsl_VarKind.Local;
					var _g2 = 0;
					var _g3 = v.qualifiers;
					while(_g2 < _g3.length) {
						var q = _g3[_g2];
						++_g2;
						if(q._hx_index == 0) {
							var _g4 = q.max;
							v.kind = hxsl_VarKind.Param;
						}
					}
				}
				var einit = null;
				if(v.expr != null) {
					if(v.kind != hxsl_VarKind.Param && v.kind != hxsl_VarKind.Local) {
						this.error("Cannot initialize variable declaration if not @param or local",v.expr.pos);
					}
					var e1 = this.typeExpr(v.expr,v.type == null ? hxsl__$Checker_WithType.Value : hxsl__$Checker_WithType.With(v.type));
					if(v.type == null) {
						v.type = e1.t;
					} else {
						this.unify(e1.t,v.type,v.expr.pos);
					}
					this.checkConst(e1);
					einit = e1;
				}
				if(v.type == null) {
					this.error("Type required for variable declaration",e.pos);
				}
				if(isImport && v.kind == hxsl_VarKind.Param) {
					continue;
				}
				if(Object.prototype.hasOwnProperty.call(this.vars.h,v.name)) {
					this.error("Duplicate var decl '" + v.name + "'",e.pos);
				}
				var v1 = this.makeVar(v,e.pos);
				var _g5 = v1.type;
				switch(_g5._hx_index) {
				case 10:
					if(_g5.dim._hx_index == 2) {
						if(_g5.isArray == true) {
							this.error("Unsupported texture type",e.pos);
						}
					}
					break;
				case 11:
					var _g6 = _g5.channels;
					if(_g5.dim._hx_index == 2) {
						if(_g5.isArray == true) {
							this.error("Unsupported texture type",e.pos);
						} else if(_g6 == 3) {
							this.error("Unsupported texture type",e.pos);
						}
					} else if(_g6 == 3) {
						this.error("Unsupported texture type",e.pos);
					}
					break;
				default:
				}
				if(einit != null) {
					this.inits.push({ v : v1, e : einit});
				} else if(v1.qualifiers != null && v1.qualifiers.indexOf(hxsl_VarQualifier.Final) >= 0) {
					this.error("Final variable needs initializer",e.pos);
				}
				this.vars.h[v1.name] = v1;
			}
			break;
		case 9:
			var f = _g.f;
			if(isImport && (f.name == "fragment" || f.name == "vertex" || StringTools.startsWith(f.name,"__init__"))) {
				return;
			}
			var _g = 0;
			var _g1 = funs.slice();
			while(_g < _g1.length) {
				var f2 = _g1[_g];
				++_g;
				if(f2.f.name == f.name && f2.inherit) {
					HxOverrides.remove(funs,f2);
				}
			}
			funs.push({ f : f, p : e.pos, inherit : isExtends || isImport});
			break;
		default:
			this.error("This expression is not allowed at shader declaration level",e.pos);
		}
	}
	,checkConst: function(e) {
		var _g = e.e;
		switch(_g._hx_index) {
		case 0:
			var _g1 = _g.c;
			break;
		case 3:
			var e1 = _g.e;
			this.checkConst(e1);
			break;
		case 8:
			var _g1 = _g.e;
			var _g2 = _g.args;
			var _g3 = _g1.e;
			var _g4 = _g1.p;
			var _g4 = _g1.t;
			if(_g3._hx_index == 2) {
				switch(_g3.g._hx_index) {
				case 41:case 42:case 43:case 44:case 45:case 46:
					var args = _g2;
					var _g1 = 0;
					while(_g1 < args.length) {
						var a = args[_g1];
						++_g1;
						this.checkConst(a);
					}
					break;
				default:
					this.error("This expression should be constant",e.p);
				}
			} else {
				this.error("This expression should be constant",e.p);
			}
			break;
		case 17:
			var el = _g.el;
			var _g = 0;
			while(_g < el.length) {
				var e1 = el[_g];
				++_g;
				this.checkConst(e1);
			}
			break;
		default:
			this.error("This expression should be constant",e.p);
		}
	}
	,makeVar: function(v,pos,parent) {
		var tv = { id : hxsl_Tools.allocVarId(), name : v.name, kind : v.kind, type : v.type, qualifiers : v.qualifiers};
		if(parent != null) {
			tv.parent = parent;
		}
		if(tv.kind == null) {
			if(parent == null) {
				tv.kind = hxsl_VarKind.Local;
			} else {
				tv.kind = parent.kind;
			}
		} else if(parent != null && tv.kind != parent.kind) {
			if(parent.kind._hx_index == 0) {
				if(tv.kind._hx_index != 3) {
					this.error("Variable " + Std.string(parent.kind) + " cannot be changed to " + Std.string(tv.kind),pos);
				}
			} else {
				this.error("Variable " + Std.string(parent.kind) + " cannot be changed to " + Std.string(tv.kind),pos);
			}
		}
		if(v.qualifiers.length > 0) {
			tv.qualifiers = v.qualifiers;
			var _g = 0;
			var _g1 = v.qualifiers;
			while(_g < _g1.length) {
				var q = _g1[_g];
				++_g;
				switch(q._hx_index) {
				case 0:
					var _g2 = q.max;
					var p = parent;
					while(p != null) {
						if(!hxsl_Tools.isStruct(p)) {
							this.error("@const only allowed in structure",pos);
						}
						p = p.parent;
					}
					if(tv.kind != hxsl_VarKind.Global && tv.kind != hxsl_VarKind.Param) {
						this.error("@const only allowed on parameter or global",pos);
					}
					break;
				case 1:
					break;
				case 2:
					if(tv.kind != hxsl_VarKind.Param) {
						this.error("@nullable only allowed on parameter or global",pos);
					}
					break;
				case 3:
					if(tv.kind != hxsl_VarKind.Global) {
						this.error("@perObject only allowed on global",pos);
					}
					break;
				case 4:
					var _g3 = q.n;
					if(parent != null) {
						this.error("Cannot have an explicit name for a structure variable",pos);
					}
					if(tv.kind != hxsl_VarKind.Global) {
						this.error("Explicit name is only allowed for global var",pos);
					}
					break;
				case 5:
					if(parent != null) {
						this.error("Cannot share a structure field",pos);
					}
					if(tv.kind != hxsl_VarKind.Param) {
						this.error("Can only share a @param",pos);
					}
					break;
				case 6:
					var _g4 = q.p;
					var _g5 = v.type;
					if(_g5 == null) {
						this.error("Precision qualifier not supported on " + Std.string(v.type),pos);
					} else {
						switch(_g5._hx_index) {
						case 3:
							break;
						case 5:
							var _g6 = _g5.size;
							if(_g5.t._hx_index != 1) {
								this.error("Precision qualifier not supported on " + Std.string(v.type),pos);
							}
							break;
						default:
							this.error("Precision qualifier not supported on " + Std.string(v.type),pos);
						}
					}
					break;
				case 7:
					var min = q.min;
					var max = q.max;
					var _g7 = v.type;
					if(_g7 == null) {
						this.error("Precision qualifier not supported on " + Std.string(v.type),pos);
					} else {
						switch(_g7._hx_index) {
						case 1:case 3:
							break;
						case 5:
							var _g8 = _g7.size;
							if(_g7.t._hx_index != 1) {
								this.error("Precision qualifier not supported on " + Std.string(v.type),pos);
							}
							break;
						default:
							this.error("Precision qualifier not supported on " + Std.string(v.type),pos);
						}
					}
					break;
				case 8:
					break;
				case 9:
					var _g9 = q.v;
					if(tv.kind != hxsl_VarKind.Input && tv.kind != hxsl_VarKind.Param && (tv.kind != hxsl_VarKind.Global || v.qualifiers.indexOf(hxsl_VarQualifier.PerObject) < 0)) {
						this.error("@perInstance only allowed on input/param",pos);
					}
					break;
				case 10:
					var _g10 = q.s;
					break;
				case 11:
					var source = q.source;
					if(v.kind != hxsl_VarKind.Local) {
						this.error("Borrow should not have a type qualifier",pos);
					}
					break;
				case 12:
					var _g11 = q.name;
					var _g12 = v.type;
					if(_g12 == null) {
						this.error("Sampler should be on sampler type or sampler array",pos);
					} else {
						switch(_g12._hx_index) {
						case 10:
							var _g13 = _g12.dim;
							var _g14 = _g12.isArray;
							break;
						case 15:
							var _g15 = _g12.t;
							var _g16 = _g12.size;
							if(_g15._hx_index == 10) {
								var _g17 = _g15.dim;
								var _g18 = _g15.isArray;
							} else {
								this.error("Sampler should be on sampler type or sampler array",pos);
							}
							break;
						default:
							this.error("Sampler should be on sampler type or sampler array",pos);
						}
					}
					break;
				case 13:
					if(tv.kind != hxsl_VarKind.Local) {
						this.error("final only allowed on local",pos);
					}
					break;
				case 14:
					if(tv.kind != hxsl_VarKind.Local) {
						this.error("flat only allowed on local",pos);
					}
					break;
				}
			}
		}
		if(tv.type != null) {
			tv.type = this.makeVarType(tv.type,tv,pos);
		}
		return tv;
	}
	,makeVarType: function(vt,parent,pos) {
		switch(vt._hx_index) {
		case 13:
			var vl = vt.vl;
			var vl1 = vl.slice();
			parent.type = hxsl_Type.TStruct(vl1);
			var _g = 0;
			var _g1 = vl1.length;
			while(_g < _g1) {
				var i = _g++;
				var v = vl1[i];
				vl1[i] = this.makeVar({ type : v.type, qualifiers : v.qualifiers, name : v.name, kind : v.kind, expr : null},pos,parent);
			}
			return parent.type;
		case 15:
			var t = vt.t;
			var size = vt.size;
			if(t._hx_index == 15) {
				var _g = t.t;
				var _g = t.size;
				this.error("Multidimentional arrays are not allowed",pos);
			}
			var s;
			switch(size._hx_index) {
			case 0:
				var _g = size.v;
				s = size;
				break;
			case 1:
				var v = size.v;
				var path = v.name.split(".");
				var v2 = null;
				var _g = 0;
				while(_g < path.length) {
					var n = path[_g];
					++_g;
					if(v2 == null) {
						v2 = this.vars.h[n];
						if(v2 == null && parent != null) {
							var p = parent;
							while(p.parent != null) p = p.parent;
							if(p.name == n) {
								v2 = p;
							}
						}
					} else {
						var _g1 = v2.type;
						if(_g1._hx_index == 13) {
							var vl = _g1.vl;
							var f = null;
							var _g2 = 0;
							while(_g2 < vl.length) {
								var v1 = vl[_g2];
								++_g2;
								if(v1.name == n) {
									f = v1;
									break;
								}
							}
							v2 = f;
						} else {
							v2 = null;
						}
					}
					if(v2 == null) {
						break;
					}
				}
				if(v2 == null) {
					this.error("Array size variable '" + v.name + "'not found",pos);
				}
				if(!hxsl_Tools.isConst(v2)) {
					this.error("Array size variable '" + v.name + "'should be a constant",pos);
				}
				s = hxsl_SizeDecl.SVar(v2);
				break;
			}
			t = this.makeVarType(t,parent,pos);
			switch(vt._hx_index) {
			case 15:
				var _g = vt.t;
				var _g = vt.size;
				return hxsl_Type.TArray(t,s);
			case 16:
				var _g = vt.t;
				var _g = vt.size;
				var kind = vt.kind;
				return hxsl_Type.TBuffer(t,s,kind);
			default:
				throw haxe_Exception.thrown("assert");
			}
			break;
		case 16:
			var _g = vt.kind;
			var t = vt.t;
			var size = vt.size;
			if(t._hx_index == 15) {
				var _g = t.t;
				var _g = t.size;
				this.error("Multidimentional arrays are not allowed",pos);
			}
			var s;
			switch(size._hx_index) {
			case 0:
				var _g = size.v;
				s = size;
				break;
			case 1:
				var v = size.v;
				var path = v.name.split(".");
				var v2 = null;
				var _g = 0;
				while(_g < path.length) {
					var n = path[_g];
					++_g;
					if(v2 == null) {
						v2 = this.vars.h[n];
						if(v2 == null && parent != null) {
							var p = parent;
							while(p.parent != null) p = p.parent;
							if(p.name == n) {
								v2 = p;
							}
						}
					} else {
						var _g1 = v2.type;
						if(_g1._hx_index == 13) {
							var vl = _g1.vl;
							var f = null;
							var _g2 = 0;
							while(_g2 < vl.length) {
								var v1 = vl[_g2];
								++_g2;
								if(v1.name == n) {
									f = v1;
									break;
								}
							}
							v2 = f;
						} else {
							v2 = null;
						}
					}
					if(v2 == null) {
						break;
					}
				}
				if(v2 == null) {
					this.error("Array size variable '" + v.name + "'not found",pos);
				}
				if(!hxsl_Tools.isConst(v2)) {
					this.error("Array size variable '" + v.name + "'should be a constant",pos);
				}
				s = hxsl_SizeDecl.SVar(v2);
				break;
			}
			t = this.makeVarType(t,parent,pos);
			switch(vt._hx_index) {
			case 15:
				var _g = vt.t;
				var _g = vt.size;
				return hxsl_Type.TArray(t,s);
			case 16:
				var _g = vt.t;
				var _g = vt.size;
				var kind = vt.kind;
				return hxsl_Type.TBuffer(t,s,kind);
			default:
				throw haxe_Exception.thrown("assert");
			}
			break;
		default:
			return vt;
		}
	}
	,isParentArray: function(v) {
		if(v.parent == null) {
			return false;
		}
		var _g = v.parent.type;
		switch(_g._hx_index) {
		case 13:
			var _g1 = _g.vl;
			return this.isParentArray(v.parent);
		case 15:
			var _g1 = _g.t;
			var _g1 = _g.size;
			return true;
		case 16:
			var _g1 = _g.t;
			var _g1 = _g.size;
			var _g1 = _g.kind;
			return true;
		default:
			return false;
		}
	}
	,fieldAccess: function(e,f,$with,pos) {
		var ef;
		var _g = e.t;
		if(_g._hx_index == 13) {
			var vl = _g.vl;
			var found = null;
			var _g = 0;
			while(_g < vl.length) {
				var v = vl[_g];
				++_g;
				if(v.name == f) {
					found = v;
					break;
				}
			}
			ef = found == null ? null : this.isParentArray(found) ? { e : hxsl_TExprDef.TField(e,f), t : found.type, p : pos} : { e : hxsl_TExprDef.TVar(found), t : found.type, p : pos};
		} else {
			ef = null;
		}
		if(ef != null) {
			return hxsl__$Checker_FieldAccess.FField(ef);
		}
		var g = this.globals.h[f];
		if(g == null) {
			var gl;
			var _g = e.t;
			switch(f) {
			case "fetch":
				switch(_g._hx_index) {
				case 10:
					var _g1 = _g.dim;
					var _g1 = _g.isArray;
					gl = hxsl_TGlobal.Texel;
					break;
				case 17:
					var _g1 = _g.size;
					gl = hxsl_TGlobal.ChannelFetch;
					break;
				default:
					gl = null;
				}
				break;
			case "fetchLod":
				switch(_g._hx_index) {
				case 10:
					var _g1 = _g.dim;
					var _g1 = _g.isArray;
					gl = hxsl_TGlobal.Texel;
					break;
				case 17:
					var _g1 = _g.size;
					gl = hxsl_TGlobal.ChannelFetch;
					break;
				default:
					gl = null;
				}
				break;
			case "get":
				switch(_g._hx_index) {
				case 10:
					var _g1 = _g.dim;
					var _g1 = _g.isArray;
					gl = hxsl_TGlobal.Texture;
					break;
				case 17:
					var _g1 = _g.size;
					gl = hxsl_TGlobal.ChannelRead;
					break;
				default:
					gl = null;
				}
				break;
			case "getLod":
				switch(_g._hx_index) {
				case 10:
					var _g1 = _g.dim;
					var _g1 = _g.isArray;
					gl = hxsl_TGlobal.TextureLod;
					break;
				case 17:
					var _g1 = _g.size;
					gl = hxsl_TGlobal.ChannelReadLod;
					break;
				default:
					gl = null;
				}
				break;
			case "size":
				switch(_g._hx_index) {
				case 10:
					var _g1 = _g.dim;
					var _g1 = _g.isArray;
					gl = hxsl_TGlobal.TextureSize;
					break;
				case 11:
					var _g1 = _g.dim;
					var _g1 = _g.isArray;
					var _g1 = _g.channels;
					gl = hxsl_TGlobal.TextureSize;
					break;
				case 17:
					var _g1 = _g.size;
					gl = hxsl_TGlobal.ChannelTextureSize;
					break;
				default:
					gl = null;
				}
				break;
			case "store":
				if(_g._hx_index == 11) {
					var _g1 = _g.dim;
					var _g1 = _g.isArray;
					var _g1 = _g.channels;
					gl = hxsl_TGlobal.ImageStore;
				} else {
					gl = null;
				}
				break;
			default:
				gl = null;
			}
			if(gl != null) {
				if(f == "get" && this.inWhile) {
					this.error("Cannot use .get() in while loop, use .getLod instead",pos);
				}
				var this1 = this.globals;
				var key = hxsl_Tools2.toString(gl);
				g = this1.h[key];
			}
		}
		if(g != null) {
			var _g = g.t;
			if(_g._hx_index == 14) {
				var variants = _g.variants;
				var sel = [];
				var _g = 0;
				while(_g < variants.length) {
					var v = variants[_g];
					++_g;
					if(v.args.length == 0 || !this.tryUnify(e.t,v.args[0].type)) {
						continue;
					}
					var args = v.args.slice();
					args.shift();
					sel.push({ args : args, ret : v.ret});
				}
				if(sel.length > 0 || variants.length == 0) {
					return hxsl__$Checker_FieldAccess.FGlobal(g.g,e,sel);
				}
			}
			var _g = e.t;
			if(g.g._hx_index == 28) {
				if(_g._hx_index == 15) {
					var _g1 = _g.t;
					var _g1 = _g.size;
					return hxsl__$Checker_FieldAccess.FField({ e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Length), t : hxsl_Type.TVoid, p : pos},[e]), t : hxsl_Type.TInt, p : pos});
				}
			}
		}
		var stype;
		var ncomps;
		var _g = e.t;
		switch(_g._hx_index) {
		case 1:
			stype = hxsl_VecType.VInt;
			ncomps = 1;
			break;
		case 2:
			stype = hxsl_VecType.VBool;
			ncomps = 1;
			break;
		case 3:
			stype = hxsl_VecType.VFloat;
			ncomps = 1;
			break;
		case 5:
			var size = _g.size;
			var t = _g.t;
			stype = t;
			ncomps = size;
			break;
		case 9:
			var size = _g.size;
			stype = hxsl_VecType.VFloat;
			ncomps = size;
			break;
		default:
			stype = null;
			ncomps = 0;
		}
		if(ncomps > 0 && f.length <= 4) {
			var str = "xrsygtzbpwaq";
			var comps = [hxsl_Component.X,hxsl_Component.Y,hxsl_Component.Z,hxsl_Component.W];
			var cat = -1;
			var out = [];
			var _g = 0;
			var _g1 = f.length;
			while(_g < _g1) {
				var i = _g++;
				var idx = str.indexOf(f.charAt(i));
				if(idx < 0) {
					return null;
				}
				var icat = idx % 3;
				if(cat < 0) {
					cat = icat;
				} else if(icat != cat) {
					return null;
				}
				var cid = idx / 3 | 0;
				if(cid >= ncomps) {
					this.error(hxsl_Tools.toString(e.t) + " does not have component " + f.charAt(i),pos);
				}
				out.push(comps[cid]);
			}
			return hxsl__$Checker_FieldAccess.FField({ e : hxsl_TExprDef.TSwiz(e,out), t : out.length == 1 ? hxsl_Tools.toType(stype) : hxsl_Type.TVec(out.length,stype), p : pos});
		}
		return null;
	}
	,getSizeType: function(size,vtype) {
		switch(size) {
		case 1:
			if(vtype == hxsl_VecType.VInt) {
				return hxsl_Type.TInt;
			} else {
				return hxsl_Type.TFloat;
			}
			break;
		case 2:
			if(vtype == hxsl_VecType.VInt) {
				return hxsl_Checker.ivec2;
			} else {
				return hxsl_Checker.vec2;
			}
			break;
		case 3:
			if(vtype == hxsl_VecType.VInt) {
				return hxsl_Checker.ivec3;
			} else {
				return hxsl_Checker.vec3;
			}
			break;
		case 4:
			if(vtype == hxsl_VecType.VInt) {
				return hxsl_Checker.ivec4;
			} else {
				return hxsl_Checker.vec4;
			}
			break;
		default:
			throw haxe_Exception.thrown("assert");
		}
	}
	,specialGlobal: function(g,e,args,pos) {
		var _gthis = this;
		var type = null;
		switch(g._hx_index) {
		case 37:
			if(args.length != 1) {
				this.error("TextureSize() requires one single argument",pos);
			}
			var _g = args[0].t;
			switch(_g._hx_index) {
			case 10:
				var dim = _g.dim;
				var arr = _g.isArray;
				type = this.getSizeType(hxsl_Tools.getDimSize(dim,arr),hxsl_VecType.VFloat);
				break;
			case 11:
				var _g1 = _g.channels;
				var dim = _g.dim;
				var arr = _g.isArray;
				type = this.getSizeType(hxsl_Tools.getDimSize(dim,arr),hxsl_VecType.VFloat);
				break;
			default:
				this.unify(args[0].t,hxsl_Type.TSampler(hxsl_TexDimension.T2D,false),args[0].p);
				type = hxsl_Checker.vec2;
			}
			break;
		case 41:
			var t = hxsl_Type.TFloat;
			var skip = false;
			if(args.length == 1 && (t == hxsl_Type.TInt || t == hxsl_Type.TFloat)) {
				var _g = args[0].t;
				if(_g._hx_index == 5) {
					var n2 = _g.size;
					var t2 = _g.t;
					if((t2 == hxsl_VecType.VInt || t2 == hxsl_VecType.VFloat) && n2 == 2) {
						skip = true;
					}
				}
			}
			if(!skip) {
				var tsize = 0;
				var _g = 0;
				while(_g < args.length) {
					var a = args[_g];
					++_g;
					var _g1 = a.t;
					if(_g1._hx_index == 5) {
						var size = _g1.size;
						var k = _g1.t;
						if(hxsl_Tools.toType(k) != t) {
							_gthis.unify(a.t,t,a.p);
						}
						tsize += size;
					} else {
						_gthis.unifyExpr(a,t);
						++tsize;
					}
				}
				if(tsize != 2 && tsize > 1) {
					_gthis.error(hxsl_Tools2.toString(g) + " requires " + 2 + " " + hxsl_Tools.toString(t) + " values but has " + tsize,pos);
				}
			}
			type = hxsl_Type.TVec(2,hxsl_VecType.VFloat);
			break;
		case 42:
			var t = hxsl_Type.TFloat;
			var skip = false;
			if(args.length == 1 && (t == hxsl_Type.TInt || t == hxsl_Type.TFloat)) {
				var _g = args[0].t;
				if(_g._hx_index == 5) {
					var n2 = _g.size;
					var t2 = _g.t;
					if((t2 == hxsl_VecType.VInt || t2 == hxsl_VecType.VFloat) && n2 == 3) {
						skip = true;
					}
				}
			}
			if(!skip) {
				var tsize = 0;
				var _g = 0;
				while(_g < args.length) {
					var a = args[_g];
					++_g;
					var _g1 = a.t;
					if(_g1._hx_index == 5) {
						var size = _g1.size;
						var k = _g1.t;
						if(hxsl_Tools.toType(k) != t) {
							_gthis.unify(a.t,t,a.p);
						}
						tsize += size;
					} else {
						_gthis.unifyExpr(a,t);
						++tsize;
					}
				}
				if(tsize != 3 && tsize > 1) {
					_gthis.error(hxsl_Tools2.toString(g) + " requires " + 3 + " " + hxsl_Tools.toString(t) + " values but has " + tsize,pos);
				}
			}
			type = hxsl_Type.TVec(3,hxsl_VecType.VFloat);
			break;
		case 43:
			var t = hxsl_Type.TFloat;
			var skip = false;
			if(args.length == 1 && (t == hxsl_Type.TInt || t == hxsl_Type.TFloat)) {
				var _g = args[0].t;
				if(_g._hx_index == 5) {
					var n2 = _g.size;
					var t2 = _g.t;
					if((t2 == hxsl_VecType.VInt || t2 == hxsl_VecType.VFloat) && n2 == 4) {
						skip = true;
					}
				}
			}
			if(!skip) {
				var tsize = 0;
				var _g = 0;
				while(_g < args.length) {
					var a = args[_g];
					++_g;
					var _g1 = a.t;
					if(_g1._hx_index == 5) {
						var size = _g1.size;
						var k = _g1.t;
						if(hxsl_Tools.toType(k) != t) {
							_gthis.unify(a.t,t,a.p);
						}
						tsize += size;
					} else {
						_gthis.unifyExpr(a,t);
						++tsize;
					}
				}
				if(tsize != 4 && tsize > 1) {
					_gthis.error(hxsl_Tools2.toString(g) + " requires " + 4 + " " + hxsl_Tools.toString(t) + " values but has " + tsize,pos);
				}
			}
			type = hxsl_Type.TVec(4,hxsl_VecType.VFloat);
			break;
		case 44:case 45:case 46:
			var k;
			switch(g._hx_index) {
			case 44:
				k = 2;
				break;
			case 45:
				k = 3;
				break;
			case 46:
				k = 4;
				break;
			default:
				throw haxe_Exception.thrown("assert");
			}
			if(args.length == 1) {
				switch(args[0].t._hx_index) {
				case 1:case 3:
					break;
				default:
					var t = hxsl_Type.TInt;
					var skip = false;
					if(args.length == 1 && (t == hxsl_Type.TInt || t == hxsl_Type.TFloat)) {
						var _g = args[0].t;
						if(_g._hx_index == 5) {
							var n2 = _g.size;
							var t2 = _g.t;
							if((t2 == hxsl_VecType.VInt || t2 == hxsl_VecType.VFloat) && n2 == k) {
								skip = true;
							}
						}
					}
					if(!skip) {
						var tsize = 0;
						var _g = 0;
						while(_g < args.length) {
							var a = args[_g];
							++_g;
							var _g1 = a.t;
							if(_g1._hx_index == 5) {
								var size = _g1.size;
								var k1 = _g1.t;
								if(hxsl_Tools.toType(k1) != t) {
									_gthis.unify(a.t,t,a.p);
								}
								tsize += size;
							} else {
								_gthis.unifyExpr(a,t);
								++tsize;
							}
						}
						if(tsize != k && tsize > 1) {
							_gthis.error(hxsl_Tools2.toString(g) + " requires " + k + " " + hxsl_Tools.toString(t) + " values but has " + tsize,pos);
						}
					}
				}
			} else {
				var t = hxsl_Type.TInt;
				var skip = false;
				if(args.length == 1 && (t == hxsl_Type.TInt || t == hxsl_Type.TFloat)) {
					var _g = args[0].t;
					if(_g._hx_index == 5) {
						var n2 = _g.size;
						var t2 = _g.t;
						if((t2 == hxsl_VecType.VInt || t2 == hxsl_VecType.VFloat) && n2 == k) {
							skip = true;
						}
					}
				}
				if(!skip) {
					var tsize = 0;
					var _g = 0;
					while(_g < args.length) {
						var a = args[_g];
						++_g;
						var _g1 = a.t;
						if(_g1._hx_index == 5) {
							var size = _g1.size;
							var k1 = _g1.t;
							if(hxsl_Tools.toType(k1) != t) {
								_gthis.unify(a.t,t,a.p);
							}
							tsize += size;
						} else {
							_gthis.unifyExpr(a,t);
							++tsize;
						}
					}
					if(tsize != k && tsize > 1) {
						_gthis.error(hxsl_Tools2.toString(g) + " requires " + k + " " + hxsl_Tools.toString(t) + " values but has " + tsize,pos);
					}
				}
			}
			type = hxsl_Type.TVec(k,hxsl_VecType.VInt);
			break;
		case 47:
			var t = hxsl_Type.TBool;
			var skip = false;
			if(args.length == 1 && (t == hxsl_Type.TInt || t == hxsl_Type.TFloat)) {
				var _g = args[0].t;
				if(_g._hx_index == 5) {
					var n2 = _g.size;
					var t2 = _g.t;
					if((t2 == hxsl_VecType.VInt || t2 == hxsl_VecType.VFloat) && n2 == 2) {
						skip = true;
					}
				}
			}
			if(!skip) {
				var tsize = 0;
				var _g = 0;
				while(_g < args.length) {
					var a = args[_g];
					++_g;
					var _g1 = a.t;
					if(_g1._hx_index == 5) {
						var size = _g1.size;
						var k = _g1.t;
						if(hxsl_Tools.toType(k) != t) {
							_gthis.unify(a.t,t,a.p);
						}
						tsize += size;
					} else {
						_gthis.unifyExpr(a,t);
						++tsize;
					}
				}
				if(tsize != 2 && tsize > 1) {
					_gthis.error(hxsl_Tools2.toString(g) + " requires " + 2 + " " + hxsl_Tools.toString(t) + " values but has " + tsize,pos);
				}
			}
			type = hxsl_Type.TVec(2,hxsl_VecType.VBool);
			break;
		case 48:
			var t = hxsl_Type.TBool;
			var skip = false;
			if(args.length == 1 && (t == hxsl_Type.TInt || t == hxsl_Type.TFloat)) {
				var _g = args[0].t;
				if(_g._hx_index == 5) {
					var n2 = _g.size;
					var t2 = _g.t;
					if((t2 == hxsl_VecType.VInt || t2 == hxsl_VecType.VFloat) && n2 == 3) {
						skip = true;
					}
				}
			}
			if(!skip) {
				var tsize = 0;
				var _g = 0;
				while(_g < args.length) {
					var a = args[_g];
					++_g;
					var _g1 = a.t;
					if(_g1._hx_index == 5) {
						var size = _g1.size;
						var k = _g1.t;
						if(hxsl_Tools.toType(k) != t) {
							_gthis.unify(a.t,t,a.p);
						}
						tsize += size;
					} else {
						_gthis.unifyExpr(a,t);
						++tsize;
					}
				}
				if(tsize != 3 && tsize > 1) {
					_gthis.error(hxsl_Tools2.toString(g) + " requires " + 3 + " " + hxsl_Tools.toString(t) + " values but has " + tsize,pos);
				}
			}
			type = hxsl_Type.TVec(3,hxsl_VecType.VBool);
			break;
		case 49:
			var t = hxsl_Type.TBool;
			var skip = false;
			if(args.length == 1 && (t == hxsl_Type.TInt || t == hxsl_Type.TFloat)) {
				var _g = args[0].t;
				if(_g._hx_index == 5) {
					var n2 = _g.size;
					var t2 = _g.t;
					if((t2 == hxsl_VecType.VInt || t2 == hxsl_VecType.VFloat) && n2 == 4) {
						skip = true;
					}
				}
			}
			if(!skip) {
				var tsize = 0;
				var _g = 0;
				while(_g < args.length) {
					var a = args[_g];
					++_g;
					var _g1 = a.t;
					if(_g1._hx_index == 5) {
						var size = _g1.size;
						var k = _g1.t;
						if(hxsl_Tools.toType(k) != t) {
							_gthis.unify(a.t,t,a.p);
						}
						tsize += size;
					} else {
						_gthis.unifyExpr(a,t);
						++tsize;
					}
				}
				if(tsize != 4 && tsize > 1) {
					_gthis.error(hxsl_Tools2.toString(g) + " requires " + 4 + " " + hxsl_Tools.toString(t) + " values but has " + tsize,pos);
				}
			}
			type = hxsl_Type.TVec(4,hxsl_VecType.VBool);
			break;
		case 50:
			var _g = [];
			var _g1 = 0;
			while(_g1 < args.length) {
				var a = args[_g1];
				++_g1;
				_g.push(a.t);
			}
			var _g1 = _g;
			switch(_g1.length) {
			case 1:
				if(_g1[0]._hx_index == 12) {
					type = hxsl_Type.TMat2;
				} else {
					this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
				}
				break;
			case 2:
				var _g = _g1[0];
				var _g2 = _g1[1];
				if(_g._hx_index == 5) {
					if(_g.size == 2) {
						if(_g.t._hx_index == 1) {
							if(_g2._hx_index == 5) {
								if(_g2.size == 2) {
									if(_g2.t._hx_index == 1) {
										type = hxsl_Type.TMat2;
									} else {
										this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
									}
								} else {
									this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
								}
							} else {
								this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
							}
						} else {
							this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
						}
					} else {
						this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
					}
				} else {
					this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
				}
				break;
			case 4:
				if(_g1[0]._hx_index == 3) {
					if(_g1[1]._hx_index == 3) {
						if(_g1[2]._hx_index == 3) {
							if(_g1[3]._hx_index == 3) {
								type = hxsl_Type.TMat2;
							} else {
								this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
							}
						} else {
							this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
						}
					} else {
						this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
					}
				} else {
					this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
				}
				break;
			default:
				this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
			}
			break;
		case 51:
			var _g = [];
			var _g1 = 0;
			while(_g1 < args.length) {
				var a = args[_g1];
				++_g1;
				_g.push(a.t);
			}
			var _g1 = _g;
			switch(_g1.length) {
			case 1:
				switch(_g1[0]._hx_index) {
				case 7:case 8:
					type = hxsl_Type.TMat3;
					break;
				default:
					this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
				}
				break;
			case 3:
				var _g = _g1[0];
				var _g2 = _g1[1];
				var _g3 = _g1[2];
				if(_g._hx_index == 5) {
					if(_g.size == 3) {
						if(_g.t._hx_index == 1) {
							if(_g2._hx_index == 5) {
								if(_g2.size == 3) {
									if(_g2.t._hx_index == 1) {
										if(_g3._hx_index == 5) {
											if(_g3.size == 3) {
												if(_g3.t._hx_index == 1) {
													type = hxsl_Type.TMat3;
												} else {
													this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
												}
											} else {
												this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
											}
										} else {
											this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
										}
									} else {
										this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
									}
								} else {
									this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
								}
							} else {
								this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
							}
						} else {
							this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
						}
					} else {
						this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
					}
				} else {
					this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
				}
				break;
			case 9:
				if(_g1[0]._hx_index == 3) {
					if(_g1[1]._hx_index == 3) {
						if(_g1[2]._hx_index == 3) {
							if(_g1[3]._hx_index == 3) {
								if(_g1[4]._hx_index == 3) {
									if(_g1[5]._hx_index == 3) {
										if(_g1[6]._hx_index == 3) {
											if(_g1[7]._hx_index == 3) {
												if(_g1[8]._hx_index == 3) {
													type = hxsl_Type.TMat3;
												} else {
													this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
												}
											} else {
												this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
											}
										} else {
											this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
										}
									} else {
										this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
									}
								} else {
									this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
								}
							} else {
								this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
							}
						} else {
							this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
						}
					} else {
						this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
					}
				} else {
					this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
				}
				break;
			default:
				this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
			}
			break;
		case 52:
			var _g = [];
			var _g1 = 0;
			while(_g1 < args.length) {
				var a = args[_g1];
				++_g1;
				_g.push(a.t);
			}
			var _g1 = _g;
			switch(_g1.length) {
			case 1:
				if(_g1[0]._hx_index == 7) {
					type = hxsl_Type.TMat4;
				} else {
					this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
				}
				break;
			case 4:
				var _g = _g1[0];
				var _g2 = _g1[1];
				var _g3 = _g1[2];
				var _g4 = _g1[3];
				if(_g._hx_index == 5) {
					if(_g.size == 4) {
						if(_g.t._hx_index == 1) {
							if(_g2._hx_index == 5) {
								if(_g2.size == 4) {
									if(_g2.t._hx_index == 1) {
										if(_g3._hx_index == 5) {
											if(_g3.size == 4) {
												if(_g3.t._hx_index == 1) {
													if(_g4._hx_index == 5) {
														if(_g4.size == 4) {
															if(_g4.t._hx_index == 1) {
																type = hxsl_Type.TMat4;
															} else {
																this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
															}
														} else {
															this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
														}
													} else {
														this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
													}
												} else {
													this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
												}
											} else {
												this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
											}
										} else {
											this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
										}
									} else {
										this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
									}
								} else {
									this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
								}
							} else {
								this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
							}
						} else {
							this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
						}
					} else {
						this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
					}
				} else {
					this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
				}
				break;
			default:
				this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
			}
			break;
		case 53:
			var _g = [];
			var _g1 = 0;
			while(_g1 < args.length) {
				var a = args[_g1];
				++_g1;
				_g.push(a.t);
			}
			var _g1 = _g;
			switch(_g1.length) {
			case 1:
				if(_g1[0]._hx_index == 7) {
					type = hxsl_Type.TMat3x4;
				} else {
					this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
				}
				break;
			case 3:
				var _g = _g1[0];
				var _g2 = _g1[1];
				var _g3 = _g1[2];
				if(_g._hx_index == 5) {
					if(_g.size == 4) {
						if(_g.t._hx_index == 1) {
							if(_g2._hx_index == 5) {
								if(_g2.size == 4) {
									if(_g2.t._hx_index == 1) {
										if(_g3._hx_index == 5) {
											if(_g3.size == 4) {
												if(_g3.t._hx_index == 1) {
													type = hxsl_Type.TMat3x4;
												} else {
													this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
												}
											} else {
												this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
											}
										} else {
											this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
										}
									} else {
										this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
									}
								} else {
									this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
								}
							} else {
								this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
							}
						} else {
							this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
						}
					} else {
						this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
					}
				} else {
					this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
				}
				break;
			default:
				this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
			}
			break;
		case 68:
			type = hxsl_Type.TVoid;
			break;
		case 79:
			var _g = [];
			var _g1 = 0;
			while(_g1 < args.length) {
				var a = args[_g1];
				++_g1;
				_g.push(a.t);
			}
			var _g1 = _g;
			if(_g1.length == 3) {
				var _g = _g1[0];
				if(_g._hx_index == 11) {
					var dim = _g.dim;
					var arr = _g.isArray;
					var chans = _g.channels;
					var uv = _g1[1];
					var color = _g1[2];
					var szt = this.getSizeType(hxsl_Tools.getDimSize(dim,arr),hxsl_VecType.VInt);
					this.unify(uv,szt,args[1].p);
					this.unify(color,chans == 1 ? hxsl_Type.TFloat : hxsl_Type.TVec(chans,hxsl_VecType.VFloat),args[2].p);
					type = hxsl_Type.TVoid;
				} else {
					this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
				}
			} else {
				this.error("Cannot apply " + hxsl_Tools2.toString(g) + " to these parameters",pos);
			}
			break;
		default:
		}
		if(type == null) {
			throw haxe_Exception.thrown("Custom Global not supported " + Std.string(g));
		}
		return { e : hxsl_TExprDef.TCall(e,args), t : type, p : pos};
	}
	,unifyCallParams: function(efun,args,variants,pos) {
		var minArgs = 1000;
		var maxArgs = -1000;
		var sel = [];
		var _g = 0;
		while(_g < variants.length) {
			var v = variants[_g];
			++_g;
			var n = v.args.length;
			if(n < minArgs) {
				minArgs = n;
			}
			if(n > maxArgs) {
				maxArgs = n;
			}
			if(n == args.length) {
				sel.push(v);
			}
		}
		switch(sel.length) {
		case 0:
			if(variants.length == 0) {
				var _g = efun.e;
				if(_g._hx_index == 2) {
					var g = _g.g;
					var _g = [];
					var _g1 = 0;
					while(_g1 < args.length) {
						var a = args[_g1];
						++_g1;
						_g.push(this.typeExpr(a,hxsl__$Checker_WithType.Value));
					}
					return this.specialGlobal(g,efun,_g,pos);
				} else {
					throw haxe_Exception.thrown("assert");
				}
			} else {
				return this.error("Function expects " + (minArgs == maxArgs ? "" + minArgs : minArgs + "-" + maxArgs) + " arguments",pos);
			}
			break;
		case 1:
			var f = sel[0];
			var targs = [];
			var _g = 0;
			var _g1 = args.length;
			while(_g < _g1) {
				var i = _g++;
				var ft = f.args[i].type;
				var a = this.typeExpr(args[i],hxsl__$Checker_WithType.With(ft));
				try {
					this.unifyExpr(a,ft);
				} catch( _g2 ) {
					var _g3 = haxe_Exception.caught(_g2).unwrap();
					if(((_g3) instanceof hxsl_Error)) {
						var e = _g3;
						e.msg += " for argument '" + f.args[i].name + "'";
						throw haxe_Exception.thrown(e);
					} else {
						throw _g2;
					}
				}
				targs.push(a);
			}
			if(variants.length > 1) {
				efun.t = hxsl_Type.TFun([f]);
			}
			return { e : hxsl_TExprDef.TCall(efun,targs), t : f.ret, p : pos};
		default:
			var bestMatch = null;
			var mcount = -1;
			var _g = 0;
			while(_g < sel.length) {
				var f = sel[_g];
				++_g;
				var outArgs = [];
				var _g1 = 0;
				var _g2 = args.length;
				while(_g1 < _g2) {
					var i = _g1++;
					var a = this.typeExpr(args[i],hxsl__$Checker_WithType.With(f.args[i].type));
					if(!this.tryUnify(a.t,f.args[i].type)) {
						break;
					}
					outArgs.push(a);
				}
				if(outArgs.length > mcount) {
					bestMatch = f;
					mcount = outArgs.length;
					if(mcount == args.length) {
						efun.t = hxsl_Type.TFun([f]);
						return { e : hxsl_TExprDef.TCall(efun,outArgs), t : f.ret, p : pos};
					}
				}
			}
			var _g = 0;
			var _g1 = args.length;
			while(_g < _g1) {
				var i = _g++;
				try {
					var e = this.typeExpr(args[i],hxsl__$Checker_WithType.Value);
					this.unify(e.t,bestMatch.args[i].type,e.p);
				} catch( _g2 ) {
					var _g3 = haxe_Exception.caught(_g2).unwrap();
					if(((_g3) instanceof hxsl_Error)) {
						var e1 = _g3;
						e1.msg += " for argument '" + bestMatch.args[i].name + "'";
						throw haxe_Exception.thrown(e1);
					} else {
						throw _g2;
					}
				}
			}
			throw haxe_Exception.thrown("assert");
		}
	}
	,toFloat: function(e) {
		if(e.t != hxsl_Type.TInt) {
			throw haxe_Exception.thrown("assert");
		}
		var _g = e.e;
		if(_g._hx_index == 0) {
			var _g1 = _g.c;
			if(_g1._hx_index == 2) {
				var v = _g1.v;
				e.e = hxsl_TExprDef.TConst(hxsl_Const.CFloat(v));
				e.t = hxsl_Type.TFloat;
			} else {
				e.e = hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.ToFloat), t : hxsl_Type.TFun([]), p : e.p},[{ e : e.e, t : e.t, p : e.p}]);
				e.t = hxsl_Type.TFloat;
			}
		} else {
			e.e = hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.ToFloat), t : hxsl_Type.TFun([]), p : e.p},[{ e : e.e, t : e.t, p : e.p}]);
			e.t = hxsl_Type.TFloat;
		}
	}
	,typeBinop: function(op,e1,e2,pos) {
		switch(op._hx_index) {
		case 4:
			throw haxe_Exception.thrown("assert");
		case 5:case 6:case 7:case 8:case 9:case 10:
			var _g = e1.t;
			switch(_g._hx_index) {
			case 2:
				if((op == haxe_macro_Binop.OpEq || op == haxe_macro_Binop.OpNotEq) && e2.t != hxsl_Type.TVoid) {
					this.unifyExpr(e2,e1.t);
					return hxsl_Type.TBool;
				} else {
					var _g1 = e1.e;
					var _g2 = e2.e;
					switch(_g1._hx_index) {
					case 0:
						if(_g1.c._hx_index == 0) {
							if(_g2._hx_index == 1) {
								var v = _g2.v;
								if(!hxsl_Tools.hasQualifier(v,hxsl_VarQualifier.Nullable)) {
									this.error("Variable is not declared as nullable",e1.p);
								}
								return hxsl_Type.TBool;
							} else {
								return this.error("Cannot compare " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
							}
						} else {
							return this.error("Cannot compare " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
						}
						break;
					case 1:
						if(_g2._hx_index == 0) {
							if(_g2.c._hx_index == 0) {
								var v = _g1.v;
								if(!hxsl_Tools.hasQualifier(v,hxsl_VarQualifier.Nullable)) {
									this.error("Variable is not declared as nullable",e1.p);
								}
								return hxsl_Type.TBool;
							} else {
								return this.error("Cannot compare " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
							}
						} else {
							return this.error("Cannot compare " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
						}
						break;
					default:
						return this.error("Cannot compare " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
					}
				}
				break;
			case 1:case 3:case 4:
				if(e2.t != hxsl_Type.TVoid) {
					this.unifyExpr(e2,e1.t);
					return hxsl_Type.TBool;
				} else {
					var _g1 = e1.e;
					var _g2 = e2.e;
					switch(_g1._hx_index) {
					case 0:
						if(_g1.c._hx_index == 0) {
							if(_g2._hx_index == 1) {
								var v = _g2.v;
								if(!hxsl_Tools.hasQualifier(v,hxsl_VarQualifier.Nullable)) {
									this.error("Variable is not declared as nullable",e1.p);
								}
								return hxsl_Type.TBool;
							} else {
								return this.error("Cannot compare " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
							}
						} else {
							return this.error("Cannot compare " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
						}
						break;
					case 1:
						if(_g2._hx_index == 0) {
							if(_g2.c._hx_index == 0) {
								var v = _g1.v;
								if(!hxsl_Tools.hasQualifier(v,hxsl_VarQualifier.Nullable)) {
									this.error("Variable is not declared as nullable",e1.p);
								}
								return hxsl_Type.TBool;
							} else {
								return this.error("Cannot compare " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
							}
						} else {
							return this.error("Cannot compare " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
						}
						break;
					default:
						return this.error("Cannot compare " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
					}
				}
				break;
			case 5:
				var _g1 = _g.size;
				var _g1 = _g.t;
				if(e2.t != hxsl_Type.TVoid) {
					this.unifyExpr(e2,e1.t);
					return e1.t;
				} else {
					var _g = e1.e;
					var _g1 = e2.e;
					switch(_g._hx_index) {
					case 0:
						if(_g.c._hx_index == 0) {
							if(_g1._hx_index == 1) {
								var v = _g1.v;
								if(!hxsl_Tools.hasQualifier(v,hxsl_VarQualifier.Nullable)) {
									this.error("Variable is not declared as nullable",e1.p);
								}
								return hxsl_Type.TBool;
							} else {
								return this.error("Cannot compare " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
							}
						} else {
							return this.error("Cannot compare " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
						}
						break;
					case 1:
						if(_g1._hx_index == 0) {
							if(_g1.c._hx_index == 0) {
								var v = _g.v;
								if(!hxsl_Tools.hasQualifier(v,hxsl_VarQualifier.Nullable)) {
									this.error("Variable is not declared as nullable",e1.p);
								}
								return hxsl_Type.TBool;
							} else {
								return this.error("Cannot compare " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
							}
						} else {
							return this.error("Cannot compare " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
						}
						break;
					default:
						return this.error("Cannot compare " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
					}
				}
				break;
			default:
				var _g = e1.e;
				var _g1 = e2.e;
				switch(_g._hx_index) {
				case 0:
					if(_g.c._hx_index == 0) {
						if(_g1._hx_index == 1) {
							var v = _g1.v;
							if(!hxsl_Tools.hasQualifier(v,hxsl_VarQualifier.Nullable)) {
								this.error("Variable is not declared as nullable",e1.p);
							}
							return hxsl_Type.TBool;
						} else {
							return this.error("Cannot compare " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
						}
					} else {
						return this.error("Cannot compare " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
					}
					break;
				case 1:
					if(_g1._hx_index == 0) {
						if(_g1.c._hx_index == 0) {
							var v = _g.v;
							if(!hxsl_Tools.hasQualifier(v,hxsl_VarQualifier.Nullable)) {
								this.error("Variable is not declared as nullable",e1.p);
							}
							return hxsl_Type.TBool;
						} else {
							return this.error("Cannot compare " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
						}
					} else {
						return this.error("Cannot compare " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
					}
					break;
				default:
					return this.error("Cannot compare " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
				}
			}
			break;
		case 11:case 12:case 13:case 16:case 17:case 18:
			this.unifyExpr(e1,hxsl_Type.TInt);
			this.unifyExpr(e2,hxsl_Type.TInt);
			return hxsl_Type.TInt;
		case 14:case 15:
			this.unifyExpr(e1,hxsl_Type.TBool);
			this.unifyExpr(e2,hxsl_Type.TBool);
			return hxsl_Type.TBool;
		case 0:case 1:case 2:case 3:case 19:
			var _g = e1.t;
			var _g1 = e2.t;
			if(op._hx_index == 1) {
				switch(_g._hx_index) {
				case 1:
					switch(_g1._hx_index) {
					case 1:
						return hxsl_Type.TInt;
					case 3:
						this.toFloat(e1);
						return hxsl_Type.TFloat;
					case 5:
						var _g2 = _g1.size;
						if(_g1.t._hx_index == 1) {
							this.toFloat(e1);
							return e2.t;
						} else {
							var opName;
							switch(op._hx_index) {
							case 0:
								opName = "add";
								break;
							case 1:
								opName = "multiply";
								break;
							case 2:
								opName = "divide";
								break;
							case 3:
								opName = "subtract";
								break;
							default:
								throw haxe_Exception.thrown("assert");
							}
							return this.error("Cannot " + opName + " " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
						}
						break;
					default:
						var opName;
						switch(op._hx_index) {
						case 0:
							opName = "add";
							break;
						case 1:
							opName = "multiply";
							break;
						case 2:
							opName = "divide";
							break;
						case 3:
							opName = "subtract";
							break;
						default:
							throw haxe_Exception.thrown("assert");
						}
						return this.error("Cannot " + opName + " " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
					}
					break;
				case 3:
					switch(_g1._hx_index) {
					case 1:
						this.toFloat(e2);
						return hxsl_Type.TFloat;
					case 3:
						return hxsl_Type.TFloat;
					case 5:
						var _g2 = _g1.size;
						if(_g1.t._hx_index == 1) {
							return e2.t;
						} else {
							var opName;
							switch(op._hx_index) {
							case 0:
								opName = "add";
								break;
							case 1:
								opName = "multiply";
								break;
							case 2:
								opName = "divide";
								break;
							case 3:
								opName = "subtract";
								break;
							default:
								throw haxe_Exception.thrown("assert");
							}
							return this.error("Cannot " + opName + " " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
						}
						break;
					default:
						var opName;
						switch(op._hx_index) {
						case 0:
							opName = "add";
							break;
						case 1:
							opName = "multiply";
							break;
						case 2:
							opName = "divide";
							break;
						case 3:
							opName = "subtract";
							break;
						default:
							throw haxe_Exception.thrown("assert");
						}
						return this.error("Cannot " + opName + " " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
					}
					break;
				case 5:
					var _g2 = _g.size;
					var _g3 = _g.t;
					switch(_g2) {
					case 2:
						if(_g3._hx_index == 1) {
							switch(_g1._hx_index) {
							case 1:
								this.toFloat(e2);
								return e1.t;
							case 3:
								return e1.t;
							case 5:
								if(_g1.t._hx_index == 1) {
									var a = _g2;
									var b = _g1.size;
									if(a == b) {
										return hxsl_Type.TVec(a,hxsl_VecType.VFloat);
									} else {
										var opName;
										switch(op._hx_index) {
										case 0:
											opName = "add";
											break;
										case 1:
											opName = "multiply";
											break;
										case 2:
											opName = "divide";
											break;
										case 3:
											opName = "subtract";
											break;
										default:
											throw haxe_Exception.thrown("assert");
										}
										return this.error("Cannot " + opName + " " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
									}
								} else {
									var opName;
									switch(op._hx_index) {
									case 0:
										opName = "add";
										break;
									case 1:
										opName = "multiply";
										break;
									case 2:
										opName = "divide";
										break;
									case 3:
										opName = "subtract";
										break;
									default:
										throw haxe_Exception.thrown("assert");
									}
									return this.error("Cannot " + opName + " " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
								}
								break;
							case 12:
								return hxsl_Checker.vec2;
							default:
								var opName;
								switch(op._hx_index) {
								case 0:
									opName = "add";
									break;
								case 1:
									opName = "multiply";
									break;
								case 2:
									opName = "divide";
									break;
								case 3:
									opName = "subtract";
									break;
								default:
									throw haxe_Exception.thrown("assert");
								}
								return this.error("Cannot " + opName + " " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
							}
						} else {
							var opName;
							switch(op._hx_index) {
							case 0:
								opName = "add";
								break;
							case 1:
								opName = "multiply";
								break;
							case 2:
								opName = "divide";
								break;
							case 3:
								opName = "subtract";
								break;
							default:
								throw haxe_Exception.thrown("assert");
							}
							return this.error("Cannot " + opName + " " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
						}
						break;
					case 3:
						if(_g3._hx_index == 1) {
							switch(_g1._hx_index) {
							case 1:
								this.toFloat(e2);
								return e1.t;
							case 3:
								return e1.t;
							case 5:
								if(_g1.t._hx_index == 1) {
									var a = _g2;
									var b = _g1.size;
									if(a == b) {
										return hxsl_Type.TVec(a,hxsl_VecType.VFloat);
									} else {
										var opName;
										switch(op._hx_index) {
										case 0:
											opName = "add";
											break;
										case 1:
											opName = "multiply";
											break;
										case 2:
											opName = "divide";
											break;
										case 3:
											opName = "subtract";
											break;
										default:
											throw haxe_Exception.thrown("assert");
										}
										return this.error("Cannot " + opName + " " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
									}
								} else {
									var opName;
									switch(op._hx_index) {
									case 0:
										opName = "add";
										break;
									case 1:
										opName = "multiply";
										break;
									case 2:
										opName = "divide";
										break;
									case 3:
										opName = "subtract";
										break;
									default:
										throw haxe_Exception.thrown("assert");
									}
									return this.error("Cannot " + opName + " " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
								}
								break;
							case 6:
								return hxsl_Checker.vec3;
							case 8:
								return hxsl_Checker.vec3;
							default:
								var opName;
								switch(op._hx_index) {
								case 0:
									opName = "add";
									break;
								case 1:
									opName = "multiply";
									break;
								case 2:
									opName = "divide";
									break;
								case 3:
									opName = "subtract";
									break;
								default:
									throw haxe_Exception.thrown("assert");
								}
								return this.error("Cannot " + opName + " " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
							}
						} else {
							var opName;
							switch(op._hx_index) {
							case 0:
								opName = "add";
								break;
							case 1:
								opName = "multiply";
								break;
							case 2:
								opName = "divide";
								break;
							case 3:
								opName = "subtract";
								break;
							default:
								throw haxe_Exception.thrown("assert");
							}
							return this.error("Cannot " + opName + " " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
						}
						break;
					case 4:
						if(_g3._hx_index == 1) {
							switch(_g1._hx_index) {
							case 1:
								this.toFloat(e2);
								return e1.t;
							case 3:
								return e1.t;
							case 5:
								if(_g1.t._hx_index == 1) {
									var a = _g2;
									var b = _g1.size;
									if(a == b) {
										return hxsl_Type.TVec(a,hxsl_VecType.VFloat);
									} else {
										var opName;
										switch(op._hx_index) {
										case 0:
											opName = "add";
											break;
										case 1:
											opName = "multiply";
											break;
										case 2:
											opName = "divide";
											break;
										case 3:
											opName = "subtract";
											break;
										default:
											throw haxe_Exception.thrown("assert");
										}
										return this.error("Cannot " + opName + " " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
									}
								} else {
									var opName;
									switch(op._hx_index) {
									case 0:
										opName = "add";
										break;
									case 1:
										opName = "multiply";
										break;
									case 2:
										opName = "divide";
										break;
									case 3:
										opName = "subtract";
										break;
									default:
										throw haxe_Exception.thrown("assert");
									}
									return this.error("Cannot " + opName + " " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
								}
								break;
							case 7:
								return hxsl_Checker.vec4;
							default:
								var opName;
								switch(op._hx_index) {
								case 0:
									opName = "add";
									break;
								case 1:
									opName = "multiply";
									break;
								case 2:
									opName = "divide";
									break;
								case 3:
									opName = "subtract";
									break;
								default:
									throw haxe_Exception.thrown("assert");
								}
								return this.error("Cannot " + opName + " " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
							}
						} else {
							var opName;
							switch(op._hx_index) {
							case 0:
								opName = "add";
								break;
							case 1:
								opName = "multiply";
								break;
							case 2:
								opName = "divide";
								break;
							case 3:
								opName = "subtract";
								break;
							default:
								throw haxe_Exception.thrown("assert");
							}
							return this.error("Cannot " + opName + " " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
						}
						break;
					default:
						if(_g3._hx_index == 1) {
							switch(_g1._hx_index) {
							case 1:
								this.toFloat(e2);
								return e1.t;
							case 3:
								return e1.t;
							case 5:
								if(_g1.t._hx_index == 1) {
									var a = _g2;
									var b = _g1.size;
									if(a == b) {
										return hxsl_Type.TVec(a,hxsl_VecType.VFloat);
									} else {
										var opName;
										switch(op._hx_index) {
										case 0:
											opName = "add";
											break;
										case 1:
											opName = "multiply";
											break;
										case 2:
											opName = "divide";
											break;
										case 3:
											opName = "subtract";
											break;
										default:
											throw haxe_Exception.thrown("assert");
										}
										return this.error("Cannot " + opName + " " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
									}
								} else {
									var opName;
									switch(op._hx_index) {
									case 0:
										opName = "add";
										break;
									case 1:
										opName = "multiply";
										break;
									case 2:
										opName = "divide";
										break;
									case 3:
										opName = "subtract";
										break;
									default:
										throw haxe_Exception.thrown("assert");
									}
									return this.error("Cannot " + opName + " " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
								}
								break;
							default:
								var opName;
								switch(op._hx_index) {
								case 0:
									opName = "add";
									break;
								case 1:
									opName = "multiply";
									break;
								case 2:
									opName = "divide";
									break;
								case 3:
									opName = "subtract";
									break;
								default:
									throw haxe_Exception.thrown("assert");
								}
								return this.error("Cannot " + opName + " " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
							}
						} else {
							var opName;
							switch(op._hx_index) {
							case 0:
								opName = "add";
								break;
							case 1:
								opName = "multiply";
								break;
							case 2:
								opName = "divide";
								break;
							case 3:
								opName = "subtract";
								break;
							default:
								throw haxe_Exception.thrown("assert");
							}
							return this.error("Cannot " + opName + " " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
						}
					}
					break;
				case 7:
					if(_g1._hx_index == 7) {
						return hxsl_Type.TMat4;
					} else {
						var opName;
						switch(op._hx_index) {
						case 0:
							opName = "add";
							break;
						case 1:
							opName = "multiply";
							break;
						case 2:
							opName = "divide";
							break;
						case 3:
							opName = "subtract";
							break;
						default:
							throw haxe_Exception.thrown("assert");
						}
						return this.error("Cannot " + opName + " " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
					}
					break;
				default:
					var opName;
					switch(op._hx_index) {
					case 0:
						opName = "add";
						break;
					case 1:
						opName = "multiply";
						break;
					case 2:
						opName = "divide";
						break;
					case 3:
						opName = "subtract";
						break;
					default:
						throw haxe_Exception.thrown("assert");
					}
					return this.error("Cannot " + opName + " " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
				}
			} else {
				switch(_g._hx_index) {
				case 1:
					switch(_g1._hx_index) {
					case 1:
						return hxsl_Type.TInt;
					case 3:
						this.toFloat(e1);
						return hxsl_Type.TFloat;
					case 5:
						var _g2 = _g1.size;
						if(_g1.t._hx_index == 1) {
							this.toFloat(e1);
							return e2.t;
						} else {
							var opName;
							switch(op._hx_index) {
							case 0:
								opName = "add";
								break;
							case 1:
								opName = "multiply";
								break;
							case 2:
								opName = "divide";
								break;
							case 3:
								opName = "subtract";
								break;
							default:
								throw haxe_Exception.thrown("assert");
							}
							return this.error("Cannot " + opName + " " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
						}
						break;
					default:
						var opName;
						switch(op._hx_index) {
						case 0:
							opName = "add";
							break;
						case 1:
							opName = "multiply";
							break;
						case 2:
							opName = "divide";
							break;
						case 3:
							opName = "subtract";
							break;
						default:
							throw haxe_Exception.thrown("assert");
						}
						return this.error("Cannot " + opName + " " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
					}
					break;
				case 3:
					switch(_g1._hx_index) {
					case 1:
						this.toFloat(e2);
						return hxsl_Type.TFloat;
					case 3:
						return hxsl_Type.TFloat;
					case 5:
						var _g2 = _g1.size;
						if(_g1.t._hx_index == 1) {
							return e2.t;
						} else {
							var opName;
							switch(op._hx_index) {
							case 0:
								opName = "add";
								break;
							case 1:
								opName = "multiply";
								break;
							case 2:
								opName = "divide";
								break;
							case 3:
								opName = "subtract";
								break;
							default:
								throw haxe_Exception.thrown("assert");
							}
							return this.error("Cannot " + opName + " " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
						}
						break;
					default:
						var opName;
						switch(op._hx_index) {
						case 0:
							opName = "add";
							break;
						case 1:
							opName = "multiply";
							break;
						case 2:
							opName = "divide";
							break;
						case 3:
							opName = "subtract";
							break;
						default:
							throw haxe_Exception.thrown("assert");
						}
						return this.error("Cannot " + opName + " " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
					}
					break;
				case 5:
					var _g2 = _g.size;
					if(_g.t._hx_index == 1) {
						switch(_g1._hx_index) {
						case 1:
							this.toFloat(e2);
							return e1.t;
						case 3:
							return e1.t;
						case 5:
							if(_g1.t._hx_index == 1) {
								var b = _g1.size;
								var a = _g2;
								if(a == b) {
									return hxsl_Type.TVec(a,hxsl_VecType.VFloat);
								} else {
									var opName;
									switch(op._hx_index) {
									case 0:
										opName = "add";
										break;
									case 1:
										opName = "multiply";
										break;
									case 2:
										opName = "divide";
										break;
									case 3:
										opName = "subtract";
										break;
									default:
										throw haxe_Exception.thrown("assert");
									}
									return this.error("Cannot " + opName + " " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
								}
							} else {
								var opName;
								switch(op._hx_index) {
								case 0:
									opName = "add";
									break;
								case 1:
									opName = "multiply";
									break;
								case 2:
									opName = "divide";
									break;
								case 3:
									opName = "subtract";
									break;
								default:
									throw haxe_Exception.thrown("assert");
								}
								return this.error("Cannot " + opName + " " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
							}
							break;
						default:
							var opName;
							switch(op._hx_index) {
							case 0:
								opName = "add";
								break;
							case 1:
								opName = "multiply";
								break;
							case 2:
								opName = "divide";
								break;
							case 3:
								opName = "subtract";
								break;
							default:
								throw haxe_Exception.thrown("assert");
							}
							return this.error("Cannot " + opName + " " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
						}
					} else {
						var opName;
						switch(op._hx_index) {
						case 0:
							opName = "add";
							break;
						case 1:
							opName = "multiply";
							break;
						case 2:
							opName = "divide";
							break;
						case 3:
							opName = "subtract";
							break;
						default:
							throw haxe_Exception.thrown("assert");
						}
						return this.error("Cannot " + opName + " " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
					}
					break;
				default:
					var opName;
					switch(op._hx_index) {
					case 0:
						opName = "add";
						break;
					case 1:
						opName = "multiply";
						break;
					case 2:
						opName = "divide";
						break;
					case 3:
						opName = "subtract";
						break;
					default:
						throw haxe_Exception.thrown("assert");
					}
					return this.error("Cannot " + opName + " " + hxsl_Tools.toString(e1.t) + " and " + hxsl_Tools.toString(e2.t),pos);
				}
			}
			break;
		case 20:
			var _g = op.op;
			throw haxe_Exception.thrown("assert");
		case 21:
			this.unifyExpr(e1,hxsl_Type.TInt);
			this.unifyExpr(e2,hxsl_Type.TInt);
			return hxsl_Type.TArray(hxsl_Type.TInt,hxsl_SizeDecl.SConst(0));
		default:
			return this.error("Unsupported operator " + Std.string(op),pos);
		}
	}
	,__class__: hxsl_Checker
};
var hxsl_Clone = function() {
	this.varMap = new haxe_ds_IntMap();
};
$hxClasses["hxsl.Clone"] = hxsl_Clone;
hxsl_Clone.__name__ = "hxsl.Clone";
hxsl_Clone.shaderData = function(s) {
	return new hxsl_Clone().shader(s);
};
hxsl_Clone.prototype = {
	tvar: function(v) {
		var v2 = this.varMap.h[v.id];
		if(v2 != null) {
			return v2;
		}
		v2 = { id : hxsl_Tools.allocVarId(), type : v.type, name : v.name, kind : v.kind};
		this.varMap.h[v.id] = v2;
		if(v.parent != null) {
			v2.parent = this.tvar(v.parent);
		}
		if(v.qualifiers != null) {
			v2.qualifiers = v.qualifiers.slice();
		}
		v2.type = this.ttype(v.type);
		return v2;
	}
	,tfun: function(f) {
		var tmp = this.ttype(f.ret);
		var f1 = f.kind;
		var tmp1 = this.tvar(f.ref);
		var _g = [];
		var _g1 = 0;
		var _g2 = f.args;
		while(_g1 < _g2.length) {
			var a = _g2[_g1];
			++_g1;
			_g.push(this.tvar(a));
		}
		return { ret : tmp, kind : f1, ref : tmp1, args : _g, expr : this.texpr(f.expr)};
	}
	,ttype: function(t) {
		switch(t._hx_index) {
		case 13:
			var vl = t.vl;
			var _g = [];
			var _g1 = 0;
			while(_g1 < vl.length) {
				var v = vl[_g1];
				++_g1;
				_g.push(this.tvar(v));
			}
			return hxsl_Type.TStruct(_g);
		case 14:
			var vars = t.variants;
			return hxsl_Type.TFun(vars);
		case 15:
			var t1 = t.t;
			var size = t.size;
			var tmp = this.ttype(t1);
			var tmp1;
			switch(size._hx_index) {
			case 0:
				var _g = size.v;
				tmp1 = size;
				break;
			case 1:
				var v = size.v;
				tmp1 = hxsl_SizeDecl.SVar(this.tvar(v));
				break;
			}
			return hxsl_Type.TArray(tmp,tmp1);
		default:
			return t;
		}
	}
	,texpr: function(e) {
		var e2 = hxsl_Tools.map(e,$bind(this,this.texpr));
		e2.t = this.ttype(e.t);
		var _g = e2.e;
		var tmp;
		switch(_g._hx_index) {
		case 1:
			var v = _g.v;
			tmp = hxsl_TExprDef.TVar(this.tvar(v));
			break;
		case 7:
			var v = _g.v;
			var init = _g.init;
			tmp = hxsl_TExprDef.TVarDecl(this.tvar(v),init);
			break;
		case 13:
			var v = _g.v;
			var it = _g.it;
			var loop = _g.loop;
			tmp = hxsl_TExprDef.TFor(this.tvar(v),it,loop);
			break;
		default:
			tmp = e2.e;
		}
		e2.e = tmp;
		return e2;
	}
	,shader: function(s) {
		var s1 = s.name;
		var _g = [];
		var _g1 = 0;
		var _g2 = s.vars;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			_g.push(this.tvar(v));
		}
		var tmp = _g;
		var _g = [];
		var _g1 = 0;
		var _g2 = s.funs;
		while(_g1 < _g2.length) {
			var f = _g2[_g1];
			++_g1;
			_g.push(this.tfun(f));
		}
		return { name : s1, vars : tmp, funs : _g};
	}
	,__class__: hxsl_Clone
};
var hxsl__$Dce_Exit = function() {
};
$hxClasses["hxsl._Dce.Exit"] = hxsl__$Dce_Exit;
hxsl__$Dce_Exit.__name__ = "hxsl._Dce.Exit";
hxsl__$Dce_Exit.prototype = {
	__class__: hxsl__$Dce_Exit
};
var hxsl__$Dce_VarRel = function(v) {
	this.fields = 0;
	this.v = v;
};
$hxClasses["hxsl._Dce.VarRel"] = hxsl__$Dce_VarRel;
hxsl__$Dce_VarRel.__name__ = "hxsl._Dce.VarRel";
hxsl__$Dce_VarRel.prototype = {
	__class__: hxsl__$Dce_VarRel
};
var hxsl__$Dce_VarDeps = function(v) {
	this.used = 0;
	this.keep = 0;
	this.v = v;
	this.deps = new haxe_ds_IntMap();
	this.adeps = [];
};
$hxClasses["hxsl._Dce.VarDeps"] = hxsl__$Dce_VarDeps;
hxsl__$Dce_VarDeps.__name__ = "hxsl._Dce.VarDeps";
hxsl__$Dce_VarDeps.prototype = {
	__class__: hxsl__$Dce_VarDeps
};
var hxsl__$Dce_WriteTo = function() {
	this.vars = [];
	this.bits = [];
};
$hxClasses["hxsl._Dce.WriteTo"] = hxsl__$Dce_WriteTo;
hxsl__$Dce_WriteTo.__name__ = "hxsl._Dce.WriteTo";
hxsl__$Dce_WriteTo.prototype = {
	push: function(v,b) {
		this.vars.push(v);
		this.bits.push(b);
	}
	,pop: function() {
		this.vars.pop();
		this.bits.pop();
	}
	,append: function(v,b) {
		var _g_current = 0;
		var _g_array = this.vars;
		while(_g_current < _g_array.length) {
			var _g_value = _g_array[_g_current];
			var _g_key = _g_current++;
			var i = _g_key;
			var v2 = _g_value;
			if(v2 == v) {
				this.bits[i] |= b;
				return;
			}
		}
		this.push(v,b);
	}
	,appendTo: function(w) {
		var _g_current = 0;
		var _g_array = this.vars;
		while(_g_current < _g_array.length) {
			var _g_value = _g_array[_g_current];
			var _g_key = _g_current++;
			var i = _g_key;
			var v = _g_value;
			w.append(v,this.bits[i]);
		}
	}
	,__class__: hxsl__$Dce_WriteTo
};
var hxsl_Dce = function() {
};
$hxClasses["hxsl.Dce"] = hxsl_Dce;
hxsl_Dce.__name__ = "hxsl.Dce";
hxsl_Dce.prototype = {
	dce: function(shaders) {
		this.used = new haxe_ds_IntMap();
		this.channelVars = [];
		var inputs = [];
		var _g = 0;
		while(_g < shaders.length) {
			var s = shaders[_g];
			++_g;
			var _g1 = 0;
			var _g2 = s.vars;
			while(_g1 < _g2.length) {
				var v = _g2[_g1];
				++_g1;
				var i = this.get(v);
				if(v.kind == hxsl_VarKind.Input) {
					inputs.push(i);
				}
				var tmp;
				if(v.kind != hxsl_VarKind.Output) {
					var _g3 = v.type;
					switch(_g3._hx_index) {
					case 11:
						var _g4 = _g3.dim;
						var _g5 = _g3.isArray;
						var _g6 = _g3.channels;
						tmp = true;
						break;
					case 16:
						var _g7 = _g3.t;
						var _g8 = _g3.size;
						tmp = _g3.kind._hx_index == 2;
						break;
					default:
						tmp = false;
					}
				} else {
					tmp = true;
				}
				if(tmp) {
					i.keep = 15;
				}
			}
		}
		var _g = 0;
		while(_g < shaders.length) {
			var s = shaders[_g];
			++_g;
			var _g1 = 0;
			var _g2 = s.funs;
			while(_g1 < _g2.length) {
				var f = _g2[_g1];
				++_g1;
				this.check(f.expr,new hxsl__$Dce_WriteTo(),new hxsl__$Dce_WriteTo());
			}
		}
		var outExprs = [];
		do {
			if(hxsl_Debug.TRACE) {
				haxe_Log.trace("DCE LOOP",{ fileName : "hxsl/Debug.hx", lineNumber : 9, className : "hxsl.Dce", methodName : "dce"});
			}
			var v = this.used.iterator();
			while(v.hasNext()) {
				var v1 = v.next();
				if(v1.keep != 0) {
					this.markRec(v1,v1.keep);
				}
			}
			while(inputs.length > 1 && inputs[inputs.length - 1].used == 0) inputs.pop();
			var _g = 0;
			while(_g < inputs.length) {
				var v2 = inputs[_g];
				++_g;
				this.markRec(v2,15);
			}
			outExprs = [];
			var _g1 = 0;
			while(_g1 < shaders.length) {
				var s = shaders[_g1];
				++_g1;
				var _g2 = 0;
				var _g3 = s.funs;
				while(_g2 < _g3.length) {
					var f = _g3[_g2];
					++_g2;
					outExprs.push(this.mapExpr(f.expr,false));
				}
			}
			this.markAsKeep = false;
			var _g4 = 0;
			while(_g4 < outExprs.length) {
				var e = outExprs[_g4];
				++_g4;
				this.checkBranches(e);
			}
		} while(this.markAsKeep);
		var _g = 0;
		while(_g < shaders.length) {
			var s = shaders[_g];
			++_g;
			var _g1 = 0;
			var _g2 = s.funs;
			while(_g1 < _g2.length) {
				var f = _g2[_g1];
				++_g1;
				f.expr = outExprs.shift();
			}
		}
		var v = this.used.iterator();
		while(v.hasNext()) {
			var v1 = v.next();
			if(v1.used != 0) {
				continue;
			}
			if(v1.v.kind == hxsl_VarKind.Input) {
				continue;
			}
			var _g = 0;
			while(_g < shaders.length) {
				var s = shaders[_g];
				++_g;
				HxOverrides.remove(s.vars,v1.v);
			}
		}
		return shaders.slice();
	}
	,get: function(v) {
		var vd = this.used.h[v.id];
		if(vd == null) {
			vd = new hxsl__$Dce_VarDeps(v);
			this.used.h[v.id] = vd;
		}
		return vd;
	}
	,varName: function(v,bits) {
		if(bits == null) {
			bits = 15;
		}
		return hxsl_Debug.varName(v,bits);
	}
	,markRec: function(v,bits) {
		if((v.used & bits) == bits) {
			return;
		}
		bits &= ~v.used;
		if(hxsl_Debug.TRACE) {
			haxe_Log.trace(this.varName(v.v,bits) + " is used",{ fileName : "hxsl/Debug.hx", lineNumber : 9, className : "hxsl.Dce", methodName : "markRec"});
		}
		v.used |= bits;
		var _g = 0;
		var _g1 = v.adeps;
		while(_g < _g1.length) {
			var d = _g1[_g];
			++_g;
			var mask = this.makeFieldsBits(15,bits);
			if((d.fields & mask) != 0) {
				this.markRec(d.v,this.extractFieldsBits(d.fields,bits));
			}
		}
	}
	,extractFieldsBits: function(fields,write) {
		return (((write & 1) == 0 ? 0 : fields) | ((write & 2) == 0 ? 0 : fields >> 4) | ((write & 4) == 0 ? 0 : fields >> 8) | ((write & 8) == 0 ? 0 : fields >> 12)) & 15;
	}
	,makeFieldsBits: function(read,write) {
		return read * ((write & 1) + ((write & 2) << 3) + ((write & 4) << 6) + ((write & 8) << 9));
	}
	,link: function(v,writeTo,bits) {
		if(bits == null) {
			bits = 15;
		}
		var vd = this.get(v);
		var _g_current = 0;
		var _g_array = writeTo.vars;
		while(_g_current < _g_array.length) {
			var _g_value = _g_array[_g_current];
			var _g_key = _g_current++;
			var i = _g_key;
			var w = _g_value;
			if(w == null) {
				if(vd.keep == 0) {
					if(hxsl_Debug.TRACE) {
						haxe_Log.trace("Force keep " + this.varName(vd.v),{ fileName : "hxsl/Debug.hx", lineNumber : 9, className : "hxsl.Dce", methodName : "link"});
					}
					vd.keep = 15;
					this.markAsKeep = true;
				}
				continue;
			}
			var d = w.deps.h[v.id];
			if(d == null) {
				d = new hxsl__$Dce_VarRel(vd);
				w.deps.h[v.id] = d;
				w.adeps.push(d);
			}
			var fields = this.makeFieldsBits(bits,writeTo.bits[i]);
			if((d.fields & fields) != fields) {
				d.fields |= fields;
				if(hxsl_Debug.TRACE) {
					haxe_Log.trace(this.varName(w.v,writeTo.bits[i]) + " depends on " + this.varName(vd.v,bits),{ fileName : "hxsl/Debug.hx", lineNumber : 9, className : "hxsl.Dce", methodName : "link"});
				}
			}
		}
	}
	,swizBits: function(sw) {
		var b = 0;
		var _g = 0;
		while(_g < sw.length) {
			var c = sw[_g];
			++_g;
			b |= 1 << c._hx_index;
		}
		return b;
	}
	,check: function(e,writeTo,isAffected) {
		var _gthis = this;
		var _g = e.e;
		switch(_g._hx_index) {
		case 1:
			var v = _g.v;
			this.link(v,writeTo);
			break;
		case 4:
			var el = _g.el;
			var noWrite = new hxsl__$Dce_WriteTo();
			var _g1 = 0;
			var _g2 = el.length;
			while(_g1 < _g2) {
				var i = _g1++;
				this.check(el[i],i < el.length - 1 ? noWrite : writeTo,isAffected);
			}
			break;
		case 5:
			var _g1 = _g.op;
			var _g2 = _g.e1;
			var _g3 = _g.e2;
			switch(_g1._hx_index) {
			case 4:
				var _g4 = _g2.e;
				var _g5 = _g2.p;
				var _g5 = _g2.t;
				switch(_g4._hx_index) {
				case 1:
					var v = _g4.v;
					var e1 = _g3;
					var v1 = this.get(v);
					writeTo.push(v1,15);
					this.check(e1,writeTo,isAffected);
					writeTo.pop();
					isAffected.append(v1,15);
					break;
				case 9:
					var _g5 = _g4.e;
					var _g6 = _g4.regs;
					var _g7 = _g5.e;
					var _g8 = _g5.p;
					var _g8 = _g5.t;
					switch(_g7._hx_index) {
					case 1:
						var v = _g7.v;
						var swiz = _g6;
						var e1 = _g3;
						var v1 = this.get(v);
						var bits = this.swizBits(swiz);
						writeTo.push(v1,bits);
						this.check(e1,writeTo,isAffected);
						writeTo.pop();
						isAffected.append(v1,bits);
						break;
					case 16:
						var _g5 = _g7.e;
						var _g6 = _g5.e;
						var _g8 = _g5.p;
						var _g8 = _g5.t;
						if(_g6._hx_index == 1) {
							var v = _g6.v;
							var i = _g7.index;
							var e1 = _g3;
							var v1 = this.get(v);
							writeTo.push(v1,15);
							this.check(i,writeTo,isAffected);
							this.check(e1,writeTo,isAffected);
							writeTo.pop();
							isAffected.append(v1,15);
						} else {
							var _g5 = this;
							var writeTo1 = writeTo;
							var isAffected1 = isAffected;
							hxsl_Tools.iter(e,function(e) {
								_g5.check(e,writeTo1,isAffected1);
							});
						}
						break;
					default:
						var _g6 = this;
						var writeTo2 = writeTo;
						var isAffected2 = isAffected;
						hxsl_Tools.iter(e,function(e) {
							_g6.check(e,writeTo2,isAffected2);
						});
					}
					break;
				case 16:
					var _g7 = _g4.e;
					var _g8 = _g7.e;
					var _g9 = _g7.p;
					var _g9 = _g7.t;
					if(_g8._hx_index == 1) {
						var v = _g8.v;
						var i = _g4.index;
						var e1 = _g3;
						var v1 = this.get(v);
						writeTo.push(v1,15);
						this.check(i,writeTo,isAffected);
						this.check(e1,writeTo,isAffected);
						writeTo.pop();
						isAffected.append(v1,15);
					} else {
						var _g7 = this;
						var writeTo3 = writeTo;
						var isAffected3 = isAffected;
						hxsl_Tools.iter(e,function(e) {
							_g7.check(e,writeTo3,isAffected3);
						});
					}
					break;
				case 21:
					var _g8 = _g4.e;
					var _g9 = _g4.name;
					var _g4 = _g8.e;
					var _g9 = _g8.p;
					var _g9 = _g8.t;
					if(_g4._hx_index == 16) {
						var _g8 = _g4.e;
						var _g9 = _g8.e;
						var _g10 = _g8.p;
						var _g10 = _g8.t;
						if(_g9._hx_index == 1) {
							var v = _g9.v;
							var i = _g4.index;
							var e1 = _g3;
							var v1 = this.get(v);
							writeTo.push(v1,15);
							this.check(i,writeTo,isAffected);
							this.check(e1,writeTo,isAffected);
							writeTo.pop();
							isAffected.append(v1,15);
						} else {
							var _g4 = this;
							var writeTo4 = writeTo;
							var isAffected4 = isAffected;
							hxsl_Tools.iter(e,function(e) {
								_g4.check(e,writeTo4,isAffected4);
							});
						}
					} else {
						var _g8 = this;
						var writeTo5 = writeTo;
						var isAffected5 = isAffected;
						hxsl_Tools.iter(e,function(e) {
							_g8.check(e,writeTo5,isAffected5);
						});
					}
					break;
				default:
					var _g9 = this;
					var writeTo6 = writeTo;
					var isAffected6 = isAffected;
					hxsl_Tools.iter(e,function(e) {
						_g9.check(e,writeTo6,isAffected6);
					});
				}
				break;
			case 20:
				var _g10 = _g1.op;
				var _g1 = _g2.e;
				var _g10 = _g2.p;
				var _g10 = _g2.t;
				switch(_g1._hx_index) {
				case 1:
					var v = _g1.v;
					var e1 = _g3;
					var v1 = this.get(v);
					writeTo.push(v1,15);
					this.check(e1,writeTo,isAffected);
					writeTo.pop();
					isAffected.append(v1,15);
					break;
				case 9:
					var _g2 = _g1.e;
					var _g10 = _g1.regs;
					var _g11 = _g2.e;
					var _g12 = _g2.p;
					var _g12 = _g2.t;
					switch(_g11._hx_index) {
					case 1:
						var v = _g11.v;
						var swiz = _g10;
						var e1 = _g3;
						var v1 = this.get(v);
						var bits = this.swizBits(swiz);
						writeTo.push(v1,bits);
						this.check(e1,writeTo,isAffected);
						writeTo.pop();
						isAffected.append(v1,bits);
						break;
					case 16:
						var _g2 = _g11.e;
						var _g10 = _g2.e;
						var _g12 = _g2.p;
						var _g12 = _g2.t;
						if(_g10._hx_index == 1) {
							var v = _g10.v;
							var i = _g11.index;
							var e1 = _g3;
							var v1 = this.get(v);
							writeTo.push(v1,15);
							this.check(i,writeTo,isAffected);
							this.check(e1,writeTo,isAffected);
							writeTo.pop();
							isAffected.append(v1,15);
						} else {
							var _g2 = this;
							var writeTo7 = writeTo;
							var isAffected7 = isAffected;
							hxsl_Tools.iter(e,function(e) {
								_g2.check(e,writeTo7,isAffected7);
							});
						}
						break;
					default:
						var _g10 = this;
						var writeTo8 = writeTo;
						var isAffected8 = isAffected;
						hxsl_Tools.iter(e,function(e) {
							_g10.check(e,writeTo8,isAffected8);
						});
					}
					break;
				case 16:
					var _g11 = _g1.e;
					var _g12 = _g11.e;
					var _g13 = _g11.p;
					var _g13 = _g11.t;
					if(_g12._hx_index == 1) {
						var v = _g12.v;
						var i = _g1.index;
						var e1 = _g3;
						var v1 = this.get(v);
						writeTo.push(v1,15);
						this.check(i,writeTo,isAffected);
						this.check(e1,writeTo,isAffected);
						writeTo.pop();
						isAffected.append(v1,15);
					} else {
						var _g11 = this;
						var writeTo9 = writeTo;
						var isAffected9 = isAffected;
						hxsl_Tools.iter(e,function(e) {
							_g11.check(e,writeTo9,isAffected9);
						});
					}
					break;
				case 21:
					var _g12 = _g1.e;
					var _g13 = _g1.name;
					var _g1 = _g12.e;
					var _g13 = _g12.p;
					var _g13 = _g12.t;
					if(_g1._hx_index == 16) {
						var _g12 = _g1.e;
						var _g13 = _g12.e;
						var _g14 = _g12.p;
						var _g14 = _g12.t;
						if(_g13._hx_index == 1) {
							var v = _g13.v;
							var i = _g1.index;
							var e1 = _g3;
							var v1 = this.get(v);
							writeTo.push(v1,15);
							this.check(i,writeTo,isAffected);
							this.check(e1,writeTo,isAffected);
							writeTo.pop();
							isAffected.append(v1,15);
						} else {
							var _g1 = this;
							var writeTo10 = writeTo;
							var isAffected10 = isAffected;
							hxsl_Tools.iter(e,function(e) {
								_g1.check(e,writeTo10,isAffected10);
							});
						}
					} else {
						var _g3 = this;
						var writeTo11 = writeTo;
						var isAffected11 = isAffected;
						hxsl_Tools.iter(e,function(e) {
							_g3.check(e,writeTo11,isAffected11);
						});
					}
					break;
				default:
					var _g12 = this;
					var writeTo12 = writeTo;
					var isAffected12 = isAffected;
					hxsl_Tools.iter(e,function(e) {
						_g12.check(e,writeTo12,isAffected12);
					});
				}
				break;
			default:
				var _g13 = this;
				var writeTo13 = writeTo;
				var isAffected13 = isAffected;
				hxsl_Tools.iter(e,function(e) {
					_g13.check(e,writeTo13,isAffected13);
				});
			}
			break;
		case 7:
			var v = _g.v;
			var init = _g.init;
			if(init != null) {
				writeTo.push(this.get(v),15);
				this.check(init,writeTo,isAffected);
				writeTo.pop();
			} else {
				var _g14 = this;
				var writeTo14 = writeTo;
				var isAffected14 = isAffected;
				hxsl_Tools.iter(e,function(e) {
					_g14.check(e,writeTo14,isAffected14);
				});
			}
			break;
		case 8:
			var _g15 = _g.e;
			var _g16 = _g.args;
			var _g17 = _g15.e;
			var _g18 = _g15.p;
			var _g18 = _g15.t;
			if(_g17._hx_index == 2) {
				switch(_g17.g._hx_index) {
				case 64:
					if(_g16.length == 3) {
						var _g15 = _g16[0];
						var _g17 = _g16[2];
						var _g18 = _g15.e;
						var _g19 = _g15.p;
						var _g19 = _g15.t;
						if(_g18._hx_index == 1) {
							var _g15 = _g17.e;
							var _g19 = _g17.p;
							var _g19 = _g17.t;
							if(_g15._hx_index == 0) {
								var _g17 = _g15.c;
								if(_g17._hx_index == 2) {
									var cid = _g17.v;
									var uv = _g16[1];
									var c = _g18.v;
									this.check(uv,writeTo,isAffected);
									if(this.channelVars[cid] == null) {
										this.channelVars[cid] = c;
										this.link(c,writeTo);
									} else {
										this.link(this.channelVars[cid],writeTo);
									}
								} else {
									var _g15 = this;
									var writeTo15 = writeTo;
									var isAffected15 = isAffected;
									hxsl_Tools.iter(e,function(e) {
										_g15.check(e,writeTo15,isAffected15);
									});
								}
							} else {
								var _g17 = this;
								var writeTo16 = writeTo;
								var isAffected16 = isAffected;
								hxsl_Tools.iter(e,function(e) {
									_g17.check(e,writeTo16,isAffected16);
								});
							}
						} else {
							var _g18 = this;
							var writeTo17 = writeTo;
							var isAffected17 = isAffected;
							hxsl_Tools.iter(e,function(e) {
								_g18.check(e,writeTo17,isAffected17);
							});
						}
					} else {
						var _g19 = this;
						var writeTo18 = writeTo;
						var isAffected18 = isAffected;
						hxsl_Tools.iter(e,function(e) {
							_g19.check(e,writeTo18,isAffected18);
						});
					}
					break;
				case 65:
					if(_g16.length == 4) {
						var _g20 = _g16[0];
						var _g21 = _g16[3];
						var _g22 = _g20.e;
						var _g23 = _g20.p;
						var _g23 = _g20.t;
						if(_g22._hx_index == 1) {
							var _g20 = _g21.e;
							var _g23 = _g21.p;
							var _g23 = _g21.t;
							if(_g20._hx_index == 0) {
								var _g21 = _g20.c;
								if(_g21._hx_index == 2) {
									var cid = _g21.v;
									var lod = _g16[2];
									var uv = _g16[1];
									var c = _g22.v;
									this.check(uv,writeTo,isAffected);
									this.check(lod,writeTo,isAffected);
									if(this.channelVars[cid] == null) {
										this.channelVars[cid] = c;
										this.link(c,writeTo);
									} else {
										this.link(this.channelVars[cid],writeTo);
									}
								} else {
									var _g20 = this;
									var writeTo19 = writeTo;
									var isAffected19 = isAffected;
									hxsl_Tools.iter(e,function(e) {
										_g20.check(e,writeTo19,isAffected19);
									});
								}
							} else {
								var _g21 = this;
								var writeTo20 = writeTo;
								var isAffected20 = isAffected;
								hxsl_Tools.iter(e,function(e) {
									_g21.check(e,writeTo20,isAffected20);
								});
							}
						} else {
							var _g22 = this;
							var writeTo21 = writeTo;
							var isAffected21 = isAffected;
							hxsl_Tools.iter(e,function(e) {
								_g22.check(e,writeTo21,isAffected21);
							});
						}
					} else {
						var _g23 = this;
						var writeTo22 = writeTo;
						var isAffected22 = isAffected;
						hxsl_Tools.iter(e,function(e) {
							_g23.check(e,writeTo22,isAffected22);
						});
					}
					break;
				case 79:
					if(_g16.length == 3) {
						var _g24 = _g16[0];
						var _g25 = _g24.e;
						var _g26 = _g24.p;
						var _g26 = _g24.t;
						if(_g25._hx_index == 1) {
							var v = _g25.v;
							var uv = _g16[1];
							var val = _g16[2];
							var v1 = this.get(v);
							writeTo.push(v1,15);
							this.check(uv,writeTo,isAffected);
							this.check(val,writeTo,isAffected);
							writeTo.pop();
							isAffected.append(v1,15);
						} else {
							var _g16 = this;
							var writeTo23 = writeTo;
							var isAffected23 = isAffected;
							hxsl_Tools.iter(e,function(e) {
								_g16.check(e,writeTo23,isAffected23);
							});
						}
					} else {
						var _g24 = this;
						var writeTo24 = writeTo;
						var isAffected24 = isAffected;
						hxsl_Tools.iter(e,function(e) {
							_g24.check(e,writeTo24,isAffected24);
						});
					}
					break;
				default:
					var _g25 = this;
					var writeTo25 = writeTo;
					var isAffected25 = isAffected;
					hxsl_Tools.iter(e,function(e) {
						_g25.check(e,writeTo25,isAffected25);
					});
				}
			} else {
				var _g26 = this;
				var writeTo26 = writeTo;
				var isAffected26 = isAffected;
				hxsl_Tools.iter(e,function(e) {
					_g26.check(e,writeTo26,isAffected26);
				});
			}
			break;
		case 9:
			var _g27 = _g.e;
			var _g28 = _g27.e;
			var _g29 = _g27.p;
			var _g29 = _g27.t;
			if(_g28._hx_index == 1) {
				var v = _g28.v;
				var swiz = _g.regs;
				this.link(v,writeTo,this.swizBits(swiz));
			} else {
				var _g27 = this;
				var writeTo27 = writeTo;
				var isAffected27 = isAffected;
				hxsl_Tools.iter(e,function(e) {
					_g27.check(e,writeTo27,isAffected27);
				});
			}
			break;
		case 10:
			var e1 = _g.econd;
			var eif = _g.eif;
			var eelse = _g.eelse;
			var affect = new hxsl__$Dce_WriteTo();
			this.check(eif,writeTo,affect);
			if(eelse != null) {
				this.check(eelse,writeTo,affect);
			}
			affect.appendTo(isAffected);
			writeTo.appendTo(affect);
			this.check(e1,affect,isAffected);
			break;
		case 13:
			var v = _g.v;
			var it = _g.it;
			var loop = _g.loop;
			var affect = new hxsl__$Dce_WriteTo();
			this.check(loop,writeTo,affect);
			affect.appendTo(isAffected);
			this.check(it,affect,isAffected);
			break;
		case 22:
			var _g28 = _g.target;
			var _g28 = _g.code;
			var args = _g.args;
			var _g = 0;
			while(_g < args.length) {
				var arg = args[_g];
				++_g;
				if(arg.access != hxsl_SyntaxArgAccess.Read) {
					var tvars = [[]];
					var findTVars = [null];
					findTVars[0] = (function(findTVars,tvars) {
						return function(e) {
							var _g = e.e;
							if(_g._hx_index == 1) {
								var v = _g.v;
								tvars[0].push(_gthis.get(v));
							} else {
								hxsl_Tools.iter(e,findTVars[0]);
							}
						};
					})(findTVars,tvars);
					findTVars[0](arg.e);
					var _g28 = 0;
					while(_g28 < tvars[0].length) {
						var v = tvars[0][_g28];
						++_g28;
						writeTo.push(v,15);
						var _g29 = 0;
						while(_g29 < args.length) {
							var arg2 = args[_g29];
							++_g29;
							if(arg2.access != hxsl_SyntaxArgAccess.Write) {
								this.check(arg2.e,writeTo,isAffected);
							}
						}
						writeTo.pop();
						isAffected.append(v,15);
					}
				} else {
					this.check(arg.e,writeTo,isAffected);
				}
			}
			break;
		default:
			var _g = this;
			var writeTo28 = writeTo;
			var isAffected28 = isAffected;
			hxsl_Tools.iter(e,function(e) {
				_g.check(e,writeTo28,isAffected28);
			});
		}
	}
	,checkBranches: function(e) {
		var _g = e.e;
		if(_g._hx_index == 10) {
			var _g1 = _g.eif;
			var _g1 = _g.eelse;
			var cond = _g.econd;
			var writeTo = new hxsl__$Dce_WriteTo();
			writeTo.append(null,0);
			this.check(cond,writeTo,new hxsl__$Dce_WriteTo());
		}
		hxsl_Tools.iter(e,$bind(this,this.checkBranches));
	}
	,mapExpr: function(e,isVar) {
		var _gthis = this;
		var _g = e.e;
		switch(_g._hx_index) {
		case 4:
			var el = _g.el;
			var out = [];
			var count = 0;
			var _g1 = 0;
			while(_g1 < el.length) {
				var e1 = el[_g1];
				++_g1;
				var isVar1 = isVar && count == el.length - 1;
				var e2 = this.mapExpr(e1,isVar1);
				if(hxsl_Tools.hasSideEffect(e2) || isVar1) {
					out.push(e2);
				}
				++count;
			}
			return { e : hxsl_TExprDef.TBlock(out), p : e.p, t : e.t};
		case 5:
			var _g1 = _g.op;
			var _g2 = _g.e1;
			var _g3 = _g.e2;
			switch(_g1._hx_index) {
			case 4:
				var _g3 = _g2.e;
				var _g4 = _g2.p;
				var _g4 = _g2.t;
				switch(_g3._hx_index) {
				case 1:
					var v = _g3.v;
					if(this.get(v).used == 0) {
						return { e : hxsl_TExprDef.TConst(hxsl_Const.CNull), t : e.t, p : e.p};
					} else {
						return hxsl_Tools.map(e,function(e) {
							return _gthis.mapExpr(e,true);
						});
					}
					break;
				case 9:
					var _g4 = _g3.e;
					var _g5 = _g4.e;
					var _g6 = _g4.p;
					var _g6 = _g4.t;
					if(_g5._hx_index == 1) {
						var _g4 = _g5.v;
						var v = _g4;
						if(this.get(v).used == 0) {
							return { e : hxsl_TExprDef.TConst(hxsl_Const.CNull), t : e.t, p : e.p};
						} else {
							var v = _g4;
							var swiz = _g3.regs;
							if((this.get(v).used & this.swizBits(swiz)) == 0) {
								return { e : hxsl_TExprDef.TConst(hxsl_Const.CNull), t : e.t, p : e.p};
							} else {
								return hxsl_Tools.map(e,function(e) {
									return _gthis.mapExpr(e,true);
								});
							}
						}
					} else {
						return hxsl_Tools.map(e,function(e) {
							return _gthis.mapExpr(e,true);
						});
					}
					break;
				case 16:
					var _g4 = _g3.e;
					var _g5 = _g3.index;
					var _g3 = _g4.e;
					var _g5 = _g4.p;
					var _g5 = _g4.t;
					if(_g3._hx_index == 1) {
						var v = _g3.v;
						if(this.get(v).used == 0) {
							return { e : hxsl_TExprDef.TConst(hxsl_Const.CNull), t : e.t, p : e.p};
						} else {
							return hxsl_Tools.map(e,function(e) {
								return _gthis.mapExpr(e,true);
							});
						}
					} else {
						return hxsl_Tools.map(e,function(e) {
							return _gthis.mapExpr(e,true);
						});
					}
					break;
				default:
					return hxsl_Tools.map(e,function(e) {
						return _gthis.mapExpr(e,true);
					});
				}
				break;
			case 20:
				var _g3 = _g1.op;
				var _g1 = _g2.e;
				var _g3 = _g2.p;
				var _g3 = _g2.t;
				switch(_g1._hx_index) {
				case 1:
					var v = _g1.v;
					if(this.get(v).used == 0) {
						return { e : hxsl_TExprDef.TConst(hxsl_Const.CNull), t : e.t, p : e.p};
					} else {
						return hxsl_Tools.map(e,function(e) {
							return _gthis.mapExpr(e,true);
						});
					}
					break;
				case 9:
					var _g2 = _g1.e;
					var _g3 = _g2.e;
					var _g4 = _g2.p;
					var _g4 = _g2.t;
					if(_g3._hx_index == 1) {
						var _g2 = _g3.v;
						var v = _g2;
						if(this.get(v).used == 0) {
							return { e : hxsl_TExprDef.TConst(hxsl_Const.CNull), t : e.t, p : e.p};
						} else {
							var v = _g2;
							var swiz = _g1.regs;
							if((this.get(v).used & this.swizBits(swiz)) == 0) {
								return { e : hxsl_TExprDef.TConst(hxsl_Const.CNull), t : e.t, p : e.p};
							} else {
								return hxsl_Tools.map(e,function(e) {
									return _gthis.mapExpr(e,true);
								});
							}
						}
					} else {
						return hxsl_Tools.map(e,function(e) {
							return _gthis.mapExpr(e,true);
						});
					}
					break;
				case 16:
					var _g2 = _g1.e;
					var _g3 = _g1.index;
					var _g1 = _g2.e;
					var _g3 = _g2.p;
					var _g3 = _g2.t;
					if(_g1._hx_index == 1) {
						var v = _g1.v;
						if(this.get(v).used == 0) {
							return { e : hxsl_TExprDef.TConst(hxsl_Const.CNull), t : e.t, p : e.p};
						} else {
							return hxsl_Tools.map(e,function(e) {
								return _gthis.mapExpr(e,true);
							});
						}
					} else {
						return hxsl_Tools.map(e,function(e) {
							return _gthis.mapExpr(e,true);
						});
					}
					break;
				default:
					return hxsl_Tools.map(e,function(e) {
						return _gthis.mapExpr(e,true);
					});
				}
				break;
			default:
				return hxsl_Tools.map(e,function(e) {
					return _gthis.mapExpr(e,true);
				});
			}
			break;
		case 7:
			var _g1 = _g.init;
			var v = _g.v;
			if(this.get(v).used == 0) {
				return { e : hxsl_TExprDef.TConst(hxsl_Const.CNull), t : e.t, p : e.p};
			} else {
				return hxsl_Tools.map(e,function(e) {
					return _gthis.mapExpr(e,true);
				});
			}
			break;
		case 8:
			var _g1 = _g.e;
			var _g2 = _g.args;
			var _g3 = _g1.e;
			var _g4 = _g1.p;
			var _g4 = _g1.t;
			if(_g3._hx_index == 2) {
				switch(_g3.g._hx_index) {
				case 64:
					if(_g2.length == 3) {
						var _g1 = _g2[0];
						var _g1 = _g2[2];
						var _g3 = _g1.e;
						var _g4 = _g1.p;
						var _g4 = _g1.t;
						if(_g3._hx_index == 0) {
							var _g1 = _g3.c;
							if(_g1._hx_index == 2) {
								var cid = _g1.v;
								var uv = _g2[1];
								var c = this.channelVars[cid];
								return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Texture), p : e.p, t : hxsl_Type.TVoid},[{ e : hxsl_TExprDef.TVar(c), t : c.type, p : e.p},this.mapExpr(uv,true)]), t : hxsl_Type.TVoid, p : e.p};
							} else {
								return hxsl_Tools.map(e,function(e) {
									return _gthis.mapExpr(e,true);
								});
							}
						} else {
							return hxsl_Tools.map(e,function(e) {
								return _gthis.mapExpr(e,true);
							});
						}
					} else {
						return hxsl_Tools.map(e,function(e) {
							return _gthis.mapExpr(e,true);
						});
					}
					break;
				case 65:
					if(_g2.length == 4) {
						var _g1 = _g2[0];
						var _g1 = _g2[3];
						var _g3 = _g1.e;
						var _g4 = _g1.p;
						var _g4 = _g1.t;
						if(_g3._hx_index == 0) {
							var _g1 = _g3.c;
							if(_g1._hx_index == 2) {
								var cid = _g1.v;
								var lod = _g2[2];
								var uv = _g2[1];
								var c = this.channelVars[cid];
								return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.TextureLod), p : e.p, t : hxsl_Type.TVoid},[{ e : hxsl_TExprDef.TVar(c), t : c.type, p : e.p},this.mapExpr(uv,true),this.mapExpr(lod,true)]), t : hxsl_Type.TVoid, p : e.p};
							} else {
								return hxsl_Tools.map(e,function(e) {
									return _gthis.mapExpr(e,true);
								});
							}
						} else {
							return hxsl_Tools.map(e,function(e) {
								return _gthis.mapExpr(e,true);
							});
						}
					} else {
						return hxsl_Tools.map(e,function(e) {
							return _gthis.mapExpr(e,true);
						});
					}
					break;
				case 66:
					switch(_g2.length) {
					case 3:
						var _g1 = _g2[0];
						var _g1 = _g2[2];
						var _g3 = _g1.e;
						var _g4 = _g1.p;
						var _g4 = _g1.t;
						if(_g3._hx_index == 0) {
							var _g1 = _g3.c;
							if(_g1._hx_index == 2) {
								var cid = _g1.v;
								var pos = _g2[1];
								var c = this.channelVars[cid];
								return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Texel), p : e.p, t : hxsl_Type.TVoid},[{ e : hxsl_TExprDef.TVar(c), t : c.type, p : e.p},this.mapExpr(pos,true)]), t : hxsl_Type.TVoid, p : e.p};
							} else {
								return hxsl_Tools.map(e,function(e) {
									return _gthis.mapExpr(e,true);
								});
							}
						} else {
							return hxsl_Tools.map(e,function(e) {
								return _gthis.mapExpr(e,true);
							});
						}
						break;
					case 4:
						var _g1 = _g2[0];
						var _g1 = _g2[3];
						var _g3 = _g1.e;
						var _g4 = _g1.p;
						var _g4 = _g1.t;
						if(_g3._hx_index == 0) {
							var _g1 = _g3.c;
							if(_g1._hx_index == 2) {
								var cid = _g1.v;
								var lod = _g2[2];
								var pos = _g2[1];
								var c = this.channelVars[cid];
								return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Texel), p : e.p, t : hxsl_Type.TVoid},[{ e : hxsl_TExprDef.TVar(c), t : c.type, p : e.p},this.mapExpr(pos,true),this.mapExpr(lod,true)]), t : hxsl_Type.TVoid, p : e.p};
							} else {
								return hxsl_Tools.map(e,function(e) {
									return _gthis.mapExpr(e,true);
								});
							}
						} else {
							return hxsl_Tools.map(e,function(e) {
								return _gthis.mapExpr(e,true);
							});
						}
						break;
					default:
						return hxsl_Tools.map(e,function(e) {
							return _gthis.mapExpr(e,true);
						});
					}
					break;
				case 67:
					switch(_g2.length) {
					case 2:
						var _g1 = _g2[0];
						var _g1 = _g2[1];
						var _g3 = _g1.e;
						var _g4 = _g1.p;
						var _g4 = _g1.t;
						if(_g3._hx_index == 0) {
							var _g1 = _g3.c;
							if(_g1._hx_index == 2) {
								var cid = _g1.v;
								var c = this.channelVars[cid];
								return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.TextureSize), p : e.p, t : hxsl_Type.TVoid},[{ e : hxsl_TExprDef.TVar(c), t : c.type, p : e.p}]), t : hxsl_Type.TVoid, p : e.p};
							} else {
								return hxsl_Tools.map(e,function(e) {
									return _gthis.mapExpr(e,true);
								});
							}
						} else {
							return hxsl_Tools.map(e,function(e) {
								return _gthis.mapExpr(e,true);
							});
						}
						break;
					case 3:
						var _g1 = _g2[0];
						var _g1 = _g2[2];
						var _g3 = _g1.e;
						var _g4 = _g1.p;
						var _g4 = _g1.t;
						if(_g3._hx_index == 0) {
							var _g1 = _g3.c;
							if(_g1._hx_index == 2) {
								var cid = _g1.v;
								var lod = _g2[1];
								var c = this.channelVars[cid];
								return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.TextureSize), p : e.p, t : hxsl_Type.TVoid},[{ e : hxsl_TExprDef.TVar(c), t : c.type, p : e.p},this.mapExpr(lod,true)]), t : hxsl_Type.TVoid, p : e.p};
							} else {
								return hxsl_Tools.map(e,function(e) {
									return _gthis.mapExpr(e,true);
								});
							}
						} else {
							return hxsl_Tools.map(e,function(e) {
								return _gthis.mapExpr(e,true);
							});
						}
						break;
					default:
						return hxsl_Tools.map(e,function(e) {
							return _gthis.mapExpr(e,true);
						});
					}
					break;
				default:
					return hxsl_Tools.map(e,function(e) {
						return _gthis.mapExpr(e,true);
					});
				}
			} else {
				return hxsl_Tools.map(e,function(e) {
					return _gthis.mapExpr(e,true);
				});
			}
			break;
		case 10:
			var e1 = _g.econd;
			var econd = _g.eif;
			var eelse = _g.eelse;
			var e2 = this.mapExpr(e1,true);
			var econd1 = this.mapExpr(econd,isVar);
			var eelse1 = eelse == null ? null : this.mapExpr(eelse,isVar);
			if(!isVar && !hxsl_Tools.hasSideEffect(econd1) && (eelse1 == null || !hxsl_Tools.hasSideEffect(eelse1))) {
				return { e : hxsl_TExprDef.TConst(hxsl_Const.CNull), t : e2.t, p : e2.p};
			}
			return { e : hxsl_TExprDef.TIf(e2,econd1,eelse1), p : e2.p, t : e2.t};
		case 13:
			var v = _g.v;
			var it = _g.it;
			var loop = _g.loop;
			var it1 = this.mapExpr(it,true);
			var loop1 = this.mapExpr(loop,false);
			if(!hxsl_Tools.hasSideEffect(loop1)) {
				return { e : hxsl_TExprDef.TConst(hxsl_Const.CNull), t : e.t, p : e.p};
			}
			return { e : hxsl_TExprDef.TFor(v,it1,loop1), p : e.p, t : e.t};
		case 20:
			var m = _g.m;
			var args = _g.args;
			var em = _g.e;
			var em1 = this.mapExpr(em,isVar);
			if(!isVar && !hxsl_Tools.hasSideEffect(em1)) {
				return { e : hxsl_TExprDef.TConst(hxsl_Const.CNull), t : e.t, p : e.p};
			}
			return { e : hxsl_TExprDef.TMeta(m,args,em1), t : e.t, p : e.p};
		default:
			return hxsl_Tools.map(e,function(e) {
				return _gthis.mapExpr(e,true);
			});
		}
	}
	,__class__: hxsl_Dce
};
var hxsl_Debug = function() { };
$hxClasses["hxsl.Debug"] = hxsl_Debug;
hxsl_Debug.__name__ = "hxsl.Debug";
hxsl_Debug.varName = function(v,swizBits) {
	if(swizBits == null) {
		swizBits = 15;
	}
	var name = v.name;
	if(swizBits != 15) {
		name += hxsl_Debug.swizStr(swizBits);
	}
	if(hxsl_Debug.VAR_IDS) {
		return name + "@" + v.id;
	} else {
		return name;
	}
};
hxsl_Debug.swizStr = function(bits) {
	var str = ".";
	if((bits & 1) != 0) {
		str += "x";
	}
	if((bits & 2) != 0) {
		str += "y";
	}
	if((bits & 4) != 0) {
		str += "z";
	}
	if((bits & 8) != 0) {
		str += "w";
	}
	return str;
};
var hxsl_Eval = function() {
	this.mapped = [];
	this.varMap = new haxe_ds_ObjectMap();
	this.funMap = new haxe_ds_ObjectMap();
	this.constants = new haxe_ds_IntMap();
};
$hxClasses["hxsl.Eval"] = hxsl_Eval;
hxsl_Eval.__name__ = "hxsl.Eval";
hxsl_Eval.prototype = {
	setConstant: function(v,c) {
		this.constants.h[v.id] = hxsl_TExprDef.TConst(c);
	}
	,mapVar: function(v,isLocal) {
		var v2 = this.varMap.h[v.__id__];
		if(v2 != null) {
			return v2;
		}
		if(v.parent != null) {
			this.mapVar(v.parent,isLocal);
			v2 = this.varMap.h[v.__id__];
			if(v2 != null) {
				if(v == v2) {
					return v2;
				} else {
					return this.mapVar(v2,isLocal);
				}
			}
		}
		var _g = v.type;
		var v21;
		if(_g._hx_index == 17) {
			var _g1 = _g.size;
			v21 = true;
		} else {
			v21 = false;
		}
		v2 = { id : v21 ? v.id : hxsl_Tools.allocVarId(), name : v.name, type : v.type, kind : v.kind};
		if(v.parent != null) {
			v2.parent = this.mapVar(v.parent,isLocal);
		}
		if(v.qualifiers != null) {
			v2.qualifiers = v.qualifiers.slice();
		}
		this.varMap.set(v,v2);
		this.varMap.set(v2,v2);
		if(isLocal) {
			this.mapped.push(v);
		}
		var _g = v2.type;
		switch(_g._hx_index) {
		case 13:
			var vl = _g.vl;
			var _g1 = [];
			var _g2 = 0;
			while(_g2 < vl.length) {
				var v = vl[_g2];
				++_g2;
				_g1.push(this.mapVar(v,isLocal));
			}
			v2.type = hxsl_Type.TStruct(_g1);
			break;
		case 15:
			var _g1 = _g.size;
			if(_g1._hx_index == 1) {
				var vs = _g1.v;
				var t = _g.t;
				var c = this.constants.h[vs.id];
				if(c != null) {
					if(c == null) {
						hxsl_Error.t("Integer value expected for array size constant " + vs.name,null);
					} else if(c._hx_index == 0) {
						var _g1 = c.c;
						if(_g1._hx_index == 2) {
							var v = _g1.v;
							var _g1 = v2.type;
							var tmp;
							switch(_g1._hx_index) {
							case 15:
								var _g2 = _g1.t;
								var _g2 = _g1.size;
								tmp = hxsl_Type.TArray(t,hxsl_SizeDecl.SConst(v));
								break;
							case 16:
								var _g2 = _g1.t;
								var _g2 = _g1.size;
								var kind = _g1.kind;
								tmp = hxsl_Type.TBuffer(t,hxsl_SizeDecl.SConst(v),kind);
								break;
							default:
								throw haxe_Exception.thrown("assert");
							}
							v2.type = tmp;
						} else {
							hxsl_Error.t("Integer value expected for array size constant " + vs.name,null);
						}
					} else {
						hxsl_Error.t("Integer value expected for array size constant " + vs.name,null);
					}
				} else {
					var vs2 = this.mapVar(vs,isLocal);
					var _g1 = v2.type;
					var tmp;
					switch(_g1._hx_index) {
					case 15:
						var _g2 = _g1.t;
						var _g2 = _g1.size;
						tmp = hxsl_Type.TArray(t,hxsl_SizeDecl.SVar(vs2));
						break;
					case 16:
						var _g2 = _g1.t;
						var _g2 = _g1.size;
						var kind = _g1.kind;
						tmp = hxsl_Type.TBuffer(t,hxsl_SizeDecl.SVar(vs2),kind);
						break;
					default:
						throw haxe_Exception.thrown("assert");
					}
					v2.type = tmp;
				}
			}
			break;
		case 16:
			var _g1 = _g.size;
			var _g2 = _g.kind;
			if(_g1._hx_index == 1) {
				var vs = _g1.v;
				var t = _g.t;
				var c = this.constants.h[vs.id];
				if(c != null) {
					if(c == null) {
						hxsl_Error.t("Integer value expected for array size constant " + vs.name,null);
					} else if(c._hx_index == 0) {
						var _g = c.c;
						if(_g._hx_index == 2) {
							var v = _g.v;
							var _g = v2.type;
							var tmp;
							switch(_g._hx_index) {
							case 15:
								var _g1 = _g.t;
								var _g1 = _g.size;
								tmp = hxsl_Type.TArray(t,hxsl_SizeDecl.SConst(v));
								break;
							case 16:
								var _g1 = _g.t;
								var _g1 = _g.size;
								var kind = _g.kind;
								tmp = hxsl_Type.TBuffer(t,hxsl_SizeDecl.SConst(v),kind);
								break;
							default:
								throw haxe_Exception.thrown("assert");
							}
							v2.type = tmp;
						} else {
							hxsl_Error.t("Integer value expected for array size constant " + vs.name,null);
						}
					} else {
						hxsl_Error.t("Integer value expected for array size constant " + vs.name,null);
					}
				} else {
					var vs2 = this.mapVar(vs,isLocal);
					var _g = v2.type;
					var tmp;
					switch(_g._hx_index) {
					case 15:
						var _g1 = _g.t;
						var _g1 = _g.size;
						tmp = hxsl_Type.TArray(t,hxsl_SizeDecl.SVar(vs2));
						break;
					case 16:
						var _g1 = _g.t;
						var _g1 = _g.size;
						var kind = _g.kind;
						tmp = hxsl_Type.TBuffer(t,hxsl_SizeDecl.SVar(vs2),kind);
						break;
					default:
						throw haxe_Exception.thrown("assert");
					}
					v2.type = tmp;
				}
			}
			break;
		default:
		}
		return v2;
	}
	,checkTextureRec: function(t) {
		if(hxsl_Tools.isTexture(t)) {
			return true;
		}
		switch(t._hx_index) {
		case 13:
			var vl = t.vl;
			var _g = 0;
			while(_g < vl.length) {
				var v = vl[_g];
				++_g;
				if(this.checkTextureRec(v.type)) {
					return true;
				}
			}
			return false;
		case 15:
			var _g = t.size;
			var t1 = t.t;
			return this.checkTextureRec(t1);
		case 16:
			var _g = t.t;
			var _g = t.size;
			var _g = t.kind;
			return true;
		default:
		}
		return false;
	}
	,needsInline: function(f) {
		var _g = 0;
		var _g1 = f.args;
		while(_g < _g1.length) {
			var a = _g1[_g];
			++_g;
			if(this.checkTextureRec(a.type)) {
				return true;
			}
		}
		return false;
	}
	,'eval': function(s) {
		var funs = [];
		var _g = 0;
		var _g1 = s.funs;
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			var f1 = f.kind;
			var f2 = this.mapVar(f.ref,false);
			var _g2 = [];
			var _g3 = 0;
			var _g4 = f.args;
			while(_g3 < _g4.length) {
				var a = _g4[_g3];
				++_g3;
				_g2.push(this.mapVar(a,false));
			}
			var f21 = { kind : f1, ref : f2, args : _g2, ret : f.ret, expr : f.expr};
			if(f.kind == hxsl_FunctionKind.Helper && this.inlineCalls || this.needsInline(f21)) {
				this.funMap.set(f21.ref,f);
			} else {
				funs.push(f21);
			}
		}
		var _g = 0;
		var _g1 = funs.length;
		while(_g < _g1) {
			var i = _g++;
			this.curFun = funs[i];
			this.curFun.expr = this.evalExpr(this.curFun.expr,false);
		}
		var s1 = s.name;
		var _g = [];
		var _g1 = 0;
		var _g2 = s.vars;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			_g.push(this.mapVar(v,false));
		}
		return { name : s1, vars : _g, funs : funs};
	}
	,hasReturn: function(e) {
		this.markReturn = false;
		this.hasReturnLoop(e);
		return this.markReturn;
	}
	,hasReturnLoop: function(e) {
		var _g = e.e;
		if(_g._hx_index == 12) {
			var _g1 = _g.e;
			this.markReturn = true;
		} else if(!this.markReturn) {
			hxsl_Tools.iter(e,$bind(this,this.hasReturnLoop));
		}
	}
	,handleReturn: function(e,isFinal) {
		if(isFinal == null) {
			isFinal = false;
		}
		var _g = e.e;
		switch(_g._hx_index) {
		case 3:
			var v = _g.e;
			var v1 = this.handleReturn(v,isFinal);
			return { e : hxsl_TExprDef.TParenthesis(v1), t : v1.t, p : e.p};
		case 4:
			var el = _g.el;
			var i = 0;
			var last = el.length;
			var out = [];
			_hx_loop1: while(i < last) {
				var e1 = el[i++];
				if(i == last) {
					out.push(this.handleReturn(e1,isFinal));
				} else {
					var _g1 = e1.e;
					switch(_g1._hx_index) {
					case 10:
						if(_g1.eelse == null) {
							var eif = _g1.eif;
							var econd = _g1.econd;
							if(isFinal && this.hasReturn(eif)) {
								out.push(this.handleReturn({ e : hxsl_TExprDef.TIf(econd,eif,{ e : hxsl_TExprDef.TBlock(el.slice(i)), t : e1.t, p : e1.p}), t : e1.t, p : e1.p}));
								break _hx_loop1;
							} else {
								out.push(this.handleReturn(e1));
							}
						} else {
							out.push(this.handleReturn(e1));
						}
						break;
					case 12:
						var e2 = _g1.e;
						out.push(this.handleReturn(e2,isFinal));
						break _hx_loop1;
					default:
						out.push(this.handleReturn(e1));
					}
				}
			}
			var t = isFinal ? out.length == 0 ? hxsl_Type.TVoid : out[out.length - 1].t : e.t;
			return { e : hxsl_TExprDef.TBlock(out), t : t, p : e.p};
		case 10:
			var cond = _g.econd;
			var eif = _g.eif;
			var eelse = _g.eelse;
			if(eelse != null && isFinal) {
				var cond1 = this.handleReturn(cond);
				var eif1 = this.handleReturn(eif,isFinal);
				return { e : hxsl_TExprDef.TIf(cond1,eif1,this.handleReturn(eelse,isFinal)), t : eif1.t, p : e.p};
			} else {
				return hxsl_Tools.map(e,$bind(this,this.handleReturnDef));
			}
			break;
		case 12:
			var v = _g.e;
			if(!isFinal) {
				hxsl_Error.t("Cannot inline not final return",e.p);
			}
			if(v == null) {
				return { e : hxsl_TExprDef.TBlock([]), t : hxsl_Type.TVoid, p : e.p};
			}
			return this.handleReturn(v,true);
		default:
			return hxsl_Tools.map(e,$bind(this,this.handleReturnDef));
		}
	}
	,handleReturnDef: function(e) {
		return this.handleReturn(e);
	}
	,evalCall: function(g,args,oldArgs,pos) {
		switch(g._hx_index) {
		case 28:
			if(args.length == 1) {
				var _g = args[0];
				var _g1 = _g.e;
				var _g2 = _g.p;
				var _g2 = _g.t;
				if(_g1._hx_index == 1) {
					var v = _g1.v;
					var _g = v.type;
					if(_g._hx_index == 15) {
						var _g1 = _g.t;
						var _g1 = _g.size;
						if(_g1._hx_index == 0) {
							var v = _g1.v;
							return hxsl_TExprDef.TConst(hxsl_Const.CInt(v));
						} else {
							return null;
						}
					} else {
						return null;
					}
				} else {
					return null;
				}
			} else {
				return null;
			}
			break;
		case 39:
			if(args.length == 1) {
				var _g = args[0];
				var _g1 = _g.e;
				var _g2 = _g.p;
				var _g2 = _g.t;
				if(_g1._hx_index == 0) {
					var _g = _g1.c;
					if(_g._hx_index == 2) {
						var i = _g.v;
						return hxsl_TExprDef.TConst(hxsl_Const.CFloat(i));
					} else {
						return null;
					}
				} else {
					return null;
				}
			} else {
				return null;
			}
			break;
		case 64:case 65:
			var i;
			var _g = args[0].e;
			if(_g._hx_index == 0) {
				var _g1 = _g.c;
				if(_g1._hx_index == 2) {
					var i1 = _g1.v;
					i = i1;
				} else {
					hxsl_Error.t("Cannot eval complex channel " + hxsl_Printer.toString(args[0],true) + " " + this.constantsToString(),pos);
					throw haxe_Exception.thrown("assert");
				}
			} else {
				hxsl_Error.t("Cannot eval complex channel " + hxsl_Printer.toString(args[0],true) + " " + this.constantsToString(),pos);
				throw haxe_Exception.thrown("assert");
			}
			var channel = oldArgs[0];
			var _g = channel.e;
			var channel1;
			if(_g._hx_index == 1) {
				var v = _g.v;
				channel1 = hxsl_TExprDef.TVar(this.mapVar(v,false));
			} else {
				throw haxe_Exception.thrown("assert");
			}
			channel = { e : channel1, t : channel.t, p : channel.p};
			var count;
			var _g = channel.t;
			if(_g._hx_index == 17) {
				var i1 = _g.size;
				count = i1;
			} else {
				throw haxe_Exception.thrown("assert");
			}
			var channelMode = Type.createEnumIndex(hxsl_Channel,i & 7,null);
			var targs = [channel];
			var _g = 1;
			var _g1 = args.length;
			while(_g < _g1) {
				var i1 = _g++;
				targs.push(args[i1]);
			}
			targs.push({ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(i >> 3)), t : hxsl_Type.TInt, p : pos});
			var tget = { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(g), t : hxsl_Type.TVoid, p : pos},targs), t : hxsl_Type.TVoid, p : pos};
			switch(channelMode._hx_index) {
			case 0:
				var zero = { e : hxsl_TExprDef.TConst(hxsl_Const.CFloat(0.)), t : hxsl_Type.TFloat, p : pos};
				if(count == 1) {
					return zero.e;
				}
				return hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal([hxsl_TGlobal.Vec2,hxsl_TGlobal.Vec3,hxsl_TGlobal.Vec4][count - 2]), t : hxsl_Type.TVoid, p : pos},[zero]);
			case 1:case 2:case 3:case 4:
				var tmp;
				switch(count) {
				case 1:
					switch(channelMode._hx_index) {
					case 1:
						tmp = [hxsl_Component.X];
						break;
					case 2:
						tmp = [hxsl_Component.Y];
						break;
					case 3:
						tmp = [hxsl_Component.Z];
						break;
					case 4:
						tmp = [hxsl_Component.W];
						break;
					default:
						throw haxe_Exception.thrown("Invalid channel value " + Std.string(channelMode) + " for " + count + " channels");
					}
					break;
				case 2:
					switch(channelMode._hx_index) {
					case 1:
						tmp = [hxsl_Component.X,hxsl_Component.Y];
						break;
					case 2:
						tmp = [hxsl_Component.Y,hxsl_Component.Z];
						break;
					case 3:
						tmp = [hxsl_Component.Z,hxsl_Component.W];
						break;
					default:
						throw haxe_Exception.thrown("Invalid channel value " + Std.string(channelMode) + " for " + count + " channels");
					}
					break;
				case 3:
					switch(channelMode._hx_index) {
					case 1:
						tmp = [hxsl_Component.X,hxsl_Component.Y,hxsl_Component.Z];
						break;
					case 2:
						tmp = [hxsl_Component.Y,hxsl_Component.Z,hxsl_Component.W];
						break;
					default:
						throw haxe_Exception.thrown("Invalid channel value " + Std.string(channelMode) + " for " + count + " channels");
					}
					break;
				default:
					throw haxe_Exception.thrown("Invalid channel value " + Std.string(channelMode) + " for " + count + " channels");
				}
				return hxsl_TExprDef.TSwiz(tget,tmp);
			case 5:
				return hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Unpack), t : hxsl_Type.TVoid, p : pos},[tget]);
			case 6:
				return hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.UnpackNormal), t : hxsl_Type.TVoid, p : pos},[tget]);
			}
			break;
		case 68:
			var args1 = args;
			var _g = 0;
			while(_g < args1.length) {
				var a = args1[_g];
				++_g;
				haxe_Log.trace(hxsl_Printer.toString(a),{ fileName : a.p.file, lineNumber : 0, className : null, methodName : null});
			}
			return hxsl_TExprDef.TBlock([]);
		default:
			return null;
		}
	}
	,constantsToString: function() {
		var _g = [];
		var c = this.constants.keys();
		while(c.hasNext()) {
			var c1 = c.next();
			_g.push(c1 + " => " + hxsl_Printer.toString({ e : this.constants.h[c1], t : hxsl_Type.TVoid, p : null},true));
		}
		return _g.toString();
	}
	,ifBlock: function(e) {
		var tmp;
		if(e != null) {
			var _g = e.e;
			var tmp1;
			if(_g._hx_index == 10) {
				var _g1 = _g.econd;
				var _g1 = _g.eif;
				var _g1 = _g.eelse;
				tmp1 = true;
			} else {
				tmp1 = false;
			}
			tmp = !tmp1;
		} else {
			tmp = true;
		}
		if(tmp) {
			return e;
		}
		return { e : hxsl_TExprDef.TBlock([e]), t : e.t, p : e.p};
	}
	,evalExpr: function(e,isVal) {
		if(isVal == null) {
			isVal = true;
		}
		var _gthis = this;
		var t = e.t;
		var d;
		var _g = e.e;
		switch(_g._hx_index) {
		case 0:
			var _g1 = _g.c;
			d = e.e;
			break;
		case 1:
			var v = _g.v;
			var c = this.constants.h[v.id];
			if(c != null) {
				d = c;
			} else {
				var v2 = this.mapVar(v,false);
				t = v2.type;
				d = hxsl_TExprDef.TVar(v2);
			}
			break;
		case 2:
			var _g1 = _g.g;
			d = e.e;
			break;
		case 3:
			var e1 = _g.e;
			var e2 = this.evalExpr(e1,isVal);
			var _g1 = e2.e;
			if(_g1._hx_index == 0) {
				var _g2 = _g1.c;
				d = e2.e;
			} else {
				d = hxsl_TExprDef.TParenthesis(e2);
			}
			break;
		case 4:
			var el = _g.el;
			var index = this.mapped.length;
			var out = [];
			var last = el.length - 1;
			var _g1 = 0;
			var _g2 = el.length;
			while(_g1 < _g2) {
				var i = _g1++;
				var isVal1 = isVal && i == last;
				var e1 = this.evalExpr(el[i],isVal1);
				var _g3 = e1.e;
				switch(_g3._hx_index) {
				case 0:
					var _g4 = _g3.c;
					if(isVal1) {
						out.push(e1);
					}
					break;
				case 1:
					var _g5 = _g3.v;
					if(isVal1) {
						out.push(e1);
					}
					break;
				default:
					out.push(e1);
				}
			}
			while(this.mapped.length > index) {
				var v = this.mapped.pop();
				var v2 = this.varMap.h[v.__id__];
				if(v2 != null) {
					this.varMap.remove(v);
					this.varMap.remove(v2);
				}
			}
			d = out.length == 1 && this.curFun.kind != hxsl_FunctionKind.Init ? out[0].e : hxsl_TExprDef.TBlock(out);
			break;
		case 5:
			var op = _g.op;
			var e1 = _g.e1;
			var e2 = _g.e2;
			var e11 = this.evalExpr(e1);
			var e21 = this.evalExpr(e2);
			switch(op._hx_index) {
			case 0:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					switch(_g3._hx_index) {
					case 2:
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 2) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CInt(a + b | 0));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 3:
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 3) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CFloat(a + b));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					default:
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 1:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					switch(_g3._hx_index) {
					case 2:
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 2) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CInt(a * b | 0));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 3:
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 3) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CFloat(a * b));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					default:
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 2:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					switch(_g3._hx_index) {
					case 2:
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 2) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CInt(a / b | 0));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 3:
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 3) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CFloat(a / b));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					default:
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 3:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					switch(_g3._hx_index) {
					case 2:
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 2) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CInt(a - b | 0));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 3:
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 3) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CFloat(a - b));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					default:
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 4:case 21:
				d = hxsl_TExprDef.TBinop(op,e11,e21);
				break;
			case 5:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					switch(_g3._hx_index) {
					case 0:
						d = _g2._hx_index == 0 ? _g2.c._hx_index == 0 ? hxsl_TExprDef.TConst(hxsl_Const.CBool(true)) : hxsl_TExprDef.TConst(hxsl_Const.CBool(false)) : hxsl_TExprDef.TBinop(op,e11,e21);
						break;
					case 1:
						var _g1 = _g3.b;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 1:
								var b = _g4.b;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a == b ? 0 : 1) == 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 2:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 2:
								var b = _g4.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(a - b == 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 3:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 3:
								var b = _g4.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a > b ? 1 : a == b ? 0 : -1) == 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 4:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g3 = _g2.c;
							switch(_g3._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 4:
								var b = _g3.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a > b ? 1 : a == b ? 0 : -1) == 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 6:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					switch(_g3._hx_index) {
					case 0:
						d = _g2._hx_index == 0 ? _g2.c._hx_index == 0 ? hxsl_TExprDef.TConst(hxsl_Const.CBool(false)) : hxsl_TExprDef.TConst(hxsl_Const.CBool(true)) : hxsl_TExprDef.TBinop(op,e11,e21);
						break;
					case 1:
						var _g1 = _g3.b;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 1:
								var b = _g4.b;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a == b ? 0 : 1) != 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 2:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 2:
								var b = _g4.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(a - b != 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 3:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 3:
								var b = _g4.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a > b ? 1 : a == b ? 0 : -1) != 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 4:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g3 = _g2.c;
							switch(_g3._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 4:
								var b = _g3.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a > b ? 1 : a == b ? 0 : -1) != 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 7:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					switch(_g3._hx_index) {
					case 0:
						d = _g2._hx_index == 0 ? _g2.c._hx_index == 0 ? hxsl_TExprDef.TConst(hxsl_Const.CBool(false)) : hxsl_TExprDef.TConst(hxsl_Const.CBool(false)) : hxsl_TExprDef.TBinop(op,e11,e21);
						break;
					case 1:
						var _g1 = _g3.b;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 1:
								var b = _g4.b;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a == b ? 0 : 1) > 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 2:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 2:
								var b = _g4.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(a - b > 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 3:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 3:
								var b = _g4.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a > b ? 1 : a == b ? 0 : -1) > 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 4:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g3 = _g2.c;
							switch(_g3._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 4:
								var b = _g3.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a > b ? 1 : a == b ? 0 : -1) > 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 8:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					switch(_g3._hx_index) {
					case 0:
						d = _g2._hx_index == 0 ? _g2.c._hx_index == 0 ? hxsl_TExprDef.TConst(hxsl_Const.CBool(true)) : hxsl_TExprDef.TConst(hxsl_Const.CBool(false)) : hxsl_TExprDef.TBinop(op,e11,e21);
						break;
					case 1:
						var _g1 = _g3.b;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 1:
								var b = _g4.b;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a == b ? 0 : 1) >= 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 2:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 2:
								var b = _g4.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(a - b >= 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 3:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 3:
								var b = _g4.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a > b ? 1 : a == b ? 0 : -1) >= 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 4:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g3 = _g2.c;
							switch(_g3._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 4:
								var b = _g3.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a > b ? 1 : a == b ? 0 : -1) >= 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 9:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					switch(_g3._hx_index) {
					case 0:
						d = _g2._hx_index == 0 ? _g2.c._hx_index == 0 ? hxsl_TExprDef.TConst(hxsl_Const.CBool(false)) : hxsl_TExprDef.TConst(hxsl_Const.CBool(true)) : hxsl_TExprDef.TBinop(op,e11,e21);
						break;
					case 1:
						var _g1 = _g3.b;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 1:
								var b = _g4.b;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a == b ? 0 : 1) < 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 2:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 2:
								var b = _g4.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(a - b < 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 3:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 3:
								var b = _g4.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a > b ? 1 : a == b ? 0 : -1) < 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 4:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g3 = _g2.c;
							switch(_g3._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 4:
								var b = _g3.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a > b ? 1 : a == b ? 0 : -1) < 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 10:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					switch(_g3._hx_index) {
					case 0:
						d = _g2._hx_index == 0 ? _g2.c._hx_index == 0 ? hxsl_TExprDef.TConst(hxsl_Const.CBool(true)) : hxsl_TExprDef.TConst(hxsl_Const.CBool(true)) : hxsl_TExprDef.TBinop(op,e11,e21);
						break;
					case 1:
						var _g1 = _g3.b;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 1:
								var b = _g4.b;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a == b ? 0 : 1) <= 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 2:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 2:
								var b = _g4.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(a - b <= 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 3:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 3:
								var b = _g4.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a > b ? 1 : a == b ? 0 : -1) <= 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 4:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g3 = _g2.c;
							switch(_g3._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 4:
								var b = _g3.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a > b ? 1 : a == b ? 0 : -1) <= 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 11:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					if(_g3._hx_index == 2) {
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 2) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CInt(a & b));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
					} else {
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 12:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					if(_g3._hx_index == 2) {
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 2) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CInt(a | b));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
					} else {
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 13:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					if(_g3._hx_index == 2) {
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 2) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CInt(a ^ b));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
					} else {
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 14:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					if(_g3._hx_index == 1) {
						var _g1 = _g3.b;
						if(_g2._hx_index == 0) {
							var _g3 = _g2.c;
							if(_g3._hx_index == 1) {
								var b = _g3.b;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(a && b));
							} else {
								var a = _g1;
								d = a == false ? hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) : e21.e;
							}
						} else {
							var a = _g1;
							d = a == false ? hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) : e21.e;
						}
					} else if(_g2._hx_index == 0) {
						var _g1 = _g2.c;
						if(_g1._hx_index == 1) {
							var a = _g1.b;
							d = a == false ? hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) : e11.e;
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
					} else {
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else if(_g2._hx_index == 0) {
					var _g1 = _g2.c;
					if(_g1._hx_index == 1) {
						var a = _g1.b;
						d = a == false ? hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) : e11.e;
					} else {
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 15:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					if(_g3._hx_index == 1) {
						var _g1 = _g3.b;
						if(_g2._hx_index == 0) {
							var _g3 = _g2.c;
							if(_g3._hx_index == 1) {
								var b = _g3.b;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(a || b));
							} else {
								var a = _g1;
								d = a == true ? hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) : e21.e;
							}
						} else {
							var a = _g1;
							d = a == true ? hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) : e21.e;
						}
					} else if(_g2._hx_index == 0) {
						var _g1 = _g2.c;
						if(_g1._hx_index == 1) {
							var a = _g1.b;
							d = a == true ? hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) : e11.e;
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
					} else {
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else if(_g2._hx_index == 0) {
					var _g1 = _g2.c;
					if(_g1._hx_index == 1) {
						var a = _g1.b;
						d = a == true ? hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) : e11.e;
					} else {
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 16:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					if(_g3._hx_index == 2) {
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 2) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CInt(a << b));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
					} else {
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 17:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					if(_g3._hx_index == 2) {
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 2) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CInt(a >> b));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
					} else {
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 18:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					if(_g3._hx_index == 2) {
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 2) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CInt(a >>> b));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
					} else {
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 19:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					switch(_g3._hx_index) {
					case 2:
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 2) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CInt(a % b | 0));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 3:
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 3) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CFloat(a % b));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					default:
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 20:
				var _g1 = op.op;
				d = hxsl_TExprDef.TBinop(op,e11,e21);
				break;
			default:
				throw haxe_Exception.thrown("assert");
			}
			break;
		case 6:
			var op = _g.op;
			var e1 = _g.e1;
			var e2 = this.evalExpr(e1);
			var _g1 = e2.e;
			if(_g1._hx_index == 0) {
				var c = _g1.c;
				switch(op._hx_index) {
				case 2:
					if(c._hx_index == 1) {
						var b = c.b;
						d = hxsl_TExprDef.TConst(hxsl_Const.CBool(!b));
					} else {
						d = hxsl_TExprDef.TUnop(op,e2);
					}
					break;
				case 3:
					switch(c._hx_index) {
					case 2:
						var i = c.v;
						d = hxsl_TExprDef.TConst(hxsl_Const.CInt(-i));
						break;
					case 3:
						var f = c.v;
						d = hxsl_TExprDef.TConst(hxsl_Const.CFloat(-f));
						break;
					default:
						d = hxsl_TExprDef.TUnop(op,e2);
					}
					break;
				default:
					d = hxsl_TExprDef.TUnop(op,e2);
				}
			} else {
				d = hxsl_TExprDef.TUnop(op,e2);
			}
			break;
		case 7:
			var v = _g.v;
			var init = _g.init;
			d = hxsl_TExprDef.TVarDecl(this.mapVar(v,true),init == null ? null : this.evalExpr(init));
			break;
		case 8:
			var c = _g.e;
			var eargs = _g.args;
			var c1 = this.evalExpr(c);
			var _g1 = [];
			var _g2 = 0;
			while(_g2 < eargs.length) {
				var a = eargs[_g2];
				++_g2;
				_g1.push(this.evalExpr(a));
			}
			var args = _g1;
			var _g1 = c1.e;
			switch(_g1._hx_index) {
			case 1:
				var v = _g1.v;
				if(this.funMap.h.__keys__[v.__id__] != null) {
					var f = this.funMap.h[v.__id__];
					var outExprs = [];
					var undo = [];
					var _g2 = 0;
					var _g3 = f.args.length;
					while(_g2 < _g3) {
						var i = _g2++;
						var v = [f.args[i]];
						var e1 = args[i];
						var _g4 = e1.e;
						switch(_g4._hx_index) {
						case 0:
							var _g5 = _g4.c;
							var old = [this.constants.h[v[0].id]];
							undo.push((function(old,v) {
								return function() {
									if(old[0] == null) {
										_gthis.constants.remove(v[0].id);
									} else {
										_gthis.constants.h[v[0].id] = old[0];
									}
								};
							})(old,v));
							this.constants.h[v[0].id] = e1.e;
							break;
						case 1:
							var _g6 = _g4.v;
							var _g7 = _g6.id;
							var _g8 = _g6.name;
							var _g9 = _g6.parent;
							var _g10 = _g6.qualifiers;
							var _g11 = _g6.type;
							switch(_g6.kind._hx_index) {
							case 0:case 1:case 2:
								var old1 = [this.constants.h[v[0].id]];
								undo.push((function(old,v) {
									return function() {
										if(old[0] == null) {
											_gthis.constants.remove(v[0].id);
										} else {
											_gthis.constants.h[v[0].id] = old[0];
										}
									};
								})(old1,v));
								this.constants.h[v[0].id] = e1.e;
								break;
							default:
								var old2 = [this.varMap.h[v[0].__id__]];
								if(old2[0] == null) {
									undo.push((function(v) {
										return function() {
											_gthis.varMap.remove(v[0]);
										};
									})(v));
								} else {
									this.varMap.remove(v[0]);
									undo.push((function(old,v) {
										return function() {
											_gthis.varMap.set(v[0],old[0]);
										};
									})(old2,v));
								}
								var v2 = this.mapVar(v[0],false);
								outExprs.push({ e : hxsl_TExprDef.TVarDecl(v2,e1), t : hxsl_Type.TVoid, p : e1.p});
							}
							break;
						default:
							var old3 = [this.varMap.h[v[0].__id__]];
							if(old3[0] == null) {
								undo.push((function(v) {
									return function() {
										_gthis.varMap.remove(v[0]);
									};
								})(v));
							} else {
								this.varMap.remove(v[0]);
								undo.push((function(old,v) {
									return function() {
										_gthis.varMap.set(v[0],old[0]);
									};
								})(old3,v));
							}
							var v21 = this.mapVar(v[0],false);
							outExprs.push({ e : hxsl_TExprDef.TVarDecl(v21,e1), t : hxsl_Type.TVoid, p : e1.p});
						}
					}
					var e1 = this.handleReturn(this.evalExpr(f.expr,false),true);
					var _g2 = 0;
					while(_g2 < undo.length) {
						var u = undo[_g2];
						++_g2;
						u();
					}
					var _g2 = e1.e;
					if(_g2._hx_index == 4) {
						var el = _g2.el;
						var _g2 = 0;
						while(_g2 < el.length) {
							var e2 = el[_g2];
							++_g2;
							outExprs.push(e2);
						}
					} else {
						outExprs.push(e1);
					}
					d = hxsl_TExprDef.TBlock(outExprs);
				} else {
					d = hxsl_TExprDef.TCall(c1,args);
				}
				break;
			case 2:
				var g = _g1.g;
				var v1 = this.evalCall(g,args,eargs,e.p);
				d = v1 != null ? v1 : hxsl_TExprDef.TCall(c1,args);
				break;
			default:
				d = hxsl_Error.t("Cannot eval non-static call expresssion '" + new hxsl_Printer().exprString(c1) + "'",c1.p);
			}
			break;
		case 9:
			var e1 = _g.e;
			var r = _g.regs;
			d = hxsl_TExprDef.TSwiz(this.evalExpr(e1),r.slice());
			break;
		case 10:
			var econd = _g.econd;
			var eif = _g.eif;
			var eelse = _g.eelse;
			var econd1 = this.evalExpr(econd);
			var _g1 = econd1.e;
			if(_g1._hx_index == 0) {
				var _g2 = _g1.c;
				if(_g2._hx_index == 1) {
					var b = _g2.b;
					d = b ? this.evalExpr(eif,isVal).e : eelse == null ? hxsl_TExprDef.TConst(hxsl_Const.CNull) : this.evalExpr(eelse,isVal).e;
				} else if(isVal && eelse != null && this.eliminateConditionals) {
					d = hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mix), t : e.t, p : e.p},[this.evalExpr(eelse,true),this.evalExpr(eif,true),{ e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.ToFloat), t : hxsl_Type.TFun([]), p : econd1.p},[econd1]), t : hxsl_Type.TFloat, p : e.p}]);
				} else {
					eif = this.evalExpr(eif,isVal);
					if(eelse != null) {
						eelse = this.evalExpr(eelse,isVal);
						var _g1 = eelse.e;
						if(_g1._hx_index == 0 && _g1.c._hx_index == 0) {
							eelse = null;
						}
					}
					eif = this.ifBlock(eif);
					eelse = this.ifBlock(eelse);
					d = hxsl_TExprDef.TIf(econd1,eif,eelse);
				}
			} else if(isVal && eelse != null && this.eliminateConditionals) {
				d = hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mix), t : e.t, p : e.p},[this.evalExpr(eelse,true),this.evalExpr(eif,true),{ e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.ToFloat), t : hxsl_Type.TFun([]), p : econd1.p},[econd1]), t : hxsl_Type.TFloat, p : e.p}]);
			} else {
				eif = this.evalExpr(eif,isVal);
				if(eelse != null) {
					eelse = this.evalExpr(eelse,isVal);
					var _g1 = eelse.e;
					if(_g1._hx_index == 0 && _g1.c._hx_index == 0) {
						eelse = null;
					}
				}
				eif = this.ifBlock(eif);
				eelse = this.ifBlock(eelse);
				d = hxsl_TExprDef.TIf(econd1,eif,eelse);
			}
			break;
		case 11:
			d = hxsl_TExprDef.TDiscard;
			break;
		case 12:
			var e1 = _g.e;
			d = hxsl_TExprDef.TReturn(e1 == null ? null : this.evalExpr(e1));
			break;
		case 13:
			var v1 = _g.v;
			var it = _g.it;
			var loop = _g.loop;
			var v2 = this.mapVar(v1,true);
			var it1 = this.evalExpr(it);
			var e1;
			var _g1 = it1.e;
			if(_g1._hx_index == 5) {
				var _g2 = _g1.e1;
				var _g3 = _g1.e2;
				if(_g1.op._hx_index == 21) {
					var _g1 = _g2.e;
					var _g4 = _g2.p;
					var _g4 = _g2.t;
					if(_g1._hx_index == 0) {
						var _g2 = _g1.c;
						if(_g2._hx_index == 2) {
							var _g1 = _g3.e;
							var _g4 = _g3.p;
							var _g4 = _g3.t;
							if(_g1._hx_index == 0) {
								var _g3 = _g1.c;
								if(_g3._hx_index == 2) {
									var len = _g3.v;
									var start = _g2.v;
									if(this.unrollLoops) {
										var out = [];
										var _g1 = start;
										var _g2 = len;
										while(_g1 < _g2) {
											var i = _g1++;
											this.constants.h[v1.id] = hxsl_TExprDef.TConst(hxsl_Const.CInt(i));
											out.push(this.evalExpr(loop,false));
										}
										this.constants.remove(v1.id);
										e1 = hxsl_TExprDef.TBlock(out);
									} else {
										e1 = hxsl_TExprDef.TFor(v2,it1,this.ifBlock(this.evalExpr(loop,false)));
									}
								} else {
									e1 = hxsl_TExprDef.TFor(v2,it1,this.ifBlock(this.evalExpr(loop,false)));
								}
							} else {
								e1 = hxsl_TExprDef.TFor(v2,it1,this.ifBlock(this.evalExpr(loop,false)));
							}
						} else {
							e1 = hxsl_TExprDef.TFor(v2,it1,this.ifBlock(this.evalExpr(loop,false)));
						}
					} else {
						e1 = hxsl_TExprDef.TFor(v2,it1,this.ifBlock(this.evalExpr(loop,false)));
					}
				} else {
					e1 = hxsl_TExprDef.TFor(v2,it1,this.ifBlock(this.evalExpr(loop,false)));
				}
			} else {
				e1 = hxsl_TExprDef.TFor(v2,it1,this.ifBlock(this.evalExpr(loop,false)));
			}
			this.varMap.remove(v1);
			d = e1;
			break;
		case 14:
			d = hxsl_TExprDef.TContinue;
			break;
		case 15:
			d = hxsl_TExprDef.TBreak;
			break;
		case 16:
			var e1 = _g.e;
			var e2 = _g.index;
			var e11 = this.evalExpr(e1);
			var e21 = this.evalExpr(e2);
			var _g1 = e11.e;
			var _g2 = e21.e;
			if(_g1._hx_index == 17) {
				if(_g2._hx_index == 0) {
					var _g3 = _g2.c;
					if(_g3._hx_index == 2) {
						var i = _g3.v;
						var el = _g1.el;
						if(i >= 0 && i < el.length) {
							d = el[i].e;
						} else {
							var _g1 = e11.t;
							switch(_g1._hx_index) {
							case 15:
								var _g2 = _g1.size;
								var at = _g1.t;
								t = at;
								break;
							case 16:
								var _g2 = _g1.size;
								var _g2 = _g1.kind;
								var at = _g1.t;
								t = at;
								break;
							default:
							}
							d = hxsl_TExprDef.TArray(e11,e21);
						}
					} else {
						var _g1 = e11.t;
						switch(_g1._hx_index) {
						case 15:
							var _g2 = _g1.size;
							var at = _g1.t;
							t = at;
							break;
						case 16:
							var _g2 = _g1.size;
							var _g2 = _g1.kind;
							var at = _g1.t;
							t = at;
							break;
						default:
						}
						d = hxsl_TExprDef.TArray(e11,e21);
					}
				} else {
					var _g1 = e11.t;
					switch(_g1._hx_index) {
					case 15:
						var _g2 = _g1.size;
						var at = _g1.t;
						t = at;
						break;
					case 16:
						var _g2 = _g1.size;
						var _g2 = _g1.kind;
						var at = _g1.t;
						t = at;
						break;
					default:
					}
					d = hxsl_TExprDef.TArray(e11,e21);
				}
			} else {
				var _g1 = e11.t;
				switch(_g1._hx_index) {
				case 15:
					var _g2 = _g1.size;
					var at = _g1.t;
					t = at;
					break;
				case 16:
					var _g2 = _g1.size;
					var _g2 = _g1.kind;
					var at = _g1.t;
					t = at;
					break;
				default:
				}
				d = hxsl_TExprDef.TArray(e11,e21);
			}
			break;
		case 17:
			var el = _g.el;
			var _g1 = [];
			var _g2 = 0;
			while(_g2 < el.length) {
				var e1 = el[_g2];
				++_g2;
				_g1.push(this.evalExpr(e1));
			}
			d = hxsl_TExprDef.TArrayDecl(_g1);
			break;
		case 18:
			var e1 = _g.e;
			var cases = _g.cases;
			var def = _g.def;
			var e2 = this.evalExpr(e1);
			var _g1 = [];
			var _g2 = 0;
			while(_g2 < cases.length) {
				var c = cases[_g2];
				++_g2;
				var _g3 = [];
				var _g4 = 0;
				var _g5 = c.values;
				while(_g4 < _g5.length) {
					var v1 = _g5[_g4];
					++_g4;
					_g3.push(this.evalExpr(v1));
				}
				_g1.push({ values : _g3, expr : this.evalExpr(c.expr,isVal)});
			}
			var cases = _g1;
			var def1 = def == null ? null : this.evalExpr(def,isVal);
			var hasCase = false;
			var _g1 = e2.e;
			if(_g1._hx_index == 0) {
				var c = _g1.c;
				if(c._hx_index == 2) {
					var val = c.v;
					var _g1 = 0;
					while(_g1 < cases.length) {
						var c1 = cases[_g1];
						++_g1;
						var _g2 = 0;
						var _g3 = c1.values;
						while(_g2 < _g3.length) {
							var v1 = _g3[_g2];
							++_g2;
							var _g4 = v1.e;
							if(_g4._hx_index == 0) {
								var cst = _g4.c;
								switch(cst._hx_index) {
								case 2:
									var k = cst.v;
									if(k == val) {
										return c1.expr;
									}
									break;
								case 3:
									var k1 = cst.v;
									if(k1 == val) {
										return c1.expr;
									}
									break;
								default:
								}
							} else {
								hasCase = true;
							}
						}
					}
				} else {
					throw haxe_Exception.thrown("Unsupported switch constant " + Std.string(c));
				}
			} else {
				hasCase = true;
			}
			d = hasCase ? hxsl_TExprDef.TSwitch(e2,cases,def1) : def1 == null ? hxsl_TExprDef.TBlock([]) : def1.e;
			break;
		case 19:
			var cond = _g.e;
			var loop = _g.loop;
			var normalWhile = _g.normalWhile;
			var cond1 = this.evalExpr(cond);
			var loop1 = this.evalExpr(loop,false);
			d = hxsl_TExprDef.TWhile(cond1,this.ifBlock(loop1),normalWhile);
			break;
		case 20:
			var name = _g.m;
			var args = _g.args;
			var e1 = _g.e;
			var e2;
			if(name == "unroll") {
				var old4 = this.unrollLoops;
				this.unrollLoops = true;
				e2 = this.evalExpr(e1,isVal);
				this.unrollLoops = false;
			} else {
				e2 = this.evalExpr(e1,isVal);
			}
			d = hxsl_TExprDef.TMeta(name,args,e2);
			break;
		case 21:
			var e1 = _g.e;
			var name = _g.name;
			d = hxsl_TExprDef.TField(this.evalExpr(e1),name);
			break;
		case 22:
			var target = _g.target;
			var code = _g.code;
			var args = _g.args;
			var _g = [];
			var _g1 = 0;
			while(_g1 < args.length) {
				var arg = args[_g1];
				++_g1;
				_g.push({ e : this.evalExpr(arg.e), access : arg.access});
			}
			d = hxsl_TExprDef.TSyntax(target,code,_g);
			break;
		}
		return { e : d, t : t, p : e.p};
	}
	,__class__: hxsl_Eval
};
var hxsl__$Flatten_Alloc = function(g,t,pos,size) {
	this.g = g;
	this.t = t;
	this.pos = pos;
	this.size = size;
};
$hxClasses["hxsl._Flatten.Alloc"] = hxsl__$Flatten_Alloc;
hxsl__$Flatten_Alloc.__name__ = "hxsl._Flatten.Alloc";
hxsl__$Flatten_Alloc.prototype = {
	__class__: hxsl__$Flatten_Alloc
};
var hxsl_ARead = $hxEnums["hxsl.ARead"] = { __ename__:true,__constructs__:null
	,AIndex: ($_=function(a) { return {_hx_index:0,a:a,__enum__:"hxsl.ARead",toString:$estr}; },$_._hx_name="AIndex",$_.__params__ = ["a"],$_)
	,AOffset: ($_=function(a,stride,delta) { return {_hx_index:1,a:a,stride:stride,delta:delta,__enum__:"hxsl.ARead",toString:$estr}; },$_._hx_name="AOffset",$_.__params__ = ["a","stride","delta"],$_)
};
hxsl_ARead.__constructs__ = [hxsl_ARead.AIndex,hxsl_ARead.AOffset];
hxsl_ARead.__empty_constructs__ = [];
var hxsl_Flatten = function() {
};
$hxClasses["hxsl.Flatten"] = hxsl_Flatten;
hxsl_Flatten.__name__ = "hxsl.Flatten";
hxsl_Flatten.prototype = {
	flatten: function(s,kind) {
		this.globals = [];
		this.params = [];
		this.outVars = [];
		this.textureFormats = [];
		this.varMap = new haxe_ds_ObjectMap();
		this.allocData = new haxe_ds_ObjectMap();
		var _g = 0;
		var _g1 = s.vars;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			this.gatherVar(v);
		}
		var prefix;
		switch(kind._hx_index) {
		case 0:
			prefix = "vertex";
			break;
		case 1:
			prefix = "fragment";
			break;
		case 4:
			prefix = "compute";
			break;
		default:
			throw haxe_Exception.thrown("assert");
		}
		this.pack(prefix + "Globals",hxsl_VarKind.Global,this.globals,hxsl_VecType.VFloat);
		this.pack(prefix + "Params",hxsl_VarKind.Param,this.params,hxsl_VecType.VFloat);
		var allVars = this.globals.concat(this.params);
		this.textureFormats.sort(function(t1,t2) {
			if(t1.rw != t2.rw) {
				return t1.rw - t2.rw;
			}
			if(t1.arr != t2.arr) {
				if(t1.arr) {
					return 1;
				} else {
					return -1;
				}
			}
			return t1.dim._hx_index - t2.dim._hx_index;
		});
		var _g = 0;
		var _g1 = this.textureFormats;
		while(_g < _g1.length) {
			var t = _g1[_g];
			++_g;
			var name;
			if(t.dim == hxsl_TexDimension.T2D) {
				name = "";
			} else {
				var e = t.dim;
				name = HxOverrides.substr($hxEnums[e.__enum__].__constructs__[e._hx_index]._hx_name,1,null);
			}
			if(t.rw > 0) {
				name = "RW" + name + t.rw;
			}
			if(t.arr) {
				name += "Array";
			}
			this.packTextures(prefix + "Textures" + name,allVars,t.rw == 0 ? hxsl_Type.TSampler(t.dim,t.arr) : hxsl_Type.TRWTexture(t.dim,t.arr,t.rw));
		}
		this.packBuffers("buffers",allVars,hxsl_BufferKind.Uniform);
		this.packBuffers("storagebuffers",allVars,hxsl_BufferKind.Storage);
		this.packBuffers("rwbuffers",allVars,hxsl_BufferKind.RW);
		var _g = [];
		var _g1 = 0;
		var _g2 = s.funs;
		while(_g1 < _g2.length) {
			var f = _g2[_g1];
			++_g1;
			_g.push(this.mapFun(f,$bind(this,this.mapExpr)));
		}
		var funs = _g;
		return { name : s.name, vars : this.outVars, funs : funs};
	}
	,mapFun: function(f,mapExpr) {
		return { kind : f.kind, ret : f.ret, args : f.args, ref : f.ref, expr : mapExpr(f.expr)};
	}
	,mkOp: function(e,by,f,binop,pos) {
		var _g = e.e;
		if(_g._hx_index == 0) {
			var _g1 = _g.c;
			if(_g1._hx_index == 2) {
				var i = _g1.v;
				return { e : hxsl_TExprDef.TConst(hxsl_Const.CInt(f(i,by))), t : hxsl_Type.TInt, p : pos};
			}
		}
		return { e : hxsl_TExprDef.TBinop(binop,e,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(by)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TInt, p : pos};
	}
	,mkAdd: function(e,offset,pos) {
		if(offset == 0) {
			return e;
		}
		return this.mkOp(e,offset,function(x,y) {
			return x + y;
		},haxe_macro_Binop.OpAdd,pos);
	}
	,mkMult: function(e,by,pos) {
		if(by == 1) {
			return e;
		}
		return this.mkOp(e,by,function(x,y) {
			return x * y;
		},haxe_macro_Binop.OpMult,pos);
	}
	,mapExpr: function(e) {
		var _gthis = this;
		var _g = e.e;
		switch(_g._hx_index) {
		case 1:
			var v = _g.v;
			var a = this.varMap.h[v.__id__];
			if(a != null) {
				e = this.access(a,v.type,e.p,hxsl_ARead.AIndex(a));
			}
			break;
		case 5:
			if(_g.op._hx_index == 4) {
				var e1 = _g.e1;
				var e2 = _g.e2;
				var e3;
				if(e.t._hx_index == 7) {
					var _g1 = e1.e;
					if(_g1._hx_index == 21) {
						var _g2 = _g1.e;
						var _g2 = _g1.name;
						e3 = true;
					} else {
						e3 = false;
					}
				} else {
					e3 = false;
				}
				if(e3) {
					var _g1 = e1.e;
					var _g2 = e1.p;
					if(_g1._hx_index == 21) {
						if(e1.t._hx_index == 7) {
							var name = _g1.name;
							var expr = _g1.e;
							var pos = -1;
							var _g1 = expr.t;
							if(_g1._hx_index == 13) {
								var vl = _g1.vl;
								var cur = 0;
								var _g1 = 0;
								while(_g1 < vl.length) {
									var v = vl[_g1];
									++_g1;
									if(v.name == name) {
										pos = cur;
										break;
									}
									cur += hxsl_Tools.size(v.type);
								}
							}
							if(pos < 0) {
								throw haxe_Exception.thrown("assert");
							}
							var pos1 = pos;
							var expr1 = this.mapExpr(expr);
							var idx = pos1 >> 2;
							var arr = _gthis.optimize({ e : hxsl_TExprDef.TArray(expr1,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(idx)), p : e.p, t : hxsl_Type.TInt}), p : e.p, t : hxsl_Type.TVec(4,hxsl_VecType.VFloat)});
							var e1;
							if((pos1 & 3) == 0) {
								e1 = arr;
							} else {
								var sw = hxsl_Flatten.SWIZ.slice(pos1 & 3,(pos1 & 3) + 4);
								e1 = { e : hxsl_TExprDef.TSwiz(arr,sw), t : hxsl_Type.TVec(4,hxsl_VecType.VFloat), p : e.p};
							}
							var e3 = { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssign,e1,{ e : hxsl_TExprDef.TArray(e2,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(0)), t : hxsl_Type.TInt, p : null}), t : hxsl_Type.TVec(4,hxsl_VecType.VFloat), p : null}), t : e.t, p : e.p};
							var pos = pos1 + 4;
							var idx = pos >> 2;
							var arr = _gthis.optimize({ e : hxsl_TExprDef.TArray(expr1,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(idx)), p : e.p, t : hxsl_Type.TInt}), p : e.p, t : hxsl_Type.TVec(4,hxsl_VecType.VFloat)});
							var e1;
							if((pos & 3) == 0) {
								e1 = arr;
							} else {
								var sw = hxsl_Flatten.SWIZ.slice(pos & 3,(pos & 3) + 4);
								e1 = { e : hxsl_TExprDef.TSwiz(arr,sw), t : hxsl_Type.TVec(4,hxsl_VecType.VFloat), p : e.p};
							}
							var e4 = { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssign,e1,{ e : hxsl_TExprDef.TArray(e2,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(1)), t : hxsl_Type.TInt, p : null}), t : hxsl_Type.TVec(4,hxsl_VecType.VFloat), p : null}), t : e.t, p : e.p};
							var pos = pos1 + 8;
							var idx = pos >> 2;
							var arr = _gthis.optimize({ e : hxsl_TExprDef.TArray(expr1,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(idx)), p : e.p, t : hxsl_Type.TInt}), p : e.p, t : hxsl_Type.TVec(4,hxsl_VecType.VFloat)});
							var e1;
							if((pos & 3) == 0) {
								e1 = arr;
							} else {
								var sw = hxsl_Flatten.SWIZ.slice(pos & 3,(pos & 3) + 4);
								e1 = { e : hxsl_TExprDef.TSwiz(arr,sw), t : hxsl_Type.TVec(4,hxsl_VecType.VFloat), p : e.p};
							}
							var e5 = { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssign,e1,{ e : hxsl_TExprDef.TArray(e2,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(2)), t : hxsl_Type.TInt, p : null}), t : hxsl_Type.TVec(4,hxsl_VecType.VFloat), p : null}), t : e.t, p : e.p};
							var pos = pos1 + 12;
							var idx = pos >> 2;
							var arr = _gthis.optimize({ e : hxsl_TExprDef.TArray(expr1,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(idx)), p : e.p, t : hxsl_Type.TInt}), p : e.p, t : hxsl_Type.TVec(4,hxsl_VecType.VFloat)});
							var e1;
							if((pos & 3) == 0) {
								e1 = arr;
							} else {
								var sw = hxsl_Flatten.SWIZ.slice(pos & 3,(pos & 3) + 4);
								e1 = { e : hxsl_TExprDef.TSwiz(arr,sw), t : hxsl_Type.TVec(4,hxsl_VecType.VFloat), p : e.p};
							}
							e = { e : hxsl_TExprDef.TBlock([e3,e4,e5,{ e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssign,e1,{ e : hxsl_TExprDef.TArray(e2,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(3)), t : hxsl_Type.TInt, p : null}), t : hxsl_Type.TVec(4,hxsl_VecType.VFloat), p : null}), t : e.t, p : e.p}]), t : e.t, p : e.p};
						} else {
							throw haxe_Exception.thrown("assert");
						}
					} else {
						throw haxe_Exception.thrown("assert");
					}
				} else {
					e = hxsl_Tools.map(e,$bind(this,this.mapExpr));
				}
			} else {
				e = hxsl_Tools.map(e,$bind(this,this.mapExpr));
			}
			break;
		case 7:
			var v = _g.v;
			var init = _g.init;
			var _g1 = v.type;
			var e1;
			if(_g1._hx_index == 13) {
				var _g2 = _g1.vl;
				e1 = true;
			} else {
				e1 = false;
			}
			if(e1) {
				var size = Math.ceil(hxsl_Tools.size(v.type) / 4);
				var v2 = { id : hxsl_Tools.allocVarId(), name : v.name, type : hxsl_Type.TArray(hxsl_Type.TVec(4,hxsl_VecType.VFloat),hxsl_SizeDecl.SConst(size)), kind : v.kind, qualifiers : v.qualifiers};
				var a = new hxsl__$Flatten_Alloc(v2,hxsl_VecType.VFloat,0,0);
				a.v = v;
				this.varMap.set(v,a);
				e = { e : hxsl_TExprDef.TVarDecl(v2,init == null ? null : this.mapExpr(init)), t : hxsl_Type.TVoid, p : e.p};
			} else {
				e = hxsl_Tools.map(e,$bind(this,this.mapExpr));
			}
			break;
		case 16:
			var _g1 = _g.e;
			var _g2 = _g1.e;
			var _g3 = _g1.t;
			if(_g2._hx_index == 1) {
				var v = _g2.v;
				var vp = _g1.p;
				var eindex = _g.index;
				var a = this.varMap.h[v.__id__];
				var e1;
				if(a != null) {
					var _g1 = v.type;
					var e2;
					if(_g1._hx_index == 16) {
						var _g2 = _g1.t;
						var _g2 = _g1.size;
						var _g2 = _g1.kind;
						e2 = true;
					} else {
						e2 = false;
					}
					if(!e2) {
						var _g1 = eindex.e;
						if(_g1._hx_index == 0) {
							var _g2 = _g1.c;
							if(_g2._hx_index == 2) {
								var _g1 = _g2.v;
								e1 = true;
							} else {
								e1 = false;
							}
						} else {
							e1 = false;
						}
					} else {
						e1 = false;
					}
				} else {
					e1 = true;
				}
				if(e1) {
					e = hxsl_Tools.map(e,$bind(this,this.mapExpr));
				} else {
					var _g1 = v.type;
					switch(_g1._hx_index) {
					case 5:
						var _g2 = _g1.size;
						switch(_g1.t._hx_index) {
						case 0:case 1:
							e = hxsl_Tools.map(e,$bind(this,this.mapExpr));
							break;
						default:
							throw haxe_Exception.thrown("assert");
						}
						break;
					case 15:
						var _g2 = _g1.t;
						var _g3 = _g1.size;
						var t = _g2;
						if(hxsl_Tools.isTexture(t)) {
							eindex = this.toInt(this.mapExpr(eindex));
							e = this.access(a,t,vp,hxsl_ARead.AOffset(a,1,eindex));
						} else {
							var t = _g2;
							var stride = this.varSize4Bytes(t,a.t);
							var e1;
							if(stride != 0) {
								var _g2 = v.type;
								var e2;
								if(_g2._hx_index == 15) {
									var _g3 = _g2.t;
									var _g3 = _g2.size;
									e2 = true;
								} else {
									e2 = false;
								}
								e1 = e2 && (stride & 3) != 0;
							} else {
								e1 = true;
							}
							if(e1) {
								throw haxe_Exception.thrown(new hxsl_Error("Dynamic access to an Array which size is not 4 components-aligned is not allowed",e.p));
							}
							stride = stride + 3 >> 2;
							eindex = this.toInt(this.mapExpr(eindex));
							e = this.access(a,t,vp,hxsl_ARead.AOffset(a,stride,this.mkMult(eindex,stride,vp)));
						}
						break;
					case 16:
						var _g2 = _g1.t;
						var _g3 = _g1.size;
						var _g3 = _g1.kind;
						switch(_g2._hx_index) {
						case 1:case 3:
							e = hxsl_Tools.map(e,$bind(this,this.mapExpr));
							break;
						default:
							var t = _g2;
							var stride = this.varSize4Bytes(t,a.t);
							var e1;
							if(stride != 0) {
								var _g1 = v.type;
								var e2;
								if(_g1._hx_index == 15) {
									var _g2 = _g1.t;
									var _g2 = _g1.size;
									e2 = true;
								} else {
									e2 = false;
								}
								e1 = e2 && (stride & 3) != 0;
							} else {
								e1 = true;
							}
							if(e1) {
								throw haxe_Exception.thrown(new hxsl_Error("Dynamic access to an Array which size is not 4 components-aligned is not allowed",e.p));
							}
							stride = stride + 3 >> 2;
							eindex = this.toInt(this.mapExpr(eindex));
							e = this.access(a,t,vp,hxsl_ARead.AOffset(a,stride,this.mkMult(eindex,stride,vp)));
						}
						break;
					default:
						throw haxe_Exception.thrown("assert");
					}
				}
			} else {
				e = hxsl_Tools.map(e,$bind(this,this.mapExpr));
			}
			break;
		case 21:
			var expr = _g.e;
			var name = _g.name;
			var pos = -1;
			var _g = expr.t;
			if(_g._hx_index == 13) {
				var vl = _g.vl;
				var cur = 0;
				var _g = 0;
				while(_g < vl.length) {
					var v = vl[_g];
					++_g;
					if(v.name == name) {
						pos = cur;
						break;
					}
					cur += hxsl_Tools.size(v.type);
				}
			}
			if(pos < 0) {
				throw haxe_Exception.thrown("assert");
			}
			var pos1 = pos;
			var expr1 = this.mapExpr(expr);
			var _g = e.t;
			switch(_g._hx_index) {
			case 3:
				var idx = pos1 >> 2;
				var arr = _gthis.optimize({ e : hxsl_TExprDef.TArray(expr1,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(idx)), p : e.p, t : hxsl_Type.TInt}), p : e.p, t : hxsl_Type.TVec(4,hxsl_VecType.VFloat)});
				var sw = hxsl_Flatten.SWIZ.slice(pos1 & 3,(pos1 & 3) + 1);
				e = { e : hxsl_TExprDef.TSwiz(arr,sw), t : hxsl_Type.TFloat, p : e.p};
				break;
			case 5:
				if(_g.t._hx_index == 1) {
					var size = _g.size;
					var idx = pos1 >> 2;
					var idx2 = pos1 + size - 1 >> 2;
					if(idx == idx2) {
						var idx = pos1 >> 2;
						var arr = _gthis.optimize({ e : hxsl_TExprDef.TArray(expr1,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(idx)), p : e.p, t : hxsl_Type.TInt}), p : e.p, t : hxsl_Type.TVec(4,hxsl_VecType.VFloat)});
						if(size == 4 && (pos1 & 3) == 0) {
							e = arr;
						} else {
							var sw = hxsl_Flatten.SWIZ.slice(pos1 & 3,(pos1 & 3) + size);
							e = { e : hxsl_TExprDef.TSwiz(arr,sw), t : size == 1 ? hxsl_Type.TFloat : hxsl_Type.TVec(size,hxsl_VecType.VFloat), p : e.p};
						}
					} else {
						var k = (idx2 << 2) - pos1;
						var type;
						switch(size) {
						case 2:
							type = hxsl_TGlobal.Vec2;
							break;
						case 3:
							type = hxsl_TGlobal.Vec3;
							break;
						case 4:
							type = hxsl_TGlobal.Vec4;
							break;
						default:
							throw haxe_Exception.thrown("assert");
						}
						var e1 = { e : hxsl_TExprDef.TGlobal(type), p : e.p, t : hxsl_Type.TVoid};
						var idx = pos1 >> 2;
						var arr = _gthis.optimize({ e : hxsl_TExprDef.TArray(expr1,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(idx)), p : e.p, t : hxsl_Type.TInt}), p : e.p, t : hxsl_Type.TVec(4,hxsl_VecType.VFloat)});
						var e2;
						if(k == 4 && (pos1 & 3) == 0) {
							e2 = arr;
						} else {
							var sw = hxsl_Flatten.SWIZ.slice(pos1 & 3,(pos1 & 3) + k);
							e2 = { e : hxsl_TExprDef.TSwiz(arr,sw), t : k == 1 ? hxsl_Type.TFloat : hxsl_Type.TVec(k,hxsl_VecType.VFloat), p : e.p};
						}
						var pos = pos1 + k;
						var size1 = size - k;
						var idx = pos >> 2;
						var arr = _gthis.optimize({ e : hxsl_TExprDef.TArray(expr1,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(idx)), p : e.p, t : hxsl_Type.TInt}), p : e.p, t : hxsl_Type.TVec(4,hxsl_VecType.VFloat)});
						var e3;
						if(size1 == 4 && (pos & 3) == 0) {
							e3 = arr;
						} else {
							var sw = hxsl_Flatten.SWIZ.slice(pos & 3,(pos & 3) + size1);
							e3 = { e : hxsl_TExprDef.TSwiz(arr,sw), t : size1 == 1 ? hxsl_Type.TFloat : hxsl_Type.TVec(size1,hxsl_VecType.VFloat), p : e.p};
						}
						e = { e : hxsl_TExprDef.TCall(e1,[e2,e3]), t : e.t, p : e.p};
					}
				} else {
					throw haxe_Exception.thrown("Unsupported type " + hxsl_Tools.toString(e.t));
				}
				break;
			case 7:
				var e1 = { e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mat4), p : e.p, t : hxsl_Type.TVoid};
				var idx = pos1 >> 2;
				var arr = _gthis.optimize({ e : hxsl_TExprDef.TArray(expr1,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(idx)), p : e.p, t : hxsl_Type.TInt}), p : e.p, t : hxsl_Type.TVec(4,hxsl_VecType.VFloat)});
				var e2;
				if((pos1 & 3) == 0) {
					e2 = arr;
				} else {
					var sw = hxsl_Flatten.SWIZ.slice(pos1 & 3,(pos1 & 3) + 4);
					e2 = { e : hxsl_TExprDef.TSwiz(arr,sw), t : hxsl_Type.TVec(4,hxsl_VecType.VFloat), p : e.p};
				}
				var pos = pos1 + 4;
				var idx = pos >> 2;
				var arr = _gthis.optimize({ e : hxsl_TExprDef.TArray(expr1,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(idx)), p : e.p, t : hxsl_Type.TInt}), p : e.p, t : hxsl_Type.TVec(4,hxsl_VecType.VFloat)});
				var e3;
				if((pos & 3) == 0) {
					e3 = arr;
				} else {
					var sw = hxsl_Flatten.SWIZ.slice(pos & 3,(pos & 3) + 4);
					e3 = { e : hxsl_TExprDef.TSwiz(arr,sw), t : hxsl_Type.TVec(4,hxsl_VecType.VFloat), p : e.p};
				}
				var pos = pos1 + 8;
				var idx = pos >> 2;
				var arr = _gthis.optimize({ e : hxsl_TExprDef.TArray(expr1,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(idx)), p : e.p, t : hxsl_Type.TInt}), p : e.p, t : hxsl_Type.TVec(4,hxsl_VecType.VFloat)});
				var e4;
				if((pos & 3) == 0) {
					e4 = arr;
				} else {
					var sw = hxsl_Flatten.SWIZ.slice(pos & 3,(pos & 3) + 4);
					e4 = { e : hxsl_TExprDef.TSwiz(arr,sw), t : hxsl_Type.TVec(4,hxsl_VecType.VFloat), p : e.p};
				}
				var pos = pos1 + 12;
				var idx = pos >> 2;
				var arr = _gthis.optimize({ e : hxsl_TExprDef.TArray(expr1,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(idx)), p : e.p, t : hxsl_Type.TInt}), p : e.p, t : hxsl_Type.TVec(4,hxsl_VecType.VFloat)});
				var e5;
				if((pos & 3) == 0) {
					e5 = arr;
				} else {
					var sw = hxsl_Flatten.SWIZ.slice(pos & 3,(pos & 3) + 4);
					e5 = { e : hxsl_TExprDef.TSwiz(arr,sw), t : hxsl_Type.TVec(4,hxsl_VecType.VFloat), p : e.p};
				}
				e = { e : hxsl_TExprDef.TCall(e1,[e2,e3,e4,e5]), t : e.t, p : e.p};
				break;
			case 8:
				var e1 = { e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mat3x4), p : e.p, t : hxsl_Type.TVoid};
				var idx = pos1 >> 2;
				var arr = _gthis.optimize({ e : hxsl_TExprDef.TArray(expr1,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(idx)), p : e.p, t : hxsl_Type.TInt}), p : e.p, t : hxsl_Type.TVec(4,hxsl_VecType.VFloat)});
				var e2;
				if((pos1 & 3) == 0) {
					e2 = arr;
				} else {
					var sw = hxsl_Flatten.SWIZ.slice(pos1 & 3,(pos1 & 3) + 4);
					e2 = { e : hxsl_TExprDef.TSwiz(arr,sw), t : hxsl_Type.TVec(4,hxsl_VecType.VFloat), p : e.p};
				}
				var pos = pos1 + 4;
				var idx = pos >> 2;
				var arr = _gthis.optimize({ e : hxsl_TExprDef.TArray(expr1,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(idx)), p : e.p, t : hxsl_Type.TInt}), p : e.p, t : hxsl_Type.TVec(4,hxsl_VecType.VFloat)});
				var e3;
				if((pos & 3) == 0) {
					e3 = arr;
				} else {
					var sw = hxsl_Flatten.SWIZ.slice(pos & 3,(pos & 3) + 4);
					e3 = { e : hxsl_TExprDef.TSwiz(arr,sw), t : hxsl_Type.TVec(4,hxsl_VecType.VFloat), p : e.p};
				}
				var pos = pos1 + 8;
				var idx = pos >> 2;
				var arr = _gthis.optimize({ e : hxsl_TExprDef.TArray(expr1,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(idx)), p : e.p, t : hxsl_Type.TInt}), p : e.p, t : hxsl_Type.TVec(4,hxsl_VecType.VFloat)});
				var e4;
				if((pos & 3) == 0) {
					e4 = arr;
				} else {
					var sw = hxsl_Flatten.SWIZ.slice(pos & 3,(pos & 3) + 4);
					e4 = { e : hxsl_TExprDef.TSwiz(arr,sw), t : hxsl_Type.TVec(4,hxsl_VecType.VFloat), p : e.p};
				}
				e = { e : hxsl_TExprDef.TCall(e1,[e2,e3,e4]), t : e.t, p : e.p};
				break;
			case 9:
				var size = _g.size;
				var e1 = { e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.UnpackSnorm4x8), p : e.p, t : hxsl_Type.TVec(size,hxsl_VecType.VFloat)};
				var idx = pos1 >> 2;
				var arr = _gthis.optimize({ e : hxsl_TExprDef.TArray(expr1,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(idx)), p : e.p, t : hxsl_Type.TInt}), p : e.p, t : hxsl_Type.TVec(4,hxsl_VecType.VFloat)});
				var sw = hxsl_Flatten.SWIZ.slice(pos1 & 3,(pos1 & 3) + 1);
				e = { e : hxsl_TExprDef.TCall(e1,[this.floatBitsToUint({ e : hxsl_TExprDef.TSwiz(arr,sw), t : hxsl_Type.TFloat, p : e.p})]), t : e.t, p : e.p};
				break;
			default:
				throw haxe_Exception.thrown("Unsupported type " + hxsl_Tools.toString(e.t));
			}
			break;
		default:
			e = hxsl_Tools.map(e,$bind(this,this.mapExpr));
		}
		return this.optimize(e);
	}
	,mkInt: function(v,pos) {
		return { e : hxsl_TExprDef.TConst(hxsl_Const.CInt(v)), t : hxsl_Type.TInt, p : pos};
	}
	,readIndex: function(a,index,pos) {
		var offs = a.t == null ? a.pos : a.pos >> 2;
		return { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a.g), t : a.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs + index)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,a.t), p : pos};
	}
	,readOffset: function(a,stride,delta,index,pos) {
		var index1;
		var _g = a.g.type;
		if(_g._hx_index == 16) {
			var _g1 = _g.t;
			var _g1 = _g.size;
			var _g1 = _g.kind;
			index1 = index;
		} else {
			index1 = (a.t == null ? a.pos : a.pos >> 2) + index;
		}
		var offset = this.mkAdd(delta,index1,pos);
		return { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a.g), t : a.g.type, p : pos},offset), t : hxsl_Type.TVec(4,a.t), p : pos};
	}
	,access: function(a,t,pos,acc) {
		var _gthis = this;
		switch(t._hx_index) {
		case 6:
			var tmp = this.access(a,hxsl_Type.TMat3x4,pos,acc);
			return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mat3), t : hxsl_Type.TFun([]), p : pos},[tmp]), t : hxsl_Type.TMat3, p : pos};
		case 7:
			var tmp = { e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mat4), t : hxsl_Type.TFun([]), p : pos};
			var tmp1;
			switch(acc._hx_index) {
			case 0:
				var a1 = acc.a;
				var offs = a1.t == null ? a1.pos : a1.pos >> 2;
				tmp1 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			case 1:
				var a1 = acc.a;
				var stride = acc.stride;
				var delta = acc.delta;
				var index;
				var _g = a1.g.type;
				if(_g._hx_index == 16) {
					var _g1 = _g.t;
					var _g1 = _g.size;
					var _g1 = _g.kind;
					index = 0;
				} else {
					index = a1.t == null ? a1.pos : a1.pos >> 2;
				}
				var offset = _gthis.mkAdd(delta,index,pos);
				tmp1 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},offset), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			}
			var tmp2;
			switch(acc._hx_index) {
			case 0:
				var a1 = acc.a;
				var offs = a1.t == null ? a1.pos : a1.pos >> 2;
				tmp2 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs + 1)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			case 1:
				var a1 = acc.a;
				var stride = acc.stride;
				var delta = acc.delta;
				var index;
				var _g = a1.g.type;
				if(_g._hx_index == 16) {
					var _g1 = _g.t;
					var _g1 = _g.size;
					var _g1 = _g.kind;
					index = 1;
				} else {
					index = (a1.t == null ? a1.pos : a1.pos >> 2) + 1;
				}
				var offset = _gthis.mkAdd(delta,index,pos);
				tmp2 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},offset), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			}
			var tmp3;
			switch(acc._hx_index) {
			case 0:
				var a1 = acc.a;
				var offs = a1.t == null ? a1.pos : a1.pos >> 2;
				tmp3 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs + 2)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			case 1:
				var a1 = acc.a;
				var stride = acc.stride;
				var delta = acc.delta;
				var index;
				var _g = a1.g.type;
				if(_g._hx_index == 16) {
					var _g1 = _g.t;
					var _g1 = _g.size;
					var _g1 = _g.kind;
					index = 2;
				} else {
					index = (a1.t == null ? a1.pos : a1.pos >> 2) + 2;
				}
				var offset = _gthis.mkAdd(delta,index,pos);
				tmp3 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},offset), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			}
			var tmp4;
			switch(acc._hx_index) {
			case 0:
				var a1 = acc.a;
				var offs = a1.t == null ? a1.pos : a1.pos >> 2;
				tmp4 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs + 3)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			case 1:
				var a1 = acc.a;
				var stride = acc.stride;
				var delta = acc.delta;
				var index;
				var _g = a1.g.type;
				if(_g._hx_index == 16) {
					var _g1 = _g.t;
					var _g1 = _g.size;
					var _g1 = _g.kind;
					index = 3;
				} else {
					index = (a1.t == null ? a1.pos : a1.pos >> 2) + 3;
				}
				var offset = _gthis.mkAdd(delta,index,pos);
				tmp4 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},offset), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			}
			return { e : hxsl_TExprDef.TCall(tmp,[tmp1,tmp2,tmp3,tmp4]), t : hxsl_Type.TMat4, p : pos};
		case 8:
			var tmp = { e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mat3x4), t : hxsl_Type.TFun([]), p : pos};
			var tmp1;
			switch(acc._hx_index) {
			case 0:
				var a1 = acc.a;
				var offs = a1.t == null ? a1.pos : a1.pos >> 2;
				tmp1 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			case 1:
				var a1 = acc.a;
				var stride = acc.stride;
				var delta = acc.delta;
				var index;
				var _g = a1.g.type;
				if(_g._hx_index == 16) {
					var _g1 = _g.t;
					var _g1 = _g.size;
					var _g1 = _g.kind;
					index = 0;
				} else {
					index = a1.t == null ? a1.pos : a1.pos >> 2;
				}
				var offset = _gthis.mkAdd(delta,index,pos);
				tmp1 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},offset), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			}
			var tmp2;
			switch(acc._hx_index) {
			case 0:
				var a1 = acc.a;
				var offs = a1.t == null ? a1.pos : a1.pos >> 2;
				tmp2 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs + 1)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			case 1:
				var a1 = acc.a;
				var stride = acc.stride;
				var delta = acc.delta;
				var index;
				var _g = a1.g.type;
				if(_g._hx_index == 16) {
					var _g1 = _g.t;
					var _g1 = _g.size;
					var _g1 = _g.kind;
					index = 1;
				} else {
					index = (a1.t == null ? a1.pos : a1.pos >> 2) + 1;
				}
				var offset = _gthis.mkAdd(delta,index,pos);
				tmp2 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},offset), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			}
			var tmp3;
			switch(acc._hx_index) {
			case 0:
				var a1 = acc.a;
				var offs = a1.t == null ? a1.pos : a1.pos >> 2;
				tmp3 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs + 2)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			case 1:
				var a1 = acc.a;
				var stride = acc.stride;
				var delta = acc.delta;
				var index;
				var _g = a1.g.type;
				if(_g._hx_index == 16) {
					var _g1 = _g.t;
					var _g1 = _g.size;
					var _g1 = _g.kind;
					index = 2;
				} else {
					index = (a1.t == null ? a1.pos : a1.pos >> 2) + 2;
				}
				var offset = _gthis.mkAdd(delta,index,pos);
				tmp3 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},offset), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			}
			return { e : hxsl_TExprDef.TCall(tmp,[tmp1,tmp2,tmp3]), t : hxsl_Type.TMat3x4, p : pos};
		case 13:
			var vl = t.vl;
			var size = 0;
			var _g = 0;
			while(_g < vl.length) {
				var v = vl[_g];
				++_g;
				size += this.varSize(v.type,a.t);
			}
			var stride = Math.ceil(size / 4);
			var _g = [];
			var _g1 = 0;
			var _g2 = stride;
			while(_g1 < _g2) {
				var i = _g1++;
				var tmp;
				switch(acc._hx_index) {
				case 0:
					var a1 = acc.a;
					var offs = a1.t == null ? a1.pos : a1.pos >> 2;
					tmp = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs + i)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,a1.t), p : pos};
					break;
				case 1:
					var a2 = acc.a;
					var stride1 = acc.stride;
					var delta = acc.delta;
					var index;
					var _g3 = a2.g.type;
					if(_g3._hx_index == 16) {
						var _g4 = _g3.t;
						var _g5 = _g3.size;
						var _g6 = _g3.kind;
						index = i;
					} else {
						index = (a2.t == null ? a2.pos : a2.pos >> 2) + i;
					}
					var offset = _gthis.mkAdd(delta,index,pos);
					tmp = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a2.g), t : a2.g.type, p : pos},offset), t : hxsl_Type.TVec(4,a2.t), p : pos};
					break;
				}
				_g.push(tmp);
			}
			var earr = _g;
			return { e : hxsl_TExprDef.TArrayDecl(earr), t : hxsl_Type.TArray(hxsl_Type.TVec(4,hxsl_VecType.VFloat),hxsl_SizeDecl.SConst(stride)), p : pos};
		case 15:
			var _g = t.size;
			if(_g._hx_index == 0) {
				var len = _g.v;
				var t1 = t.t;
				var stride = a.size / len | 0;
				var _g = [];
				var _g1 = 0;
				var _g2 = len;
				while(_g1 < _g2) {
					var i = _g1++;
					var a1 = new hxsl__$Flatten_Alloc(a.g,a.t,a.pos + stride * i,stride);
					_g.push(this.access(a1,t1,pos,hxsl_ARead.AIndex(a1)));
				}
				var earr = _g;
				return { e : hxsl_TExprDef.TArrayDecl(earr), t : t1, p : pos};
			} else {
				var t1 = t;
				if(hxsl_Tools.isTexture(t1)) {
					var e;
					switch(acc._hx_index) {
					case 0:
						var a1 = acc.a;
						var offs = a1.t == null ? a1.pos : a1.pos >> 2;
						e = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,a1.t), p : pos};
						break;
					case 1:
						var a1 = acc.a;
						var stride = acc.stride;
						var delta = acc.delta;
						var index;
						var _g = a1.g.type;
						if(_g._hx_index == 16) {
							var _g1 = _g.t;
							var _g1 = _g.size;
							var _g1 = _g.kind;
							index = 0;
						} else {
							index = a1.t == null ? a1.pos : a1.pos >> 2;
						}
						var offset = _gthis.mkAdd(delta,index,pos);
						e = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},offset), t : hxsl_Type.TVec(4,a1.t), p : pos};
						break;
					}
					e.t = t1;
					return e;
				} else {
					var size = this.varSize(t,a.t);
					if(size > 4) {
						return hxsl_Error.t("Access not supported for " + hxsl_Tools.toString(t),null);
					}
					var e;
					switch(acc._hx_index) {
					case 0:
						var a1 = acc.a;
						var offs = a1.t == null ? a1.pos : a1.pos >> 2;
						e = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,a1.t), p : pos};
						break;
					case 1:
						var a1 = acc.a;
						var stride = acc.stride;
						var delta = acc.delta;
						var index;
						var _g = a1.g.type;
						if(_g._hx_index == 16) {
							var _g1 = _g.t;
							var _g1 = _g.size;
							var _g1 = _g.kind;
							index = 0;
						} else {
							index = a1.t == null ? a1.pos : a1.pos >> 2;
						}
						var offset = _gthis.mkAdd(delta,index,pos);
						e = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},offset), t : hxsl_Type.TVec(4,a1.t), p : pos};
						break;
					}
					if(size == 4) {
						if(a.pos == -1) {
							return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Vec4), t : hxsl_Type.TFun([]), p : pos},[{ e : hxsl_TExprDef.TConst(hxsl_Const.CFloat(0)), t : hxsl_Type.TFloat, p : pos}]), t : hxsl_Type.TVec(4,hxsl_VecType.VFloat), p : pos};
						}
					} else {
						var sw = [];
						var _g = 0;
						var _g1 = size;
						while(_g < _g1) {
							var i = _g++;
							sw.push(hxsl_Tools.SWIZ[i + (a.pos & 3)]);
						}
						e = { e : hxsl_TExprDef.TSwiz(e,sw), t : t, p : pos};
					}
					switch(t._hx_index) {
					case 1:
						e.t = hxsl_Type.TFloat;
						e = this.toInt(e);
						break;
					case 5:
						if(t.t._hx_index == 0) {
							var size = t.size;
							e.t = hxsl_Type.TVec(size,hxsl_VecType.VFloat);
							e = { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal([hxsl_TGlobal.IVec2,hxsl_TGlobal.IVec3,hxsl_TGlobal.IVec4][size - 2]), t : hxsl_Type.TFun([]), p : pos},[e]), t : t, p : pos};
						}
						break;
					default:
					}
					return e;
				}
			}
			break;
		case 16:
			var _g = t.t;
			var _g = t.size;
			var _g = t.kind;
			return { e : hxsl_TExprDef.TVar(a.g), t : t, p : pos};
		default:
			var t1 = t;
			if(hxsl_Tools.isTexture(t1)) {
				var e;
				switch(acc._hx_index) {
				case 0:
					var a1 = acc.a;
					var offs = a1.t == null ? a1.pos : a1.pos >> 2;
					e = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,a1.t), p : pos};
					break;
				case 1:
					var a1 = acc.a;
					var stride = acc.stride;
					var delta = acc.delta;
					var index;
					var _g = a1.g.type;
					if(_g._hx_index == 16) {
						var _g1 = _g.t;
						var _g1 = _g.size;
						var _g1 = _g.kind;
						index = 0;
					} else {
						index = a1.t == null ? a1.pos : a1.pos >> 2;
					}
					var offset = _gthis.mkAdd(delta,index,pos);
					e = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},offset), t : hxsl_Type.TVec(4,a1.t), p : pos};
					break;
				}
				e.t = t1;
				return e;
			} else {
				var size = this.varSize(t,a.t);
				if(size > 4) {
					return hxsl_Error.t("Access not supported for " + hxsl_Tools.toString(t),null);
				}
				var e;
				switch(acc._hx_index) {
				case 0:
					var a1 = acc.a;
					var offs = a1.t == null ? a1.pos : a1.pos >> 2;
					e = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,a1.t), p : pos};
					break;
				case 1:
					var a1 = acc.a;
					var stride = acc.stride;
					var delta = acc.delta;
					var index;
					var _g = a1.g.type;
					if(_g._hx_index == 16) {
						var _g1 = _g.t;
						var _g1 = _g.size;
						var _g1 = _g.kind;
						index = 0;
					} else {
						index = a1.t == null ? a1.pos : a1.pos >> 2;
					}
					var offset = _gthis.mkAdd(delta,index,pos);
					e = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},offset), t : hxsl_Type.TVec(4,a1.t), p : pos};
					break;
				}
				if(size == 4) {
					if(a.pos == -1) {
						return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Vec4), t : hxsl_Type.TFun([]), p : pos},[{ e : hxsl_TExprDef.TConst(hxsl_Const.CFloat(0)), t : hxsl_Type.TFloat, p : pos}]), t : hxsl_Type.TVec(4,hxsl_VecType.VFloat), p : pos};
					}
				} else {
					var sw = [];
					var _g = 0;
					var _g1 = size;
					while(_g < _g1) {
						var i = _g++;
						sw.push(hxsl_Tools.SWIZ[i + (a.pos & 3)]);
					}
					e = { e : hxsl_TExprDef.TSwiz(e,sw), t : t, p : pos};
				}
				switch(t._hx_index) {
				case 1:
					e.t = hxsl_Type.TFloat;
					e = this.toInt(e);
					break;
				case 5:
					if(t.t._hx_index == 0) {
						var size = t.size;
						e.t = hxsl_Type.TVec(size,hxsl_VecType.VFloat);
						e = { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal([hxsl_TGlobal.IVec2,hxsl_TGlobal.IVec3,hxsl_TGlobal.IVec4][size - 2]), t : hxsl_Type.TFun([]), p : pos},[e]), t : t, p : pos};
					}
					break;
				default:
				}
				return e;
			}
		}
	}
	,floatBitsToUint: function(e) {
		return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.FloatBitsToUint), t : hxsl_Type.TFun([]), p : e.p},[e]), t : hxsl_Type.TInt, p : e.p};
	}
	,toInt: function(e) {
		if(e.t == hxsl_Type.TInt) {
			return e;
		}
		return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.ToInt), t : hxsl_Type.TFun([]), p : e.p},[e]), t : hxsl_Type.TInt, p : e.p};
	}
	,optimize: function(e) {
		var _g = e.e;
		switch(_g._hx_index) {
		case 8:
			var _g1 = _g.e;
			var _g2 = _g.args;
			var _g3 = _g1.e;
			var _g4 = _g1.p;
			var _g4 = _g1.t;
			if(_g3._hx_index == 2) {
				if(_g3.g._hx_index == 53) {
					if(_g2.length == 1) {
						var _g1 = _g2[0];
						var _g2 = _g1.e;
						var _g3 = _g1.p;
						var _g3 = _g1.t;
						if(_g2._hx_index == 8) {
							var _g1 = _g2.e;
							var _g3 = _g1.e;
							var _g4 = _g1.p;
							var _g4 = _g1.t;
							if(_g3._hx_index == 2) {
								if(_g3.g._hx_index == 52) {
									var args = _g2.args;
									var rem = 0;
									var size = 0;
									while(size < 4) {
										var t = args[args.length - 1 - rem].t;
										size += this.varSize(t,hxsl_VecType.VFloat);
										++rem;
									}
									if(size == 4) {
										var _g1 = 0;
										var _g2 = rem;
										while(_g1 < _g2) {
											var i = _g1++;
											args.pop();
										}
										var emat;
										var _g1 = e.e;
										if(_g1._hx_index == 8) {
											var _g2 = _g1.args;
											var e1 = _g1.e;
											emat = e1;
										} else {
											throw haxe_Exception.thrown("assert");
										}
										return { e : hxsl_TExprDef.TCall(emat,args), t : e.t, p : e.p};
									}
								}
							}
						}
					}
				}
			}
			break;
		case 16:
			var _g1 = _g.e;
			var _g2 = _g.index;
			var _g = _g1.e;
			var _g3 = _g1.p;
			var _g3 = _g1.t;
			if(_g._hx_index == 17) {
				var _g1 = _g2.e;
				var _g3 = _g2.p;
				var _g3 = _g2.t;
				if(_g1._hx_index == 0) {
					var _g2 = _g1.c;
					if(_g2._hx_index == 2) {
						var i = _g2.v;
						var el = _g.el;
						if(i >= 0 && i < el.length) {
							return el[i];
						}
						hxsl_Error.t("Reading outside array bounds",e.p);
					}
				}
			}
			break;
		default:
		}
		return e;
	}
	,packTextures: function(name,vars,t) {
		var alloc = [];
		var g = { id : hxsl_Tools.allocVarId(), name : name, type : t, kind : hxsl_VarKind.Param};
		var pos = 0;
		var samplers = [];
		var _g = 0;
		while(_g < vars.length) {
			var v = vars[_g];
			++_g;
			var count = 1;
			if(!Type.enumEq(v.type,t)) {
				var _g1 = v.type;
				switch(_g1._hx_index) {
				case 15:
					var _g2 = _g1.size;
					if(_g2._hx_index == 0) {
						var n = _g2.v;
						var t2 = _g1.t;
						if(Type.enumEq(t2,t)) {
							count = n;
						} else {
							continue;
						}
					} else {
						continue;
					}
					break;
				case 17:
					var _g3 = _g1.size;
					if(!(t._hx_index == 10 && (t.dim._hx_index == 1 && t.isArray == false))) {
						continue;
					}
					break;
				default:
					continue;
				}
			}
			var a = new hxsl__$Flatten_Alloc(g,null,pos,count);
			a.v = v;
			if(v.qualifiers != null) {
				var _g4 = 0;
				var _g5 = v.qualifiers;
				while(_g4 < _g5.length) {
					var q = _g5[_g4];
					++_g4;
					if(q._hx_index == 12) {
						var name = q.name;
						var _g6 = 0;
						var _g7 = count;
						while(_g6 < _g7) {
							var i = _g6++;
							samplers[pos + i] = name;
						}
					}
				}
			}
			this.varMap.set(v,a);
			alloc.push(a);
			pos += count;
		}
		g.type = hxsl_Type.TArray(t,hxsl_SizeDecl.SConst(pos));
		if(samplers.length > 0) {
			var _g = 0;
			var _g1 = pos;
			while(_g < _g1) {
				var i = _g++;
				if(samplers[i] == null) {
					samplers[i] = "";
				}
			}
			if(g.qualifiers == null) {
				g.qualifiers = [];
			}
			g.qualifiers.push(hxsl_VarQualifier.Sampler(samplers.join(",")));
		}
		if(alloc.length > 0) {
			this.outVars.push(g);
			this.allocData.set(g,alloc);
		}
		return alloc;
	}
	,packBuffers: function(name,vars,kind) {
		var alloc = [];
		var g = { id : hxsl_Tools.allocVarId(), name : name, type : hxsl_Type.TVoid, kind : hxsl_VarKind.Param};
		var _g = 0;
		while(_g < vars.length) {
			var v = vars[_g];
			++_g;
			var _g1 = v.type;
			if(_g1._hx_index == 16) {
				var _g2 = _g1.size;
				if(_g2._hx_index == 0) {
					var size = _g2.v;
					var t = _g1.t;
					var k = _g1.kind;
					if(kind == k) {
						var stride = Math.ceil(hxsl_Tools.size(t) / 4);
						var bt;
						switch(t._hx_index) {
						case 1:case 3:
							var bt1;
							switch(kind._hx_index) {
							case 1:case 2:case 4:case 5:
								bt1 = true;
								break;
							default:
								bt1 = false;
							}
							bt = bt1 ? v.type : hxsl_Type.TBuffer(hxsl_Type.TVec(4,hxsl_VecType.VFloat),hxsl_SizeDecl.SConst(size * stride),k);
							break;
						default:
							bt = hxsl_Type.TBuffer(hxsl_Type.TVec(4,hxsl_VecType.VFloat),hxsl_SizeDecl.SConst(size * stride),k);
						}
						var vbuf = { id : hxsl_Tools.allocVarId(), name : v.name, type : bt, kind : hxsl_VarKind.Param};
						var a = new hxsl__$Flatten_Alloc(vbuf,null,alloc.length,1);
						a.t = hxsl_VecType.VFloat;
						a.v = v;
						alloc.push(a);
						this.varMap.set(v,a);
						this.outVars.push(vbuf);
					}
				}
			}
		}
		g.type = hxsl_Type.TArray(hxsl_Type.TBuffer(hxsl_Type.TVoid,hxsl_SizeDecl.SConst(0),kind),hxsl_SizeDecl.SConst(alloc.length));
		this.allocData.set(g,alloc);
	}
	,pack: function(name,kind,vars,t) {
		var alloc = [];
		var apos = 0;
		var g = { id : hxsl_Tools.allocVarId(), name : name, type : hxsl_Type.TVec(0,t), kind : kind};
		var _g = 0;
		while(_g < vars.length) {
			var v = vars[_g];
			++_g;
			var tmp;
			if(!hxsl_Tools.isTexture(v.type)) {
				var _g1 = v.type;
				if(_g1._hx_index == 16) {
					var _g2 = _g1.t;
					var _g3 = _g1.size;
					var _g4 = _g1.kind;
					tmp = true;
				} else {
					tmp = false;
				}
			} else {
				tmp = true;
			}
			if(tmp) {
				continue;
			}
			var _g5 = v.type;
			if(_g5._hx_index == 15) {
				var _g6 = _g5.size;
				var t1 = _g5.t;
				if(hxsl_Tools.isTexture(t1)) {
					continue;
				}
			}
			var size = this.varSize(v.type,t);
			if(size == 0) {
				var a = new hxsl__$Flatten_Alloc(g,t,-1,size);
				a.v = v;
				this.varMap.set(v,a);
				continue;
			}
			var best = null;
			var _g7 = 0;
			while(_g7 < alloc.length) {
				var a1 = alloc[_g7];
				++_g7;
				if(a1.v == null && a1.size >= size && (best == null || best.size > a1.size)) {
					best = a1;
				}
			}
			if(best != null) {
				var free = best.size - size;
				if(free > 0) {
					var i = alloc.indexOf(best);
					var a2 = new hxsl__$Flatten_Alloc(g,t,best.pos + size,free);
					alloc.splice(i + 1,0,a2);
					best.size = size;
				}
				best.v = v;
				this.varMap.set(v,best);
			} else {
				var a3 = new hxsl__$Flatten_Alloc(g,t,apos,size);
				apos += size;
				a3.v = v;
				this.varMap.set(v,a3);
				alloc.push(a3);
				var pad = (4 - size % 4) % 4;
				if(pad > 0) {
					var a4 = new hxsl__$Flatten_Alloc(g,t,apos,pad);
					apos += pad;
					alloc.push(a4);
				}
			}
		}
		g.type = hxsl_Type.TArray(hxsl_Type.TVec(4,t),hxsl_SizeDecl.SConst(apos >> 2));
		if(apos > 0) {
			this.outVars.push(g);
			this.allocData.set(g,alloc);
		}
		return g;
	}
	,varSize: function(v,t) {
		switch(v._hx_index) {
		case 1:case 3:
			if(t == hxsl_VecType.VFloat) {
				return 1;
			} else {
				throw haxe_Exception.thrown(hxsl_Tools.toString(v) + " size unknown for type " + Std.string(t));
			}
			break;
		case 5:
			var n = v.size;
			var t2 = v.t;
			if(t == t2) {
				return n;
			} else {
				throw haxe_Exception.thrown(hxsl_Tools.toString(v) + " size unknown for type " + Std.string(t));
			}
			break;
		case 7:
			if(t == hxsl_VecType.VFloat) {
				return 16;
			} else {
				throw haxe_Exception.thrown(hxsl_Tools.toString(v) + " size unknown for type " + Std.string(t));
			}
			break;
		case 6:case 8:
			if(t == hxsl_VecType.VFloat) {
				return 12;
			} else {
				throw haxe_Exception.thrown(hxsl_Tools.toString(v) + " size unknown for type " + Std.string(t));
			}
			break;
		case 9:
			var n = v.size;
			return n;
		case 13:
			var vl = v.vl;
			var size = 0;
			var _g = 0;
			while(_g < vl.length) {
				var v1 = vl[_g];
				++_g;
				size += this.varSize(v1.type,t);
			}
			return size;
		case 15:
			var _g = v.size;
			if(_g._hx_index == 0) {
				var n = _g.v;
				var at = v.t;
				return this.varSize(at,t) * n;
			} else {
				throw haxe_Exception.thrown(hxsl_Tools.toString(v) + " size unknown for type " + Std.string(t));
			}
			break;
		default:
			throw haxe_Exception.thrown(hxsl_Tools.toString(v) + " size unknown for type " + Std.string(t));
		}
	}
	,varSize4Bytes: function(v,t) {
		switch(v._hx_index) {
		case 9:
			if(v.size == 4) {
				return 1;
			} else {
				throw haxe_Exception.thrown(hxsl_Tools.toString(v) + " 4 bytes size unknown for type" + Std.string(t));
			}
			break;
		case 13:
			var vl = v.vl;
			var size = 0;
			var _g = 0;
			while(_g < vl.length) {
				var v1 = vl[_g];
				++_g;
				size += this.varSize4Bytes(v1.type,t);
			}
			return size;
		case 15:
			var _g = v.size;
			if(_g._hx_index == 0) {
				var n = _g.v;
				var at = v.t;
				return this.varSize4Bytes(at,t) * n;
			} else {
				return this.varSize(v,t);
			}
			break;
		default:
			return this.varSize(v,t);
		}
	}
	,addTextureFormat: function(dim,arr,rw) {
		if(rw == null) {
			rw = 0;
		}
		var _g = 0;
		var _g1 = this.textureFormats;
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			if(f.dim == dim && f.arr == arr && f.rw == rw) {
				return;
			}
		}
		this.textureFormats.push({ dim : dim, arr : arr, rw : rw});
	}
	,gatherVar: function(v) {
		var _g = v.type;
		switch(_g._hx_index) {
		case 10:
			var dim = _g.dim;
			var arr = _g.isArray;
			var rw;
			var _g1 = v.type;
			if(_g1._hx_index == 11) {
				var _g2 = _g1.dim;
				var _g2 = _g1.isArray;
				var chans = _g1.channels;
				rw = chans;
			} else {
				rw = 0;
			}
			this.addTextureFormat(dim,arr,rw);
			break;
		case 11:
			var _g1 = _g.channels;
			var dim = _g.dim;
			var arr = _g.isArray;
			var rw;
			var _g1 = v.type;
			if(_g1._hx_index == 11) {
				var _g2 = _g1.dim;
				var _g2 = _g1.isArray;
				var chans = _g1.channels;
				rw = chans;
			} else {
				rw = 0;
			}
			this.addTextureFormat(dim,arr,rw);
			break;
		case 13:
			var vl = _g.vl;
			var _g1 = 0;
			while(_g1 < vl.length) {
				var v1 = vl[_g1];
				++_g1;
				this.gatherVar(v1);
			}
			return;
		case 15:
			var _g1 = _g.size;
			var type = _g.t;
			switch(type._hx_index) {
			case 10:
				var dim = type.dim;
				var arr = type.isArray;
				this.addTextureFormat(dim,arr,0);
				break;
			case 11:
				var dim = type.dim;
				var arr = type.isArray;
				var chans = type.channels;
				this.addTextureFormat(dim,arr,chans);
				break;
			default:
			}
			break;
		case 17:
			var _g1 = _g.size;
			this.addTextureFormat(hxsl_TexDimension.T2D,false);
			break;
		default:
		}
		switch(v.kind._hx_index) {
		case 0:
			if(hxsl_Tools.hasQualifier(v,hxsl_VarQualifier.PerObject)) {
				this.params.push(v);
			} else {
				this.globals.push(v);
			}
			break;
		case 2:
			this.params.push(v);
			break;
		default:
			this.outVars.push(v);
		}
	}
	,__class__: hxsl_Flatten
};
var hxsl_GlobalSlot = {};
hxsl_GlobalSlot._new = function(name) {
	return hxsl_Globals.allocID(name);
};
hxsl_GlobalSlot.toInt = function(this1) {
	return this1;
};
hxsl_GlobalSlot.set = function(this1,globals,v) {
	globals.map.h[this1] = v;
};
hxsl_GlobalSlot.get = function(this1,globals) {
	return globals.map.h[this1];
};
var hxsl_Globals = function() {
	this.channels = [];
	this.map = new haxe_ds_IntMap();
};
$hxClasses["hxsl.Globals"] = hxsl_Globals;
hxsl_Globals.__name__ = "hxsl.Globals";
hxsl_Globals.allocID = function(path) {
	if(hxsl_Globals.MAP == null) {
		hxsl_Globals.MAP = new haxe_ds_StringMap();
		hxsl_Globals.ALL = [];
	}
	var id = hxsl_Globals.MAP.h[path];
	if(id == null) {
		id = hxsl_Globals.ALL.length;
		hxsl_Globals.ALL.push(path);
		hxsl_Globals.MAP.h[path] = id;
	}
	return id;
};
hxsl_Globals.getIDName = function(id) {
	return hxsl_Globals.ALL[id];
};
hxsl_Globals.prototype = {
	set: function(path,v) {
		var this1 = this.map;
		var key = hxsl_Globals.allocID(path);
		this1.h[key] = v;
	}
	,get: function(path) {
		var this1 = this.map;
		var key = hxsl_Globals.allocID(path);
		return this1.h[key];
	}
	,fastSet: function(id,v) {
		this.map.h[id] = v;
	}
	,fastGet: function(id) {
		return this.map.h[id];
	}
	,resetChannels: function() {
		this.maxChannels = 0;
	}
	,allocChannelID: function(t) {
		var _g = 0;
		var _g1 = this.maxChannels;
		while(_g < _g1) {
			var i = _g++;
			if(this.channels[i] == t) {
				return i;
			}
		}
		if(this.maxChannels == 1 << hxsl_Tools.MAX_CHANNELS_BITS) {
			throw haxe_Exception.thrown("Too many unique channels");
		}
		var i = this.maxChannels++;
		this.channels[i] = t;
		return i;
	}
	,__class__: hxsl_Globals
};
var js_Boot = function() { };
$hxClasses["js.Boot"] = js_Boot;
js_Boot.__name__ = "js.Boot";
js_Boot.getClass = function(o) {
	if(o == null) {
		return null;
	} else if(((o) instanceof Array)) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var con = e.__constructs__[o._hx_index];
			var n = con._hx_name;
			if(con.__params__) {
				s = s + "\t";
				return n + "(" + ((function($this) {
					var $r;
					var _g = [];
					{
						var _g1 = 0;
						var _g2 = con.__params__;
						while(true) {
							if(!(_g1 < _g2.length)) {
								break;
							}
							var p = _g2[_g1];
							_g1 = _g1 + 1;
							_g.push(js_Boot.__string_rec(o[p],s));
						}
					}
					$r = _g;
					return $r;
				}(this))).join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	var intf = cc.__interfaces__;
	if(intf != null) {
		var _g = 0;
		var _g1 = intf.length;
		while(_g < _g1) {
			var i = _g++;
			var i1 = intf[i];
			if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
				return true;
			}
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		return ((o) instanceof Array);
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return o != null;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return ((o | 0) === o);
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(js_Boot.__downcastCheck(o,cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(((o) instanceof cl)) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class ? o.__name__ != null : false) {
			return true;
		}
		if(cl == Enum ? o.__ename__ != null : false) {
			return true;
		}
		return o.__enum__ != null ? $hxEnums[o.__enum__] == cl : false;
	}
};
js_Boot.__downcastCheck = function(o,cl) {
	if(!((o) instanceof cl)) {
		if(cl.__isInterface__) {
			return js_Boot.__interfLoop(js_Boot.getClass(o),cl);
		} else {
			return false;
		}
	} else {
		return true;
	}
};
js_Boot.__cast = function(o,t) {
	if(o == null || js_Boot.__instanceof(o,t)) {
		return o;
	} else {
		throw haxe_Exception.thrown("Cannot cast " + Std.string(o) + " to " + Std.string(t));
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var hxsl_GlslOut = function() {
	this.computeLayout = [1,1,1];
	this.outIndex = 0;
	this.uniformBuffer = 0;
	this.exprIds = 0;
	this.varNames = new haxe_ds_IntMap();
	this.allNames = new haxe_ds_StringMap();
};
$hxClasses["hxsl.GlslOut"] = hxsl_GlslOut;
hxsl_GlslOut.__name__ = "hxsl.GlslOut";
hxsl_GlslOut.compile = function(s) {
	var out = new hxsl_GlslOut();
	out.glES = 1;
	out.version = 100;
	return out.run(s);
};
hxsl_GlslOut.prototype = {
	get_isES: function() {
		return this.glES != null;
	}
	,get_isES2: function() {
		if(this.glES != null) {
			return this.glES <= 2;
		} else {
			return false;
		}
	}
	,add: function(v) {
		this.buf.b += Std.string(v);
	}
	,ident: function(v) {
		var v1 = this.varName(v);
		this.buf.b += Std.string(v1);
	}
	,decl: function(s) {
		var _g = 0;
		var _g1 = this.decls;
		while(_g < _g1.length) {
			var d = _g1[_g];
			++_g;
			if(d == s) {
				return;
			}
		}
		if(HxOverrides.cca(s,0) == 35) {
			this.decls.unshift(s);
		} else {
			this.decls.push(s);
		}
	}
	,getSamplerType: function(dim,arr) {
		var name = "sampler" + HxOverrides.substr($hxEnums[dim.__enum__].__constructs__[dim._hx_index]._hx_name,1,null);
		if(arr) {
			name += "Array";
		}
		return name;
	}
	,addType: function(t) {
		switch(t._hx_index) {
		case 0:
			this.buf.b += Std.string("void");
			break;
		case 1:
			this.buf.b += Std.string("int");
			break;
		case 2:
			this.buf.b += Std.string("bool");
			break;
		case 3:
			this.buf.b += Std.string("float");
			break;
		case 4:
			this.buf.b += Std.string("string");
			break;
		case 5:
			var size = t.size;
			var k = t.t;
			switch(k._hx_index) {
			case 0:
				this.buf.b += Std.string("i");
				break;
			case 1:
				break;
			case 2:
				this.buf.b += Std.string("b");
				break;
			}
			this.buf.b += Std.string("vec");
			this.buf.b += Std.string(size);
			break;
		case 6:
			this.buf.b += Std.string("mat3");
			break;
		case 7:
			this.buf.b += Std.string("mat4");
			break;
		case 8:
			this.decl(hxsl_GlslOut.MAT34);
			this.buf.b += Std.string("_mat3x4");
			break;
		case 9:
			var n = t.size;
			this.buf.b += Std.string("vec");
			this.buf.b += Std.string(n);
			break;
		case 10:
			var dim = t.dim;
			var arr = t.isArray;
			var name = this.getSamplerType(dim,arr);
			this.buf.b += Std.string(name);
			if(this.glES != null && (arr || dim == hxsl_TexDimension.T3D)) {
				this.decl("precision lowp " + name + ";");
			}
			break;
		case 11:
			var dim = t.dim;
			var arr = t.isArray;
			var chans = t.channels;
			this.buf.b += Std.string("image" + HxOverrides.substr($hxEnums[dim.__enum__].__constructs__[dim._hx_index]._hx_name,1,null) + (arr ? "Array" : ""));
			break;
		case 12:
			this.buf.b += Std.string("mat2");
			break;
		case 13:
			var vl = t.vl;
			this.buf.b += Std.string("struct { ");
			var _g = 0;
			while(_g < vl.length) {
				var v = vl[_g];
				++_g;
				this.addVar(v);
				this.buf.b += Std.string(";");
			}
			this.buf.b += Std.string(" }");
			break;
		case 14:
			var _g = t.variants;
			this.buf.b += Std.string("function");
			break;
		case 15:
			var t1 = t.t;
			var size = t.size;
			this.addType(t1);
			this.buf.b += Std.string("[");
			switch(size._hx_index) {
			case 0:
				var _g = size.v;
				switch(_g) {
				case 0:
					break;
				case 1:
					if(this.intelDriverFix) {
						this.buf.b += Std.string(2);
					} else {
						var v = _g;
						this.buf.b += Std.string(v);
					}
					break;
				default:
					var v = _g;
					this.buf.b += Std.string(v);
				}
				break;
			case 1:
				var v = size.v;
				var v1 = this.varName(v);
				this.buf.b += Std.string(v1);
				break;
			}
			this.buf.b += Std.string("]");
			break;
		case 16:
			var _g = t.t;
			var _g = t.size;
			var _g = t.kind;
			throw haxe_Exception.thrown("assert");
		case 17:
			var n = t.size;
			this.buf.b += Std.string("channel" + n);
			break;
		}
	}
	,addVar: function(v) {
		var _g = v.type;
		switch(_g._hx_index) {
		case 15:
			var t = _g.t;
			var size = _g.size;
			var old = v.type;
			v.type = t;
			this.addVar(v);
			v.type = old;
			this.buf.b += Std.string("[");
			switch(size._hx_index) {
			case 0:
				var _g1 = size.v;
				switch(_g1) {
				case 0:
					break;
				case 1:
					if(this.intelDriverFix) {
						this.buf.b += Std.string(2);
					} else {
						var n = _g1;
						this.buf.b += Std.string(n);
					}
					break;
				default:
					var n = _g1;
					this.buf.b += Std.string(n);
				}
				break;
			case 1:
				var v1 = size.v;
				var v2 = this.varName(v1);
				this.buf.b += Std.string(v2);
				break;
			}
			this.buf.b += Std.string("]");
			break;
		case 16:
			var t = _g.t;
			var size = _g.size;
			var kind = _g.kind;
			switch(kind._hx_index) {
			case 0:case 3:
				break;
			case 1:case 4:
				this.buf.b += Std.string("storage_");
				break;
			case 2:case 5:
				this.buf.b += Std.string("rw_");
				break;
			}
			this.buf.b += Std.string((this.isVertex ? "vertex_" : "") + "uniform_buffer" + this.uniformBuffer++);
			this.buf.b += Std.string(" { ");
			v.type = hxsl_Type.TArray(t,size);
			this.addVar(v);
			v.type = hxsl_Type.TBuffer(t,size,kind);
			this.buf.b += Std.string("; }");
			break;
		default:
			this.addType(v.type);
			this.buf.b += Std.string(" ");
			var v1 = this.varName(v);
			this.buf.b += Std.string(v1);
		}
	}
	,addValue: function(e,tabs) {
		var _g = e.e;
		switch(_g._hx_index) {
		case 4:
			var el = _g.el;
			var name = "_val" + this.exprIds++;
			var tmp = this.buf;
			this.buf = new StringBuf();
			this.addType(e.t);
			this.buf.b += Std.string(" ");
			this.buf.b += Std.string(name);
			this.buf.b += Std.string("(void)");
			var el2 = el.slice();
			var last = el2[el2.length - 1];
			el2[el2.length - 1] = { e : hxsl_TExprDef.TReturn(last), t : e.t, p : last.p};
			var e2 = { t : hxsl_Type.TVoid, e : hxsl_TExprDef.TBlock(el2), p : e.p};
			this.addExpr(e2,"");
			this.exprValues.push(this.buf.b);
			this.buf = tmp;
			this.buf.b += Std.string(name);
			this.buf.b += Std.string("()");
			break;
		case 10:
			var econd = _g.econd;
			var eif = _g.eif;
			var eelse = _g.eelse;
			this.buf.b += Std.string("( ");
			this.addValue(econd,tabs);
			this.buf.b += Std.string(" ) ? ");
			this.addValue(eif,tabs);
			this.buf.b += Std.string(" : ");
			this.addValue(eelse,tabs);
			break;
		case 20:
			var _g1 = _g.m;
			var _g1 = _g.args;
			var e1 = _g.e;
			this.addValue(e1,tabs);
			break;
		default:
			this.addExpr(e,tabs);
		}
	}
	,addBlock: function(e,tabs) {
		this.addExpr(e,tabs);
	}
	,getFunName: function(g,args,rt) {
		switch(g._hx_index) {
		case 20:
			if(rt == hxsl_Type.TInt && this.glES != null) {
				this.decl("int _imod( int x, int y ) { return int(mod(float(x),float(y))); }");
				return "_imod";
			}
			break;
		case 25:
			this.decl("float invLerp(float v, float a, float b) { return clamp((v - a) / (b - a), 0.0, 1.0); }");
			break;
		case 34:
			var _g = args[0].t;
			switch(_g._hx_index) {
			case 10:
				var _g1 = _g.isArray;
				switch(_g.dim._hx_index) {
				case 1:
					if(this.glES != null && this.glES <= 2) {
						return "texture2D";
					}
					break;
				case 3:
					if(this.glES != null && this.glES <= 2) {
						return "textureCube";
					}
					break;
				default:
				}
				break;
			case 17:
				var _g1 = _g.size;
				if(this.glES != null && this.glES <= 2) {
					return "texture2D";
				}
				break;
			default:
			}
			break;
		case 35:
			var _g = args[0].t;
			switch(_g._hx_index) {
			case 10:
				var _g1 = _g.isArray;
				switch(_g.dim._hx_index) {
				case 1:
					if(this.glES != null && this.glES <= 2) {
						this.decl("#extension GL_EXT_shader_texture_lod : enable");
						return "texture2DLodEXT";
					}
					break;
				case 3:
					if(this.glES != null && this.glES <= 2) {
						this.decl("#extension GL_EXT_shader_texture_lod : enable");
						return "textureCubeLodEXT";
					}
					break;
				default:
				}
				break;
			case 17:
				var _g1 = _g.size;
				if(this.glES != null && this.glES <= 2) {
					this.decl("#extension GL_EXT_shader_texture_lod : enable");
					return "texture2DLodEXT";
				}
				break;
			default:
			}
			break;
		case 36:
			return "texelFetch";
		case 37:
			var sufix = "";
			var _g = args[0].t;
			switch(_g._hx_index) {
			case 10:
				var dim = _g.dim;
				var arr = _g.isArray;
				var size = hxsl_Tools.getDimSize(dim,arr);
				sufix = arr ? "Array" : "";
				var t = "sampler" + HxOverrides.substr($hxEnums[dim.__enum__].__constructs__[dim._hx_index]._hx_name,1,null) + sufix;
				this.decl("vec" + size + " _texture" + sufix + "Size(" + t + " sampler, int lod) { return vec" + size + "(textureSize(sampler, lod)); }");
				break;
			case 11:
				var _g1 = _g.channels;
				var dim = _g.dim;
				var arr = _g.isArray;
				var size = hxsl_Tools.getDimSize(dim,arr);
				return "vec" + size + "(imageSize";
			case 17:
				var _g1 = _g.size;
				this.decl("vec2 _textureSize(sampler2D sampler, int lod) { return vec2(textureSize(sampler, lod)); }");
				break;
			default:
			}
			return "_texture" + sufix + "Size";
		case 51:
			if(args[0].t == hxsl_Type.TMat3x4) {
				this.decl(hxsl_GlslOut.MAT34);
				this.decl("mat3 _mat3( _mat3x4 v ) { return mat3(v.a.xyz,v.b.xyz,v.c.xyz); }");
				return "_mat3";
			}
			break;
		case 53:
			this.decl(hxsl_GlslOut.MAT34);
			if(args.length == 1) {
				this.decl("_mat3x4 mat_to_34( mat4 m ) { return _mat3x4(m[0],m[1],m[2]); }");
				return "mat_to_34";
			}
			break;
		case 55:
			this.decl("vec4 pack( float v ) { vec4 color = fract(v * vec4(1, 255, 255.*255., 255.*255.*255.)); return color - color.yzww * vec4(1. / 255., 1. / 255., 1. / 255., 0.); }");
			break;
		case 56:
			this.decl("float unpack( vec4 color ) { return dot(color,vec4(1., 1. / 255., 1. / (255. * 255.), 1. / (255. * 255. * 255.))); }");
			break;
		case 57:
			this.decl("vec4 packNormal( vec3 v ) { return vec4((v + vec3(1.)) * vec3(0.5),1.); }");
			break;
		case 58:
			this.decl("vec3 unpackNormal( vec4 v ) { return normalize((v.xyz - vec3(0.5)) * vec3(2.)); }");
			break;
		case 59:
			this.decl("vec2 screenToUv( vec2 v ) { return v * vec2(0.5,-0.5) + vec2(0.5,0.5); }");
			break;
		case 60:
			this.decl("vec2 uvToScreen( vec2 v ) { return v * vec2(2.,-2.) + vec2(-1., 1.); }");
			break;
		case 61:case 62:case 63:
			if(this.isVertex) {
				throw haxe_Exception.thrown("Can't use " + Std.string(g) + " in vertex shader");
			}
			if(this.version < 300) {
				this.decl("#extension GL_OES_standard_derivatives:enable");
			}
			break;
		case 74:
			if(this.version < 330) {
				this.decl("#extension GL_ARB_shader_bit_encoding :enable");
			}
			this.decl("int _floatBitsToUint( float v) { return int(floatBitsToUint(v)); }");
			this.decl("ivec2 _floatBitsToUint( vec2 v ) { return ivec2(floatBitsToUint(v)); }");
			this.decl("ivec3 _floatBitsToUint( vec3 v ) { return ivec3(floatBitsToUint(v)); }");
			this.decl("ivec4 _floatBitsToUint( vec4 v ) { return ivec4(floatBitsToUint(v)); }");
			break;
		case 73:case 75:
			if(this.version < 330) {
				this.decl("#extension GL_ARB_shader_bit_encoding :enable");
			}
			break;
		case 76:
			if(this.version < 330) {
				this.decl("#extension GL_ARB_shader_bit_encoding :enable");
			}
			this.decl("float _uintBitsToFloat( int v ) { return uintBitsToFloat(uint(v)); }");
			this.decl("vec2 _uintBitsToFloat( ivec2 v ) { return uintBitsToFloat(uvec2(v)); }");
			this.decl("vec3 _uintBitsToFloat( ivec3 v ) { return uintBitsToFloat(uvec3(v)); }");
			this.decl("vec4 _uintBitsToFloat( ivec4 v ) { return uintBitsToFloat(uvec4(v)); }");
			break;
		default:
		}
		return hxsl_GlslOut.GLOBALS[g._hx_index];
	}
	,addExpr: function(e,tabs) {
		var _g = e.e;
		switch(_g._hx_index) {
		case 0:
			var c = _g.c;
			switch(c._hx_index) {
			case 0:
				this.buf.b += Std.string("null");
				break;
			case 1:
				var b = c.b;
				this.buf.b += Std.string(b);
				break;
			case 2:
				var v = c.v;
				this.buf.b += Std.string(v);
				break;
			case 3:
				var f = c.v;
				var str = "" + f;
				this.buf.b += Std.string(str);
				if(str.indexOf(".") == -1 && str.indexOf("e") == -1) {
					this.buf.b += Std.string(".");
				}
				break;
			case 4:
				var v = c.v;
				this.buf.b += Std.string("\"" + v + "\"");
				break;
			}
			break;
		case 1:
			var v = _g.v;
			var v1 = this.varName(v);
			this.buf.b += Std.string(v1);
			break;
		case 2:
			var g = _g.g;
			this.buf.b += Std.string(hxsl_GlslOut.GLOBALS[g._hx_index]);
			break;
		case 3:
			var e1 = _g.e;
			this.buf.b += Std.string("(");
			this.addValue(e1,tabs);
			this.buf.b += Std.string(")");
			break;
		case 4:
			var el = _g.el;
			this.buf.b += Std.string("{\n");
			var t2 = tabs + "\t";
			var _g1 = 0;
			while(_g1 < el.length) {
				var e1 = el[_g1];
				++_g1;
				this.buf.b += Std.string(t2);
				this.addExpr(e1,t2);
				this.newLine(e1);
			}
			this.buf.b += Std.string(tabs);
			this.buf.b += Std.string("}");
			break;
		case 5:
			var op = _g.op;
			var e1 = _g.e1;
			var e2 = _g.e2;
			var _g1 = e1.t;
			var _g2 = e2.t;
			switch(op._hx_index) {
			case 1:
				if(_g1._hx_index == 5) {
					if(_g1.size == 3) {
						if(_g1.t._hx_index == 1) {
							if(_g2._hx_index == 8) {
								this.decl(hxsl_GlslOut.MAT34);
								this.decl("vec3 m3x4mult( vec3 v, _mat3x4 m) { vec4 ve = vec4(v,1.0); return vec3(dot(m.a,ve),dot(m.b,ve),dot(m.c,ve)); }");
								var tmp;
								if(op._hx_index == 20) {
									var _g3 = op.op;
									tmp = true;
								} else {
									tmp = false;
								}
								if(tmp) {
									this.addValue(e1,tabs);
									this.buf.b += Std.string(" = ");
								}
								this.buf.b += Std.string("m3x4mult(");
								this.addValue(e1,tabs);
								this.buf.b += Std.string(",");
								this.addValue(e2,tabs);
								this.buf.b += Std.string(")");
							} else {
								this.addValue(e1,tabs);
								this.buf.b += Std.string(" ");
								var v = hxsl_Printer.opStr(op);
								this.buf.b += Std.string(v);
								this.buf.b += Std.string(" ");
								this.addValue(e2,tabs);
							}
						} else {
							this.addValue(e1,tabs);
							this.buf.b += Std.string(" ");
							var v = hxsl_Printer.opStr(op);
							this.buf.b += Std.string(v);
							this.buf.b += Std.string(" ");
							this.addValue(e2,tabs);
						}
					} else {
						this.addValue(e1,tabs);
						this.buf.b += Std.string(" ");
						var v = hxsl_Printer.opStr(op);
						this.buf.b += Std.string(v);
						this.buf.b += Std.string(" ");
						this.addValue(e2,tabs);
					}
				} else {
					this.addValue(e1,tabs);
					this.buf.b += Std.string(" ");
					var v = hxsl_Printer.opStr(op);
					this.buf.b += Std.string(v);
					this.buf.b += Std.string(" ");
					this.addValue(e2,tabs);
				}
				break;
			case 5:
				if(_g1._hx_index == 5) {
					var _g3 = _g1.t;
					if(_g2._hx_index == 5) {
						var _g3 = _g2.size;
						var _g3 = _g2.t;
						var n = _g1.size;
						this.buf.b += Std.string("vec" + n + "(");
						var v;
						switch(op._hx_index) {
						case 5:
							v = "equal";
							break;
						case 6:
							v = "notEqual";
							break;
						case 7:
							v = "greaterThan";
							break;
						case 8:
							v = "greaterThanEqual";
							break;
						case 9:
							v = "lessThan";
							break;
						case 10:
							v = "lessThanEqual";
							break;
						default:
							throw haxe_Exception.thrown("assert");
						}
						this.buf.b += Std.string(v);
						this.buf.b += Std.string("(");
						this.addValue(e1,tabs);
						this.buf.b += Std.string(",");
						this.addValue(e2,tabs);
						this.buf.b += Std.string("))");
					} else {
						this.addValue(e1,tabs);
						this.buf.b += Std.string(" ");
						var v = hxsl_Printer.opStr(op);
						this.buf.b += Std.string(v);
						this.buf.b += Std.string(" ");
						this.addValue(e2,tabs);
					}
				} else {
					this.addValue(e1,tabs);
					this.buf.b += Std.string(" ");
					var v = hxsl_Printer.opStr(op);
					this.buf.b += Std.string(v);
					this.buf.b += Std.string(" ");
					this.addValue(e2,tabs);
				}
				break;
			case 6:
				if(_g1._hx_index == 5) {
					var _g3 = _g1.t;
					if(_g2._hx_index == 5) {
						var _g3 = _g2.size;
						var _g3 = _g2.t;
						var n = _g1.size;
						this.buf.b += Std.string("vec" + n + "(");
						var v;
						switch(op._hx_index) {
						case 5:
							v = "equal";
							break;
						case 6:
							v = "notEqual";
							break;
						case 7:
							v = "greaterThan";
							break;
						case 8:
							v = "greaterThanEqual";
							break;
						case 9:
							v = "lessThan";
							break;
						case 10:
							v = "lessThanEqual";
							break;
						default:
							throw haxe_Exception.thrown("assert");
						}
						this.buf.b += Std.string(v);
						this.buf.b += Std.string("(");
						this.addValue(e1,tabs);
						this.buf.b += Std.string(",");
						this.addValue(e2,tabs);
						this.buf.b += Std.string("))");
					} else {
						this.addValue(e1,tabs);
						this.buf.b += Std.string(" ");
						var v = hxsl_Printer.opStr(op);
						this.buf.b += Std.string(v);
						this.buf.b += Std.string(" ");
						this.addValue(e2,tabs);
					}
				} else {
					this.addValue(e1,tabs);
					this.buf.b += Std.string(" ");
					var v = hxsl_Printer.opStr(op);
					this.buf.b += Std.string(v);
					this.buf.b += Std.string(" ");
					this.addValue(e2,tabs);
				}
				break;
			case 7:
				if(_g1._hx_index == 5) {
					var _g3 = _g1.t;
					if(_g2._hx_index == 5) {
						var _g3 = _g2.size;
						var _g3 = _g2.t;
						var n = _g1.size;
						this.buf.b += Std.string("vec" + n + "(");
						var v;
						switch(op._hx_index) {
						case 5:
							v = "equal";
							break;
						case 6:
							v = "notEqual";
							break;
						case 7:
							v = "greaterThan";
							break;
						case 8:
							v = "greaterThanEqual";
							break;
						case 9:
							v = "lessThan";
							break;
						case 10:
							v = "lessThanEqual";
							break;
						default:
							throw haxe_Exception.thrown("assert");
						}
						this.buf.b += Std.string(v);
						this.buf.b += Std.string("(");
						this.addValue(e1,tabs);
						this.buf.b += Std.string(",");
						this.addValue(e2,tabs);
						this.buf.b += Std.string("))");
					} else {
						this.addValue(e1,tabs);
						this.buf.b += Std.string(" ");
						var v = hxsl_Printer.opStr(op);
						this.buf.b += Std.string(v);
						this.buf.b += Std.string(" ");
						this.addValue(e2,tabs);
					}
				} else {
					this.addValue(e1,tabs);
					this.buf.b += Std.string(" ");
					var v = hxsl_Printer.opStr(op);
					this.buf.b += Std.string(v);
					this.buf.b += Std.string(" ");
					this.addValue(e2,tabs);
				}
				break;
			case 8:
				if(_g1._hx_index == 5) {
					var _g3 = _g1.t;
					if(_g2._hx_index == 5) {
						var _g3 = _g2.size;
						var _g3 = _g2.t;
						var n = _g1.size;
						this.buf.b += Std.string("vec" + n + "(");
						var v;
						switch(op._hx_index) {
						case 5:
							v = "equal";
							break;
						case 6:
							v = "notEqual";
							break;
						case 7:
							v = "greaterThan";
							break;
						case 8:
							v = "greaterThanEqual";
							break;
						case 9:
							v = "lessThan";
							break;
						case 10:
							v = "lessThanEqual";
							break;
						default:
							throw haxe_Exception.thrown("assert");
						}
						this.buf.b += Std.string(v);
						this.buf.b += Std.string("(");
						this.addValue(e1,tabs);
						this.buf.b += Std.string(",");
						this.addValue(e2,tabs);
						this.buf.b += Std.string("))");
					} else {
						this.addValue(e1,tabs);
						this.buf.b += Std.string(" ");
						var v = hxsl_Printer.opStr(op);
						this.buf.b += Std.string(v);
						this.buf.b += Std.string(" ");
						this.addValue(e2,tabs);
					}
				} else {
					this.addValue(e1,tabs);
					this.buf.b += Std.string(" ");
					var v = hxsl_Printer.opStr(op);
					this.buf.b += Std.string(v);
					this.buf.b += Std.string(" ");
					this.addValue(e2,tabs);
				}
				break;
			case 9:
				if(_g1._hx_index == 5) {
					var _g3 = _g1.t;
					if(_g2._hx_index == 5) {
						var _g3 = _g2.size;
						var _g3 = _g2.t;
						var n = _g1.size;
						this.buf.b += Std.string("vec" + n + "(");
						var v;
						switch(op._hx_index) {
						case 5:
							v = "equal";
							break;
						case 6:
							v = "notEqual";
							break;
						case 7:
							v = "greaterThan";
							break;
						case 8:
							v = "greaterThanEqual";
							break;
						case 9:
							v = "lessThan";
							break;
						case 10:
							v = "lessThanEqual";
							break;
						default:
							throw haxe_Exception.thrown("assert");
						}
						this.buf.b += Std.string(v);
						this.buf.b += Std.string("(");
						this.addValue(e1,tabs);
						this.buf.b += Std.string(",");
						this.addValue(e2,tabs);
						this.buf.b += Std.string("))");
					} else {
						this.addValue(e1,tabs);
						this.buf.b += Std.string(" ");
						var v = hxsl_Printer.opStr(op);
						this.buf.b += Std.string(v);
						this.buf.b += Std.string(" ");
						this.addValue(e2,tabs);
					}
				} else {
					this.addValue(e1,tabs);
					this.buf.b += Std.string(" ");
					var v = hxsl_Printer.opStr(op);
					this.buf.b += Std.string(v);
					this.buf.b += Std.string(" ");
					this.addValue(e2,tabs);
				}
				break;
			case 10:
				if(_g1._hx_index == 5) {
					var _g3 = _g1.t;
					if(_g2._hx_index == 5) {
						var _g3 = _g2.size;
						var _g3 = _g2.t;
						var n = _g1.size;
						this.buf.b += Std.string("vec" + n + "(");
						var v;
						switch(op._hx_index) {
						case 5:
							v = "equal";
							break;
						case 6:
							v = "notEqual";
							break;
						case 7:
							v = "greaterThan";
							break;
						case 8:
							v = "greaterThanEqual";
							break;
						case 9:
							v = "lessThan";
							break;
						case 10:
							v = "lessThanEqual";
							break;
						default:
							throw haxe_Exception.thrown("assert");
						}
						this.buf.b += Std.string(v);
						this.buf.b += Std.string("(");
						this.addValue(e1,tabs);
						this.buf.b += Std.string(",");
						this.addValue(e2,tabs);
						this.buf.b += Std.string("))");
					} else {
						this.addValue(e1,tabs);
						this.buf.b += Std.string(" ");
						var v = hxsl_Printer.opStr(op);
						this.buf.b += Std.string(v);
						this.buf.b += Std.string(" ");
						this.addValue(e2,tabs);
					}
				} else {
					this.addValue(e1,tabs);
					this.buf.b += Std.string(" ");
					var v = hxsl_Printer.opStr(op);
					this.buf.b += Std.string(v);
					this.buf.b += Std.string(" ");
					this.addValue(e2,tabs);
				}
				break;
			case 18:
				this.decl("int _ushr( int i, int j ) { return int(uint(i) >> uint(j)); }");
				this.buf.b += Std.string("_ushr(");
				this.addValue(e1,tabs);
				this.buf.b += Std.string(",");
				this.addValue(e2,tabs);
				this.buf.b += Std.string(")");
				break;
			case 19:
				if(e.t != hxsl_Type.TInt) {
					var tmp;
					if(op._hx_index == 20) {
						var _g3 = op.op;
						tmp = true;
					} else {
						tmp = false;
					}
					if(tmp) {
						this.addValue(e1,tabs);
						this.buf.b += Std.string(" = ");
					}
					this.addExpr({ e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mod), t : hxsl_Type.TFun([]), p : e.p},[e1,e2]), t : e.t, p : e.p},tabs);
				} else {
					this.addValue(e1,tabs);
					this.buf.b += Std.string(" ");
					var v = hxsl_Printer.opStr(op);
					this.buf.b += Std.string(v);
					this.buf.b += Std.string(" ");
					this.addValue(e2,tabs);
				}
				break;
			case 20:
				switch(op.op._hx_index) {
				case 1:
					if(_g1._hx_index == 5) {
						if(_g1.size == 3) {
							if(_g1.t._hx_index == 1) {
								if(_g2._hx_index == 8) {
									this.decl(hxsl_GlslOut.MAT34);
									this.decl("vec3 m3x4mult( vec3 v, _mat3x4 m) { vec4 ve = vec4(v,1.0); return vec3(dot(m.a,ve),dot(m.b,ve),dot(m.c,ve)); }");
									var tmp;
									if(op._hx_index == 20) {
										var _g1 = op.op;
										tmp = true;
									} else {
										tmp = false;
									}
									if(tmp) {
										this.addValue(e1,tabs);
										this.buf.b += Std.string(" = ");
									}
									this.buf.b += Std.string("m3x4mult(");
									this.addValue(e1,tabs);
									this.buf.b += Std.string(",");
									this.addValue(e2,tabs);
									this.buf.b += Std.string(")");
								} else {
									this.addValue(e1,tabs);
									this.buf.b += Std.string(" ");
									var v = hxsl_Printer.opStr(op);
									this.buf.b += Std.string(v);
									this.buf.b += Std.string(" ");
									this.addValue(e2,tabs);
								}
							} else {
								this.addValue(e1,tabs);
								this.buf.b += Std.string(" ");
								var v = hxsl_Printer.opStr(op);
								this.buf.b += Std.string(v);
								this.buf.b += Std.string(" ");
								this.addValue(e2,tabs);
							}
						} else {
							this.addValue(e1,tabs);
							this.buf.b += Std.string(" ");
							var v = hxsl_Printer.opStr(op);
							this.buf.b += Std.string(v);
							this.buf.b += Std.string(" ");
							this.addValue(e2,tabs);
						}
					} else {
						this.addValue(e1,tabs);
						this.buf.b += Std.string(" ");
						var v = hxsl_Printer.opStr(op);
						this.buf.b += Std.string(v);
						this.buf.b += Std.string(" ");
						this.addValue(e2,tabs);
					}
					break;
				case 19:
					if(e.t != hxsl_Type.TInt) {
						var tmp;
						if(op._hx_index == 20) {
							var _g1 = op.op;
							tmp = true;
						} else {
							tmp = false;
						}
						if(tmp) {
							this.addValue(e1,tabs);
							this.buf.b += Std.string(" = ");
						}
						this.addExpr({ e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mod), t : hxsl_Type.TFun([]), p : e.p},[e1,e2]), t : e.t, p : e.p},tabs);
					} else {
						this.addValue(e1,tabs);
						this.buf.b += Std.string(" ");
						var v = hxsl_Printer.opStr(op);
						this.buf.b += Std.string(v);
						this.buf.b += Std.string(" ");
						this.addValue(e2,tabs);
					}
					break;
				default:
					this.addValue(e1,tabs);
					this.buf.b += Std.string(" ");
					var v = hxsl_Printer.opStr(op);
					this.buf.b += Std.string(v);
					this.buf.b += Std.string(" ");
					this.addValue(e2,tabs);
				}
				break;
			default:
				this.addValue(e1,tabs);
				this.buf.b += Std.string(" ");
				var v = hxsl_Printer.opStr(op);
				this.buf.b += Std.string(v);
				this.buf.b += Std.string(" ");
				this.addValue(e2,tabs);
			}
			break;
		case 6:
			var op = _g.op;
			var e1 = _g.e1;
			var v;
			switch(op._hx_index) {
			case 0:
				v = "++";
				break;
			case 1:
				v = "--";
				break;
			case 2:
				v = "!";
				break;
			case 3:
				v = "-";
				break;
			case 4:
				v = "~";
				break;
			default:
				throw haxe_Exception.thrown("assert");
			}
			this.buf.b += Std.string(v);
			this.addValue(e1,tabs);
			break;
		case 7:
			var v = _g.v;
			var init = _g.init;
			this.locals.h[v.id] = v;
			if(init != null) {
				var v1 = this.varName(v);
				this.buf.b += Std.string(v1);
				this.buf.b += Std.string(" = ");
				this.addValue(init,tabs);
			} else {
				this.buf.b += Std.string("/*var*/");
			}
			break;
		case 8:
			var _g1 = _g.e;
			var _g2 = _g.args;
			var _g3 = _g1.e;
			var _g4 = _g1.p;
			var _g4 = _g1.t;
			if(_g3._hx_index == 2) {
				var _g4 = _g3.g;
				switch(_g4._hx_index) {
				case 36:
					var g = _g4;
					var args = _g2;
					var v = this.getFunName(g,args,e.t);
					this.buf.b += Std.string(v);
					this.buf.b += Std.string("(");
					this.addValue(args[0],tabs);
					this.buf.b += Std.string(", ");
					this.addValue(args[1],tabs);
					if(args.length != 2) {
						this.buf.b += Std.string(", ");
						this.addValue(args[2],tabs);
						this.buf.b += Std.string(")");
					} else {
						this.buf.b += Std.string(", 0)");
					}
					break;
				case 37:
					var g = _g4;
					var args = _g2;
					var v = this.getFunName(g,args,e.t);
					this.buf.b += Std.string(v);
					this.buf.b += Std.string("(");
					this.addValue(args[0],tabs);
					if(args.length != 1) {
						this.buf.b += Std.string(", ");
						this.addValue(args[1],tabs);
						this.buf.b += Std.string(")");
					} else {
						var _g3 = args[0].t;
						var tmp;
						if(_g3._hx_index == 11) {
							var _g4 = _g3.dim;
							var _g4 = _g3.isArray;
							var _g4 = _g3.channels;
							tmp = true;
						} else {
							tmp = false;
						}
						if(tmp) {
							this.buf.b += Std.string("))");
						} else {
							this.buf.b += Std.string(", 0)");
						}
					}
					break;
				case 54:
					if(_g2.length == 1) {
						var e1 = _g2[0];
						this.buf.b += Std.string("clamp(");
						this.addValue(e1,tabs);
						this.buf.b += Std.string(", 0., 1.)");
					} else {
						var v = _g1;
						var args = _g2;
						var _g3 = v.e;
						if(_g3._hx_index == 2) {
							var g = _g3.g;
							var v1 = this.getFunName(g,args,e.t);
							this.buf.b += Std.string(v1);
						} else {
							this.addValue(v,tabs);
						}
						this.buf.b += Std.string("(");
						var first = true;
						var _g3 = 0;
						while(_g3 < args.length) {
							var e1 = args[_g3];
							++_g3;
							if(first) {
								first = false;
							} else {
								this.buf.b += Std.string(", ");
							}
							this.addValue(e1,tabs);
						}
						this.buf.b += Std.string(")");
					}
					break;
				case 78:
					break;
				case 79:
					if(_g2.length == 3) {
						var tex = _g2[0];
						var uv = _g2[1];
						var color = _g2[2];
						var chans;
						var _g3 = tex.t;
						if(_g3._hx_index == 11) {
							var _g4 = _g3.dim;
							var _g4 = _g3.isArray;
							var chans1 = _g3.channels;
							chans = chans1;
						} else {
							throw haxe_Exception.thrown("assert");
						}
						this.buf.b += Std.string("imageStore(");
						this.addValue(tex,tabs);
						this.buf.b += Std.string(",");
						this.addValue(uv,tabs);
						this.buf.b += Std.string(",");
						if(chans != 4) {
							this.buf.b += Std.string("(");
						}
						this.addValue(color,tabs);
						if(chans != 4) {
							this.buf.b += Std.string(")" + (chans == 1 ? ".xx" : ".xyyy"));
						}
						this.buf.b += Std.string(")");
					} else {
						var v = _g1;
						var args = _g2;
						var _g3 = v.e;
						if(_g3._hx_index == 2) {
							var g = _g3.g;
							var v1 = this.getFunName(g,args,e.t);
							this.buf.b += Std.string(v1);
						} else {
							this.addValue(v,tabs);
						}
						this.buf.b += Std.string("(");
						var first = true;
						var _g3 = 0;
						while(_g3 < args.length) {
							var e1 = args[_g3];
							++_g3;
							if(first) {
								first = false;
							} else {
								this.buf.b += Std.string(", ");
							}
							this.addValue(e1,tabs);
						}
						this.buf.b += Std.string(")");
					}
					break;
				case 84:
					var args = _g2;
					this.buf.b += Std.string("atomicAdd(");
					this.addValue(args[0],tabs);
					this.buf.b += Std.string("[");
					this.addValue(args[1],tabs);
					this.buf.b += Std.string("],");
					this.addValue(args[2],tabs);
					this.buf.b += Std.string(")");
					break;
				default:
					var v = _g1;
					var args = _g2;
					var _g3 = v.e;
					if(_g3._hx_index == 2) {
						var g = _g3.g;
						var v1 = this.getFunName(g,args,e.t);
						this.buf.b += Std.string(v1);
					} else {
						this.addValue(v,tabs);
					}
					this.buf.b += Std.string("(");
					var first = true;
					var _g3 = 0;
					while(_g3 < args.length) {
						var e1 = args[_g3];
						++_g3;
						if(first) {
							first = false;
						} else {
							this.buf.b += Std.string(", ");
						}
						this.addValue(e1,tabs);
					}
					this.buf.b += Std.string(")");
				}
			} else {
				var v = _g1;
				var args = _g2;
				var _g1 = v.e;
				if(_g1._hx_index == 2) {
					var g = _g1.g;
					var v1 = this.getFunName(g,args,e.t);
					this.buf.b += Std.string(v1);
				} else {
					this.addValue(v,tabs);
				}
				this.buf.b += Std.string("(");
				var first = true;
				var _g1 = 0;
				while(_g1 < args.length) {
					var e1 = args[_g1];
					++_g1;
					if(first) {
						first = false;
					} else {
						this.buf.b += Std.string(", ");
					}
					this.addValue(e1,tabs);
				}
				this.buf.b += Std.string(")");
			}
			break;
		case 9:
			var e1 = _g.e;
			var regs = _g.regs;
			if(e1.t._hx_index == 3) {
				var _g1 = 0;
				while(_g1 < regs.length) {
					var r = regs[_g1];
					++_g1;
					if(r != hxsl_Component.X) {
						throw haxe_Exception.thrown("assert");
					}
				}
				switch(regs.length) {
				case 1:
					this.addValue(e1,tabs);
					break;
				case 2:
					this.decl("vec2 _vec2( float v ) { return vec2(v,v); }");
					this.buf.b += Std.string("_vec2(");
					this.addValue(e1,tabs);
					this.buf.b += Std.string(")");
					break;
				case 3:
					this.decl("vec3 _vec3( float v ) { return vec3(v,v,v); }");
					this.buf.b += Std.string("_vec3(");
					this.addValue(e1,tabs);
					this.buf.b += Std.string(")");
					break;
				case 4:
					this.decl("vec4 _vec4( float v ) { return vec4(v,v,v,v); }");
					this.buf.b += Std.string("_vec4(");
					this.addValue(e1,tabs);
					this.buf.b += Std.string(")");
					break;
				default:
					throw haxe_Exception.thrown("assert");
				}
			} else {
				this.addValue(e1,tabs);
				this.buf.b += Std.string(".");
				var _g1 = 0;
				while(_g1 < regs.length) {
					var r = regs[_g1];
					++_g1;
					var _this = this.buf;
					var _this1 = _this.b;
					var tmp;
					switch(r._hx_index) {
					case 0:
						tmp = "x";
						break;
					case 1:
						tmp = "y";
						break;
					case 2:
						tmp = "z";
						break;
					case 3:
						tmp = "w";
						break;
					}
					_this.b = _this1 + Std.string(tmp);
				}
			}
			break;
		case 10:
			var econd = _g.econd;
			var eif = _g.eif;
			var eelse = _g.eelse;
			this.buf.b += Std.string("if( ");
			this.addValue(econd,tabs);
			this.buf.b += Std.string(") ");
			this.addExpr(eif,tabs);
			if(eelse != null) {
				if(!this.isBlock(eif)) {
					this.buf.b += Std.string(";");
				}
				this.buf.b += Std.string(" else ");
				this.addExpr(eelse,tabs);
			}
			break;
		case 11:
			this.buf.b += Std.string("discard");
			break;
		case 12:
			var e1 = _g.e;
			if(e1 == null) {
				this.buf.b += Std.string("return");
			} else {
				this.buf.b += Std.string("return ");
				this.addValue(e1,tabs);
			}
			break;
		case 13:
			var v = _g.v;
			var it = _g.it;
			var loop = _g.loop;
			this.locals.h[v.id] = v;
			var _g1 = it.e;
			if(_g1._hx_index == 5) {
				if(_g1.op._hx_index == 21) {
					var e1 = _g1.e1;
					var e2 = _g1.e2;
					this.buf.b += Std.string("for(");
					this.buf.b += Std.string(v.name + "=");
					this.addValue(e1,tabs);
					this.buf.b += Std.string(";" + v.name + "<");
					this.addValue(e2,tabs);
					this.buf.b += Std.string(";" + v.name + "++) ");
					this.addBlock(loop,tabs);
				} else {
					throw haxe_Exception.thrown("assert");
				}
			} else {
				throw haxe_Exception.thrown("assert");
			}
			break;
		case 14:
			this.buf.b += Std.string("continue");
			break;
		case 15:
			this.buf.b += Std.string("break");
			break;
		case 16:
			var e1 = _g.e;
			var index = _g.index;
			this.addValue(e1,tabs);
			this.buf.b += Std.string("[");
			this.addValue(index,tabs);
			this.buf.b += Std.string("]");
			break;
		case 17:
			var el = _g.el;
			var _g1 = e.t;
			if(_g1._hx_index == 15) {
				var _g2 = _g1.size;
				var t = _g1.t;
				this.addType(t);
			} else {
				throw haxe_Exception.thrown("assert");
			}
			this.buf.b += Std.string("[" + el.length + "]");
			this.buf.b += Std.string("(");
			var first = true;
			var _g1 = 0;
			while(_g1 < el.length) {
				var e = el[_g1];
				++_g1;
				if(first) {
					first = false;
				} else {
					this.buf.b += Std.string(", ");
				}
				this.addValue(e,tabs);
			}
			this.buf.b += Std.string(")");
			break;
		case 18:
			var _g1 = _g.e;
			var _g1 = _g.cases;
			var _g1 = _g.def;
			this.buf.b += Std.string("switch(...)");
			break;
		case 19:
			var _g1 = _g.e;
			var _g2 = _g.loop;
			if(_g.normalWhile == false) {
				var loop = _g2;
				var e = _g1;
				var old = tabs;
				tabs += "\t";
				this.buf.b += Std.string("do ");
				this.addBlock(loop,tabs);
				this.buf.b += Std.string(" while( ");
				this.addValue(e,tabs);
				this.buf.b += Std.string(" )");
			} else {
				var loop = _g2;
				var e = _g1;
				this.buf.b += Std.string("while( ");
				this.addValue(e,tabs);
				this.buf.b += Std.string(" ) ");
				this.addBlock(loop,tabs);
			}
			break;
		case 20:
			var _g1 = _g.m;
			var _g1 = _g.args;
			var e = _g.e;
			this.addExpr(e,tabs);
			break;
		case 21:
			var val = _g.e;
			var name = _g.name;
			this.addExpr(val,tabs);
			this.buf.b += Std.string(".");
			this.buf.b += Std.string(name);
			break;
		case 22:
			var _g1 = _g.code;
			var _g2 = _g.args;
			switch(_g.target) {
			case "code":case "glsl":
				var code = _g1;
				var args = _g2;
				var pos = 0;
				var argRegex = new EReg("{(\\d+)}","g");
				while(argRegex.matchSub(code,pos)) {
					var matchPos = argRegex.matchedPos();
					this.buf.b += Std.string(code.substring(pos,matchPos.pos));
					var index = Std.parseInt(argRegex.matched(1));
					if(index < args.length) {
						this.addValue(args[index].e,tabs);
					}
					pos = matchPos.pos + matchPos.len;
				}
				this.buf.b += Std.string(HxOverrides.substr(code,pos,null));
				break;
			default:
			}
			break;
		}
	}
	,varName: function(v) {
		if(v.kind == hxsl_VarKind.Output) {
			if(this.isVertex) {
				return "gl_Position";
			}
			if(this.glES != null && this.glES <= 2) {
				if(this.outIndexes == null) {
					return "gl_FragColor";
				}
				return "gl_FragData[" + this.outIndexes.h[v.id] + "]";
			}
		}
		var n = this.varNames.h[v.id];
		if(n != null) {
			return n;
		}
		n = v.name;
		if(v.kind == hxsl_VarKind.Var) {
			n += "_varying";
		}
		if(Object.prototype.hasOwnProperty.call(hxsl_GlslOut.KWDS.h,n)) {
			n = "_" + n;
		}
		if(Object.prototype.hasOwnProperty.call(this.allNames.h,n)) {
			var k = 2;
			n += "_";
			while(Object.prototype.hasOwnProperty.call(this.allNames.h,n + k)) ++k;
			n += k;
		}
		this.varNames.h[v.id] = n;
		this.allNames.h[n] = v.id;
		return n;
	}
	,newLine: function(e) {
		if(this.isBlock(e)) {
			this.buf.b += Std.string("\n");
		} else {
			this.buf.b += Std.string(";\n");
		}
	}
	,isBlock: function(e) {
		var _g = e.e;
		switch(_g._hx_index) {
		case 4:
			var _g1 = _g.el;
			return true;
		case 13:
			var _g1 = _g.v;
			var _g1 = _g.it;
			var loop = _g.loop;
			return this.isBlock(loop);
		case 19:
			var _g1 = _g.e;
			if(_g.normalWhile == true) {
				var loop = _g.loop;
				return this.isBlock(loop);
			} else {
				return false;
			}
			break;
		default:
			return false;
		}
	}
	,initVar: function(v) {
		switch(v.kind._hx_index) {
		case 0:case 2:
			var _g = v.type;
			switch(_g._hx_index) {
			case 15:
				var _g1 = _g.t;
				var _g2 = _g.size;
				if(_g1._hx_index == 11) {
					var _g2 = _g1.dim;
					var _g2 = _g1.isArray;
					var chans = _g1.channels;
					var format = HxOverrides.substr("rgba",0,chans);
					this.buf.b += Std.string("layout(" + format + "32f) uniform ");
				} else {
					this.buf.b += Std.string("uniform ");
				}
				break;
			case 16:
				var _g1 = _g.t;
				var _g1 = _g.size;
				var _g1 = _g.kind;
				switch(_g1._hx_index) {
				case 1:case 4:
					if(this.version < 430) {
						throw haxe_Exception.thrown("SSBO are available since version 4.3");
					}
					this.buf.b += Std.string("layout(std430) readonly buffer ");
					break;
				case 2:case 5:
					if(this.version < 430) {
						throw haxe_Exception.thrown("SSBO are available since version 4.3");
					}
					this.buf.b += Std.string("layout(std430) buffer ");
					break;
				default:
					var kind = _g1;
					this.buf.b += Std.string("layout(std140) ");
					switch(kind._hx_index) {
					case 0:case 3:
						this.buf.b += Std.string("uniform ");
						break;
					default:
						throw haxe_Exception.thrown("assert");
					}
				}
				break;
			default:
				this.buf.b += Std.string("uniform ");
			}
			break;
		case 1:
			this.buf.b += Std.string(this.glES != null && this.glES <= 2 ? "attribute " : "in ");
			break;
		case 3:
			if(hxsl_Tools.hasQualifier(v,hxsl_VarQualifier.Flat)) {
				this.buf.b += Std.string("flat ");
			}
			this.buf.b += Std.string(this.glES != null && this.glES <= 2 ? "varying " : this.isVertex ? "out " : "in ");
			break;
		case 4:
			break;
		case 5:
			if(this.glES != null && this.glES <= 2) {
				this.outIndexes.h[v.id] = this.outIndex++;
				return;
			}
			if(this.isVertex) {
				return;
			}
			if(this.glES != null) {
				this.buf.b += Std.string("layout(location=" + this.outIndex++ + ") ");
			}
			this.buf.b += Std.string("out ");
			break;
		case 6:
			return;
		}
		if(v.qualifiers != null) {
			var _g = 0;
			var _g1 = v.qualifiers;
			while(_g < _g1.length) {
				var q = _g1[_g];
				++_g;
				if(q._hx_index == 6) {
					var p = q.p;
					switch(p._hx_index) {
					case 0:
						this.buf.b += Std.string("lowp ");
						break;
					case 1:
						this.buf.b += Std.string("mediump ");
						break;
					case 2:
						this.buf.b += Std.string("highp ");
						break;
					}
				}
			}
		}
		this.addVar(v);
		this.buf.b += Std.string(";\n");
	}
	,initVars: function(s) {
		this.outIndex = 0;
		this.uniformBuffer = 0;
		this.outIndexes = new haxe_ds_IntMap();
		var _g = 0;
		var _g1 = s.vars;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			this.initVar(v);
		}
		this.buf.b += Std.string("\n");
		if(this.outIndex < 2) {
			this.outIndexes = null;
		} else if(!this.isVertex && (this.glES != null && this.glES <= 2)) {
			this.decl("#extension GL_EXT_draw_buffers : enable");
		}
	}
	,collectGlobals: function(m,e) {
		var _g = e.e;
		switch(_g._hx_index) {
		case 2:
			var g = _g.g;
			m.set(g,true);
			break;
		case 8:
			var _g1 = _g.e;
			var _g2 = _g.args;
			var _g = _g1.e;
			var _g3 = _g1.p;
			var _g3 = _g1.t;
			if(_g._hx_index == 2) {
				if(_g.g._hx_index == 78) {
					switch(_g2.length) {
					case 1:
						var _g = _g2[0];
						var _g1 = _g.e;
						var _g3 = _g.p;
						var _g3 = _g.t;
						if(_g1._hx_index == 0) {
							var _g = _g1.c;
							if(_g._hx_index == 2) {
								var x = _g.v;
								this.computeLayout = [x,1,1];
							} else {
								var _g = this;
								var m1 = m;
								hxsl_Tools.iter(e,function(e) {
									_g.collectGlobals(m1,e);
								});
							}
						} else {
							var _g1 = this;
							var m2 = m;
							hxsl_Tools.iter(e,function(e) {
								_g1.collectGlobals(m2,e);
							});
						}
						break;
					case 2:
						var _g3 = _g2[0];
						var _g4 = _g2[1];
						var _g5 = _g3.e;
						var _g6 = _g3.p;
						var _g6 = _g3.t;
						if(_g5._hx_index == 0) {
							var _g3 = _g5.c;
							if(_g3._hx_index == 2) {
								var _g5 = _g4.e;
								var _g6 = _g4.p;
								var _g6 = _g4.t;
								if(_g5._hx_index == 0) {
									var _g4 = _g5.c;
									if(_g4._hx_index == 2) {
										var y = _g4.v;
										var x = _g3.v;
										this.computeLayout = [x,y,1];
									} else {
										var _g3 = this;
										var m3 = m;
										hxsl_Tools.iter(e,function(e) {
											_g3.collectGlobals(m3,e);
										});
									}
								} else {
									var _g4 = this;
									var m4 = m;
									hxsl_Tools.iter(e,function(e) {
										_g4.collectGlobals(m4,e);
									});
								}
							} else {
								var _g5 = this;
								var m5 = m;
								hxsl_Tools.iter(e,function(e) {
									_g5.collectGlobals(m5,e);
								});
							}
						} else {
							var _g6 = this;
							var m6 = m;
							hxsl_Tools.iter(e,function(e) {
								_g6.collectGlobals(m6,e);
							});
						}
						break;
					case 3:
						var _g7 = _g2[0];
						var _g8 = _g2[1];
						var _g9 = _g2[2];
						var _g2 = _g7.e;
						var _g10 = _g7.p;
						var _g10 = _g7.t;
						if(_g2._hx_index == 0) {
							var _g7 = _g2.c;
							if(_g7._hx_index == 2) {
								var _g2 = _g8.e;
								var _g10 = _g8.p;
								var _g10 = _g8.t;
								if(_g2._hx_index == 0) {
									var _g8 = _g2.c;
									if(_g8._hx_index == 2) {
										var _g2 = _g9.e;
										var _g10 = _g9.p;
										var _g10 = _g9.t;
										if(_g2._hx_index == 0) {
											var _g9 = _g2.c;
											if(_g9._hx_index == 2) {
												var z = _g9.v;
												var x = _g7.v;
												var y = _g8.v;
												this.computeLayout = [x,y,z];
											} else {
												var _g2 = this;
												var m7 = m;
												hxsl_Tools.iter(e,function(e) {
													_g2.collectGlobals(m7,e);
												});
											}
										} else {
											var _g7 = this;
											var m8 = m;
											hxsl_Tools.iter(e,function(e) {
												_g7.collectGlobals(m8,e);
											});
										}
									} else {
										var _g8 = this;
										var m9 = m;
										hxsl_Tools.iter(e,function(e) {
											_g8.collectGlobals(m9,e);
										});
									}
								} else {
									var _g9 = this;
									var m10 = m;
									hxsl_Tools.iter(e,function(e) {
										_g9.collectGlobals(m10,e);
									});
								}
							} else {
								var _g10 = this;
								var m11 = m;
								hxsl_Tools.iter(e,function(e) {
									_g10.collectGlobals(m11,e);
								});
							}
						} else {
							var _g11 = this;
							var m12 = m;
							hxsl_Tools.iter(e,function(e) {
								_g11.collectGlobals(m12,e);
							});
						}
						break;
					default:
						var _g12 = this;
						var m13 = m;
						hxsl_Tools.iter(e,function(e) {
							_g12.collectGlobals(m13,e);
						});
					}
				} else {
					var _g13 = this;
					var m14 = m;
					hxsl_Tools.iter(e,function(e) {
						_g13.collectGlobals(m14,e);
					});
				}
			} else {
				var _g14 = this;
				var m15 = m;
				hxsl_Tools.iter(e,function(e) {
					_g14.collectGlobals(m15,e);
				});
			}
			break;
		default:
			var _g15 = this;
			var m16 = m;
			hxsl_Tools.iter(e,function(e) {
				_g15.collectGlobals(m16,e);
			});
		}
	}
	,run: function(s) {
		var foundGlobals = new haxe_ds_EnumValueMap();
		var _g = 0;
		var _g1 = s.funs;
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			this.collectGlobals(foundGlobals,f.expr);
		}
		this.locals = new haxe_ds_IntMap();
		this.decls = [];
		this.buf = new StringBuf();
		this.exprValues = [];
		if(s.funs.length != 1) {
			throw haxe_Exception.thrown("assert");
		}
		var f = s.funs[0];
		this.isVertex = f.kind == hxsl_FunctionKind.Vertex;
		this.isCompute = f.kind == hxsl_FunctionKind.Main;
		if(!this.isCompute) {
			if(this.isVertex) {
				this.decl("precision highp float;");
			} else {
				this.decl("precision mediump float;");
			}
		}
		this.initVars(s);
		if(this.isCompute) {
			this.decl("layout(local_size_x = " + this.computeLayout[0] + ", local_size_y = " + this.computeLayout[1] + ", local_size_z = " + this.computeLayout[2] + ") in;");
		}
		var tmp = this.buf;
		this.buf = new StringBuf();
		this.buf.b += Std.string("void main(void) {\n");
		var _g = f.expr.e;
		if(_g._hx_index == 4) {
			var el = _g.el;
			var _g = 0;
			while(_g < el.length) {
				var e = el[_g];
				++_g;
				this.buf.b += Std.string("\t");
				this.addExpr(e,"\t");
				this.newLine(e);
			}
		} else {
			this.addExpr(f.expr,"");
		}
		if(this.isVertex) {
			this.buf.b += Std.string("\tgl_Position.z += gl_Position.z - gl_Position.w;\n");
		}
		this.buf.b += Std.string("}");
		this.exprValues.push(this.buf.b);
		this.buf = tmp;
		var locals = Lambda.array(this.locals);
		locals.sort(function(v1,v2) {
			return Reflect.compare(v1.name,v2.name);
		});
		var _g = 0;
		while(_g < locals.length) {
			var v = locals[_g];
			++_g;
			this.addVar(v);
			this.buf.b += Std.string(";\n");
		}
		this.buf.b += Std.string("\n");
		var _g = 0;
		var _g1 = this.exprValues;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			this.buf.b += Std.string(e);
			this.buf.b += Std.string("\n\n");
		}
		if(this.glES != null) {
			this.decl("#version " + (this.version < 100 ? 100 : this.version) + (this.version > 150 ? " es" : ""));
		} else if(this.isCompute || this.version >= 430) {
			this.decl("#version 430");
		} else if(this.version != null) {
			this.decl("#version " + (this.version > 150 ? 150 : this.version));
		} else {
			this.decl("#version 130");
		}
		this.decls.push(this.buf.b);
		this.buf = null;
		return this.decls.join("\n");
	}
	,__class__: hxsl_GlslOut
};
var hxsl__$Linker_AllocatedVar = function() {
};
$hxClasses["hxsl._Linker.AllocatedVar"] = hxsl__$Linker_AllocatedVar;
hxsl__$Linker_AllocatedVar.__name__ = "hxsl._Linker.AllocatedVar";
hxsl__$Linker_AllocatedVar.prototype = {
	__class__: hxsl__$Linker_AllocatedVar
};
var hxsl__$Linker_ShaderInfos = function(n,v) {
	this.name = n;
	this.uid = hxsl__$Linker_ShaderInfos.UID++;
	this.vertex = v;
	this.processed = new haxe_ds_IntMap();
	this.usedFunctions = [];
	this.readMap = new haxe_ds_IntMap();
	this.readVars = [];
	this.writeMap = new haxe_ds_IntMap();
	this.writeVars = [];
};
$hxClasses["hxsl._Linker.ShaderInfos"] = hxsl__$Linker_ShaderInfos;
hxsl__$Linker_ShaderInfos.__name__ = "hxsl._Linker.ShaderInfos";
hxsl__$Linker_ShaderInfos.prototype = {
	__class__: hxsl__$Linker_ShaderInfos
};
var hxsl_Linker = function(mode) {
	this.debugDepth = 0;
	this.mode = mode;
};
$hxClasses["hxsl.Linker"] = hxsl_Linker;
hxsl_Linker.__name__ = "hxsl.Linker";
hxsl_Linker.prototype = {
	error: function(msg,p) {
		return hxsl_Error.t(msg,p);
	}
	,mergeVar: function(path,v,v2,p,shaderName) {
		switch(v.kind._hx_index) {
		case 2:
			if(!(shaderName != null && hxsl_Tools.hasBorrowQualifier(v2,shaderName))) {
				throw haxe_Exception.thrown("assert");
			}
			break;
		case 0:case 1:case 3:case 4:case 5:
			break;
		case 6:
			throw haxe_Exception.thrown("assert");
		}
		if(v.kind != v2.kind && v.kind != hxsl_VarKind.Local && v2.kind != hxsl_VarKind.Local) {
			this.error("'" + path + "' kind does not match : " + Std.string(v.kind) + " should be " + Std.string(v2.kind),p);
		}
		var _g = v.type;
		var _g1 = v2.type;
		if(_g._hx_index == 13) {
			if(_g1._hx_index == 13) {
				var fl2 = _g1.vl;
				var fl1 = _g.vl;
				var _g = 0;
				while(_g < fl1.length) {
					var f1 = fl1[_g];
					++_g;
					var ft = null;
					var _g1 = 0;
					while(_g1 < fl2.length) {
						var f2 = fl2[_g1];
						++_g1;
						if(f1.name == f2.name) {
							ft = f2;
							break;
						}
					}
					if(ft == null) {
						fl2.push(this.allocVar(f1,p,shaderName).v);
					} else {
						this.mergeVar(path + "." + ft.name,f1,ft,p,shaderName);
					}
				}
			} else if(!Type.enumEq(v.type,v2.type)) {
				this.error("'" + path + "' type does not match : " + hxsl_Tools.toString(v.type) + " should be " + hxsl_Tools.toString(v2.type),p);
			}
		} else if(!Type.enumEq(v.type,v2.type)) {
			this.error("'" + path + "' type does not match : " + hxsl_Tools.toString(v.type) + " should be " + hxsl_Tools.toString(v2.type),p);
		}
	}
	,allocVar: function(v,p,shaderName,path,parent) {
		var _gthis = this;
		if(v.parent != null && parent == null) {
			parent = this.allocVar(v.parent,p,shaderName);
			var p1 = parent.v;
			path = p1.name;
			p1 = p1.parent;
			while(p1 != null) {
				path = p1.name + "." + path;
				p1 = p1.parent;
			}
		}
		var key = path == null ? v.name : path + "." + v.name;
		if(v.qualifiers != null) {
			var _g = 0;
			var _g1 = v.qualifiers;
			while(_g < _g1.length) {
				var q = _g1[_g];
				++_g;
				if(q._hx_index == 4) {
					var n = q.n;
					key = n;
				}
			}
		}
		var ukey = key.toLowerCase();
		var v2 = this.varMap.h[ukey];
		var vname = v.name;
		if(v2 != null) {
			var _g = 0;
			var _g1 = v2.merged;
			while(_g < _g1.length) {
				var vm = _g1[_g];
				++_g;
				if(vm == v) {
					return v2;
				}
			}
			var tmp;
			var borrowed = hxsl_Tools.hasBorrowQualifier(v2.v,shaderName);
			if(!(v.kind == hxsl_VarKind.Param && !borrowed && !hxsl_Tools.hasQualifier(v,hxsl_VarQualifier.Shared) && !_gthis.isBatchShader || v.kind == hxsl_VarKind.Function || (v.kind == hxsl_VarKind.Var || v.kind == hxsl_VarKind.Local) && hxsl_Tools.hasQualifier(v,hxsl_VarQualifier.Private))) {
				var v1 = v2.v;
				var borrowed = hxsl_Tools.hasBorrowQualifier(v,v2.rootShaderName);
				tmp = v1.kind == hxsl_VarKind.Param && !borrowed && !hxsl_Tools.hasQualifier(v1,hxsl_VarQualifier.Shared) && !_gthis.isBatchShader || v1.kind == hxsl_VarKind.Function || (v1.kind == hxsl_VarKind.Var || v1.kind == hxsl_VarKind.Local) && hxsl_Tools.hasQualifier(v1,hxsl_VarQualifier.Private);
			} else {
				tmp = true;
			}
			if(tmp || v.kind == hxsl_VarKind.Param && v2.v.kind == hxsl_VarKind.Param) {
				var k = 2;
				while(true) {
					var a = this.varMap.h[ukey + k];
					if(a == null) {
						break;
					}
					var _g = 0;
					var _g1 = a.merged;
					while(_g < _g1.length) {
						var vm = _g1[_g];
						++_g;
						if(vm == v) {
							return a;
						}
					}
					++k;
				}
				if(v.kind == hxsl_VarKind.Input) {
					var _this = this.varMap;
					if(Object.prototype.hasOwnProperty.call(_this.h,ukey)) {
						delete(_this.h[ukey]);
					}
					this.varMap.h[ukey + k] = v2;
					v2.v.name += k;
					v2.path += k;
				} else {
					vname += k;
					key += k;
					ukey += k;
				}
			} else {
				v2.merged.push(v);
				this.mergeVar(key,v,v2.v,p,v2.rootShaderName);
				this.varIdMap.h[v.id] = v2.id;
				return v2;
			}
		}
		var v2 = { id : hxsl_Tools.allocVarId(), name : vname, type : v.type, kind : v.kind, qualifiers : v.qualifiers, parent : parent == null ? null : parent.v};
		var a = new hxsl__$Linker_AllocatedVar();
		a.v = v2;
		a.merged = [v];
		a.path = key;
		a.id = v2.id;
		a.parent = parent;
		a.instanceIndex = this.curInstance;
		a.rootShaderName = shaderName;
		this.allVars.push(a);
		this.varMap.h[ukey] = a;
		var _g = v2.type;
		if(_g._hx_index == 13) {
			var vl = _g.vl;
			var _g = [];
			var _g1 = 0;
			while(_g1 < vl.length) {
				var v = vl[_g1];
				++_g1;
				_g.push(this.allocVar(v,p,shaderName,key,a).v);
			}
			v2.type = hxsl_Type.TStruct(_g);
		}
		return a;
	}
	,mapExprVar: function(e) {
		var _g = e.e;
		switch(_g._hx_index) {
		case 1:
			var v = _g.v;
			if(!this.locals.h.hasOwnProperty(v.id)) {
				var v1 = this.allocVar(v,e.p);
				if(this.curShader != null && !this.curShader.writeMap.h.hasOwnProperty(v1.id)) {
					if(hxsl_Debug.TRACE) {
						var msg = this.curShader.name + " read " + v1.path;
						var _g1 = 0;
						var _g2 = this.debugDepth;
						while(_g1 < _g2) {
							var i = _g1++;
							msg = "    " + msg;
						}
						haxe_Log.trace(msg,{ fileName : "hxsl/Debug.hx", lineNumber : 31, className : "hxsl.Linker", methodName : "mapExprVar"});
					}
					if(!this.curShader.readMap.h.hasOwnProperty(v1.id)) {
						this.curShader.readMap.h[v1.id] = v1;
						this.curShader.readVars.push(v1);
					}
					if(this.curShader.vertex == null && v1.v.kind == hxsl_VarKind.Var) {
						if(hxsl_Debug.TRACE) {
							var msg = "Force " + this.curShader.name + " into fragment (use varying)";
							var _g1 = 0;
							var _g2 = this.debugDepth;
							while(_g1 < _g2) {
								var i = _g1++;
								msg = "    " + msg;
							}
							haxe_Log.trace(msg,{ fileName : "hxsl/Debug.hx", lineNumber : 31, className : "hxsl.Linker", methodName : "mapExprVar"});
						}
						this.curShader.vertex = false;
					}
				}
				return { e : hxsl_TExprDef.TVar(v1.v), t : v1.v.type, p : e.p};
			}
			break;
		case 5:
			var op = _g.op;
			var e1 = _g.e1;
			var e2 = _g.e2;
			var _g1 = e1.e;
			switch(op._hx_index) {
			case 4:
				switch(_g1._hx_index) {
				case 1:
					var _g2 = _g1.v;
					var v = _g2;
					if(!this.locals.h.hasOwnProperty(v.id)) {
						var e21 = this.mapExprVar(e2);
						var v1 = this.allocVar(v,e1.p);
						if(this.curShader != null && !this.curShader.writeMap.h.hasOwnProperty(v1.id)) {
							if(hxsl_Debug.TRACE) {
								var msg = this.curShader.name + " write " + v1.path;
								var _g3 = 0;
								var _g4 = this.debugDepth;
								while(_g3 < _g4) {
									var i = _g3++;
									msg = "    " + msg;
								}
								haxe_Log.trace(msg,{ fileName : "hxsl/Debug.hx", lineNumber : 31, className : "hxsl.Linker", methodName : "mapExprVar"});
							}
							this.curShader.writeMap.h[v1.id] = v1;
							this.curShader.writeVars.push(v1);
						}
						return { e : hxsl_TExprDef.TBinop(op,{ e : hxsl_TExprDef.TVar(v1.v), t : v1.v.type, p : e.p},e21), t : e.t, p : e.p};
					} else {
						var v = _g2;
						if(!this.locals.h.hasOwnProperty(v.id)) {
							var e11 = this.mapExprVar(e1);
							var e21 = this.mapExprVar(e2);
							var v1 = this.allocVar(v,e11.p);
							if(this.curShader != null && !this.curShader.writeMap.h.hasOwnProperty(v1.id)) {
								if(hxsl_Debug.TRACE) {
									var msg = this.curShader.name + " write " + v1.path;
									var _g2 = 0;
									var _g3 = this.debugDepth;
									while(_g2 < _g3) {
										var i = _g2++;
										msg = "    " + msg;
									}
									haxe_Log.trace(msg,{ fileName : "hxsl/Debug.hx", lineNumber : 31, className : "hxsl.Linker", methodName : "mapExprVar"});
								}
								this.curShader.writeMap.h[v1.id] = v1;
								this.curShader.writeVars.push(v1);
							}
							return { e : hxsl_TExprDef.TBinop(op,e11,e21), t : e.t, p : e.p};
						}
					}
					break;
				case 9:
					var _g2 = _g1.e;
					var _g3 = _g1.regs;
					var _g3 = _g2.e;
					var _g4 = _g2.p;
					var _g4 = _g2.t;
					if(_g3._hx_index == 1) {
						var v = _g3.v;
						if(!this.locals.h.hasOwnProperty(v.id)) {
							var e11 = this.mapExprVar(e1);
							var e21 = this.mapExprVar(e2);
							var v1 = this.allocVar(v,e11.p);
							if(this.curShader != null && !this.curShader.writeMap.h.hasOwnProperty(v1.id)) {
								if(hxsl_Debug.TRACE) {
									var msg = this.curShader.name + " write " + v1.path;
									var _g2 = 0;
									var _g3 = this.debugDepth;
									while(_g2 < _g3) {
										var i = _g2++;
										msg = "    " + msg;
									}
									haxe_Log.trace(msg,{ fileName : "hxsl/Debug.hx", lineNumber : 31, className : "hxsl.Linker", methodName : "mapExprVar"});
								}
								this.curShader.writeMap.h[v1.id] = v1;
								this.curShader.writeVars.push(v1);
							}
							return { e : hxsl_TExprDef.TBinop(op,e11,e21), t : e.t, p : e.p};
						}
					}
					break;
				default:
				}
				break;
			case 20:
				var _g2 = op.op;
				switch(_g1._hx_index) {
				case 1:
					var v = _g1.v;
					if(!this.locals.h.hasOwnProperty(v.id)) {
						var e11 = this.mapExprVar(e1);
						var e21 = this.mapExprVar(e2);
						var v1 = this.allocVar(v,e11.p);
						if(this.curShader != null && !this.curShader.writeMap.h.hasOwnProperty(v1.id)) {
							if(hxsl_Debug.TRACE) {
								var msg = this.curShader.name + " write " + v1.path;
								var _g2 = 0;
								var _g3 = this.debugDepth;
								while(_g2 < _g3) {
									var i = _g2++;
									msg = "    " + msg;
								}
								haxe_Log.trace(msg,{ fileName : "hxsl/Debug.hx", lineNumber : 31, className : "hxsl.Linker", methodName : "mapExprVar"});
							}
							this.curShader.writeMap.h[v1.id] = v1;
							this.curShader.writeVars.push(v1);
						}
						return { e : hxsl_TExprDef.TBinop(op,e11,e21), t : e.t, p : e.p};
					}
					break;
				case 9:
					var _g2 = _g1.e;
					var _g3 = _g1.regs;
					var _g1 = _g2.e;
					var _g3 = _g2.p;
					var _g3 = _g2.t;
					if(_g1._hx_index == 1) {
						var v = _g1.v;
						if(!this.locals.h.hasOwnProperty(v.id)) {
							var e11 = this.mapExprVar(e1);
							var e21 = this.mapExprVar(e2);
							var v1 = this.allocVar(v,e11.p);
							if(this.curShader != null && !this.curShader.writeMap.h.hasOwnProperty(v1.id)) {
								if(hxsl_Debug.TRACE) {
									var msg = this.curShader.name + " write " + v1.path;
									var _g1 = 0;
									var _g2 = this.debugDepth;
									while(_g1 < _g2) {
										var i = _g1++;
										msg = "    " + msg;
									}
									haxe_Log.trace(msg,{ fileName : "hxsl/Debug.hx", lineNumber : 31, className : "hxsl.Linker", methodName : "mapExprVar"});
								}
								this.curShader.writeMap.h[v1.id] = v1;
								this.curShader.writeVars.push(v1);
							}
							return { e : hxsl_TExprDef.TBinop(op,e11,e21), t : e.t, p : e.p};
						}
					}
					break;
				default:
				}
				break;
			default:
			}
			break;
		case 7:
			var _g1 = _g.init;
			var v = _g.v;
			this.locals.h[v.id] = true;
			break;
		case 11:
			if(this.curShader != null) {
				this.curShader.vertex = false;
				this.curShader.hasDiscard = true;
			}
			break;
		case 13:
			var _g1 = _g.it;
			var _g1 = _g.loop;
			var v = _g.v;
			this.locals.h[v.id] = true;
			break;
		case 22:
			var target = _g.target;
			var code = _g.code;
			var args = _g.args;
			var mappedArgs = [];
			var _g = 0;
			while(_g < args.length) {
				var arg = args[_g];
				++_g;
				var e1;
				switch(arg.access._hx_index) {
				case 0:
					e1 = this.mapExprVar(arg.e);
					break;
				case 1:
					var e2 = this.curShader != null ? this.mapSyntaxWrite(arg.e) : arg.e;
					e1 = this.mapExprVar(e2);
					break;
				case 2:
					var e3 = this.mapExprVar(arg.e);
					if(this.curShader != null) {
						e3 = this.mapSyntaxWrite(e3);
					}
					e1 = e3;
					break;
				}
				mappedArgs.push({ e : e1, access : arg.access});
			}
			if(this.curShader != null) {
				this.curShader.hasSyntax = true;
			}
			return { e : hxsl_TExprDef.TSyntax(target,code,mappedArgs), t : e.t, p : e.p};
		default:
		}
		return hxsl_Tools.map(e,$bind(this,this.mapExprVar));
	}
	,mapSyntaxWrite: function(e) {
		var _g = e.e;
		if(_g._hx_index == 1) {
			var v = _g.v;
			var v1 = this.allocVar(v,e.p);
			if(!this.curShader.writeMap.h.hasOwnProperty(v1.id)) {
				if(hxsl_Debug.TRACE) {
					var msg = this.curShader.name + " syntax write " + v1.path;
					var _g = 0;
					var _g1 = this.debugDepth;
					while(_g < _g1) {
						var i = _g++;
						msg = "    " + msg;
					}
					haxe_Log.trace(msg,{ fileName : "hxsl/Debug.hx", lineNumber : 31, className : "hxsl.Linker", methodName : "mapSyntaxWrite"});
				}
				this.curShader.writeMap.h[v1.id] = v1;
				this.curShader.writeVars.push(v1);
			}
			return { e : hxsl_TExprDef.TVar(v1.v), t : v1.v.type, p : e.p};
		} else {
			return hxsl_Tools.map(e,$bind(this,this.mapSyntaxWrite));
		}
	}
	,addShader: function(name,vertex,e,p) {
		var s = new hxsl__$Linker_ShaderInfos(name,vertex);
		this.curShader = s;
		s.priority = p;
		s.body = this.mapExprVar(e);
		this.shaders.push(s);
		this.curShader = null;
		if(hxsl_Debug.TRACE) {
			var msg = "Adding shader " + name + " with priority " + p;
			var _g = 0;
			var _g1 = this.debugDepth;
			while(_g < _g1) {
				var i = _g++;
				msg = "    " + msg;
			}
			haxe_Log.trace(msg,{ fileName : "hxsl/Debug.hx", lineNumber : 31, className : "hxsl.Linker", methodName : "addShader"});
		}
		return s;
	}
	,sortByPriorityDesc: function(s1,s2) {
		if(s1.priority == s2.priority) {
			return s1.uid - s2.uid;
		}
		return s2.priority - s1.priority;
	}
	,buildDependency: function(s,v,isWritten) {
		var found = !isWritten;
		var _g = 0;
		var _g1 = this.shaders;
		while(_g < _g1.length) {
			var parent = _g1[_g];
			++_g;
			if(parent == s) {
				found = true;
				continue;
			} else if(!found) {
				continue;
			}
			if(!parent.writeMap.h.hasOwnProperty(v.id)) {
				continue;
			}
			if(s.vertex) {
				if(parent.vertex == false) {
					continue;
				}
				if(parent.vertex == null) {
					parent.vertex = true;
				}
			}
			if(hxsl_Debug.TRACE) {
				var msg = s.name + " => " + parent.name + " (" + v.path + ")";
				var _g2 = 0;
				var _g3 = this.debugDepth;
				while(_g2 < _g3) {
					var i = _g2++;
					msg = "    " + msg;
				}
				haxe_Log.trace(msg,{ fileName : "hxsl/Debug.hx", lineNumber : 31, className : "hxsl.Linker", methodName : "buildDependency"});
			}
			s.deps.set(parent,true);
			this.debugDepth++;
			this.initDependencies(parent);
			this.debugDepth--;
			if(!parent.readMap.h.hasOwnProperty(v.id)) {
				return;
			}
		}
		if(v.v.kind == hxsl_VarKind.Var) {
			this.error("Variable " + v.path + " required by " + s.name + " is missing initializer",null);
		}
	}
	,initDependencies: function(s) {
		if(s.deps != null) {
			return;
		}
		s.deps = new haxe_ds_ObjectMap();
		var _g = 0;
		var _g1 = s.readVars;
		while(_g < _g1.length) {
			var r = _g1[_g];
			++_g;
			this.buildDependency(s,r,s.writeMap.h.hasOwnProperty(r.id));
		}
	}
	,collect: function(cur,out,vertex) {
		if(cur.onStack) {
			this.error("Loop in shader dependencies (" + cur.name + ")",null);
		}
		if(cur.marked == vertex) {
			return;
		}
		cur.marked = vertex;
		cur.onStack = true;
		var _g = [];
		var d = cur.deps.keys();
		while(d.hasNext()) {
			var d1 = d.next();
			_g.push(d1);
		}
		var deps = _g;
		deps.sort($bind(this,this.sortByPriorityDesc));
		var _g = 0;
		while(_g < deps.length) {
			var d = deps[_g];
			++_g;
			this.collect(d,out,vertex);
		}
		if(cur.vertex == null) {
			if(hxsl_Debug.TRACE) {
				var msg = "MARK " + cur.name + " " + (vertex ? "vertex" : "fragment");
				var _g = 0;
				var _g1 = this.debugDepth;
				while(_g < _g1) {
					var i = _g++;
					msg = "    " + msg;
				}
				haxe_Log.trace(msg,{ fileName : "hxsl/Debug.hx", lineNumber : 31, className : "hxsl.Linker", methodName : "collect"});
			}
			cur.vertex = vertex;
		}
		if(cur.vertex == vertex) {
			if(hxsl_Debug.TRACE) {
				var msg = "COLLECT " + cur.name + " " + (vertex ? "vertex" : "fragment");
				var _g = 0;
				var _g1 = this.debugDepth;
				while(_g < _g1) {
					var i = _g++;
					msg = "    " + msg;
				}
				haxe_Log.trace(msg,{ fileName : "hxsl/Debug.hx", lineNumber : 31, className : "hxsl.Linker", methodName : "collect"});
			}
			out.push(cur);
		}
		cur.onStack = false;
	}
	,link: function(shadersData) {
		if(hxsl_Debug.TRACE) {
			var msg = "---------------------- LINKING -----------------------";
			var _g = 0;
			var _g1 = this.debugDepth;
			while(_g < _g1) {
				var i = _g++;
				msg = "    " + msg;
			}
			haxe_Log.trace(msg,{ fileName : "hxsl/Debug.hx", lineNumber : 31, className : "hxsl.Linker", methodName : "link"});
		}
		this.varMap = new haxe_ds_StringMap();
		this.varIdMap = new haxe_ds_IntMap();
		this.allVars = [];
		this.shaders = [];
		this.locals = new haxe_ds_IntMap();
		var dupShaders = [];
		var _g = [];
		var _g_current = 0;
		var _g_array = shadersData;
		while(_g_current < _g_array.length) {
			var _g_value = _g_array[_g_current];
			var _g_key = _g_current++;
			var i = _g_key;
			var s = _g_value;
			if(shadersData.indexOf(s) < i) {
				var s2 = hxsl_Clone.shaderData(s);
				dupShaders.push({ origin : s, cloned : s2});
				_g.push(s2);
			} else {
				_g.push(s);
			}
		}
		shadersData = _g;
		this.curInstance = 0;
		var outVars = [];
		var _g = 0;
		while(_g < shadersData.length) {
			var s = shadersData[_g];
			++_g;
			this.isBatchShader = this.mode == hxsl_LinkMode.Batch && StringTools.startsWith(s.name,"batchShader_");
			var _g1 = 0;
			var _g2 = s.vars;
			while(_g1 < _g2.length) {
				var v = _g2[_g1];
				++_g1;
				var v2 = this.allocVar(v,null,s.name);
				if(this.isBatchShader && v2.v.kind == hxsl_VarKind.Param && !StringTools.startsWith(v2.path,"Batch_")) {
					v2.v.kind = hxsl_VarKind.Local;
					if(v2.v.qualifiers == null) {
						v2.v.qualifiers = [];
					}
					v2.v.qualifiers.push(hxsl_VarQualifier.Flat);
				}
				if(v.kind == hxsl_VarKind.Output) {
					outVars.push(v);
				}
			}
			var _g3 = 0;
			var _g4 = s.funs;
			while(_g3 < _g4.length) {
				var f = _g4[_g3];
				++_g3;
				var v1 = this.allocVar(f.ref,f.expr.p);
				v1.kind = f.kind;
			}
			this.curInstance++;
		}
		var priority = 0;
		var initPrio_init = [-3000];
		var initPrio_vert = [-2000];
		var initPrio_frag = [-1000];
		var initPrio_main = [-2500];
		var shaderOffset_vert = -1500;
		var shaderOffset_frag = -500;
		var _g = 0;
		while(_g < shadersData.length) {
			var s = shadersData[_g];
			++_g;
			var _g1 = 0;
			var _g2 = s.funs;
			while(_g1 < _g2.length) {
				var f = _g2[_g1];
				++_g1;
				var v = this.allocVar(f.ref,f.expr.p);
				if(v.kind == null) {
					throw haxe_Exception.thrown("assert");
				}
				switch(v.kind._hx_index) {
				case 0:case 1:
					if(this.mode == hxsl_LinkMode.Compute) {
						var e = v.kind;
						throw haxe_Exception.thrown("Unexpected " + $hxEnums[e.__enum__].__constructs__[e._hx_index]._hx_name.toLowerCase() + "() function in compute shader");
					}
					var offset = v.kind == hxsl_FunctionKind.Vertex ? shaderOffset_vert : shaderOffset_frag;
					this.addShader(s.name + "." + (v.kind == hxsl_FunctionKind.Vertex ? "vertex" : "fragment"),v.kind == hxsl_FunctionKind.Vertex,f.expr,priority + offset);
					break;
				case 2:
					var prio;
					var status;
					switch(f.ref.name) {
					case "__init__fragment":
						prio = initPrio_frag;
						status = false;
						break;
					case "__init__main":
						prio = initPrio_main;
						status = false;
						break;
					case "__init__vertex":
						prio = initPrio_vert;
						status = true;
						break;
					default:
						prio = initPrio_init;
						status = null;
					}
					var _g3 = f.expr.e;
					if(_g3._hx_index == 4) {
						var el = _g3.el;
						var index = 0;
						var _g4 = 0;
						while(_g4 < el.length) {
							var e1 = el[_g4];
							++_g4;
							this.addShader(s.name + "." + f.ref.name + index++,status,e1,prio[0]++);
						}
					} else {
						this.addShader(s.name + "." + f.ref.name,status,f.expr,prio[0]++);
					}
					break;
				case 3:
					throw haxe_Exception.thrown("Unexpected helper function in linker " + v.v.name);
				case 4:
					if(this.mode != hxsl_LinkMode.Compute) {
						throw haxe_Exception.thrown("Unexpected main() outside compute shader");
					}
					this.addShader(s.name,true,f.expr,priority).isCompute = true;
					break;
				}
			}
			++priority;
		}
		this.shaders.sort($bind(this,this.sortByPriorityDesc));
		var uid = 0;
		var _g = 0;
		var _g1 = this.shaders;
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			s.uid = uid++;
		}
		var entry = new hxsl__$Linker_ShaderInfos("<entry>",false);
		entry.deps = new haxe_ds_ObjectMap();
		var _g = 0;
		while(_g < outVars.length) {
			var v = outVars[_g];
			++_g;
			this.buildDependency(entry,this.allocVar(v,null),false);
		}
		var _g = 0;
		var _g1 = this.shaders;
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			if(s.hasDiscard || s.isCompute || s.hasSyntax) {
				this.initDependencies(s);
				entry.deps.set(s,true);
			}
		}
		var _g = 0;
		var _g1 = this.shaders;
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			if(s.vertex != null) {
				continue;
			}
			var onlyParams = true;
			var _g2 = 0;
			var _g3 = s.readVars;
			while(_g2 < _g3.length) {
				var r = _g3[_g2];
				++_g2;
				if(r.v.kind != hxsl_VarKind.Param) {
					onlyParams = false;
					break;
				}
			}
			if(onlyParams) {
				if(hxsl_Debug.TRACE) {
					var msg = "Force " + s.name + " into fragment since it only reads params";
					var _g4 = 0;
					var _g5 = this.debugDepth;
					while(_g4 < _g5) {
						var i = _g4++;
						msg = "    " + msg;
					}
					haxe_Log.trace(msg,{ fileName : "hxsl/Debug.hx", lineNumber : 31, className : "hxsl.Linker", methodName : "link"});
				}
				s.vertex = false;
			}
		}
		var _g = 0;
		var _g1 = this.shaders;
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			if(s.deps == null) {
				continue;
			}
			if(s.vertex == null) {
				var d = s.deps.keys();
				while(d.hasNext()) {
					var d1 = d.next();
					if(d1.vertex == false) {
						if(hxsl_Debug.TRACE) {
							var msg = s.name + " marked as fragment because of " + d1.name;
							var _g2 = 0;
							var _g3 = this.debugDepth;
							while(_g2 < _g3) {
								var i = _g2++;
								msg = "    " + msg;
							}
							haxe_Log.trace(msg,{ fileName : "hxsl/Debug.hx", lineNumber : 31, className : "hxsl.Linker", methodName : "link"});
						}
						s.vertex = false;
						break;
					}
				}
			}
			if(s.vertex) {
				var d2 = s.deps.keys();
				while(d2.hasNext()) {
					var d3 = d2.next();
					if(d3.vertex == null) {
						if(hxsl_Debug.TRACE) {
							var msg1 = d3.name + " marked as vertex because of " + s.name;
							var _g4 = 0;
							var _g5 = this.debugDepth;
							while(_g4 < _g5) {
								var i1 = _g4++;
								msg1 = "    " + msg1;
							}
							haxe_Log.trace(msg1,{ fileName : "hxsl/Debug.hx", lineNumber : 31, className : "hxsl.Linker", methodName : "link"});
						}
						d3.vertex = true;
					}
				}
			}
		}
		var v = [];
		var f = [];
		this.collect(entry,v,true);
		this.collect(entry,f,false);
		if(f.pop() != entry) {
			throw haxe_Exception.thrown("assert");
		}
		var _g = 0;
		var _g1 = this.shaders;
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			s.marked = null;
		}
		var _g = 0;
		var _g1 = v.concat(f);
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			var d = s.deps.keys();
			while(d.hasNext()) {
				var d1 = d.next();
				if(d1.marked == null) {
					this.error(d1.name + " needed by " + s.name + " is unreachable",null);
				}
			}
			s.marked = true;
		}
		var outVars = [];
		var varMap_h = { };
		var addVar = null;
		addVar = function(v) {
			if(varMap_h.hasOwnProperty(v.id)) {
				return;
			}
			varMap_h[v.id] = true;
			if(v.v.parent != null) {
				addVar(v.parent);
			} else {
				outVars.push(v.v);
			}
		};
		var _g = 0;
		var _g1 = v.concat(f);
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			var _g2 = 0;
			var _g3 = s.readVars;
			while(_g2 < _g3.length) {
				var v1 = _g3[_g2];
				++_g2;
				addVar(v1);
			}
			var _g4 = 0;
			var _g5 = s.writeVars;
			while(_g4 < _g5.length) {
				var v2 = _g5[_g4];
				++_g4;
				addVar(v2);
			}
		}
		var cleanVar = null;
		cleanVar = function(v) {
			var _g = v.type;
			if(_g._hx_index == 13) {
				var vl = _g.vl;
				if(v.kind != hxsl_VarKind.Input) {
					var vout = [];
					var _g = 0;
					while(_g < vl.length) {
						var v1 = vl[_g];
						++_g;
						if(varMap_h.hasOwnProperty(v1.id)) {
							cleanVar(v1);
							vout.push(v1);
						}
					}
					v.type = hxsl_Type.TStruct(vout);
				}
			}
		};
		var _g = 0;
		while(_g < outVars.length) {
			var v1 = outVars[_g];
			++_g;
			cleanVar(v1);
		}
		var build = function(kind,name,a) {
			var v = { id : hxsl_Tools.allocVarId(), name : name, type : hxsl_Type.TFun([{ ret : hxsl_Type.TVoid, args : []}]), kind : hxsl_VarKind.Function};
			outVars.push(v);
			var exprs = [];
			var _g = 0;
			while(_g < a.length) {
				var s = a[_g];
				++_g;
				var _g1 = s.body.e;
				if(_g1._hx_index == 4) {
					var el = _g1.el;
					var _g2 = 0;
					while(_g2 < el.length) {
						var e = el[_g2];
						++_g2;
						exprs.push(e);
					}
				} else {
					exprs.push(s.body);
				}
			}
			var expr = { e : hxsl_TExprDef.TBlock(exprs), t : hxsl_Type.TVoid, p : exprs.length == 0 ? null : exprs[0].p};
			return { kind : kind, ref : v, ret : hxsl_Type.TVoid, args : [], expr : expr};
		};
		var funs = this.mode == hxsl_LinkMode.Compute ? [build(hxsl_FunctionKind.Main,"main",v)] : [build(hxsl_FunctionKind.Vertex,"vertex",v),build(hxsl_FunctionKind.Fragment,"fragment",f)];
		var _g = 0;
		while(_g < dupShaders.length) {
			var d = dupShaders[_g];
			++_g;
			var _g1 = 0;
			var _g2 = d.cloned.vars.length;
			while(_g1 < _g2) {
				var i = _g1++;
				this.allocVar(d.cloned.vars[i],null).merged.unshift(d.origin.vars[i]);
			}
		}
		return { name : "out", vars : outVars, funs : funs};
	}
	,__class__: hxsl_Linker
};
var hxsl_Output = $hxEnums["hxsl.Output"] = { __ename__:true,__constructs__:null
	,Const: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"hxsl.Output",toString:$estr}; },$_._hx_name="Const",$_.__params__ = ["v"],$_)
	,Value: ($_=function(v,size) { return {_hx_index:1,v:v,size:size,__enum__:"hxsl.Output",toString:$estr}; },$_._hx_name="Value",$_.__params__ = ["v","size"],$_)
	,PackNormal: ($_=function(v) { return {_hx_index:2,v:v,__enum__:"hxsl.Output",toString:$estr}; },$_._hx_name="PackNormal",$_.__params__ = ["v"],$_)
	,PackFloat: ($_=function(v) { return {_hx_index:3,v:v,__enum__:"hxsl.Output",toString:$estr}; },$_._hx_name="PackFloat",$_.__params__ = ["v"],$_)
	,Vec2: ($_=function(a) { return {_hx_index:4,a:a,__enum__:"hxsl.Output",toString:$estr}; },$_._hx_name="Vec2",$_.__params__ = ["a"],$_)
	,Vec3: ($_=function(a) { return {_hx_index:5,a:a,__enum__:"hxsl.Output",toString:$estr}; },$_._hx_name="Vec3",$_.__params__ = ["a"],$_)
	,Vec4: ($_=function(a) { return {_hx_index:6,a:a,__enum__:"hxsl.Output",toString:$estr}; },$_._hx_name="Vec4",$_.__params__ = ["a"],$_)
	,Swiz: ($_=function(a,swiz) { return {_hx_index:7,a:a,swiz:swiz,__enum__:"hxsl.Output",toString:$estr}; },$_._hx_name="Swiz",$_.__params__ = ["a","swiz"],$_)
};
hxsl_Output.__constructs__ = [hxsl_Output.Const,hxsl_Output.Value,hxsl_Output.PackNormal,hxsl_Output.PackFloat,hxsl_Output.Vec2,hxsl_Output.Vec3,hxsl_Output.Vec4,hxsl_Output.Swiz];
hxsl_Output.__empty_constructs__ = [];
var hxsl_Printer = function(varId) {
	if(varId == null) {
		varId = false;
	}
	this.varId = varId;
};
$hxClasses["hxsl.Printer"] = hxsl_Printer;
hxsl_Printer.__name__ = "hxsl.Printer";
hxsl_Printer.opStr = function(op) {
	switch(op._hx_index) {
	case 0:
		return "+";
	case 1:
		return "*";
	case 2:
		return "/";
	case 3:
		return "-";
	case 4:
		return "=";
	case 5:
		return "==";
	case 6:
		return "!=";
	case 7:
		return ">";
	case 8:
		return ">=";
	case 9:
		return "<";
	case 10:
		return "<=";
	case 11:
		return "&";
	case 12:
		return "|";
	case 13:
		return "^";
	case 14:
		return "&&";
	case 15:
		return "||";
	case 16:
		return "<<";
	case 17:
		return ">>";
	case 18:
		return ">>>";
	case 19:
		return "%";
	case 20:
		var op1 = op.op;
		return hxsl_Printer.opStr(op1) + "=";
	case 21:
		return "...";
	case 22:
		return "=>";
	default:
		return "??" + Std.string(op);
	}
};
hxsl_Printer.toString = function(e,varId) {
	if(varId == null) {
		varId = false;
	}
	return new hxsl_Printer(varId).exprString(e);
};
hxsl_Printer.shaderToString = function(s,varId) {
	if(varId == null) {
		varId = false;
	}
	return new hxsl_Printer(varId).shaderString(s);
};
hxsl_Printer.check = function(s,from) {
	try {
		var vars = new haxe_ds_IntMap();
		var regVars = [];
		var regVar = null;
		regVar = function(v,reg) {
			if(reg) {
				if(vars.h.hasOwnProperty(v.id)) {
					throw haxe_Exception.thrown("Duplicate var " + v.id);
				}
				vars.h[v.id] = v;
				regVars.push(v);
			} else {
				vars.remove(v.id);
			}
			var _g = v.type;
			if(_g._hx_index == 13) {
				var vl = _g.vl;
				var _g = 0;
				while(_g < vl.length) {
					var v = vl[_g];
					++_g;
					regVar(v,reg);
				}
			}
		};
		var checkExpr = null;
		checkExpr = function(e) {
			var _g = e.e;
			switch(_g._hx_index) {
			case 1:
				var v = _g.v;
				if(!vars.h.hasOwnProperty(v.id)) {
					throw haxe_Exception.thrown("Unbound var " + v.name + "@" + v.id);
				}
				break;
			case 4:
				var el = _g.el;
				var old = regVars;
				regVars = [];
				var _g1 = 0;
				while(_g1 < el.length) {
					var e1 = el[_g1];
					++_g1;
					checkExpr(e1);
				}
				var _g1 = 0;
				while(_g1 < regVars.length) {
					var v = regVars[_g1];
					++_g1;
					regVar(v,false);
				}
				regVars = old;
				break;
			case 7:
				var v = _g.v;
				var init = _g.init;
				if(init != null) {
					checkExpr(init);
				}
				regVar(v,true);
				break;
			case 13:
				var v = _g.v;
				var it = _g.it;
				var loop = _g.loop;
				checkExpr(it);
				regVar(v,true);
				checkExpr(loop);
				regVar(v,false);
				break;
			default:
				hxsl_Tools.iter(e,checkExpr);
			}
		};
		var _g = 0;
		var _g1 = s.vars;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			regVar(v,true);
		}
		var _g = 0;
		var _g1 = s.funs;
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			var _g2 = 0;
			var _g3 = f.args;
			while(_g2 < _g3.length) {
				var v = _g3[_g2];
				++_g2;
				regVar(v,true);
			}
			checkExpr(f.expr);
			var _g4 = 0;
			var _g5 = f.args;
			while(_g4 < _g5.length) {
				var v1 = _g5[_g4];
				++_g4;
				regVar(v1,false);
			}
		}
	} catch( _g ) {
		var _g1 = haxe_Exception.caught(_g).unwrap();
		if(typeof(_g1) == "string") {
			var e = _g1;
			var msg = e + "\n    in\n" + hxsl_Printer.shaderToString(s,true);
			if(from != null) {
				var _g1 = [];
				var _g2 = 0;
				while(_g2 < from.length) {
					var s = from[_g2];
					++_g2;
					_g1.push(hxsl_Printer.shaderToString(s,true));
				}
				msg += "\n    from\n\n" + _g1.join("\n\n");
			}
			throw haxe_Exception.thrown(msg);
		} else {
			throw _g;
		}
	}
};
hxsl_Printer.prototype = {
	add: function(v) {
		this.buffer.b += Std.string(v);
	}
	,shaderString: function(s) {
		this.buffer = new StringBuf();
		var _g = 0;
		var _g1 = s.vars;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			this.addVar(v,null);
			this.buffer.b += Std.string(";\n");
		}
		if(s.vars.length > 0) {
			this.buffer.b += Std.string("\n");
		}
		var _g = 0;
		var _g1 = s.funs;
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			this.addFun(f);
			this.buffer.b += Std.string("\n\n");
		}
		return this.buffer.b;
	}
	,varString: function(v) {
		this.buffer = new StringBuf();
		this.addVar(v,null);
		return this.buffer.b;
	}
	,funString: function(f) {
		this.buffer = new StringBuf();
		this.addFun(f);
		return this.buffer.b;
	}
	,exprString: function(e) {
		this.buffer = new StringBuf();
		this.addExpr(e,"");
		return this.buffer.b;
	}
	,addVar: function(v,defKind,tabs,parent) {
		if(tabs == null) {
			tabs = "";
		}
		if(v.qualifiers != null) {
			var _g = 0;
			var _g1 = v.qualifiers;
			while(_g < _g1.length) {
				var q = _g1[_g];
				++_g;
				var v1;
				switch(q._hx_index) {
				case 0:
					var max = q.max;
					v1 = "const" + (max == null ? "" : "(" + max + ")");
					break;
				case 1:
					v1 = "private";
					break;
				case 2:
					v1 = "nullable";
					break;
				case 3:
					v1 = "perObject";
					break;
				case 4:
					var n = q.n;
					v1 = "name('" + n + "')";
					break;
				case 5:
					v1 = "shared";
					break;
				case 6:
					var p = q.p;
					v1 = $hxEnums[p.__enum__].__constructs__[p._hx_index]._hx_name.toLowerCase() + "p";
					break;
				case 7:
					var min = q.min;
					var max1 = q.max;
					v1 = "range(" + min + "," + max1 + ")";
					break;
				case 8:
					v1 = "ignore";
					break;
				case 9:
					var n1 = q.v;
					v1 = "perInstance(" + n1 + ")";
					break;
				case 10:
					var s = q.s;
					v1 = "doc(\"" + StringTools.replace(s,"\"","\\\"") + "\")";
					break;
				case 11:
					var s1 = q.source;
					v1 = "borrow(" + s1 + ")";
					break;
				case 12:
					var s2 = q.name;
					v1 = "sampler(" + s2 + ")";
					break;
				case 13:
					v1 = "final";
					break;
				case 14:
					v1 = "flat";
					break;
				}
				this.buffer.b += Std.string("@" + v1 + " ");
			}
		}
		if(v.kind != defKind) {
			switch(v.kind._hx_index) {
			case 0:
				this.buffer.b += Std.string("@global ");
				break;
			case 1:
				this.buffer.b += Std.string("@input ");
				break;
			case 2:
				this.buffer.b += Std.string("@param ");
				break;
			case 3:
				this.buffer.b += Std.string("@varying ");
				break;
			case 4:
				this.buffer.b += Std.string("@local ");
				break;
			case 5:
				this.buffer.b += Std.string("@output ");
				break;
			case 6:
				this.buffer.b += Std.string("@function ");
				break;
			}
		}
		this.buffer.b += Std.string("var ");
		if(v.parent == parent) {
			this.buffer.b += Std.string(v.name + (this.varId ? "@" + v.id : ""));
		} else {
			this.addVarName(v);
		}
		this.buffer.b += Std.string(" : ");
		var _g = v.type;
		if(_g._hx_index == 13) {
			var vl = _g.vl;
			this.buffer.b += Std.string("{");
			var first = true;
			var _g = 0;
			while(_g < vl.length) {
				var v1 = vl[_g];
				++_g;
				if(first) {
					first = false;
				} else {
					this.buffer.b += Std.string(", ");
				}
				this.addVar(v1,v1.kind,tabs,v1);
			}
			this.buffer.b += Std.string("}");
		} else {
			var v1 = hxsl_Tools.toString(v.type);
			this.buffer.b += Std.string(v1);
		}
	}
	,addFun: function(f) {
		this.buffer.b += Std.string("function " + f.ref.name + "(");
		var first = true;
		var _g = 0;
		var _g1 = f.args;
		while(_g < _g1.length) {
			var a = _g1[_g];
			++_g;
			if(first) {
				this.buffer.b += Std.string(" ");
				first = false;
			} else {
				this.buffer.b += Std.string(", ");
			}
			this.addVar(a,hxsl_VarKind.Local);
		}
		if(f.args.length > 0) {
			this.buffer.b += Std.string(" ");
		}
		var v = ") : " + hxsl_Tools.toString(f.ret) + " ";
		this.buffer.b += Std.string(v);
		this.addExpr(f.expr,"");
	}
	,addVarName: function(v) {
		if(v.parent != null) {
			this.addVarName(v.parent);
			this.buffer.b += Std.string(".");
		}
		this.buffer.b += Std.string(v.name);
		if(this.varId) {
			this.buffer.b += Std.string("@" + v.id);
		}
	}
	,addConst: function(c) {
		var _this = this.buffer;
		var _this1 = _this.b;
		var tmp;
		switch(c._hx_index) {
		case 0:
			tmp = "null";
			break;
		case 1:
			var b = c.b;
			tmp = b;
			break;
		case 2:
			var i = c.v;
			tmp = i;
			break;
		case 3:
			var f = c.v;
			tmp = f;
			break;
		case 4:
			var s = c.v;
			tmp = "\"" + s + "\"";
			break;
		}
		_this.b = _this1 + Std.string(tmp);
	}
	,addExpr: function(e,tabs) {
		var _g = e.e;
		switch(_g._hx_index) {
		case 0:
			var c = _g.c;
			this.addConst(c);
			break;
		case 1:
			var v = _g.v;
			this.addVarName(v);
			break;
		case 2:
			var g = _g.g;
			var v = hxsl_Tools2.toString(g);
			this.buffer.b += Std.string(v);
			break;
		case 3:
			var e = _g.e;
			this.buffer.b += Std.string("(");
			this.addExpr(e,tabs);
			this.buffer.b += Std.string(")");
			break;
		case 4:
			var el = _g.el;
			this.buffer.b += Std.string("{");
			tabs += "\t";
			var _g1 = 0;
			while(_g1 < el.length) {
				var e = el[_g1];
				++_g1;
				this.buffer.b += Std.string("\n" + tabs);
				this.addExpr(e,tabs);
				this.buffer.b += Std.string(";");
			}
			tabs = HxOverrides.substr(tabs,1,null);
			if(el.length > 0) {
				this.buffer.b += Std.string("\n" + tabs);
			}
			this.buffer.b += Std.string("}");
			break;
		case 5:
			var op = _g.op;
			var e1 = _g.e1;
			var e2 = _g.e2;
			this.addExpr(e1,tabs);
			var v = " " + hxsl_Printer.opStr(op) + " ";
			this.buffer.b += Std.string(v);
			this.addExpr(e2,tabs);
			break;
		case 6:
			var op = _g.op;
			var e = _g.e1;
			var v;
			switch(op._hx_index) {
			case 0:
				v = "++";
				break;
			case 1:
				v = "--";
				break;
			case 2:
				v = "!";
				break;
			case 3:
				v = "-";
				break;
			case 4:
				v = "~";
				break;
			default:
				throw haxe_Exception.thrown("assert");
			}
			this.buffer.b += Std.string(v);
			this.addExpr(e,tabs);
			break;
		case 7:
			var v = _g.v;
			var init = _g.init;
			this.addVar(v,hxsl_VarKind.Local,tabs);
			if(init != null) {
				this.buffer.b += Std.string(" = ");
				this.addExpr(init,tabs);
			}
			break;
		case 8:
			var e = _g.e;
			var el = _g.args;
			this.addExpr(e,tabs);
			this.buffer.b += Std.string("(");
			var first = true;
			var _g1 = 0;
			while(_g1 < el.length) {
				var e = el[_g1];
				++_g1;
				if(first) {
					first = false;
				} else {
					this.buffer.b += Std.string(", ");
				}
				this.addExpr(e,tabs);
			}
			this.buffer.b += Std.string(")");
			break;
		case 9:
			var e = _g.e;
			var regs = _g.regs;
			this.addExpr(e,tabs);
			this.buffer.b += Std.string(".");
			var _g1 = 0;
			while(_g1 < regs.length) {
				var r = regs[_g1];
				++_g1;
				this.buffer.b += Std.string(hxsl_Printer.SWIZ[r._hx_index]);
			}
			break;
		case 10:
			var cond = _g.econd;
			var eif = _g.eif;
			var eelse = _g.eelse;
			this.buffer.b += Std.string("if( ");
			this.addExpr(cond,tabs);
			this.buffer.b += Std.string(" ) ");
			this.addExpr(eif,tabs);
			if(eelse != null) {
				this.buffer.b += Std.string(" else ");
				this.addExpr(eelse,tabs);
			}
			break;
		case 11:
			this.buffer.b += Std.string("discard");
			break;
		case 12:
			var e = _g.e;
			this.buffer.b += Std.string("return");
			if(e != null) {
				this.buffer.b += Std.string(" ");
				this.addExpr(e,tabs);
			}
			break;
		case 13:
			var v = _g.v;
			var it = _g.it;
			var loop = _g.loop;
			this.buffer.b += Std.string("for( ");
			this.addVarName(v);
			this.buffer.b += Std.string(" in ");
			this.addExpr(it,tabs);
			this.buffer.b += Std.string(" ) ");
			this.addExpr(loop,tabs);
			break;
		case 14:
			this.buffer.b += Std.string("continue");
			break;
		case 15:
			this.buffer.b += Std.string("break");
			break;
		case 16:
			var e1 = _g.e;
			var e2 = _g.index;
			this.addExpr(e1,tabs);
			this.buffer.b += Std.string("[");
			this.addExpr(e2,tabs);
			this.buffer.b += Std.string("]");
			break;
		case 17:
			var el = _g.el;
			this.buffer.b += Std.string("[");
			var first = true;
			var _g1 = 0;
			while(_g1 < el.length) {
				var e = el[_g1];
				++_g1;
				if(first) {
					first = false;
				} else {
					this.buffer.b += Std.string(", ");
				}
				this.addExpr(e,tabs);
			}
			this.buffer.b += Std.string("]");
			break;
		case 18:
			var e = _g.e;
			var cases = _g.cases;
			var def = _g.def;
			this.buffer.b += Std.string("switch( ");
			this.addExpr(e,tabs);
			this.buffer.b += Std.string(") {");
			var old = tabs;
			var _g1 = 0;
			while(_g1 < cases.length) {
				var c = cases[_g1];
				++_g1;
				this.buffer.b += Std.string("\n" + tabs);
				this.buffer.b += Std.string("case ");
				var first = true;
				var _g2 = 0;
				var _g3 = c.values;
				while(_g2 < _g3.length) {
					var v = _g3[_g2];
					++_g2;
					if(first) {
						first = false;
					} else {
						this.buffer.b += Std.string(", ");
					}
					this.addExpr(v,tabs);
				}
				tabs += "\t";
				this.buffer.b += Std.string(":\n" + tabs);
				this.addExpr(c.expr,tabs);
				tabs = old;
			}
			if(def != null) {
				this.buffer.b += Std.string("\n" + tabs);
				tabs += "\t";
				this.buffer.b += Std.string("default:\n" + tabs);
				this.addExpr(def,tabs);
				tabs = old;
			}
			this.buffer.b += Std.string("\n" + tabs + "}");
			break;
		case 19:
			var _g1 = _g.e;
			var _g2 = _g.loop;
			if(_g.normalWhile == false) {
				var loop = _g2;
				var e = _g1;
				var old = tabs;
				tabs += "\t";
				this.buffer.b += Std.string("do {\n" + tabs);
				this.addExpr(loop,tabs);
				tabs = old;
				this.buffer.b += Std.string("\n" + tabs + "} while( ");
				this.addExpr(e,tabs);
				this.buffer.b += Std.string(" )");
			} else {
				var loop = _g2;
				var e = _g1;
				this.buffer.b += Std.string("while( ");
				this.addExpr(e,tabs);
				var old = tabs;
				tabs += "\t";
				this.buffer.b += Std.string(" ) {\n" + tabs);
				this.addExpr(loop,tabs);
				tabs = old;
				this.buffer.b += Std.string("\n" + tabs + "}");
			}
			break;
		case 20:
			var m = _g.m;
			var args = _g.args;
			var e = _g.e;
			this.buffer.b += Std.string("@");
			this.buffer.b += Std.string(m);
			if(args.length > 0) {
				this.buffer.b += Std.string("(");
				var first = true;
				var _g1 = 0;
				while(_g1 < args.length) {
					var c = args[_g1];
					++_g1;
					if(first) {
						first = false;
					} else {
						this.buffer.b += Std.string(", ");
					}
					this.addConst(c);
				}
				this.buffer.b += Std.string(")");
			}
			this.buffer.b += Std.string(" ");
			this.addExpr(e,tabs);
			break;
		case 21:
			var e = _g.e;
			var name = _g.name;
			this.addExpr(e,tabs);
			this.buffer.b += Std.string(".");
			this.buffer.b += Std.string(name);
			break;
		case 22:
			var target = _g.target;
			var code = _g.code;
			var args = _g.args;
			this.buffer.b += Std.string("Syntax.");
			this.buffer.b += Std.string(target);
			this.buffer.b += Std.string("(");
			this.addConst(hxsl_Const.CString(code));
			var _g = 0;
			while(_g < args.length) {
				var arg = args[_g];
				++_g;
				switch(arg.access._hx_index) {
				case 0:
					this.buffer.b += Std.string(", @r ");
					break;
				case 1:
					this.buffer.b += Std.string(", @w ");
					break;
				case 2:
					this.buffer.b += Std.string(", @rw ");
					break;
				}
				this.addExpr(arg.e,tabs);
			}
			this.buffer.b += Std.string(")");
			break;
		}
	}
	,__class__: hxsl_Printer
};
var hxsl_LinkMode = $hxEnums["hxsl.LinkMode"] = { __ename__:true,__constructs__:null
	,Default: {_hx_name:"Default",_hx_index:0,__enum__:"hxsl.LinkMode",toString:$estr}
	,Batch: {_hx_name:"Batch",_hx_index:1,__enum__:"hxsl.LinkMode",toString:$estr}
	,Compute: {_hx_name:"Compute",_hx_index:2,__enum__:"hxsl.LinkMode",toString:$estr}
};
hxsl_LinkMode.__constructs__ = [hxsl_LinkMode.Default,hxsl_LinkMode.Batch,hxsl_LinkMode.Compute];
hxsl_LinkMode.__empty_constructs__ = [hxsl_LinkMode.Default,hxsl_LinkMode.Batch,hxsl_LinkMode.Compute];
var hxsl_AllocParam = function(name,pos,instance,index,type) {
	this.name = name;
	this.pos = pos;
	this.instance = instance;
	this.index = index;
	this.type = type;
};
$hxClasses["hxsl.AllocParam"] = hxsl_AllocParam;
hxsl_AllocParam.__name__ = "hxsl.AllocParam";
hxsl_AllocParam.prototype = {
	clone: function(resetGID) {
		if(resetGID == null) {
			resetGID = false;
		}
		var p = new hxsl_AllocParam(this.name,this.pos,this.instance,this.index,this.type);
		if(this.perObjectGlobal != null) {
			p.perObjectGlobal = this.perObjectGlobal.clone(resetGID);
		}
		if(this.next != null) {
			p.next = this.next.clone(resetGID);
		}
		return p;
	}
	,__class__: hxsl_AllocParam
};
var hxsl_AllocGlobal = function(pos,path,type) {
	this.pos = pos;
	this.path = path;
	this.gid = hxsl_Globals.allocID(path);
	this.type = type;
};
$hxClasses["hxsl.AllocGlobal"] = hxsl_AllocGlobal;
hxsl_AllocGlobal.__name__ = "hxsl.AllocGlobal";
hxsl_AllocGlobal.prototype = {
	clone: function(resetGID) {
		if(resetGID == null) {
			resetGID = false;
		}
		var g = new hxsl_AllocGlobal(this.pos,this.path,this.type);
		if(this.next != null) {
			g.next = this.next.clone(resetGID);
		}
		if(resetGID) {
			g.gid = 0;
		}
		return g;
	}
	,__class__: hxsl_AllocGlobal
};
var hxsl_RuntimeShaderData = function() {
};
$hxClasses["hxsl.RuntimeShaderData"] = hxsl_RuntimeShaderData;
hxsl_RuntimeShaderData.__name__ = "hxsl.RuntimeShaderData";
hxsl_RuntimeShaderData.prototype = {
	__class__: hxsl_RuntimeShaderData
};
var hxsl_ShaderInstanceDesc = function(shader,bits) {
	this.shader = shader;
	this.bits = bits;
};
$hxClasses["hxsl.ShaderInstanceDesc"] = hxsl_ShaderInstanceDesc;
hxsl_ShaderInstanceDesc.__name__ = "hxsl.ShaderInstanceDesc";
hxsl_ShaderInstanceDesc.prototype = {
	__class__: hxsl_ShaderInstanceDesc
};
var hxsl_RuntimeShader = function() {
	this.id = hxsl_RuntimeShader.UID++;
};
$hxClasses["hxsl.RuntimeShader"] = hxsl_RuntimeShader;
hxsl_RuntimeShader.__name__ = "hxsl.RuntimeShader";
hxsl_RuntimeShader.prototype = {
	get_compute: function() {
		return this.vertex;
	}
	,set_compute: function(v) {
		return this.vertex = v;
	}
	,hasGlobal: function(gid) {
		return this.globals.h.hasOwnProperty(gid);
	}
	,getShaders: function() {
		if(this.mode == hxsl_LinkMode.Compute) {
			return [this.vertex];
		} else {
			return [this.vertex,this.fragment];
		}
	}
	,__class__: hxsl_RuntimeShader
};
var hxsl_Serializer = function() {
	this.tid = 1;
	this.uid = 1;
};
$hxClasses["hxsl.Serializer"] = hxsl_Serializer;
hxsl_Serializer.__name__ = "hxsl.Serializer";
hxsl_Serializer.run = function(s) {
	return new hxsl_Serializer().serialize(s);
};
hxsl_Serializer.prototype = {
	writeArr: function(arr,f) {
		this.writeVarInt(arr.length);
		var _g = 0;
		while(_g < arr.length) {
			var v = arr[_g];
			++_g;
			f(v);
		}
	}
	,readArr: function(f) {
		var _g = [];
		var _g1 = 0;
		var _g2 = this.readVarInt();
		while(_g1 < _g2) {
			var i = _g1++;
			_g.push(f());
		}
		return _g;
	}
	,readVarInt: function() {
		var b = this.input.readByte();
		if(b < 128) {
			return b;
		}
		if(b == 255) {
			return this.input.readInt32();
		}
		return (b & 127) << 8 | this.input.readByte();
	}
	,writeVarInt: function(id) {
		if(id < 128) {
			this.out.addByte(id);
		} else {
			var n = id >> 8;
			if(n >= 127) {
				this.out.addByte(255);
				this.out.addInt32(n);
			} else {
				this.out.addByte(n | 128);
				this.out.addByte(id & 255);
			}
		}
	}
	,writeID: function(id) {
		var id2 = this.idMap.h[id];
		if(id2 == null) {
			id2 = this.uid++;
			this.idMap.h[id] = id2;
		}
		this.writeVarInt(id2);
	}
	,readID: function() {
		return this.readVarInt();
	}
	,writeTID: function(t) {
		var tid = this.typeIdMap.get(t);
		if(tid != null) {
			this.writeVarInt(tid);
			return false;
		}
		tid = this.tid++;
		this.typeIdMap.set(t,tid);
		this.writeVarInt(tid);
		return true;
	}
	,writeType: function(t) {
		this.out.addByte(t._hx_index);
		switch(t._hx_index) {
		case 5:
			var size = t.size;
			var t1 = t.t;
			this.out.addByte(size | t1._hx_index << 3);
			break;
		case 0:case 1:case 2:case 3:case 4:case 6:case 7:case 8:case 12:
			break;
		case 9:
			var size = t.size;
			this.out.addInt32(size);
			break;
		case 10:
			var dim = t.dim;
			var arr = t.isArray;
			this.out.addByte(dim._hx_index << 1 | (arr ? 1 : 0));
			break;
		case 11:
			var dim = t.dim;
			var arr = t.isArray;
			var chans = t.channels;
			this.out.addByte(dim._hx_index << 3 | (arr ? 1 : 0) | chans - 1 << 1);
			break;
		case 13:
			var vl = t.vl;
			if(this.writeTID(t)) {
				var f = $bind(this,this.writeVar);
				this.writeVarInt(vl.length);
				var _g = 0;
				while(_g < vl.length) {
					var v = vl[_g];
					++_g;
					f(v);
				}
			}
			break;
		case 14:
			var variants = t.variants;
			break;
		case 15:
			var t1 = t.t;
			var size = t.size;
			this.writeType(t1);
			switch(size._hx_index) {
			case 0:
				var v = size.v;
				this.out.addByte(0);
				this.writeVarInt(v);
				break;
			case 1:
				var v = size.v;
				this.writeVar(v);
				break;
			}
			break;
		case 16:
			var _g = t.t;
			var _g1 = t.size;
			var _g2 = t.kind;
			if(_g2._hx_index == 0) {
				var size = _g1;
				var t1 = _g;
				this.writeType(t1);
				switch(size._hx_index) {
				case 0:
					var v = size.v;
					this.out.addByte(0);
					this.writeVarInt(v);
					break;
				case 1:
					var v = size.v;
					this.writeVar(v);
					break;
				}
			} else {
				var kind = _g2;
				var size = _g1;
				var t1 = _g;
				this.out.addByte(kind._hx_index + 128);
				this.writeType(t1);
				switch(size._hx_index) {
				case 0:
					var v = size.v;
					this.out.addByte(0);
					this.writeVarInt(v);
					break;
				case 1:
					var v = size.v;
					this.writeVar(v);
					break;
				}
			}
			break;
		case 17:
			var size = t.size;
			this.out.addByte(size);
			break;
		}
	}
	,readType: function() {
		switch(this.input.readByte()) {
		case 0:
			return hxsl_Type.TVoid;
		case 1:
			return hxsl_Type.TInt;
		case 2:
			return hxsl_Type.TBool;
		case 3:
			return hxsl_Type.TFloat;
		case 4:
			return hxsl_Type.TString;
		case 5:
			var bits = this.input.readByte();
			var v = hxsl_Serializer.TVECS.h[bits];
			if(v == null) {
				v = hxsl_Type.TVec(bits & 7,Type.createEnumIndex(hxsl_VecType,bits >> 3,null));
				hxsl_Serializer.TVECS.h[bits] = v;
			}
			return v;
		case 6:
			return hxsl_Type.TMat3;
		case 7:
			return hxsl_Type.TMat4;
		case 8:
			return hxsl_Type.TMat3x4;
		case 9:
			return hxsl_Type.TBytes(this.input.readInt32());
		case 10:
			if(this.version == 0) {
				return hxsl_Type.TSampler(hxsl_TexDimension.T2D,false);
			} else {
				var b = this.input.readByte();
				var dim = hxsl_Serializer.TDIMS[b >> 1];
				return hxsl_Type.TSampler(dim,(b & 1) != 0);
			}
			break;
		case 11:
			if(this.version == 0) {
				return hxsl_Type.TSampler(hxsl_TexDimension.T2D,true);
			} else {
				var b = this.input.readByte();
				var dim = hxsl_Serializer.TDIMS[b >> 3];
				return hxsl_Type.TRWTexture(dim,(b & 1) != 0,(b >> 1 & 3) + 1);
			}
			break;
		case 12:
			if(this.version == 0) {
				return hxsl_Type.TSampler(hxsl_TexDimension.TCube,false);
			} else {
				return hxsl_Type.TMat2;
			}
			break;
		case 13:
			var id = this.readVarInt();
			var t = this.types[id];
			if(t != null) {
				return t;
			}
			var f = $bind(this,this.readVar);
			var _g = [];
			var _g1 = 0;
			var _g2 = this.readVarInt();
			while(_g1 < _g2) {
				var i = _g1++;
				_g.push(f());
			}
			t = hxsl_Type.TStruct(_g);
			this.types[id] = t;
			return t;
		case 14:
			return hxsl_Type.TFun(null);
		case 15:
			var t = this.readType();
			var v = this.readVar();
			return hxsl_Type.TArray(t,v == null ? hxsl_SizeDecl.SConst(this.readVarInt()) : hxsl_SizeDecl.SVar(v));
		case 16:
			var tag = this.input.readByte();
			var kind = hxsl_BufferKind.Uniform;
			if((tag & 128) == 0) {
				var fh = this.input;
				fh.set_position(fh.pos - 1);
			} else {
				kind = Type.createEnumIndex(hxsl_BufferKind,tag & 127,null);
			}
			var t = this.readType();
			var v = this.readVar();
			return hxsl_Type.TBuffer(t,v == null ? hxsl_SizeDecl.SConst(this.readVarInt()) : hxsl_SizeDecl.SVar(v),kind);
		case 17:
			return hxsl_Type.TChannel(this.input.readByte());
		case 18:
			if(this.version == 0) {
				return hxsl_Type.TMat2;
			} else {
				throw haxe_Exception.thrown("assert");
			}
			break;
		default:
			throw haxe_Exception.thrown("assert");
		}
	}
	,writeString: function(s) {
		var bytes = haxe_io_Bytes.ofString(s);
		this.writeVarInt(bytes.length);
		this.out.add(bytes);
	}
	,readString: function() {
		var len = this.readVarInt();
		var s = this.input.read(len).getString(0,len);
		return s;
	}
	,writeVar: function(v) {
		if(v == null) {
			this.out.addByte(0);
			return;
		}
		this.writeID(v.id);
		if(this.varMap.h.hasOwnProperty(v.id)) {
			return;
		}
		this.varMap.h[v.id] = v;
		this.writeString(v.name);
		this.writeType(v.type);
		this.out.addByte(v.kind._hx_index);
		this.writeVar(v.parent);
		if(v.qualifiers == null) {
			this.out.addByte(0);
		} else {
			this.out.addByte(v.qualifiers.length);
			var _g = 0;
			var _g1 = v.qualifiers;
			while(_g < _g1.length) {
				var q = _g1[_g];
				++_g;
				this.out.addByte(q._hx_index);
				switch(q._hx_index) {
				case 0:
					var max = q.max;
					this.out.addInt32(max == null ? 0 : max);
					break;
				case 4:
					var n = q.n;
					this.writeString(n);
					break;
				case 6:
					var p = q.p;
					this.out.addByte(p._hx_index);
					break;
				case 7:
					var min = q.min;
					var max1 = q.max;
					this.out.addDouble(min);
					this.out.addDouble(max1);
					break;
				case 9:
					var v = q.v;
					this.out.addInt32(v);
					break;
				case 10:
					var s = q.s;
					this.writeString(s);
					break;
				case 11:
					var s1 = q.source;
					this.writeString(s1);
					break;
				case 12:
					var s2 = q.name;
					this.writeString(s2);
					break;
				case 1:case 2:case 3:case 5:case 8:case 13:case 14:
					break;
				}
			}
		}
	}
	,writeFun: function(f) {
		this.out.addByte(f.kind._hx_index);
		this.writeVar(f.ref);
		var arr = f.args;
		var f1 = $bind(this,this.writeVar);
		this.writeVarInt(arr.length);
		var _g = 0;
		while(_g < arr.length) {
			var v = arr[_g];
			++_g;
			f1(v);
		}
		this.writeType(f.ret);
		this.writeExpr(f.expr);
	}
	,writeConst: function(c) {
		this.out.addByte(c._hx_index);
		switch(c._hx_index) {
		case 0:
			break;
		case 1:
			var b = c.b;
			this.out.addByte(b ? 1 : 0);
			break;
		case 2:
			var v = c.v;
			this.out.addInt32(v);
			break;
		case 3:
			var v = c.v;
			this.out.addDouble(v);
			break;
		case 4:
			var v = c.v;
			this.writeString(v);
			break;
		}
	}
	,writeExpr: function(e) {
		var _gthis = this;
		if(e == null) {
			this.out.addByte(0);
			return;
		}
		this.out.addByte(e.e._hx_index + 1);
		var _g = e.e;
		switch(_g._hx_index) {
		case 0:
			var c = _g.c;
			this.writeConst(c);
			break;
		case 1:
			var v = _g.v;
			this.writeVar(v);
			break;
		case 2:
			var g = _g.g;
			this.out.addByte(g._hx_index);
			break;
		case 3:
			var e1 = _g.e;
			this.writeExpr(e1);
			break;
		case 4:
			var el = _g.el;
			var f = $bind(this,this.writeExpr);
			this.writeVarInt(el.length);
			var _g1 = 0;
			while(_g1 < el.length) {
				var v = el[_g1];
				++_g1;
				f(v);
			}
			break;
		case 5:
			var op = _g.op;
			var e1 = _g.e1;
			var e2 = _g.e2;
			if(op._hx_index == 20) {
				var op1 = op.op;
				this.out.addByte(op1._hx_index | 128);
			} else {
				this.out.addByte(op._hx_index);
			}
			this.writeExpr(e1);
			this.writeExpr(e2);
			break;
		case 6:
			var op = _g.op;
			var e1 = _g.e1;
			this.out.addByte(op._hx_index);
			this.writeExpr(e1);
			break;
		case 7:
			var v = _g.v;
			var init = _g.init;
			this.writeVar(v);
			this.writeExpr(init);
			break;
		case 8:
			var e1 = _g.e;
			var args = _g.args;
			this.writeExpr(e1);
			var f = $bind(this,this.writeExpr);
			this.writeVarInt(args.length);
			var _g1 = 0;
			while(_g1 < args.length) {
				var v = args[_g1];
				++_g1;
				f(v);
			}
			break;
		case 9:
			var e1 = _g.e;
			var regs = _g.regs;
			this.writeExpr(e1);
			if(regs.length == 0) {
				throw haxe_Exception.thrown("assert");
			}
			var bits = regs.length - 1;
			var k = 2;
			var _g1 = 0;
			while(_g1 < regs.length) {
				var r = regs[_g1];
				++_g1;
				bits |= r._hx_index << k;
				k += 2;
			}
			this.out.addByte(bits & 255);
			this.out.addByte(bits >> 8);
			break;
		case 10:
			var econd = _g.econd;
			var eif = _g.eif;
			var eelse = _g.eelse;
			this.writeExpr(econd);
			this.writeExpr(eif);
			this.writeExpr(eelse);
			break;
		case 11:
			break;
		case 12:
			var e1 = _g.e;
			this.writeExpr(e1);
			break;
		case 13:
			var v = _g.v;
			var it = _g.it;
			var loop = _g.loop;
			this.writeVar(v);
			this.writeExpr(it);
			this.writeExpr(loop);
			break;
		case 14:
			break;
		case 15:
			break;
		case 16:
			var e1 = _g.e;
			var index = _g.index;
			this.writeExpr(e1);
			this.writeExpr(index);
			break;
		case 17:
			var el = _g.el;
			var f = $bind(this,this.writeExpr);
			this.writeVarInt(el.length);
			var _g1 = 0;
			while(_g1 < el.length) {
				var v = el[_g1];
				++_g1;
				f(v);
			}
			break;
		case 18:
			var e1 = _g.e;
			var cases = _g.cases;
			var def = _g.def;
			this.writeExpr(e1);
			this.writeVarInt(cases.length);
			var _g1 = 0;
			while(_g1 < cases.length) {
				var v = cases[_g1];
				++_g1;
				var arr = v.values;
				var f = $bind(_gthis,_gthis.writeExpr);
				_gthis.writeVarInt(arr.length);
				var _g2 = 0;
				while(_g2 < arr.length) {
					var v1 = arr[_g2];
					++_g2;
					f(v1);
				}
				_gthis.writeExpr(v.expr);
			}
			this.writeExpr(def);
			break;
		case 19:
			var e1 = _g.e;
			var loop = _g.loop;
			var normalWhile = _g.normalWhile;
			this.writeExpr(e1);
			this.writeExpr(loop);
			this.out.addByte(normalWhile ? 1 : 0);
			break;
		case 20:
			var m = _g.m;
			var args = _g.args;
			var e1 = _g.e;
			this.writeString(m);
			var f = $bind(this,this.writeConst);
			this.writeVarInt(args.length);
			var _g1 = 0;
			while(_g1 < args.length) {
				var v = args[_g1];
				++_g1;
				f(v);
			}
			this.writeExpr(e1);
			break;
		case 21:
			var e1 = _g.e;
			var name = _g.name;
			this.writeExpr(e1);
			this.writeString(name);
			break;
		case 22:
			var target = _g.target;
			var code = _g.code;
			var args = _g.args;
			this.writeString(target);
			this.writeString(code);
			this.writeVarInt(args.length);
			var _g = 0;
			while(_g < args.length) {
				var v = args[_g];
				++_g;
				_gthis.writeExpr(v.e);
				_gthis.out.addByte(v.access._hx_index);
			}
			break;
		}
		this.writeType(e.t);
	}
	,readConst: function() {
		switch(this.input.readByte()) {
		case 0:
			return hxsl_Const.CNull;
		case 1:
			return hxsl_Const.CBool(this.input.readByte() != 0);
		case 2:
			return hxsl_Const.CInt(this.input.readInt32());
		case 3:
			return hxsl_Const.CFloat(this.input.readDouble());
		case 4:
			return hxsl_Const.CString(this.readString());
		default:
			throw haxe_Exception.thrown("assert");
		}
	}
	,readExpr: function() {
		var _gthis = this;
		var k = this.input.readByte();
		if(k-- == 0) {
			return null;
		}
		var e;
		switch(k) {
		case 0:
			e = hxsl_TExprDef.TConst(this.readConst());
			break;
		case 1:
			e = hxsl_TExprDef.TVar(this.readVar());
			break;
		case 2:
			e = hxsl_TExprDef.TGlobal(hxsl_Serializer.TGLOBALS[this.input.readByte()]);
			break;
		case 3:
			e = hxsl_TExprDef.TParenthesis(this.readExpr());
			break;
		case 4:
			var f = $bind(this,this.readExpr);
			var _g = [];
			var _g1 = 0;
			var _g2 = this.readVarInt();
			while(_g1 < _g2) {
				var i = _g1++;
				_g.push(f());
			}
			e = hxsl_TExprDef.TBlock(_g);
			break;
		case 5:
			var op = this.input.readByte();
			e = hxsl_TExprDef.TBinop(op >= 128 ? haxe_macro_Binop.OpAssignOp(hxsl_Serializer.BOPS[op & 127]) : hxsl_Serializer.BOPS[op],this.readExpr(),this.readExpr());
			break;
		case 6:
			e = hxsl_TExprDef.TUnop(hxsl_Serializer.UNOPS[this.input.readByte()],this.readExpr());
			break;
		case 7:
			e = hxsl_TExprDef.TVarDecl(this.readVar(),this.readExpr());
			break;
		case 8:
			var e1 = this.readExpr();
			var f = $bind(this,this.readExpr);
			var _g = [];
			var _g1 = 0;
			var _g2 = this.readVarInt();
			while(_g1 < _g2) {
				var i = _g1++;
				_g.push(f());
			}
			e = hxsl_TExprDef.TCall(e1,_g);
			break;
		case 9:
			var e1 = this.readExpr();
			var bits = this.input.readUInt16();
			var swiz = hxsl_Serializer.TSWIZ.h[bits];
			if(swiz == null) {
				var _g = [];
				var _g1 = 0;
				var _g2 = (bits & 3) + 1;
				while(_g1 < _g2) {
					var i = _g1++;
					_g.push(hxsl_Serializer.REGS[bits >> i * 2 + 2 & 3]);
				}
				swiz = _g;
				hxsl_Serializer.TSWIZ.h[bits] = swiz;
			}
			e = hxsl_TExprDef.TSwiz(e1,swiz);
			break;
		case 10:
			e = hxsl_TExprDef.TIf(this.readExpr(),this.readExpr(),this.readExpr());
			break;
		case 11:
			e = hxsl_TExprDef.TDiscard;
			break;
		case 12:
			e = hxsl_TExprDef.TReturn(this.readExpr());
			break;
		case 13:
			e = hxsl_TExprDef.TFor(this.readVar(),this.readExpr(),this.readExpr());
			break;
		case 14:
			e = hxsl_TExprDef.TContinue;
			break;
		case 15:
			e = hxsl_TExprDef.TBreak;
			break;
		case 16:
			e = hxsl_TExprDef.TArray(this.readExpr(),this.readExpr());
			break;
		case 17:
			var f = $bind(this,this.readExpr);
			var _g = [];
			var _g1 = 0;
			var _g2 = this.readVarInt();
			while(_g1 < _g2) {
				var i = _g1++;
				_g.push(f());
			}
			e = hxsl_TExprDef.TArrayDecl(_g);
			break;
		case 18:
			var e1 = this.readExpr();
			var _g = [];
			var _g1 = 0;
			var _g2 = this.readVarInt();
			while(_g1 < _g2) {
				var i = _g1++;
				var f = $bind(_gthis,_gthis.readExpr);
				var _g3 = [];
				var _g4 = 0;
				var _g5 = _gthis.readVarInt();
				while(_g4 < _g5) {
					var i1 = _g4++;
					_g3.push(f());
				}
				_g.push({ values : _g3, expr : _gthis.readExpr()});
			}
			e = hxsl_TExprDef.TSwitch(e1,_g,this.readExpr());
			break;
		case 19:
			e = hxsl_TExprDef.TWhile(this.readExpr(),this.readExpr(),this.input.readByte() != 0);
			break;
		case 20:
			var e1 = this.readString();
			var f = $bind(this,this.readConst);
			var _g = [];
			var _g1 = 0;
			var _g2 = this.readVarInt();
			while(_g1 < _g2) {
				var i = _g1++;
				_g.push(f());
			}
			e = hxsl_TExprDef.TMeta(e1,_g,this.readExpr());
			break;
		case 21:
			e = hxsl_TExprDef.TField(this.readExpr(),this.readString());
			break;
		case 22:
			var e1 = this.readString();
			var e2 = this.readString();
			var _g = [];
			var _g1 = 0;
			var _g2 = this.readVarInt();
			while(_g1 < _g2) {
				var i = _g1++;
				_g.push({ e : _gthis.readExpr(), access : Type.createEnumIndex(hxsl_SyntaxArgAccess,_gthis.input.readByte(),null), read : false, write : false});
			}
			e = hxsl_TExprDef.TSyntax(e1,e2,_g);
			break;
		default:
			throw haxe_Exception.thrown("assert");
		}
		return { e : e, t : this.readType(), p : null};
	}
	,readVar: function() {
		var id = this.readVarInt();
		if(id == 0) {
			return null;
		}
		var v = this.varMap.h[id];
		if(v != null) {
			return v;
		}
		v = { id : hxsl_Tools.allocVarId(), name : this.readString(), type : null, kind : null};
		this.varMap.h[id] = v;
		v.type = this.readType();
		v.kind = hxsl_Serializer.VKINDS[this.input.readByte()];
		v.parent = this.readVar();
		var nq = this.input.readByte();
		if(nq > 0) {
			v.qualifiers = [];
			var _g = 0;
			var _g1 = nq;
			while(_g < _g1) {
				var i = _g++;
				var qid = this.input.readByte();
				var q;
				switch(qid) {
				case 0:
					var n = this.input.readInt32();
					q = hxsl_VarQualifier.Const(n == 0 ? null : n);
					break;
				case 1:
					q = hxsl_VarQualifier.Private;
					break;
				case 2:
					q = hxsl_VarQualifier.Nullable;
					break;
				case 3:
					q = hxsl_VarQualifier.PerObject;
					break;
				case 4:
					q = hxsl_VarQualifier.Name(this.readString());
					break;
				case 5:
					q = hxsl_VarQualifier.Shared;
					break;
				case 6:
					q = hxsl_VarQualifier.Precision(hxsl_Serializer.PRECS[this.input.readByte()]);
					break;
				case 7:
					q = hxsl_VarQualifier.Range(this.input.readDouble(),this.input.readDouble());
					break;
				case 8:
					q = hxsl_VarQualifier.Ignore;
					break;
				case 9:
					q = hxsl_VarQualifier.PerInstance(this.input.readInt32());
					break;
				case 10:
					q = hxsl_VarQualifier.Doc(this.readString());
					break;
				case 11:
					q = hxsl_VarQualifier.Borrow(this.readString());
					break;
				case 12:
					q = hxsl_VarQualifier.Sampler(this.readString());
					break;
				case 13:
					q = hxsl_VarQualifier.Final;
					break;
				case 14:
					q = hxsl_VarQualifier.Flat;
					break;
				default:
					throw haxe_Exception.thrown("assert");
				}
				v.qualifiers.push(q);
			}
		}
		return v;
	}
	,readFun: function() {
		var tmp = hxsl_Serializer.FKIND[this.input.readByte()];
		var tmp1 = this.readVar();
		var f = $bind(this,this.readVar);
		var _g = [];
		var _g1 = 0;
		var _g2 = this.readVarInt();
		while(_g1 < _g2) {
			var i = _g1++;
			_g.push(f());
		}
		return { kind : tmp, ref : tmp1, args : _g, ret : this.readType(), expr : this.readExpr()};
	}
	,unserialize: function(data) {
		this.input = new haxe_io_BytesInput(haxe_crypto_Base64.decode(data,false));
		if(this.input.readByte() != (hxsl_Serializer.SIGN & 255) || this.input.readByte() != (hxsl_Serializer.SIGN >> 8 & 255)) {
			throw haxe_Exception.thrown("Invalid HXSL data");
		}
		this.version = this.input.readByte() - 139;
		if(this.version < 0 || this.version > 1) {
			throw haxe_Exception.thrown("Invalid HXSL data");
		}
		this.varMap = new haxe_ds_IntMap();
		this.types = [];
		var tmp = this.readString();
		var f = $bind(this,this.readVar);
		var _g = [];
		var _g1 = 0;
		var _g2 = this.readVarInt();
		while(_g1 < _g2) {
			var i = _g1++;
			_g.push(f());
		}
		var tmp1 = _g;
		var f = $bind(this,this.readFun);
		var _g = [];
		var _g1 = 0;
		var _g2 = this.readVarInt();
		while(_g1 < _g2) {
			var i = _g1++;
			_g.push(f());
		}
		return { name : tmp, vars : tmp1, funs : _g};
	}
	,serialize: function(s) {
		this.varMap = new haxe_ds_IntMap();
		this.idMap = new haxe_ds_IntMap();
		this.typeIdMap = new haxe_ds_EnumValueMap();
		this.out = new haxe_io_BytesBuffer();
		this.out.addByte(hxsl_Serializer.SIGN & 255);
		this.out.addByte(hxsl_Serializer.SIGN >> 8 & 255);
		this.out.addByte(hxsl_Serializer.SIGN >> 16 & 255);
		this.writeString(s.name);
		var arr = s.vars;
		var f = $bind(this,this.writeVar);
		this.writeVarInt(arr.length);
		var _g = 0;
		while(_g < arr.length) {
			var v = arr[_g];
			++_g;
			f(v);
		}
		var arr = s.funs;
		var f = $bind(this,this.writeFun);
		this.writeVarInt(arr.length);
		var _g = 0;
		while(_g < arr.length) {
			var v = arr[_g];
			++_g;
			f(v);
		}
		return haxe_crypto_Base64.encode(this.out.getBytes(),false);
	}
	,__class__: hxsl_Serializer
};
var hxsl_ShaderList = function(s,n) {
	this.s = s;
	this.next = n;
};
$hxClasses["hxsl.ShaderList"] = hxsl_ShaderList;
hxsl_ShaderList.__name__ = "hxsl.ShaderList";
hxsl_ShaderList.addSort = function(s,shaders) {
	var prev = null;
	var hd = shaders;
	while(hd != null && hd.s.priority < s.priority) {
		prev = hd;
		hd = hd.next;
	}
	if(prev == null) {
		var l = new hxsl_ShaderList(s,shaders);
		hxsl_ShaderList.checkSize(l);
		return l;
	}
	prev.next = new hxsl_ShaderList(s,prev.next);
	hxsl_ShaderList.checkSize(shaders);
	return shaders;
};
hxsl_ShaderList.checkSize = function(list) {
	if(hxsl_ShaderList.MAX_LIST_SIZE <= 0) {
		return;
	}
	var hd = list;
	var count = 0;
	while(hd != null) {
		if(!hxsl_ShaderList.ALLOW_DUPLICATES && hd.next != null && hd.next.s == hd.s) {
			throw haxe_Exception.thrown("Duplicate shader " + Std.string(hd.s));
		}
		++count;
		hd = hd.next;
	}
	if(count > hxsl_ShaderList.MAX_LIST_SIZE) {
		throw haxe_Exception.thrown("Too many shaders");
	}
};
hxsl_ShaderList.prototype = {
	clone: function() {
		return new hxsl_ShaderList(this.s.clone(),this.next == null ? null : this.next.clone());
	}
	,iterator: function() {
		return new hxsl__$ShaderList_ShaderIterator(this,null);
	}
	,iterateTo: function(s) {
		return new hxsl__$ShaderList_ShaderIterator(this,s);
	}
	,__class__: hxsl_ShaderList
};
var hxsl__$ShaderList_ShaderIterator = function(l,last) {
	this.l = l;
	this.last = last;
};
$hxClasses["hxsl._ShaderList.ShaderIterator"] = hxsl__$ShaderList_ShaderIterator;
hxsl__$ShaderList_ShaderIterator.__name__ = "hxsl._ShaderList.ShaderIterator";
hxsl__$ShaderList_ShaderIterator.prototype = {
	hasNext: function() {
		return this.l != this.last;
	}
	,next: function() {
		var s = this.l.s;
		this.l = this.l.next;
		return s;
	}
	,__class__: hxsl__$ShaderList_ShaderIterator
};
var hxsl_ShaderInstance = function(shader) {
	this.id = ++hxsl_ShaderInstance.UID;
	this.shader = shader;
	this.params = new haxe_ds_IntMap();
};
$hxClasses["hxsl.ShaderInstance"] = hxsl_ShaderInstance;
hxsl_ShaderInstance.__name__ = "hxsl.ShaderInstance";
hxsl_ShaderInstance.prototype = {
	__class__: hxsl_ShaderInstance
};
var hxsl_ShaderGlobal = function(v,gid) {
	this.v = v;
	this.globalId = gid;
};
$hxClasses["hxsl.ShaderGlobal"] = hxsl_ShaderGlobal;
hxsl_ShaderGlobal.__name__ = "hxsl.ShaderGlobal";
hxsl_ShaderGlobal.prototype = {
	__class__: hxsl_ShaderGlobal
};
var hxsl_ShaderConst = function(v,pos,bits) {
	this.v = v;
	this.pos = pos;
	this.bits = bits;
};
$hxClasses["hxsl.ShaderConst"] = hxsl_ShaderConst;
hxsl_ShaderConst.__name__ = "hxsl.ShaderConst";
hxsl_ShaderConst.prototype = {
	__class__: hxsl_ShaderConst
};
var hxsl_SharedShader = function(src,module) {
	this.instanceCache = new haxe_ds_IntMap();
	this.consts = null;
	this.globals = [];
	if(src == "") {
		return;
	}
	this.module = module;
	this.data = new hxsl_Serializer().unserialize(src);
	var _g = 0;
	var _g1 = this.data.vars;
	while(_g < _g1.length) {
		var v = _g1[_g];
		++_g;
		this.initVarId(v);
	}
	this.data = hxsl_SharedShader.compactMem(this.data);
	this.initialize();
	this.initLiveReload();
};
$hxClasses["hxsl.SharedShader"] = hxsl_SharedShader;
hxsl_SharedShader.__name__ = "hxsl.SharedShader";
hxsl_SharedShader.mergeVars = function(vl,vl2) {
	if(vl.length != vl2.length) {
		return false;
	}
	var _g_current = 0;
	var _g_array = vl;
	while(_g_current < _g_array.length) {
		var _g_value = _g_array[_g_current];
		var _g_key = _g_current++;
		var i = _g_key;
		var v = _g_value;
		var v2 = vl2[i];
		if(v.name != v2.name) {
			return false;
		}
		v2.id = v.id;
		var _g = v.type;
		var _g1 = v2.type;
		if(_g._hx_index == 13) {
			if(_g1._hx_index == 13) {
				var vl21 = _g1.vl;
				var vl = _g.vl;
				if(vl.length != vl21.length) {
					return false;
				}
				if(!hxsl_SharedShader.mergeVars(vl,vl21)) {
					return false;
				}
			}
		}
	}
	return true;
};
hxsl_SharedShader.loadShader = function(fs,name) {
	var text = fs.getText();
	throw haxe_Exception.thrown("Shader live reload requires --library hscript");
};
hxsl_SharedShader.compactMem = function(mem) {
	return mem;
};
hxsl_SharedShader.prototype = {
	initialize: function() {
		var _g = 0;
		var _g1 = this.data.vars;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			this.browseVar(v);
		}
	}
	,getInstance: function(constBits) {
		var i = this.instanceCache.h[constBits];
		if(i == null) {
			return this.makeInstance(constBits);
		} else {
			return i;
		}
	}
	,makeBufferType: function(v,tbuf,fmt) {
		var name = v.name;
		if(tbuf._hx_index == 13) {
			var vl = tbuf.vl;
			var _g = [];
			var _g_current = 0;
			var _g_array = fmt.inputs;
			while(_g_current < _g_array.length) {
				var i = _g_array[_g_current++];
				_g.push(i);
			}
			var inputs = _g;
			var vli = [];
			var p = 0;
			while(p < inputs.length) {
				var i = inputs[p++];
				var name = i.name;
				var t;
				switch(i.type) {
				case 1:
					t = hxsl_Type.TFloat;
					break;
				case 2:
					t = hxsl_Type.TVec(2,hxsl_VecType.VFloat);
					break;
				case 3:
					t = hxsl_Type.TVec(3,hxsl_VecType.VFloat);
					break;
				case 4:
					t = hxsl_Type.TVec(4,hxsl_VecType.VFloat);
					break;
				case 9:
					t = hxsl_Type.TBytes(4);
					break;
				}
				if(StringTools.endsWith(i.name,"__m0")) {
					var h = i.type & 7;
					var w = 2;
					while(inputs[p + w - 1] != null && StringTools.endsWith(inputs[p + w - 1].name,"__m" + w)) ++w;
					switch(w) {
					case 2:
						if(h == 2) {
							t = hxsl_Type.TMat2;
						} else {
							throw haxe_Exception.thrown("Unsupported matrix format");
						}
						break;
					case 3:
						switch(h) {
						case 3:
							t = hxsl_Type.TMat3;
							break;
						case 4:
							t = hxsl_Type.TMat3x4;
							break;
						default:
							throw haxe_Exception.thrown("Unsupported matrix format");
						}
						break;
					case 4:
						if(h == 4) {
							t = hxsl_Type.TMat4;
						} else {
							throw haxe_Exception.thrown("Unsupported matrix format");
						}
						break;
					default:
						throw haxe_Exception.thrown("Unsupported matrix format");
					}
					name = HxOverrides.substr(i.name,0,-4);
					p += w - 1;
				}
				vli.push({ id : hxsl_Tools.allocVarId(), name : name, type : t, kind : v.kind, parent : v});
			}
			var _g = 0;
			while(_g < vl.length) {
				var v = vl[_g];
				++_g;
				var found = false;
				var _g1 = 0;
				while(_g1 < vli.length) {
					var v2 = vli[_g1];
					++_g1;
					if(v.name == v2.name) {
						var _g2 = v.type;
						var _g3 = v2.type;
						switch(_g2._hx_index) {
						case 3:
							if(_g3._hx_index != 3) {
								if(!Type.enumEq(v.type,v2.type)) {
									throw haxe_Exception.thrown("Buffer " + this.data.name + "." + v.name + ":" + hxsl_Tools.toString(v.type) + " should be " + hxsl_Tools.toString(v2.type));
								}
							}
							break;
						case 5:
							if(_g2.t._hx_index == 1) {
								if(_g3._hx_index == 5) {
									if(_g3.t._hx_index == 1) {
										var b = _g3.size;
										var a = _g2.size;
										if(a > b) {
											if(!Type.enumEq(v.type,v2.type)) {
												throw haxe_Exception.thrown("Buffer " + this.data.name + "." + v.name + ":" + hxsl_Tools.toString(v.type) + " should be " + hxsl_Tools.toString(v2.type));
											}
										}
									} else if(!Type.enumEq(v.type,v2.type)) {
										throw haxe_Exception.thrown("Buffer " + this.data.name + "." + v.name + ":" + hxsl_Tools.toString(v.type) + " should be " + hxsl_Tools.toString(v2.type));
									}
								} else if(!Type.enumEq(v.type,v2.type)) {
									throw haxe_Exception.thrown("Buffer " + this.data.name + "." + v.name + ":" + hxsl_Tools.toString(v.type) + " should be " + hxsl_Tools.toString(v2.type));
								}
							} else if(!Type.enumEq(v.type,v2.type)) {
								throw haxe_Exception.thrown("Buffer " + this.data.name + "." + v.name + ":" + hxsl_Tools.toString(v.type) + " should be " + hxsl_Tools.toString(v2.type));
							}
							break;
						default:
							if(!Type.enumEq(v.type,v2.type)) {
								throw haxe_Exception.thrown("Buffer " + this.data.name + "." + v.name + ":" + hxsl_Tools.toString(v.type) + " should be " + hxsl_Tools.toString(v2.type));
							}
						}
						found = true;
						break;
					}
				}
				if(!found) {
					throw haxe_Exception.thrown("Buffer is missing " + this.data.name + "." + v.name + ":" + hxsl_Tools.toString(v.type));
				}
			}
			return hxsl_Type.TStruct(vli);
		} else {
			throw haxe_Exception.thrown("assert");
		}
	}
	,makeInstance: function(constBits) {
		var $eval = new hxsl_Eval();
		var c = this.consts;
		var buffers = [];
		while(c != null) {
			var _g = c.v.type;
			switch(_g._hx_index) {
			case 1:
				$eval.setConstant(c.v,hxsl_Const.CInt(constBits >>> c.pos & (1 << c.bits) - 1));
				break;
			case 2:
				$eval.setConstant(c.v,hxsl_Const.CBool((constBits >>> c.pos & 1) != 0));
				break;
			case 16:
				var t = _g.t;
				var size = _g.size;
				var kind = _g.kind;
				var bits = constBits >>> c.pos & (1 << c.bits) - 1;
				var fmt = hxd_BufferFormat.fromID(bits);
				var v = { id : c.v.id, name : c.v.name, kind : c.v.kind, type : null};
				var fullT = this.makeBufferType(v,t,fmt);
				var tmp;
				switch(kind._hx_index) {
				case 3:
					tmp = hxsl_BufferKind.Uniform;
					break;
				case 4:
					tmp = hxsl_BufferKind.Storage;
					break;
				case 5:
					tmp = hxsl_BufferKind.RW;
					break;
				default:
					throw haxe_Exception.thrown("assert");
				}
				v.type = hxsl_Type.TBuffer(fullT,size,tmp);
				$eval.varMap.set(c.v,v);
				buffers.push(v);
				break;
			case 17:
				var _g1 = _g.size;
				$eval.setConstant(c.v,hxsl_Const.CInt(constBits >>> c.pos & (1 << c.bits) - 1));
				break;
			default:
				throw haxe_Exception.thrown("assert");
			}
			c = c.next;
		}
		var _g = 0;
		while(_g < buffers.length) {
			var v = buffers[_g];
			++_g;
			var _g1 = v.type;
			if(_g1._hx_index == 16) {
				var _g2 = _g1.size;
				if(_g2._hx_index == 1) {
					var vs = _g2.v;
					var t = _g1.t;
					var kind = _g1.kind;
					var c = $eval.constants.h[vs.id];
					if(c != null) {
						if(c != null) {
							if(c._hx_index == 0) {
								var _g3 = c.c;
								if(_g3._hx_index == 2) {
									var i = _g3.v;
									v.type = hxsl_Type.TBuffer(t,hxsl_SizeDecl.SConst(i),kind);
								}
							}
						}
					}
				}
			}
		}
		$eval.inlineCalls = true;
		$eval.unrollLoops = hxsl_SharedShader.UNROLL_LOOPS;
		var edata = $eval.eval(this.data);
		edata = hxsl_SharedShader.compactMem(edata);
		var i = new hxsl_ShaderInstance(edata);
		hxsl_Printer.check(i.shader,[this.data]);
		this.paramsCount = 0;
		var _g = 0;
		var _g1 = this.data.vars;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			this.addParam($eval,i,v);
		}
		this.instanceCache.h[constBits] = i;
		return i;
	}
	,addSelfParam: function(i,v) {
		var _g = v.type;
		if(_g._hx_index == 13) {
			var vl = _g.vl;
			var _g = 0;
			while(_g < vl.length) {
				var v1 = vl[_g];
				++_g;
				this.addSelfParam(i,v1);
			}
		} else if(v.kind == hxsl_VarKind.Param) {
			i.params.h[v.id] = this.paramsCount;
			this.paramsCount++;
		}
	}
	,addParam: function($eval,i,v) {
		var _g = v.type;
		if(_g._hx_index == 13) {
			var vl = _g.vl;
			var _g = 0;
			while(_g < vl.length) {
				var v1 = vl[_g];
				++_g;
				this.addParam($eval,i,v1);
			}
		} else if(v.kind == hxsl_VarKind.Param) {
			i.params.h[$eval.varMap.h[v.__id__].id] = this.paramsCount;
			this.paramsCount++;
		}
	}
	,initVarId: function(v) {
		v.id = hxsl_Tools.allocVarId();
		var _g = v.type;
		if(_g._hx_index == 13) {
			var vl = _g.vl;
			var _g = 0;
			while(_g < vl.length) {
				var v = vl[_g];
				++_g;
				this.initVarId(v);
			}
		}
	}
	,browseVar: function(v,path) {
		if(path == null) {
			path = hxsl_Tools.getName(v);
		} else {
			path += "." + v.name;
		}
		var _g = v.type;
		if(_g._hx_index == 13) {
			var vl = _g.vl;
			var _g = 0;
			while(_g < vl.length) {
				var vs = vl[_g];
				++_g;
				this.browseVar(vs,path);
			}
		} else {
			var globalId = 0;
			if(v.kind == hxsl_VarKind.Global) {
				globalId = hxsl_Globals.allocID(path);
				this.globals.push(new hxsl_ShaderGlobal(v,globalId));
			}
			if(!hxsl_Tools.isConst(v)) {
				return;
			}
			var bits = hxsl_Tools.getConstBits(v);
			if(bits > 0) {
				var pos = this.consts == null ? 0 : this.consts.pos + this.consts.bits;
				var c = new hxsl_ShaderConst(v,pos,bits);
				c.globalId = globalId;
				c.next = this.consts;
				this.consts = c;
			}
		}
	}
	,initLiveReload: function() {
		if(this.module == null) {
			return;
		}
		if(!hxd_fs_SourceLoader.isActive()) {
			return;
		}
		hxsl_SharedShader.SHADER_RESOLVE.h[this.data.name] = this;
		var path = this.module.split(".").join("/") + ".hx";
		this.file = hxd_fs_SourceLoader.resolve(path);
		if(this.file != null) {
			this.file.watch($bind(this,this.onFileReload));
		}
	}
	,onFileReload: function() {
		var h = hxsl_SharedShader.SHADER_RESOLVE.h;
		var sh_h = h;
		var sh_keys = Object.keys(h);
		var sh_length = sh_keys.length;
		var sh_current = 0;
		while(sh_current < sh_length) {
			var sh = sh_h[sh_keys[sh_current++]];
			if(sh.file == this.file) {
				sh.reloadShader();
			}
		}
	}
	,reloadShader: function() {
		try {
			var expr = hxsl_SharedShader.loadShader(this.file,this.data.name);
			if(expr == null) {
				return;
			}
			var checker = new hxsl_Checker();
			checker.loadShader = function(name) {
				var sh = hxsl_SharedShader.SHADER_RESOLVE.h[name];
				if(sh == null) {
					throw haxe_Exception.thrown("Could not resolve shader " + name);
				}
				if(sh.file == null) {
					throw haxe_Exception.thrown("Shader " + name + " can't be live reload because of missing live path");
				}
				return hxsl_SharedShader.loadShader(sh.file,sh.data.name);
			};
			var data = checker.check(this.data.name,expr);
			this.applyChanges(data);
		} catch( _g ) {
			var _g1 = haxe_Exception.caught(_g).unwrap();
			if(((_g1) instanceof hxsl_Error)) {
				var e = _g1;
				var line = HxOverrides.substr(this.file.getText(),0,e.pos.min).split("\n").length;
				haxe_Log.trace(e.msg,{ methodName : null, className : null, fileName : e.pos.file, lineNumber : line});
				return;
			} else {
				throw _g;
			}
		}
	}
	,applyChanges: function(data2) {
		if(!hxsl_SharedShader.mergeVars(this.data.vars,data2.vars)) {
			return false;
		}
		this.data = hxsl_SharedShader.compactMem(data2);
		this.instanceCache = new haxe_ds_IntMap();
		return true;
	}
	,__class__: hxsl_SharedShader
};
var hxsl__$Splitter_VarProps = function(v) {
	this.v = v;
	this.read = 0;
	this.write = 0;
};
$hxClasses["hxsl._Splitter.VarProps"] = hxsl__$Splitter_VarProps;
hxsl__$Splitter_VarProps.__name__ = "hxsl._Splitter.VarProps";
hxsl__$Splitter_VarProps.prototype = {
	__class__: hxsl__$Splitter_VarProps
};
var hxsl_Splitter = function() {
};
$hxClasses["hxsl.Splitter"] = hxsl_Splitter;
hxsl_Splitter.__name__ = "hxsl.Splitter";
hxsl_Splitter.prototype = {
	split: function(s,isBatchShader) {
		var _gthis = this;
		this.isBatchShader = isBatchShader;
		var vfun = null;
		var vvars = new haxe_ds_IntMap();
		var avvars = [];
		var ffun = null;
		var fvars = new haxe_ds_IntMap();
		var afvars = [];
		var isCompute = false;
		this.varNames = new haxe_ds_StringMap();
		this.varMap = new haxe_ds_ObjectMap();
		var _g = 0;
		var _g1 = s.funs;
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			switch(f.kind._hx_index) {
			case 1:
				this.vars = fvars;
				this.avars = afvars;
				ffun = f;
				this.checkExpr(f.expr);
				break;
			case 0:case 4:
				this.vars = vvars;
				this.avars = avvars;
				vfun = f;
				this.checkExpr(f.expr);
				if(f.kind == hxsl_FunctionKind.Main) {
					isCompute = true;
				}
				break;
			default:
				throw haxe_Exception.thrown("assert");
			}
		}
		var vafterMap = [];
		var length = avvars.length;
		var _g = 0;
		var _g1 = length;
		while(_g < _g1) {
			var i = _g++;
			var inf = [avvars[i]];
			var v = [inf[0].v];
			if(inf[0].local) {
				continue;
			}
			switch(v[0].kind._hx_index) {
			case 3:case 4:
				var fv = fvars.h[inf[0].origin.id];
				v[0].kind = fv != null && fv.read > 0 ? hxsl_VarKind.Var : hxsl_VarKind.Local;
				break;
			default:
			}
			switch(v[0].kind._hx_index) {
			case 3:case 5:
				if(inf[0].read > 0 || inf[0].write > 1) {
					var nv = { id : hxsl_Tools.allocVarId(), name : v[0].name, kind : hxsl_VarKind.Local, type : v[0].type};
					this.uniqueName(nv);
					this.varMap.set(inf[0].origin,nv);
					var ninf = new hxsl__$Splitter_VarProps(nv);
					ninf.read++;
					vvars.h[nv.id] = ninf;
					var p = vfun.expr.p;
					var e = [{ e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssign,{ e : hxsl_TExprDef.TVar(v[0]), t : nv.type, p : p},{ e : hxsl_TExprDef.TVar(nv), t : v[0].type, p : p}), t : nv.type, p : p}];
					vafterMap.push((function(e) {
						return function() {
							_gthis.addExpr(vfun,e[0]);
						};
					})(e));
					if(v[0].kind == hxsl_VarKind.Var) {
						vafterMap.push((function(v,inf) {
							return function() {
								_gthis.varMap.set(inf[0].origin,v[0]);
							};
						})(v,inf));
					}
				}
				break;
			default:
			}
		}
		vfun = { ret : vfun.ret, ref : vfun.ref, kind : vfun.kind, args : vfun.args, expr : this.mapVars(vfun.expr)};
		var _g = 0;
		while(_g < vafterMap.length) {
			var f = vafterMap[_g];
			++_g;
			f();
		}
		var finits = [];
		var _g = 0;
		while(_g < afvars.length) {
			var inf1 = afvars[_g];
			++_g;
			var v1 = inf1.v;
			switch(v1.kind._hx_index) {
			case 1:
				var nv = { id : hxsl_Tools.allocVarId(), name : v1.name, kind : hxsl_VarKind.Var, type : v1.type};
				this.uniqueName(nv);
				var i = vvars.h[inf1.origin.id];
				if(i == null) {
					i = new hxsl__$Splitter_VarProps(v1);
					vvars.h[inf1.origin.id] = i;
				}
				i.read++;
				this.varMap.set(inf1.origin,nv);
				var ninf = new hxsl__$Splitter_VarProps(nv);
				ninf.origin = inf1.origin;
				fvars.h[inf1.origin.id] = ninf;
				vvars.h[nv.id] = ninf;
				this.addExpr(vfun,{ e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssign,{ e : hxsl_TExprDef.TVar(nv), t : v1.type, p : vfun.expr.p},{ e : hxsl_TExprDef.TVar(v1), t : v1.type, p : vfun.expr.p}), t : v1.type, p : vfun.expr.p});
				break;
			case 3:
				if(inf1.write > 0) {
					var nv1 = { id : hxsl_Tools.allocVarId(), name : v1.name, kind : hxsl_VarKind.Local, type : v1.type};
					this.uniqueName(nv1);
					finits.push({ e : hxsl_TExprDef.TVarDecl(nv1,{ e : hxsl_TExprDef.TVar(v1), t : v1.type, p : ffun.expr.p}), t : hxsl_Type.TVoid, p : ffun.expr.p});
					this.varMap.set(inf1.origin,nv1);
				}
				break;
			default:
			}
		}
		var v1 = vvars.iterator();
		while(v1.hasNext()) {
			var v2 = v1.next();
			this.checkVar(v2,true,vvars,vfun.expr.p);
		}
		var v1 = fvars.iterator();
		while(v1.hasNext()) {
			var v2 = v1.next();
			this.checkVar(v2,false,vvars,ffun.expr.p);
		}
		if(ffun != null) {
			ffun = { ret : ffun.ret, ref : ffun.ref, kind : ffun.kind, args : ffun.args, expr : this.mapVars(ffun.expr)};
			var _g = ffun.expr.e;
			if(_g._hx_index == 4) {
				var el = _g.el;
				var _g = 0;
				while(_g < finits.length) {
					var e1 = finits[_g];
					++_g;
					el.unshift(e1);
				}
			} else {
				finits.push(ffun.expr);
				ffun.expr = { e : hxsl_TExprDef.TBlock(finits), t : hxsl_Type.TVoid, p : ffun.expr.p};
			}
		}
		var _g = [];
		var v1 = vvars.iterator();
		while(v1.hasNext()) {
			var v2 = v1.next();
			if(!v2.local) {
				_g.push(v2);
			}
		}
		var vvars = _g;
		var _g = [];
		var v1 = fvars.iterator();
		while(v1.hasNext()) {
			var v2 = v1.next();
			if(!v2.local) {
				_g.push(v2);
			}
		}
		var fvars = _g;
		vvars.sort(function(v1,v2) {
			var result = (v1.origin == null ? v1.v.id : v1.origin.id) - (v2.origin == null ? v2.v.id : v2.origin.id);
			if(result != 0) {
				return result;
			} else {
				return v1.v.id - v2.v.id;
			}
		});
		fvars.sort(function(v1,v2) {
			var result = (v1.origin == null ? v1.v.id : v1.origin.id) - (v2.origin == null ? v2.v.id : v2.origin.id);
			if(result != 0) {
				return result;
			} else {
				return v1.v.id - v2.v.id;
			}
		});
		if(isCompute) {
			var _g = [];
			var _g1 = 0;
			while(_g1 < vvars.length) {
				var v1 = vvars[_g1];
				++_g1;
				_g.push(v1.v);
			}
			return [{ name : "main", vars : _g, funs : [vfun]}];
		} else {
			var _g = [];
			var _g1 = 0;
			while(_g1 < vvars.length) {
				var v1 = vvars[_g1];
				++_g1;
				_g.push(v1.v);
			}
			var tmp = { name : "vertex", vars : _g, funs : [vfun]};
			var _g = [];
			var _g1 = 0;
			while(_g1 < fvars.length) {
				var v1 = fvars[_g1];
				++_g1;
				_g.push(v1.v);
			}
			return [tmp,{ name : "fragment", vars : _g, funs : [ffun]}];
		}
	}
	,addExpr: function(f,e) {
		var _g = f.expr.e;
		if(_g._hx_index == 4) {
			var el = _g.el;
			el.push(e);
		} else {
			f.expr = { e : hxsl_TExprDef.TBlock([f.expr,e]), t : hxsl_Type.TVoid, p : f.expr.p};
		}
	}
	,checkVar: function(v,vertex,vvars,p) {
		switch(v.v.kind._hx_index) {
		case 3:
			if(!vertex) {
				var i = vvars.h[v.origin.id];
				if(i != null && i.v.kind == hxsl_VarKind.Input) {
					return;
				}
				if(v.requireInit && (i == null || i.write == 0)) {
					throw haxe_Exception.thrown(new hxsl_Error("Varying " + v.v.name + " is not written by vertex shader",p));
				}
			}
			break;
		case 4:
			if(v.requireInit) {
				if(v.origin.parent == null || v.origin.parent.name != "global" && !this.isBatchShader) {
					throw haxe_Exception.thrown(new hxsl_Error("Variable " + v.v.name + " is used without being initialized",p));
				}
			}
			break;
		default:
		}
	}
	,mapVars: function(e) {
		var _g = e.e;
		switch(_g._hx_index) {
		case 1:
			var v = _g.v;
			var v2 = this.varMap.h[v.__id__];
			if(v2 == null) {
				return e;
			} else {
				return { e : hxsl_TExprDef.TVar(v2), t : e.t, p : e.p};
			}
			break;
		case 7:
			var v = _g.v;
			var init = _g.init;
			var v2 = this.varMap.h[v.__id__];
			if(v2 == null) {
				return hxsl_Tools.map(e,$bind(this,this.mapVars));
			} else {
				return { e : hxsl_TExprDef.TVarDecl(v2,init == null ? null : this.mapVars(init)), t : e.t, p : e.p};
			}
			break;
		case 13:
			var v = _g.v;
			var it = _g.it;
			var loop = _g.loop;
			var v2 = this.varMap.h[v.__id__];
			if(v2 == null) {
				return hxsl_Tools.map(e,$bind(this,this.mapVars));
			} else {
				return { e : hxsl_TExprDef.TFor(v2,this.mapVars(it),this.mapVars(loop)), t : e.t, p : e.p};
			}
			break;
		default:
			return hxsl_Tools.map(e,$bind(this,this.mapVars));
		}
	}
	,get: function(v) {
		var i = this.vars.h[v.id];
		if(i == null) {
			var nv = this.varMap.h[v.__id__];
			if(nv == null) {
				if(v.kind == hxsl_VarKind.Global || v.kind == hxsl_VarKind.Output || v.kind == hxsl_VarKind.Input) {
					nv = v;
				} else {
					nv = { id : hxsl_Tools.allocVarId(), name : v.name, kind : v.kind, type : v.type};
					if(v.qualifiers != null) {
						var _g = 0;
						var _g1 = v.qualifiers;
						while(_g < _g1.length) {
							var q = _g1[_g];
							++_g;
							switch(q._hx_index) {
							case 0:
								var _g2 = q.max;
								break;
							case 4:
								var _g3 = q.n;
								break;
							case 6:
								var _g4 = q.p;
								break;
							case 7:
								var _g5 = q.min;
								var _g6 = q.max;
								break;
							case 1:case 2:case 3:case 5:case 8:
								break;
							case 9:
								var _g7 = q.v;
								break;
							case 10:
								var _g8 = q.s;
								break;
							case 11:
								var _g9 = q.source;
								break;
							case 12:
								var _g10 = q.name;
								break;
							case 13:case 14:
								if(nv.qualifiers == null) {
									nv.qualifiers = [];
								}
								nv.qualifiers.push(q);
								break;
							}
						}
					}
					this.uniqueName(nv);
				}
				this.varMap.set(v,nv);
			}
			i = new hxsl__$Splitter_VarProps(nv);
			i.origin = v;
			this.vars.h[v.id] = i;
			this.avars.push(i);
		}
		return i;
	}
	,uniqueName: function(v) {
		if(v.kind == hxsl_VarKind.Global || v.kind == hxsl_VarKind.Output || v.kind == hxsl_VarKind.Input) {
			return;
		}
		var n = this.varNames.h[v.name];
		if(n != null && n != v) {
			var prefix = v.name;
			while(HxOverrides.cca(prefix,prefix.length - 1) >= 48 && HxOverrides.cca(prefix,prefix.length - 1) <= 57) prefix = HxOverrides.substr(prefix,0,-1);
			var k = prefix == v.name ? 2 : Std.parseInt(HxOverrides.substr(v.name,prefix.length,null));
			while(Object.prototype.hasOwnProperty.call(this.varNames.h,prefix + k)) ++k;
			v.name = prefix + k;
		}
		this.varNames.h[v.name] = v;
	}
	,checkExpr: function(e) {
		var _gthis = this;
		var _g = e.e;
		switch(_g._hx_index) {
		case 1:
			var v = _g.v;
			var inf = this.get(v);
			if(inf.write == 0) {
				inf.requireInit = true;
			}
			inf.read++;
			break;
		case 5:
			var _g1 = _g.op;
			var _g2 = _g.e1;
			var _g3 = _g.e2;
			switch(_g1._hx_index) {
			case 4:
				var _g4 = _g2.e;
				var _g5 = _g2.p;
				var _g5 = _g2.t;
				switch(_g4._hx_index) {
				case 1:
					var v = _g4.v;
					var e1 = _g3;
					var inf = this.get(v);
					inf.write++;
					this.checkExpr(e1);
					break;
				case 9:
					var _g5 = _g4.e;
					var _g6 = _g4.regs;
					var _g4 = _g5.e;
					var _g6 = _g5.p;
					var _g6 = _g5.t;
					if(_g4._hx_index == 1) {
						var v = _g4.v;
						var e1 = _g3;
						var inf = this.get(v);
						inf.write++;
						this.checkExpr(e1);
					} else {
						hxsl_Tools.iter(e,$bind(this,this.checkExpr));
					}
					break;
				default:
					hxsl_Tools.iter(e,$bind(this,this.checkExpr));
				}
				break;
			case 20:
				var _g4 = _g1.op;
				var _g1 = _g2.e;
				var _g4 = _g2.p;
				var _g4 = _g2.t;
				switch(_g1._hx_index) {
				case 1:
					var v = _g1.v;
					var e1 = _g3;
					var inf = this.get(v);
					if(inf.write == 0) {
						inf.requireInit = true;
					}
					inf.read++;
					inf.write++;
					this.checkExpr(e1);
					break;
				case 9:
					var _g2 = _g1.e;
					var _g4 = _g1.regs;
					var _g1 = _g2.e;
					var _g4 = _g2.p;
					var _g4 = _g2.t;
					if(_g1._hx_index == 1) {
						var v = _g1.v;
						var e1 = _g3;
						var inf = this.get(v);
						if(inf.write == 0) {
							inf.requireInit = true;
						}
						inf.read++;
						inf.write++;
						this.checkExpr(e1);
					} else {
						hxsl_Tools.iter(e,$bind(this,this.checkExpr));
					}
					break;
				default:
					hxsl_Tools.iter(e,$bind(this,this.checkExpr));
				}
				break;
			default:
				hxsl_Tools.iter(e,$bind(this,this.checkExpr));
			}
			break;
		case 7:
			var v = _g.v;
			var init = _g.init;
			var inf = this.get(v);
			inf.local = true;
			if(init != null) {
				this.checkExpr(init);
				inf.write++;
			}
			break;
		case 13:
			var v = _g.v;
			var it = _g.it;
			var loop = _g.loop;
			this.checkExpr(it);
			var inf = this.get(v);
			inf.local = true;
			inf.write++;
			this.checkExpr(loop);
			break;
		case 22:
			var _g1 = _g.target;
			var _g1 = _g.code;
			var args = _g.args;
			var arg = null;
			var checkSyntaxExpr = null;
			checkSyntaxExpr = function(e) {
				var _g = e.e;
				if(_g._hx_index == 1) {
					var v = _g.v;
					var inf = _gthis.get(v);
					switch(arg.access._hx_index) {
					case 0:
						inf.read--;
						break;
					case 1:
						inf.write++;
						break;
					case 2:
						inf.read--;
						inf.write++;
						break;
					}
				} else {
					hxsl_Tools.iter(e,checkSyntaxExpr);
				}
			};
			var _g = 0;
			var _g1 = args.length;
			while(_g < _g1) {
				var i = _g++;
				arg = args[i];
				checkSyntaxExpr(arg.e);
				this.checkExpr(arg.e);
			}
			break;
		default:
			hxsl_Tools.iter(e,$bind(this,this.checkExpr));
		}
	}
	,__class__: hxsl_Splitter
};
var hxsl_ChannelTools = function() { };
$hxClasses["hxsl.ChannelTools"] = hxsl_ChannelTools;
hxsl_ChannelTools.__name__ = "hxsl.ChannelTools";
hxsl_ChannelTools.isPackedFormat = function(c) {
	return c.format == h3d_mat_Texture.nativeFormat;
};
var js_html__$CanvasElement_CanvasUtil = function() { };
$hxClasses["js.html._CanvasElement.CanvasUtil"] = js_html__$CanvasElement_CanvasUtil;
js_html__$CanvasElement_CanvasUtil.__name__ = "js.html._CanvasElement.CanvasUtil";
js_html__$CanvasElement_CanvasUtil.getContextWebGL = function(canvas,attribs) {
	var name = "webgl";
	var ctx = canvas.getContext(name,attribs);
	if(ctx != null) {
		return ctx;
	}
	var name = "experimental-webgl";
	var ctx = canvas.getContext(name,attribs);
	if(ctx != null) {
		return ctx;
	}
	return null;
};
var js_lib__$ArrayBuffer_ArrayBufferCompat = function() { };
$hxClasses["js.lib._ArrayBuffer.ArrayBufferCompat"] = js_lib__$ArrayBuffer_ArrayBufferCompat;
js_lib__$ArrayBuffer_ArrayBufferCompat.__name__ = "js.lib._ArrayBuffer.ArrayBufferCompat";
js_lib__$ArrayBuffer_ArrayBufferCompat.sliceImpl = function(begin,end) {
	var u = new Uint8Array(this,begin,end == null ? null : end - begin);
	var resultArray = new Uint8Array(u.byteLength);
	resultArray.set(u);
	return resultArray.buffer;
};
Math.__name__ = "Math";
function $getIterator(o) { if( o instanceof Array ) return new haxe_iterators_ArrayIterator(o); else return o.iterator(); }
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
$hxClasses["Math"] = Math;
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
Object.defineProperty(String.prototype,"__class__",{ value : $hxClasses["String"] = String, enumerable : false, writable : true});
String.__name__ = "String";
$hxClasses["Array"] = Array;
Array.__name__ = "Array";
Date.prototype.__class__ = $hxClasses["Date"] = Date;
Date.__name__ = "Date";
var Int = { };
var Dynamic = { };
var Float = Number;
var Bool = Boolean;
var Class = { };
var Enum = { };
haxe_Resource.content = [{ name : "R_marius_png", data : "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"},{ name : "R_README_md", data : "IyBHYW1lIEFzc2V0cw0KDQpUaGlzIGZvbGRlciBjb250YWlucyBnYW1lIGFzc2V0cyBzdWNoIGFzOg0KDQotIEltYWdlcyAoUE5HLCBKUEcpDQotIFNvdW5kcyAoT0dHLCBNUDMpDQotIEZvbnRzIChUVEYsIE9URikgDQotIDNEIE1vZGVscyAoRkJYLCBldGMuKQ0KLSBPdGhlciByZXNvdXJjZXMNCg0KIyMgSGVhcHMuaW8gUmVzb3VyY2UgU3lzdGVtDQoNCkluIHlvdXIgSGF4ZSBjb2RlLCBhY2Nlc3MgYXNzZXRzIHVzaW5nIHRoZSBoZWFwcyByZXNvdXJjZSBzeXN0ZW06DQoNCmBgYGhheGUNCi8vIExvYWQgYW4gaW1hZ2UNCnZhciB0ZXh0dXJlID0gaHhkLlJlcy5teUltYWdlLnRvVGV4dHVyZSgpOw0KdmFyIGJpdG1hcCA9IG5ldyBoMmQuQml0bWFwKHRleHR1cmUsIHMyZCk7DQoNCi8vIExvYWQgYSBzb3VuZA0KdmFyIHNvdW5kID0gaHhkLlJlcy5teVNvdW5kOw0Kc291bmQucGxheSgpOw0KDQovLyBMb2FkIGEgZm9udA0KdmFyIGZvbnQgPSBoeGQuUmVzLm15Rm9udC50b0ZvbnQoKTsNCnZhciB0ZXh0ID0gbmV3IGgyZC5UZXh0KGZvbnQsIHMyZCk7DQpgYGANCg0KIyMgTW9iaWxlIE9wdGltaXphdGlvbiBUaXBzDQoNCi0gS2VlcCB0ZXh0dXJlIHNpemVzIHBvd2VyLW9mLTIgd2hlbiBwb3NzaWJsZSAoNTEyeDUxMiwgMTAyNHgxMDI0LCBldGMuKQ0KLSBVc2UgY29tcHJlc3NlZCBmb3JtYXRzIGFwcHJvcHJpYXRlIGZvciB5b3VyIHRhcmdldCBwbGF0Zm9ybXMNCi0gQ29uc2lkZXIgZGlmZmVyZW50IERQSSB2YXJpYW50cyBmb3IgaGlnaC1yZXNvbHV0aW9uIGRpc3BsYXlzDQotIE9wdGltaXplIGF1ZGlvIGZpbGVzIGZvciBtb2JpbGUgYmFuZHdpZHRoIGFuZCBzdG9yYWdlDQotIFVzZSBhdGxhc2VzIHRvIHJlZHVjZSBkcmF3IGNhbGxzIGZvciAyRCBncmFwaGljcw"}];
haxe_MainLoop.add(hxd_System.updateCursor,-1);
var hx__registerFont;
hx__registerFont = function(name,data) {
	var s = window.document.createElement("style");
	s.type = "text/css";
	s.innerHTML = "@font-face{ font-family: " + name + "; src: url('data:font/ttf;base64," + data + "') format('truetype'); }";
	window.document.getElementsByTagName("head")[0].appendChild(s);
	var div = window.document.createElement("div");
	div.style.fontFamily = name;
	div.style.opacity = 0;
	div.style.width = "1px";
	div.style.height = "1px";
	div.style.position = "fixed";
	div.style.bottom = "0px";
	div.style.right = "0px";
	div.innerHTML = ".";
	div.className = "hx__loadFont";
	window.document.body.appendChild(div);
};
js_Boot.__toStr = ({ }).toString;
if(ArrayBuffer.prototype.slice == null) {
	ArrayBuffer.prototype.slice = js_lib__$ArrayBuffer_ArrayBufferCompat.sliceImpl;
}
Xml.Element = 0;
Xml.PCData = 1;
Xml.CData = 2;
Xml.Comment = 3;
Xml.DocType = 4;
Xml.ProcessingInstruction = 5;
Xml.Document = 6;
engine_view_EventBusConstants.ENTITY_SPAWN = "entity:spawn";
engine_view_EventBusConstants.ENTITY_DEATH = "entity:death";
engine_view_EventBusConstants.ENTITY_MOVE = "entity:move";
engine_view_EventBusConstants.ENTITY_CORRECTION = "entity:correction";
engine_view_EventBusConstants.ENTITY_DAMAGE = "entity:damage";
engine_view_EventBusConstants.ENTITY_COLLISION = "entity:collision";
engine_view_EventBusConstants.TICK_COMPLETE = "tick:complete";
engine_view_EventBusConstants.SNAPSHOT = "snapshot";
engine_view_EventBusConstants.PHYSICS_CONTACT = "physics:contact";
engine_view_EventBusConstants.COLLIDER_TRIGGER = "collider:trigger";
engine_view_EventBusConstants.ACTION_INTENT = "action:intent";
engine_view_EventBusConstants.ACTION_RESOLVED = "action:resolved";
engine_view_EventBusTypes.ENTITY_SPAWN = "entity:spawn";
engine_view_EventBusTypes.ENTITY_DEATH = "entity:death";
engine_view_EventBusTypes.ENTITY_MOVE = "entity:move";
engine_view_EventBusTypes.ENTITY_CORRECTION = "entity:correction";
engine_view_EventBusTypes.ENTITY_DAMAGE = "entity:damage";
engine_view_EventBusTypes.ENTITY_COLLISION = "entity:collision";
engine_view_EventBusTypes.TICK_COMPLETE = "tick:complete";
engine_view_EventBusTypes.SNAPSHOT = "snapshot";
engine_view_EventBusTypes.PHYSICS_CONTACT = "physics:contact";
engine_view_EventBusTypes.ACTION_INTENT = "action:intent";
engine_view_EventBusTypes.ACTION_RESOLVED = "action:resolved";
format_gif_Tools.LN2 = Math.log(2);
format_mp3_MPEG.V1 = 3;
format_mp3_MPEG.V2 = 2;
format_mp3_MPEG.V25 = 0;
format_mp3_MPEG.Reserved = 1;
format_mp3_MPEG.V1_Bitrates = [[format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad],[format_mp3_Bitrate.BR_Free,format_mp3_Bitrate.BR_32,format_mp3_Bitrate.BR_40,format_mp3_Bitrate.BR_48,format_mp3_Bitrate.BR_56,format_mp3_Bitrate.BR_64,format_mp3_Bitrate.BR_80,format_mp3_Bitrate.BR_96,format_mp3_Bitrate.BR_112,format_mp3_Bitrate.BR_128,format_mp3_Bitrate.BR_160,format_mp3_Bitrate.BR_192,format_mp3_Bitrate.BR_224,format_mp3_Bitrate.BR_256,format_mp3_Bitrate.BR_320,format_mp3_Bitrate.BR_Bad],[format_mp3_Bitrate.BR_Free,format_mp3_Bitrate.BR_32,format_mp3_Bitrate.BR_48,format_mp3_Bitrate.BR_56,format_mp3_Bitrate.BR_64,format_mp3_Bitrate.BR_80,format_mp3_Bitrate.BR_96,format_mp3_Bitrate.BR_112,format_mp3_Bitrate.BR_128,format_mp3_Bitrate.BR_160,format_mp3_Bitrate.BR_192,format_mp3_Bitrate.BR_224,format_mp3_Bitrate.BR_256,format_mp3_Bitrate.BR_320,format_mp3_Bitrate.BR_384,format_mp3_Bitrate.BR_Bad],[format_mp3_Bitrate.BR_Free,format_mp3_Bitrate.BR_32,format_mp3_Bitrate.BR_64,format_mp3_Bitrate.BR_96,format_mp3_Bitrate.BR_128,format_mp3_Bitrate.BR_160,format_mp3_Bitrate.BR_192,format_mp3_Bitrate.BR_224,format_mp3_Bitrate.BR_256,format_mp3_Bitrate.BR_288,format_mp3_Bitrate.BR_320,format_mp3_Bitrate.BR_352,format_mp3_Bitrate.BR_384,format_mp3_Bitrate.BR_416,format_mp3_Bitrate.BR_448,format_mp3_Bitrate.BR_Bad]];
format_mp3_MPEG.V2_Bitrates = [[format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad],[format_mp3_Bitrate.BR_Free,format_mp3_Bitrate.BR_8,format_mp3_Bitrate.BR_16,format_mp3_Bitrate.BR_24,format_mp3_Bitrate.BR_32,format_mp3_Bitrate.BR_40,format_mp3_Bitrate.BR_48,format_mp3_Bitrate.BR_56,format_mp3_Bitrate.BR_64,format_mp3_Bitrate.BR_80,format_mp3_Bitrate.BR_96,format_mp3_Bitrate.BR_112,format_mp3_Bitrate.BR_128,format_mp3_Bitrate.BR_144,format_mp3_Bitrate.BR_160,format_mp3_Bitrate.BR_Bad],[format_mp3_Bitrate.BR_Free,format_mp3_Bitrate.BR_8,format_mp3_Bitrate.BR_16,format_mp3_Bitrate.BR_24,format_mp3_Bitrate.BR_32,format_mp3_Bitrate.BR_40,format_mp3_Bitrate.BR_48,format_mp3_Bitrate.BR_56,format_mp3_Bitrate.BR_64,format_mp3_Bitrate.BR_80,format_mp3_Bitrate.BR_96,format_mp3_Bitrate.BR_112,format_mp3_Bitrate.BR_128,format_mp3_Bitrate.BR_144,format_mp3_Bitrate.BR_160,format_mp3_Bitrate.BR_Bad],[format_mp3_Bitrate.BR_Free,format_mp3_Bitrate.BR_32,format_mp3_Bitrate.BR_48,format_mp3_Bitrate.BR_56,format_mp3_Bitrate.BR_64,format_mp3_Bitrate.BR_80,format_mp3_Bitrate.BR_96,format_mp3_Bitrate.BR_112,format_mp3_Bitrate.BR_128,format_mp3_Bitrate.BR_144,format_mp3_Bitrate.BR_160,format_mp3_Bitrate.BR_176,format_mp3_Bitrate.BR_192,format_mp3_Bitrate.BR_224,format_mp3_Bitrate.BR_256,format_mp3_Bitrate.BR_Bad]];
format_mp3_MPEG.SamplingRates = [[format_mp3_SamplingRate.SR_11025,format_mp3_SamplingRate.SR_12000,format_mp3_SamplingRate.SR_8000,format_mp3_SamplingRate.SR_Bad],[format_mp3_SamplingRate.SR_Bad,format_mp3_SamplingRate.SR_Bad,format_mp3_SamplingRate.SR_Bad,format_mp3_SamplingRate.SR_Bad],[format_mp3_SamplingRate.SR_22050,format_mp3_SamplingRate.SR_24000,format_mp3_SamplingRate.SR_12000,format_mp3_SamplingRate.SR_Bad],[format_mp3_SamplingRate.SR_44100,format_mp3_SamplingRate.SR_48000,format_mp3_SamplingRate.SR_32000,format_mp3_SamplingRate.SR_Bad]];
format_mp3_CLayer.LReserved = 0;
format_mp3_CLayer.LLayer3 = 1;
format_mp3_CLayer.LLayer2 = 2;
format_mp3_CLayer.LLayer1 = 3;
format_mp3_CChannelMode.CStereo = 0;
format_mp3_CChannelMode.CJointStereo = 1;
format_mp3_CChannelMode.CDualChannel = 2;
format_mp3_CChannelMode.CMono = 3;
format_mp3_CEmphasis.ENone = 0;
format_mp3_CEmphasis.EMs50_15 = 1;
format_mp3_CEmphasis.EReserved = 2;
format_mp3_CEmphasis.ECCIT_J17 = 3;
game_event_EventManager.EVENT_LOAD_HOME_SCENE = "EVENT_LOAD_HOME_SCENE";
game_event_EventManager.EVENT_LOAD_GAME_SCENE = "EVENT_LOAD_GAME_SCENE";
game_event_EventManager.instance = new game_event_EventManager();
game_mvp_presenter_GamePresenter.Config = game_config_GameClientConfig.createSingleplayer();
h2d_Object.tmpPoint = new h2d_col_PointImpl(0.,0.);
h3d_impl_RenderContext.STRICT = true;
h2d_RenderContext.BUFFERING = false;
h2d_col_Matrix.tmp = new h2d_col_Matrix();
h2d_filter_Filter.defaultUseScreenResolution = false;
h3d_Buffer.GUID = 0;
h3d_Engine.SOFTWARE_DRIVER = false;
h3d_Engine.ANTIALIASING = 0;
h3d_MatrixImpl.tmp = new h3d_MatrixImpl();
h3d_MatrixImpl.lumR = 0.212671;
h3d_MatrixImpl.lumG = 0.71516;
h3d_MatrixImpl.lumB = 0.072169;
h3d_MatrixImpl.SQ13 = 0.57735026918962576450914878050196;
h3d_Matrix.IDENTITY_DECOMPOSED = h3d_Matrix.L([1,0,0,0,0,1,1,0,0,0,1,0,0,0,0,1]);
h3d_anim_Animation.EPSILON = 0.000001;
h3d_anim_DynamicJoint.SLEEP_THRESHOLD = 0.0001;
h3d_anim_DynamicJoint.MAX_THRESHOLD = 10e5;
h3d_col_ObjectCollider.TMP_RAY = new h3d_col_Ray();
h3d_col_ObjectCollider.TMP_MAT = new h3d_MatrixImpl();
h3d_scene_Object.ROT2RAD = -0.017453292519943295769236907684886;
h3d_scene_Object.NO_VELOCITY = -1;
h3d_scene_Object.VELOCITY = 0;
h3d_scene_Object.tmpMat = new h3d_MatrixImpl();
h3d_impl_GlDriver.UID = 0;
h3d_impl_GlDriver.ALLOW_WEBGL2 = true;
h3d_impl_GlDriver.hasMultiIndirectCount = false;
h3d_impl_GlDriver.BLACK = (function($this) {
	var $r;
	var x = 0;
	var y = 0;
	var z = 0;
	var w = 0;
	if(w == null) {
		w = 1.;
	}
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	$r = new h3d_Vector4Impl(x,y,z,w);
	return $r;
}(this));
h3d_impl_GlDriver.outOfMemoryCheck = false;
h3d_impl_GlDriver.STREAM_POS = 1;
h3d_impl_GlDriver.TFILTERS = [[[9728,9728],[9729,9729]],[[9728,9984],[9729,9985]],[[9728,9986],[9729,9987]]];
h3d_impl_GlDriver.TWRAP = [33071,10497];
h3d_impl_GlDriver.FACES = [0,1028,1029,1032];
h3d_impl_GlDriver.BLEND = [1,0,770,768,772,774,771,769,773,775,32769,32771,32770,32772,776];
h3d_impl_GlDriver.COMPARE = [519,512,514,517,516,518,513,515];
h3d_impl_GlDriver.STENCIL_OP = [7680,0,7681,7682,34055,7683,34056,5386];
h3d_impl_GlDriver.OP = [32774,32778,32779,32775,32776];
h3d_impl_GlDriver.CUBE_FACES = [34069,34070,34071,34072,34073,34074];
h3d_impl_GlDriver.CBUFFERS = (function($this) {
	var $r;
	var _g = [];
	{
		var _g1 = 0;
		while(_g1 < 32) {
			var i = _g1++;
			var _g2 = [];
			var _g3 = 0;
			var _g4 = i;
			while(_g3 < _g4) {
				var k = _g3++;
				_g2.push(36064 + k);
			}
			_g.push(_g2);
		}
	}
	$r = _g;
	return $r;
}(this));
h3d_impl_MemoryManager.MAX_MEMORY = 4294967296.;
h3d_impl_MemoryManager.SIZE = 65532;
h3d_impl_MemoryManager.ALL_FLAGS = h3d_BufferFlag.__empty_constructs__.slice();
h3d_impl_TextureCache.checkFlags = -1;
h3d_mat_Defaults.defaultKillAlphaThreshold = 0.5;
h3d_mat_Defaults.loadingTextureColor = -65281;
h3d_mat_MaterialSetup.current = new h3d_mat_MaterialSetup("Default");
h3d_mat_Pass.enableLights_bits = 1;
h3d_mat_Pass.enableLights_offset = 0;
h3d_mat_Pass.enableLights_mask = 1;
h3d_mat_Pass.dynamicParameters_bits = 1;
h3d_mat_Pass.dynamicParameters_offset = 1;
h3d_mat_Pass.dynamicParameters_mask = 2;
h3d_mat_Pass.isStatic_bits = 1;
h3d_mat_Pass.isStatic_offset = 2;
h3d_mat_Pass.isStatic_mask = 4;
h3d_mat_Pass.batchMode_bits = 1;
h3d_mat_Pass.batchMode_offset = 3;
h3d_mat_Pass.batchMode_mask = 8;
h3d_mat_Pass.culling_bits = 2;
h3d_mat_Pass.culling_offset = 0;
h3d_mat_Pass.culling_mask = 3;
h3d_mat_Pass.depthWrite_bits = 1;
h3d_mat_Pass.depthWrite_offset = 2;
h3d_mat_Pass.depthWrite_mask = 4;
h3d_mat_Pass.depthTest_bits = 3;
h3d_mat_Pass.depthTest_offset = 3;
h3d_mat_Pass.depthTest_mask = 56;
h3d_mat_Pass.blendSrc_bits = 4;
h3d_mat_Pass.blendSrc_offset = 6;
h3d_mat_Pass.blendSrc_mask = 960;
h3d_mat_Pass.blendDst_bits = 4;
h3d_mat_Pass.blendDst_offset = 10;
h3d_mat_Pass.blendDst_mask = 15360;
h3d_mat_Pass.blendAlphaSrc_bits = 4;
h3d_mat_Pass.blendAlphaSrc_offset = 14;
h3d_mat_Pass.blendAlphaSrc_mask = 245760;
h3d_mat_Pass.blendAlphaDst_bits = 4;
h3d_mat_Pass.blendAlphaDst_offset = 18;
h3d_mat_Pass.blendAlphaDst_mask = 3932160;
h3d_mat_Pass.blendOp_bits = 3;
h3d_mat_Pass.blendOp_offset = 22;
h3d_mat_Pass.blendOp_mask = 29360128;
h3d_mat_Pass.blendAlphaOp_bits = 3;
h3d_mat_Pass.blendAlphaOp_offset = 25;
h3d_mat_Pass.blendAlphaOp_mask = 234881024;
h3d_mat_Pass.wireframe_bits = 1;
h3d_mat_Pass.wireframe_offset = 28;
h3d_mat_Pass.wireframe_mask = 268435456;
h3d_mat_Pass.culled_bits = 1;
h3d_mat_Pass.culled_offset = 29;
h3d_mat_Pass.culled_mask = 536870912;
h3d_mat_Pass.reserved_bits = 1;
h3d_mat_Pass.reserved_offset = 30;
h3d_mat_Pass.reserved_mask = 1073741824;
h3d_mat_Stencil.readMask_bits = 8;
h3d_mat_Stencil.readMask_offset = 0;
h3d_mat_Stencil.readMask_mask = 255;
h3d_mat_Stencil.writeMask_bits = 8;
h3d_mat_Stencil.writeMask_offset = 8;
h3d_mat_Stencil.writeMask_mask = 65280;
h3d_mat_Stencil.reference_bits = 8;
h3d_mat_Stencil.reference_offset = 16;
h3d_mat_Stencil.reference_mask = 16711680;
h3d_mat_Stencil.frontTest_bits = 3;
h3d_mat_Stencil.frontTest_offset = 0;
h3d_mat_Stencil.frontTest_mask = 7;
h3d_mat_Stencil.frontPass_bits = 3;
h3d_mat_Stencil.frontPass_offset = 3;
h3d_mat_Stencil.frontPass_mask = 56;
h3d_mat_Stencil.frontSTfail_bits = 3;
h3d_mat_Stencil.frontSTfail_offset = 6;
h3d_mat_Stencil.frontSTfail_mask = 448;
h3d_mat_Stencil.frontDPfail_bits = 3;
h3d_mat_Stencil.frontDPfail_offset = 9;
h3d_mat_Stencil.frontDPfail_mask = 3584;
h3d_mat_Stencil.backTest_bits = 3;
h3d_mat_Stencil.backTest_offset = 12;
h3d_mat_Stencil.backTest_mask = 28672;
h3d_mat_Stencil.backPass_bits = 3;
h3d_mat_Stencil.backPass_offset = 15;
h3d_mat_Stencil.backPass_mask = 229376;
h3d_mat_Stencil.backSTfail_bits = 3;
h3d_mat_Stencil.backSTfail_offset = 18;
h3d_mat_Stencil.backSTfail_mask = 1835008;
h3d_mat_Stencil.backDPfail_bits = 3;
h3d_mat_Stencil.backDPfail_offset = 21;
h3d_mat_Stencil.backDPfail_mask = 14680064;
h3d_mat_Texture.UID = 0;
h3d_mat_Texture.PREVENT_AUTO_DISPOSE = 2147483647;
h3d_mat_Texture.PREVENT_FORCED_DISPOSE = -1;
h3d_mat_Texture.nativeFormat = hxd_PixelFormat.RGBA;
h3d_mat_Texture.TRILINEAR_FILTERING_ENABLED = true;
h3d_mat_Texture.DEFAULT_WRAP = h3d_mat_Wrap.Clamp;
h3d_mat_Texture.checkerTextureKeys = new haxe_ds_IntMap();
h3d_mat_Texture.noiseTextureKeys = new haxe_ds_IntMap();
h3d_mat_Texture.genTextureKeys = new haxe_ds_StringMap();
h3d_pass_Blur.__meta__ = { obj : { ignore : ["shader"]}};
h3d_shader_ScreenShader.SRC = "HXSMF2gzZC5zaGFkZXIuU2NyZWVuU2hhZGVyBwEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACghfX2luaXRfXw4GAAALBnZlcnRleA4GAAACAgoAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAALAAAFAQYEAgYFDAkDKw4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAA";
h3d_shader_ScreenShader._MODULE = "h3d.shader.ScreenShader";
h3d_pass__$Border_BorderShader.SRC = "HXSMHWgzZC5wYXNzLl9Cb3JkZXIuQm9yZGVyU2hhZGVyCQEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACgVjb2xvcgUMAgAACwhfX2luaXRfXw4GAAAMBnZlcnRleA4GAAANCGZyYWdtZW50DgYAAAMCCwAABQIGBAIHBQwCCAUMBQwGBAIJBQoCAwUKBQoAAAwAAAUBBgQCBgUMCQMrDgQKAgIFCgAAAwYBCgICBQoEAAMCBAMDAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwUMBQwAAQ0AAAUBBgQCCAUMAgoFDAUMAA";
h3d_pass__$Border_BorderShader._MODULE = "h3d.pass.Border";
h3d_pass__$Copy_ArrayCopyShader.SRC = "HXSMHmgzZC5wYXNzLl9Db3B5LkFycmF5Q29weVNoYWRlcgoBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoHdGV4dHVyZQoDAgAACwVsYXllcgECAAAMCF9faW5pdF9fDgYAAA0GdmVydGV4DgYAAA4IZnJhZ21lbnQOBgAAAwIMAAAFAgYEAgcFDAIIBQwFDAYEAgkFCgIDBQoFCgAADQAABQEGBAIGBQwJAysOBAoCAgUKAAADBgEKAgIFCgQAAwIEAwMBAwAAAAAAAAAAAwEDAAAAAAAA8D8DBQwFDAABDgAABQEGBAIIBQwJAyIOAgIKCgMJAyoOAgIJBQoJAycOAQILAQMFCwUMBQwA";
h3d_pass__$Copy_ArrayCopyShader._MODULE = "h3d.pass.Copy";
h3d_pass__$Copy_CopyShader.SRC = "HXSMGWgzZC5wYXNzLl9Db3B5LkNvcHlTaGFkZXIJAQVpbnB1dA0BAgIIcG9zaXRpb24FCgEBAAMCdXYFCgEBAAEAAAQFZmxpcFkDAgAABQZvdXRwdXQNAgIGCHBvc2l0aW9uBQwEBQAHBWNvbG9yBQwEBQAEAAAICnBpeGVsQ29sb3IFDAQAAAkMY2FsY3VsYXRlZFVWBQoEAAAKB3RleHR1cmUKAgIAAAsIX19pbml0X18OBgAADAZ2ZXJ0ZXgOBgAADQhmcmFnbWVudA4GAAADAgsAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAAMAAAFAQYEAgYFDAkDKw4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAENAAAFAQYEAggFDAkDIg4CAgoKAgIJBQoFDAUMAA";
h3d_pass__$Copy_CopyShader._MODULE = "h3d.pass.Copy";
h3d_pass__$CubeCopy_CubeCopyShader.SRC = "HXSMIWgzZC5wYXNzLl9DdWJlQ29weS5DdWJlQ29weVNoYWRlcgoBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoHdGV4dHVyZQoGAgAACwNtYXQGAgAADAhfX2luaXRfXw4GAAANBnZlcnRleA4GAAAOCGZyYWdtZW50DgYAAAMCDAAABQIGBAIHBQwCCAUMBQwGBAIJBQoCAwUKBQoAAA0AAAUBBgQCBgUMCQMrDgQKAgIFCgAAAwYBCgICBQoEAAMCBAMDAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwUMBQwAAQ4AAAUCCA8CdXYFCgQAAAYDBgECCQUKAQMAAAAAAAAAQAMFCgEDAAAAAAAA8D8DBQoABgQCCAUMCQMiDgICCgoGCQMgDgEGAQkDKg4CAg8FCgEDAAAAAAAA8D8DBQsCCwYFCwULBQwFDAA";
h3d_pass__$CubeCopy_CubeCopyShader._MODULE = "h3d.pass.CubeCopy";
h3d_prim_ModelDatabase.db = new haxe_ds_StringMap();
h3d_prim_ModelDatabase.FILE_NAME = "model.props";
h3d_prim_ModelDatabase.LOD_CONFIG = "lodConfig";
h3d_prim_ModelDatabase.DYN_BONES_CONFIG = "dynamicBones";
h3d_prim_ModelDatabase.defaultLodConfigs = new haxe_ds_StringMap();
h3d_prim_ModelDatabase.baseLodConfig = [0.5,0.2,0.01];
h3d_prim_ModelDatabase.current = new h3d_prim_ModelDatabase();
h3d_scene_Mesh.tmpMat = new h3d_MatrixImpl();
h3d_scene_ObjectFlags.FPosChanged = 1;
h3d_scene_ObjectFlags.FVisible = 2;
h3d_scene_ObjectFlags.FCulled = 4;
h3d_scene_ObjectFlags.FFollowPositionOnly = 8;
h3d_scene_ObjectFlags.FLightCameraCenter = 16;
h3d_scene_ObjectFlags.FAllocated = 32;
h3d_scene_ObjectFlags.FAlwaysSyncAnimation = 64;
h3d_scene_ObjectFlags.FInheritCulled = 128;
h3d_scene_ObjectFlags.FModelRoot = 256;
h3d_scene_ObjectFlags.FIgnoreBounds = 512;
h3d_scene_ObjectFlags.FIgnoreCollide = 1024;
h3d_scene_ObjectFlags.FIgnoreParentTransform = 2048;
h3d_scene_ObjectFlags.FCullingColliderInherited = 4096;
h3d_scene_ObjectFlags.FFixedPosition = 8192;
h3d_scene_ObjectFlags.FFixedPositionSynced = 16384;
h3d_scene_ObjectFlags.FAlwaysSync = 32768;
h3d_scene_ObjectFlags.FDrawn = 65536;
h3d_scene_ObjectFlags.FInSync = 131072;
h3d_scene_ObjectFlags.FPosChangedInSync = 262144;
h3d_scene_RenderContext.__meta__ = { fields : { cameraView : { global : ["camera.view"]}, cameraNear : { global : ["camera.zNear"]}, cameraFar : { global : ["camera.zFar"]}, cameraProj : { global : ["camera.proj"]}, cameraPos : { global : ["camera.position"]}, cameraProjDiag : { global : ["camera.projDiag"]}, cameraProjFlip : { global : ["camera.projFlip"]}, cameraViewProj : { global : ["camera.viewProj"]}, cameraInverseViewProj : { global : ["camera.inverseViewProj"]}, cameraPreviousViewProj : { global : ["camera.previousViewProj"]}, cameraJitterOffsets : { global : ["camera.jitterOffsets"]}, globalTime : { global : ["global.time"]}, pixelSize : { global : ["global.pixelSize"]}, globalModelView : { global : ["global.modelView"]}, globalModelViewInverse : { global : ["global.modelViewInverse"]}, globalPreviousModelView : { global : ["global.previousModelView"]}}};
h3d_scene_DynamicJointData.newWorldPos = (function($this) {
	var $r;
	var x = 0;
	var y = 0;
	var z = 0;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	$r = new h3d_VectorImpl(x,y,z);
	return $r;
}(this));
h3d_scene_DynamicJointData.expectedPos = (function($this) {
	var $r;
	var x = 0;
	var y = 0;
	var z = 0;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	$r = new h3d_VectorImpl(x,y,z);
	return $r;
}(this));
h3d_scene_DynamicJointData.tmpVec = (function($this) {
	var $r;
	var x = 0;
	var y = 0;
	var z = 0;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	$r = new h3d_VectorImpl(x,y,z);
	return $r;
}(this));
h3d_scene_DynamicJointData.tmpVec2 = (function($this) {
	var $r;
	var x = 0;
	var y = 0;
	var z = 0;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	$r = new h3d_VectorImpl(x,y,z);
	return $r;
}(this));
h3d_scene_DynamicJointData.tmpQ = new h3d_Quat();
h3d_scene_Skin.TMP_MAT = new h3d_MatrixImpl();
h3d_shader_AmbientLight.SRC = "HXSMF2gzZC5zaGFkZXIuQW1iaWVudExpZ2h0CgEGZ2xvYmFsDQECAgxhbWJpZW50TGlnaHQFCwABAAMQcGVyUGl4ZWxMaWdodGluZwIAAQEAAAAAAAAAAAQKcGl4ZWxDb2xvcgUMBAAABQ9saWdodFBpeGVsQ29sb3IFCwQAAAYKbGlnaHRDb2xvcgULBAAABwhhZGRpdGl2ZQICAAEAAAAAAAgIX19pbml0X18OBgAACRBfX2luaXRfX2ZyYWdtZW50DgYAAAoJY2FsY0xpZ2h0DgYAAAsGdmVydGV4DgYAAAwIZnJhZ21lbnQOBgAABQIIAAAFAQYEAgYFCwsCBwICAgULCQMqDgEBAwAAAAAAAAAAAwULBQsFCwACCQAABQEGBAIFBQsLAgcCAgIFCwkDKg4BAQMAAAAAAAAAAAMFCwULBQsAAwoBDQpsaWdodENvbG9yBQsEAAAFCwUBDQsCBwICDQULBAYAAgIFCwYBCQMWDgIEBgMBAwAAAAAAAPA/AwICBQsFCwULAQMAAAAAAAAAAAMFCwINBQsFCwULBQsFCwAAAAsAAAUBCwcCAgMCAgaBCgIEBQySAAULCQIKDgECBgULBQsFCwAAAAEMAAAFAQsCAwIGgQoCBAUMkgAFCwkCCg4BAgUFCwULBQsAAAA";
h3d_shader_AmbientLight._MODULE = "h3d.shader.AmbientLight";
h3d_shader_Base2d.SRC = "HXSMEWgzZC5zaGFkZXIuQmFzZTJkGwEFaW5wdXQNAQMCCHBvc2l0aW9uBQoBAQADAnV2BQoBAQAEBWNvbG9yBQwBAQABAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgEdGltZQMAAAAJBnpWYWx1ZQMCAAAKB3RleHR1cmUKAgIAAAsOc3ByaXRlUG9zaXRpb24FDAQAAAwQYWJzb2x1dGVQb3NpdGlvbgUMBAAADQpwaXhlbENvbG9yBQwEAAAODHRleHR1cmVDb2xvcgUMBAAADwxjYWxjdWxhdGVkVVYFCgMAABAKaXNSZWxhdGl2ZQICAAEAAAAAABEFY29sb3IFDAIAABIPYWJzb2x1dGVNYXRyaXhBBQsCAAATD2Fic29sdXRlTWF0cml4QgULAgAAFA1maWx0ZXJNYXRyaXhBBQsCAAAVDWZpbHRlck1hdHJpeEIFCwIAABYIaGFzVVZQb3MCAgABAAAAAAAXBXV2UG9zBQwCAAAYCWtpbGxBbHBoYQICAAEAAAAAABkKcGl4ZWxBbGlnbgICAAEAAAAAABoQaGFsZlBpeGVsSW52ZXJzZQUKAgAAGwl2aWV3cG9ydEEFCwIAABwJdmlld3BvcnRCBQsCAAAdDm91dHB1dFBvc2l0aW9uBQwEAAAeCF9faW5pdF9fDgYAAB8GdmVydGV4DgYAACAIZnJhZ21lbnQOBgAAAwIeAAAFBgYEAgsFDAkDKw4DAgIFCgIJAwEDAAAAAAAA8D8DBQwFDAsCEAIFAwYECgIMBQwAAAMJAx4OAgkDKg4CCgILBQwRAAUKAQMAAAAAAADwPwMFCwISBQsDAwYECgIMBQwEAAMJAx4OAgkDKg4CCgILBQwRAAUKAQMAAAAAAADwPwMFCwITBQsDAwYECgIMBQw5AAUKCgILBQw5AAUKBQoABgQCDAUMAgsFDAUMAAYEAg8FCgsCFgIGAAYBAgMFCgoCFwUMOQAFCgUKCgIXBQwRAAUKBQoCAwUKBQoFCgYEAg0FDAsCEAIGAQIRBQwCBAUMBQwCBAUMBQwFDAYEAg4FDAkDIg4CAgoKAgIPBQoFDAUMBoECDQUMAg4FDAUMAAAfAAAFBQghA3RtcAULBAAACQMqDgIKAgwFDBEABQoBAwAAAAAAAPA/AwULAAYEAiEFCwkDKg4DCQMeDgICIQULAhQFCwMJAx4OAgIhBQsCFQULAwEDAAAAAAAA8D8DBQsFCwYEAh0FDAkDKw4DCQMeDgICIQULAhsFCwMJAx4OAgIhBQsCHAULAwoCDAUMOQAFCgUMBQwLAhkCBoMKAh0FDBEABQoCGgUKBQoAAAYEAgYFDAIdBQwFDAABIAAABQILBg4CGAIGCQoCDQUMDAADAQP8qfHSTWJQPwMCAgwAAAAGBAIHBQwCDQUMBQwA";
h3d_shader_Base2d._MODULE = "h3d.shader.Base2d";
h3d_shader_BaseMesh.SRC = "HXSME2gzZC5zaGFkZXIuQmFzZU1lc2gcAQZjYW1lcmENAQwCBHZpZXcHAAEAAwRwcm9qBwABAAQIcG9zaXRpb24FCwABAAUIcHJvakZsaXADAAEABghwcm9qRGlhZwULAAEABwh2aWV3UHJvagcAAQAIEHByZXZpb3VzVmlld1Byb2oHAAEACQ9pbnZlcnNlVmlld1Byb2oHAAEACgV6TmVhcgMAAQALBHpGYXIDAAEADANkaXIFCwMBAA0Naml0dGVyT2Zmc2V0cwUMAAEAAAAADgZnbG9iYWwNAgUPBHRpbWUDAA4AEAlwaXhlbFNpemUFCgAOABEJbW9kZWxWaWV3BwAOAQMSEG1vZGVsVmlld0ludmVyc2UHAA4BAxMRcHJldmlvdXNNb2RlbFZpZXcHAA4BAwAAABQFaW5wdXQNAwIVCHBvc2l0aW9uBQsBFAAWBm5vcm1hbAULARQAAQAAFwZvdXRwdXQNBAYYCHBvc2l0aW9uBQwEFwAZBWNvbG9yBQwEFwAaBWRlcHRoAwQXABsGbm9ybWFsBQsEFwAcCXdvcmxkRGlzdAMEFwAdCHZlbG9jaXR5BQoEFwAEAAAeEHJlbGF0aXZlUG9zaXRpb24FCwQAAB8TdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAIBtwcmV2aW91c1RyYW5zZm9ybWVkUG9zaXRpb24FCwQAACEYcGl4ZWxUcmFuc2Zvcm1lZFBvc2l0aW9uBQsEAAAiEXRyYW5zZm9ybWVkTm9ybWFsBQsEAAAjEXByb2plY3RlZFBvc2l0aW9uBQwEAAAkGXByZXZpb3VzUHJvamVjdGVkUG9zaXRpb24FDAQAACUKcGl4ZWxDb2xvcgUMBAAAJgVkZXB0aAMEAAAnC25kY1Bvc2l0aW9uBQoEAAAoE3ByZXZpb3VzTmRjUG9zaXRpb24FCgQAACkIc2NyZWVuVVYFCgQAACoJc3BlY1Bvd2VyAwQAACsJc3BlY0NvbG9yBQsEAAAsCXdvcmxkRGlzdAMEAAAtDXBpeGVsVmVsb2NpdHkFCgQAAC4FY29sb3IFDAIAAC8Nc3BlY3VsYXJQb3dlcgMCAAEHAAAAAAAAAAAAAAAAAABZQDAOc3BlY3VsYXJBbW91bnQDAgABBwAAAAAAAAAAAAAAAAAAJEAxDXNwZWN1bGFyQ29sb3IFCwIAADIIX19pbml0X18OBgAAMxBfX2luaXRfX2ZyYWdtZW50DgYAADQGdmVydGV4DgYAADUIZnJhZ21lbnQOBgAABAIyAAAFDQYEAh4FCwIVBQsFCwYEAh8FCwYBAh4FCwkDNQ4BAhEHCAULBQsGBAIjBQwGAQkDKw4CAh8FCwEDAAAAAAAA8D8DBQwCBwcFDAUMBgQCIAULBgECHgULCQM1DgECEwcIBQsFCwYEAiQFDAYBCQMrDgICIAULAQMAAAAAAADwPwMFDAIIBwUMBQwGBAIiBQsJAyAOAQQGAQIWBQsJAzMOAQIRBwYFCwULBQsFCwYEAgwFCwkDIA4BBAYDAgQFCwIfBQsFCwULBQsFCwYEAiUFDAIuBQwFDAYEAioDAi8DAwYEAisFCwYBAjEFCwIwAwULBQsGBAIpBQoJAzsOAQYCCgIjBQwRAAUKCgIjBQwMAAMFCgUKBQoGBAImAwYCCgIjBQwIAAMKAiMFDAwAAwMDBgQCLAMGAgkDHA4BBgMCHwULAgQFCwULAwILAwMDAAIzAAAFCgYEAiIFCwkDIA4BAiIFCwULBQsGBAInBQoGAgoCIwUMEQAFCgoCIwUMDAADBQoFCgYEAigFCgYCCgIkBQwRAAUKCgIkBQwMAAMFCgUKBgQCKQUKCQM7DgECJwUKBQoFCgYEAiYDBgIKAiMFDAgAAwoCIwUMDAADAwMGBAIqAwIvAwMGBAIrBQsGAQIxBQsCMAMFCwULBoMCJwUKCgINBQwRAAUKBQoGgwIoBQoKAg0FDDkABQoFCgYEAi0FCgYBBAYDAigFCgInBQoFCgUKCQMpDgIBAwAAAAAAAOA/AwEDAAAAAAAA4L8DBQoFCgUKAAA0AAAFAgYEAhgFDAYBAiMFDAkDKw4EAQMAAAAAAADwPwMCBQMBAwAAAAAAAPA/AwEDAAAAAAAA8D8DBQwFDAUMBgQCIQULAh8FCwULAAE1AAAFBQYEAhkFDAIlBQwFDAYEAhoDAiYDAwYEAhsFCwIiBQsFCwYEAhwDAiwDAwYEAh0FCgItBQoFCgA";
h3d_shader_BaseMesh._MODULE = "h3d.shader.BaseMesh";
h3d_shader_Blur.SRC = "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";
h3d_shader_Blur._MODULE = "h3d.shader.Blur";
h3d_shader_ColorAdd.SRC = "HXSME2gzZC5zaGFkZXIuQ29sb3JBZGQDAQpwaXhlbENvbG9yBQwEAAACBWNvbG9yBQsCAAADCGZyYWdtZW50DgYAAAEBAwAABQEGgAoCAQUMkgAFCwICBQsFCwA";
h3d_shader_ColorAdd._MODULE = "h3d.shader.ColorAdd";
h3d_shader_ColorKey.SRC = "HXSME2gzZC5zaGFkZXIuQ29sb3JLZXkDAQhjb2xvcktleQUMAgAAAgx0ZXh0dXJlQ29sb3IFDAQAAAMIZnJhZ21lbnQOBgAAAQEDAAAFAggEBWNkaWZmBQwEAAAGAwICBQwCAQUMBQwACwYJCQMeDgICBAUMAgQFDAMBA/Fo44i1+OQ+AwIMAAAAAA";
h3d_shader_ColorKey._MODULE = "h3d.shader.ColorKey";
h3d_shader_ColorMatrix.SRC = "HXSMFmgzZC5zaGFkZXIuQ29sb3JNYXRyaXgEAQpwaXhlbENvbG9yBQwEAAACBm1hdHJpeAcCAAADB2VuYWJsZWQCAgABAAAAAAAECGZyYWdtZW50DgYAAAEBBAAABQELAgMCBgQCAQUMCQMrDgIKBAYBCQMrDgIKAgEFDJIABQsBAwAAAAAAAPA/AwUMAgIHBQwFDJIABQsKBAYBAgEFDAICBwUMBQwMAAMFDAUMAAAA";
h3d_shader_ColorMatrix._MODULE = "h3d.shader.ColorMatrix";
h3d_shader_DirShadow.SRC = "HXSMFGgzZC5zaGFkZXIuRGlyU2hhZG93EAEGZW5hYmxlAgIAAQAAAAAAAgdVU0VfRVNNAgIAAQAAAAAAAwtzaGFkb3dQb3dlcgMCAAAEB1VTRV9QQ0YCAgABAAAAAAAFC1BDRl9TQU1QTEVTAQIAAQAAAAAABghwY2ZTY2FsZQMCAAAHCXNoYWRvd1JlcwUKAgAACAlzaGFkb3dNYXARAQIAAAkKc2hhZG93UHJvaggCAAAKCnNoYWRvd0JpYXMDAgAACxN0cmFuc2Zvcm1lZFBvc2l0aW9uBQsEAAAMBnNoYWRvdwMEAAANCWRpclNoYWRvdwMEAAAOC3BvaXNzb25EaXNrDwUMBQIAAA8EcmFuZA4GAAAQCGZyYWdtZW50DgYAAAIDDwERAXYDBAAAAwUCCBICZHADBAAACQMeDgIJAysOAQIRAwUMCQMrDgQBA18pyxDH+ilAAwED9P3UeOmOU0ADAQOiRbbz/ZRGQAMBA1CNl24Sq1dAAwUMAwANCQMTDgEGAQkDAg4BAhIDAwEDUPwYc9Fd5UADAwMAAAEQAAAFAgsCAQIFAQsCBAIFCwYEAgwDAQMAAAAAAADwPwMDCBMJdGV4ZWxTaXplBQoEAAAGAgEDAAAAAAAA8D8DAgcFCgUKAAgUCXNoYWRvd1BvcwULBAAABgECCwULAgkIBQsACBUIc2hhZG93VXYFCgQAAAkDOw4BCgIUBQsRAAUKBQoACBYEek1heAMEAAAJAzYOAQoCFAULCAADAwAIFwNyb3QDBAAABgEGAQkCDw4BBgAGAAoCCwULAAADCgILBQsEAAMDCgILBQsIAAMDAwEDH4XrUbgeCUADAwEDAAAAAAAAAEADAwAIGARjb3NSAwQAAAkDAw4BAhcDAwAIGQRzaW5SAwQAAAkDAg4BAhcDAwAIGg5zYW1wbGVTdHJlbmd0aAMEAAAGAgEDAAAAAAAA8D8DCQMnDgECBQEDAwAIGwhvZmZTY2FsZQUKBAAABgECEwUKAgYDBQoADhwBaQEEAAAGFQECAAAAAAECBQEPAQAABQQIHQZvZmZzZXQFCgQAAAYBChECDg8FDAUCHAEFDBEABQoCGwUKBQoABgQCHQUKCQMpDgIGAwYBAhgDCgIdBQoAAAMDBgECGQMKAh0FCgQAAwMDBgAGAQIYAwoCHQUKBAADAwYBAhkDCgIdBQoAAAMDAwUKBQoIHgVkZXB0aAMEAAAJA0EOAwIIEQEGAAIVBQoCHQUKBQoBAwAAAAAAAAAAAwMABoMCDAMLBAYHBgMCFgMCCgMDAh4DAgICGgMBAwAAAAAAAAAAAwMDAAAACwICAgUFCB8Jc2hhZG93UG9zBQsEAAAGAQILBQsCCQgFCwAIIAVkZXB0aAMEAAAJA0AOAgIIEQEJAzsOAQoCHwULEQAFCgUKAwAIIQR6TWF4AwQAAAkDNg4BCgIfBQsIAAMDAAgiBWRlbHRhAwQAAAYDCQMVDgIEBgACIAMCCgMDAwIhAwMCIQMDAAYEAgwDCQM2DgEJAwkOAQYBAgMDAiIDAwMDAwAFBAgjCXNoYWRvd1BvcwULBAAABgECCwULAgkIBQsACCQIc2hhZG93VXYFCgQAAAkDOw4BCgIjBQsRAAUKBQoACCUFZGVwdGgDBAAACQNADgICCBEBCgIkBQoRAAUKAwAGBAIMAwsGBwYDCQM2DgEKAiMFCwgAAwMCCgMDAiUDAgEDAAAAAAAAAAADAQMAAAAAAADwPwMDAwAAAAAAAAYEAg0DAgwDAwA";
h3d_shader_DirShadow._MODULE = "h3d.shader.DirShadow";
h3d_shader_GenTexture.SRC = "HXSMFWgzZC5zaGFkZXIuR2VuVGV4dHVyZQoBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoEbW9kZQECAAEAAAAAAAsFY29sb3IFDAIAAAwIX19pbml0X18OBgAADQZ2ZXJ0ZXgOBgAADghmcmFnbWVudA4GAAADAgwAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAANAAAFAQYEAgYFDAkDKw4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEOAAAFARMEAgoBAQEBAQIAAAAAAQUBBgQCCAUMCwYHCQMcDgEKAgYFDBEABQoDAQMAAAAAAADwPwMCCQMrDgEBAwAAAAAAAAAAAwUMAgsFDAUMBQwAAAAA";
h3d_shader_GenTexture._MODULE = "h3d.shader.GenTexture";
h3d_shader_LineShader.SRC = "HXSMFWgzZC5zaGFkZXIuTGluZVNoYWRlcgwBBmNhbWVyYQ0BAwIEdmlldwcAAQADBHByb2oHAAEABAh2aWV3UHJvagcAAQAAAAAFBmdsb2JhbA0CAgYJcGl4ZWxTaXplBQoABQAHCW1vZGVsVmlldwcABQEDAAAACAVpbnB1dA0DAwkIcG9zaXRpb24FCwEIAAoGbm9ybWFsBQsBCAALAnV2BQoBCAABAAAMBm91dHB1dA0EAQ0IcG9zaXRpb24FDAQMAAQAAA4RdHJhbnNmb3JtZWROb3JtYWwFCwQAAA8TdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAEBFwcm9qZWN0ZWRQb3NpdGlvbgUMBAAAEQtsZW5ndGhTY2FsZQMCAAASBXdpZHRoAwIAABMEcGRpcgUMBAAAFAhfX2luaXRfXw4GAAAVBnZlcnRleA4GAAACAhQAAAUBBQUIFgNkaXIFCwQAAAYBAgoFCwkDMw4BAgcHBgULAAYEAhMFDAYBCQMrDgIGAQIWBQsJAzMOAQICBwYFCwEDAAAAAAAA8D8DBQwCAwcFDAUMBoEKAhMFDBEABQoGAgEDAAAAAAAA8D8DCQMNDgEGAAYBCgITBQwAAAMKAhMFDAAAAwMGAQoCEwUMBAADCgITBQwEAAMDAwMDBQoGgAIPBQsGAQYBAhYFCwoCCwUKAAADBQsCEQMFCwULBgQCDgULCQMgDgECFgULBQsFCwAAABUAAAUBBoAKAhAFDBEABQoGAQYBBgEGAQQGAQoCEwUMBQAFCgkDKQ4CAQMAAAAAAADwPwMBAwAAAAAAAPC/AwUKBQoFCgQGAwoCCwUKBAADAQMAAAAAAADgPwMDAwUKCgIQBQwIAAMFCgIGBQoFCgISAwUKBQoA";
h3d_shader_LineShader._MODULE = "h3d.shader.LineShader";
h3d_shader_MinMaxShader.SRC = "HXSMF2gzZC5zaGFkZXIuTWluTWF4U2hhZGVyCwEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACgR0ZXhBCgICAAALBHRleEIKAgIAAAwFaXNNYXgCAgABAAAAAAANCF9faW5pdF9fDgYAAA4GdmVydGV4DgYAAA8IZnJhZ21lbnQOBgAAAwINAAAFAgYEAgcFDAIIBQwFDAYEAgkFCgIDBQoFCgAADgAABQEGBAIGBQwJAysOBAoCAgUKAAADBgEKAgIFCgQAAwIEAwMBAwAAAAAAAAAAAwEDAAAAAAAA8D8DBQwFDAABDwAABQMIEAFhBQwEAAAJAyIOAgIKCgICCQUKBQwACBEBYgUMBAAACQMiDgICCwoCAgkFCgUMAAYEAggFDAsCDAIJAxYOAgIQBQwCEQUMBQwJAxUOAgIQBQwCEQUMBQwFDAUMAA";
h3d_shader_MinMaxShader._MODULE = "h3d.shader.MinMaxShader";
h3d_shader_CubeMinMaxShader.SRC = "HXSMG2gzZC5zaGFkZXIuQ3ViZU1pbk1heFNoYWRlcgwBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoEdGV4QQoGAgAACwR0ZXhCCgYCAAAMBWlzTWF4AgIAAQAAAAAADQNtYXQGAgAADghfX2luaXRfXw4GAAAPBnZlcnRleA4GAAAQCGZyYWdtZW50DgYAAAMCDgAABQIGBAIHBQwCCAUMBQwGBAIJBQoCAwUKBQoAAA8AAAUBBgQCBgUMCQMrDgQKAgIFCgAAAwYBCgICBQoEAAMCBAMDAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwUMBQwAARAAAAUFCBECdXYFCgQAAAYDBgECCQUKAQMAAAAAAAAAQAMFCgEDAAAAAAAA8D8DBQoACBIDZGlyBQsEAAAGAQkDKg4CAhEFCgEDAAAAAAAA8D8DBQsCDQYFCwAIEwFhBQwEAAAJAyIOAgIKCgYCEgULBQwACBQBYgUMBAAACQMiDgICCwoGAhIFCwUMAAYEAggFDAsCDAIJAxYOAgITBQwCFAUMBQwJAxUOAgITBQwCFAUMBQwFDAUMAA";
h3d_shader_CubeMinMaxShader._MODULE = "h3d.shader.MinMaxShader";
h3d_shader_NormalMap.SRC = "HXSMFGgzZC5zaGFkZXIuTm9ybWFsTWFwCgEGY2FtZXJhDQECAghwb3NpdGlvbgULAAEAAwNkaXIFCwMBAAAAAAQGZ2xvYmFsDQIBBQltb2RlbFZpZXcHAAQBAwAAAAYFaW5wdXQNAwIHBm5vcm1hbAULAQYACAd0YW5nZW50BQsBBgABAAAJB3RleHR1cmUKAgIAAAoMY2FsY3VsYXRlZFVWBQoEAAALE3RyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAwRdHJhbnNmb3JtZWROb3JtYWwFCwQAAA0SdHJhbnNmb3JtZWRUYW5nZW50BQwDAAAODl9faW5pdF9fdmVydGV4DgYAAA8IZnJhZ21lbnQOBgAAAgIOAAAFAQYEAg0FDAkDKw4CBgECCAULCQMzDgECBQcGBQsLBgcJAx4OAgIIBQsCCAULAwEDAAAAAAAA4D8DAgEDAAAAAAAA8D8DAQMAAAAAAADwvwMDBQwFDAABDwAABQUIEAFuBQsEAAACDAULAAgRAm5mBQsEAAAJAzoOAQkDIg4CAgkKAgIKBQoFDAULAAgSBHRhblgFCwQAAAkDIA4BCgINBQySAAULBQsACBMEdGFuWQULBAAABgEJAx8OAgIQBQsCEgULBQsHAwoCDQUMDAADAwULAAYEAgwFCwkDIA4BBAYABgAGAQoCEQULAAADAhIFCwULBgEKAhEFCwQAAwITBQsFCwULBgEKAhEFCwgAAwIQBQsFCwULBQsFCwULAA";
h3d_shader_NormalMap._MODULE = "h3d.shader.NormalMap";
h3d_shader_Shadow.SRC = "HXSMEWgzZC5zaGFkZXIuU2hhZG93BgEGc2hhZG93DQEFAgNtYXARAQABAAMEcHJvaggAAQAEBWNvbG9yBQsAAQAFBXBvd2VyAwABAAYEYmlhcwMAAQAAAAAHCnBpeGVsQ29sb3IFDAQAAAgTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAACRhwaXhlbFRyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAoJc2hhZG93UG9zBQsEAAEBCwhmcmFnbWVudA4GAAABAQsAAAUGCAwJc2hhZG93UG9zBQsEAAAGAQIJBQsCAwgFCwAIDQVkZXB0aAMEAAAJA0AOAgICEQEJAzsOAQoCDAULEQAFCgUKAwAIDgR6TWF4AwQAAAkDNg4BCgIMBQsIAAMDAAgPBWRlbHRhAwQAAAYDCQMVDgIEBgACDQMCBgMDAwIOAwMCDgMDAAgQBXNoYWRlAwQAAAkDNg4BCQMJDgEGAQIFAwIPAwMDAwAGgQoCBwUMkgAFCwYABgEEBgMBAwAAAAAAAPA/AwIQAwMDCgIEBQuSAAULBQsCEAMFCwULAA";
h3d_shader_Shadow._MODULE = "h3d.shader.Shadow";
h3d_shader_SignedDistanceField.SRC = "HXSMHmgzZC5zaGFkZXIuU2lnbmVkRGlzdGFuY2VGaWVsZA8BBWlucHV0DQEDAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEABAVjb2xvcgUMAQEAAQAABQZvdXRwdXQNAgIGCHBvc2l0aW9uBQwEBQAHBWNvbG9yBQwEBQAEAAAIBHRpbWUDAAAACQ5zcHJpdGVQb3NpdGlvbgUMBAAAChBhYnNvbHV0ZVBvc2l0aW9uBQwEAAALCnBpeGVsQ29sb3IFDAQAAAwMdGV4dHVyZUNvbG9yBQwEAAANDGNhbGN1bGF0ZWRVVgUKAwAADg5vdXRwdXRQb3NpdGlvbgUMBAAADwdjaGFubmVsAQIAAQAAAAAAEA1hdXRvU21vb3RoaW5nAgIAAQAAAAAAEQthbHBoYUN1dG9mZgMCAAASCXNtb290aGluZwMCAAATBm1lZGlhbg4GAAAUCGZyYWdtZW50DgYAAAIDEwMVAXIDBAAAFgFnAwQAABcBYgMEAAADBQENCQMWDgIJAxUOAgIVAwIWAwMJAxUOAgkDFg4CAhUDAhYDAwIXAwMDAAABFAAABQUIGA10ZXh0dXJlU2FtcGxlBQwEAAACDAUMAAgZCGRpc3RhbmNlAwQAAAAABgQCGQMLBgUCDwEBAgAAAAABAgoCGAUMAAADCwYFAg8BAQIBAAAAAQIKAhgFDAQAAwsGBQIPAQECAgAAAAECCgIYBQwIAAMLBgUCDwEBAgMAAAABAgoCGAUMDAADCQITDgMKAhgFDAAAAwoCGAUMBAADCgIYBQwIAAMDAwMDAwMIGglzbW9vdGhWYWwDBAAACwIQAgkDDw4BBgEJAz8OAQIZAwMBAwAAAAAAAOA/AwMDAhIDAwAGBAIMBQwJAysOBAEDAAAAAAAA8D8DAQMAAAAAAADwPwMBAwAAAAAAAPA/AwkDGw4DBgMCEQMCGgMDBgACEQMCGgMDAhkDAwUMBQwA";
h3d_shader_SignedDistanceField._MODULE = "h3d.shader.SignedDistanceField";
h3d_shader_Utils.SRC = "HXSMEGgzZC5zaGFkZXIuVXRpbHMHAQtib25lTWF0cml4WAgEAAACC2JvbmVNYXRyaXhZCAQAAAMLYm9uZU1hdHJpeFoIBAAABAtib25lTWF0cml4VwgEAAAFC3NraW5XZWlnaHRzBQwEAAAGDmFwcGx5U2tpblBvaW50DgYAAAcMYXBwbHlTa2luVmVjDgYAAAIDBgEIAXAFCwQAAAULBQMICQt0cmFuc2Zvcm1lZAULBAAABgAGAAYBBAYBAggFCwIBCAULBQsKAgUFDAAAAwULBgEEBgECCAULAgIIBQsFCwoCBQUMBAADBQsFCwYBBAYBAggFCwIDCAULBQsKAgUFDAgAAwULBQsACwYHCgIFBQwMAAMBAwAAAAAAAAAAAwIFAQaAAgkFCwYBBAYBAggFCwIECAULBQsKAgUFDAwAAwULBQsAAAANAgkFCwAAAwcBCgF2BQsEAAAFCwUDCAsLdHJhbnNmb3JtZWQFCwQAAAYABgAGAQQGAQIKBQsJAzMOAQIBCAYFCwULCgIFBQwAAAMFCwYBBAYBAgoFCwkDMw4BAgIIBgULBQsKAgUFDAQAAwULBQsGAQQGAQIKBQsJAzMOAQIDCAYFCwULCgIFBQwIAAMFCwULAAsGBwoCBQUMDAADAQMAAAAAAAAAAAMCBQEGgAILBQsGAQQGAQIKBQsJAzMOAQIECAYFCwULCgIFBQwMAAMFCwULAAAADQILBQsAAA";
h3d_shader_Utils._MODULE = "h3d.shader.Skin";
h3d_shader_SkinBase.SRC = "HXSME2gzZC5zaGFkZXIuU2tpbkJhc2UGARByZWxhdGl2ZVBvc2l0aW9uBQsEAAACE3RyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAMRdHJhbnNmb3JtZWROb3JtYWwFCwQAAAQITWF4Qm9uZXMBAgABAAAAAAAFEWZvdXJCb25lc0J5VmVydGV4AgIAAQAAAAAABg1ib25lc01hdHJpeGVzDwgEAgABCAA";
h3d_shader_SkinBase._MODULE = "h3d.shader.SkinBase";
h3d_shader_Skin.SRC = "HXSMD2gzZC5zaGFkZXIuU2tpbhEBEHJlbGF0aXZlUG9zaXRpb24FCwQAAAITdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAAxF0cmFuc2Zvcm1lZE5vcm1hbAULBAAABAhNYXhCb25lcwECAAEAAAAAAAURZm91ckJvbmVzQnlWZXJ0ZXgCAgABAAAAAAAGDWJvbmVzTWF0cml4ZXMPCAQCAAEIBwtib25lTWF0cml4WAgEAAAIC2JvbmVNYXRyaXhZCAQAAAkLYm9uZU1hdHJpeFoIBAAACgtib25lTWF0cml4VwgEAAALC3NraW5XZWlnaHRzBQwEAAAMBWlucHV0DQEEDQhwb3NpdGlvbgULAQwADgZub3JtYWwFCwEMAA8Hd2VpZ2h0cwULAQwAEAdpbmRleGVzCQQAAAABDAABAAAREnRyYW5zZm9ybWVkVGFuZ2VudAUMBAAAEhtwcmV2aW91c1RyYW5zZm9ybWVkUG9zaXRpb24FCwQAABMOYXBwbHlTa2luUG9pbnQOBgAAFAxhcHBseVNraW5WZWMOBgAAFQZ2ZXJ0ZXgOBgAAAwMTARYBcAULBAAABQsFAwgXC3RyYW5zZm9ybWVkBQsEAAAGAAYABgEEBgECFgULAgcIBQsFCwoCCwUMAAADBQsGAQQGAQIWBQsCCAgFCwULCgILBQwEAAMFCwULBgEEBgECFgULAgkIBQsFCwoCCwUMCAADBQsFCwALBgcKAgsFDAwAAwEDAAAAAAAAAAADAgUBBoACFwULBgEEBgECFgULAgoIBQsFCwoCCwUMDAADBQsFCwAAAA0CFwULAAADFAEYAXYFCwQAAAULBQMIGQt0cmFuc2Zvcm1lZAULBAAABgAGAAYBBAYBAhgFCwkDMw4BAgcIBgULBQsKAgsFDAAAAwULBgEEBgECGAULCQMzDgECCAgGBQsFCwoCCwUMBAADBQsFCwYBBAYBAhgFCwkDMw4BAgkIBgULBQsKAgsFDAgAAwULBQsACwYHCgILBQwMAAMBAwAAAAAAAAAAAwIFAQaAAhkFCwYBBAYBAhgFCwkDMw4BAgoIBgULBQsKAgsFDAwAAwULBQsAAAANAhkFCwAAABUAAAUKBgQCBwgRAgYPCAQJAyYOAQoCEAkEAAAAAAADAQgIBgQCCAgRAgYPCAQJAyYOAQoCEAkEAAAABAADAQgIBgQCCQgRAgYPCAQJAyYOAQoCEAkEAAAACAADAQgIBgQCCggRAgYPCAQJAyYOAQoCEAkEAAAADAADAQgIBgQCCwUMCQMrDgICDwULAQMAAAAAAAAAAAMFDAUMCwIFAgUBBgQKAgsFDAgAAwYDAQMAAAAAAADwPwMEBgAGAAoCDwULAAADCgIPBQsEAAMDCgIPBQsIAAMDAwMDAAAABgQCAgULCQITDgECAQULBQsFCwYEAgMFCwkCFA4BAg4FCwULBQsGBAISBQsCAgULBQsGBAIDBQsJAyAOAQIDBQsFCwULAA";
h3d_shader_Skin._MODULE = "h3d.shader.Skin";
h3d_shader_SkinTangent.SRC = "HXSMFmgzZC5zaGFkZXIuU2tpblRhbmdlbnQJARByZWxhdGl2ZVBvc2l0aW9uBQsEAAACE3RyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAMRdHJhbnNmb3JtZWROb3JtYWwFCwQAAAQITWF4Qm9uZXMBAgABAAAAAAAFEWZvdXJCb25lc0J5VmVydGV4AgIAAQAAAAAABg1ib25lc01hdHJpeGVzDwgEAgABCAcFaW5wdXQNAQUICHBvc2l0aW9uBQsBBwAJBm5vcm1hbAULAQcACgd0YW5nZW50BQsBBwALB3dlaWdodHMFCwEHAAwHaW5kZXhlcwkEAAAAAQcAAQAADRJ0cmFuc2Zvcm1lZFRhbmdlbnQFDAQAAA4GdmVydGV4DgYAAAEADgAABQYGBAICBQsGAAYABgEEBgECAQULEQIGDwgECQMmDgEKAgwJBAAAAAAAAwEIBQsFCwoCCwULAAADBQsGAQQGAQIBBQsRAgYPCAQJAyYOAQoCDAkEAAAABAADAQgFCwULCgILBQsEAAMFCwULBgEEBgECAQULEQIGDwgECQMmDgEKAgwJBAAAAAgAAwEIBQsFCwoCCwULCAADBQsFCwULBgQCAwULBgAGAAYBBAYBAgkFCwkDMw4BEQIGDwgECQMmDgEKAgwJBAAAAAAAAwEIBgULBQsKAgsFCwAAAwULBgEEBgECCQULCQMzDgERAgYPCAQJAyYOAQoCDAkEAAAABAADAQgGBQsFCwoCCwULBAADBQsFCwYBBAYBAgkFCwkDMw4BEQIGDwgECQMmDgEKAgwJBAAAAAgAAwEIBgULBQsKAgsFCwgAAwULBQsFCwYECgINBQySAAULBgAGAAYBBAYBCgIKBQuSAAULCQMzDgERAgYPCAQJAyYOAQoCDAkEAAAAAAADAQgGBQsFCwoCCwULAAADBQsGAQQGAQoCCgULkgAFCwkDMw4BEQIGDwgECQMmDgEKAgwJBAAAAAQAAwEIBgULBQsKAgsFCwQAAwULBQsGAQQGAQoCCgULkgAFCwkDMw4BEQIGDwgECQMmDgEKAgwJBAAAAAgAAwEIBgULBQsKAgsFCwgAAwULBQsFCwsCBQIFBAgPAnc0AwQAAAYDAQMAAAAAAADwPwMEBgAGAAoCCwULAAADCgILBQsEAAMDCgILBQsIAAMDAwMABoACAgULBgEEBgECAQULEQIGDwgECQMmDgEKAgwJBAAAAAwAAwEIBQsFCwIPAwULBQsGgAIDBQsGAQQGAQIJBQsJAzMOARECBg8IBAkDJg4BCgIMCQQAAAAIAAMBCAYFCwULAg8DBQsFCwaACgINBQySAAULBgEEBgEKAgoFC5IABQsJAzMOARECBg8IBAkDJg4BCgIMCQQAAAAMAAMBCAYFCwULAg8DBQsFCwAAAAYEAgMFCwkDIA4BAgMFCwULBQsGBAoCDQUMkgAFCwkDIA4BCgINBQySAAULBQsFCwA";
h3d_shader_SkinTangent._MODULE = "h3d.shader.SkinTangent";
h3d_shader_SpecularTexture.SRC = "HXSMGmgzZC5zaGFkZXIuU3BlY3VsYXJUZXh0dXJlBAEHdGV4dHVyZQoCAgAAAgxjYWxjdWxhdGVkVVYFCgQAAAMJc3BlY0NvbG9yBQsEAAAECGZyYWdtZW50DgYAAAEBBAAABQEGgQIDBQsKCQMiDgICAQoCAgIFCgUMkgAFCwULAA";
h3d_shader_SpecularTexture._MODULE = "h3d.shader.SpecularTexture";
h3d_shader_Texture.SRC = "HXSMEmgzZC5zaGFkZXIuVGV4dHVyZQsBBWlucHV0DQEBAgJ1dgUKAQEAAQAAAwhhZGRpdGl2ZQICAAEAAAAAAAQJa2lsbEFscGhhAgIAAQAAAAAABQ1zcGVjdWxhckFscGhhAgIAAQAAAAAABhJraWxsQWxwaGFUaHJlc2hvbGQDAgABBwAAAAAAAAAAAAAAAAAA8D8HB3RleHR1cmUKAgIAAAgMY2FsY3VsYXRlZFVWBQoEAAAJCnBpeGVsQ29sb3IFDAQAAAoJc3BlY0NvbG9yBQsEAAALBnZlcnRleA4GAAAMCGZyYWdtZW50DgYAAAIACwAABQEGBAIIBQoCAgUKBQoAAQwAAAUECA0BYwUMBAAACQMiDgICBwoCAggFCgUMAAsGDgIEAgYJBgMKAg0FDAwAAwIGAwMBAwAAAAAAAAAAAwICDAAAAAsCAwIGgAIJBQwCDQUMBQwGgQIJBQwCDQUMBQwACwIFAgaBAgoFCwoCDQUM/gAFCwULAAAA";
h3d_shader_Texture._MODULE = "h3d.shader.Texture";
h3d_shader_UVDelta.SRC = "HXSMEmgzZC5zaGFkZXIuVVZEZWx0YQQBB3V2RGVsdGEFCgIAAAIHdXZTY2FsZQUKAgAAAwxjYWxjdWxhdGVkVVYFCgQAAAQGdmVydGV4DgYAAAEABAAABQEGBAIDBQoGAAYBAgMFCgICBQoFCgIBBQoFCgUKAA";
h3d_shader_UVDelta._MODULE = "h3d.shader.UVDelta";
h3d_shader_VertexColorAlpha.SRC = "HXSMG2gzZC5zaGFkZXIuVmVydGV4Q29sb3JBbHBoYQQBBWlucHV0DQEBAgVjb2xvcgUMAQEAAQAAAwpwaXhlbENvbG9yBQwEAAAECGFkZGl0aXZlAgIAAQAAAAAABQhmcmFnbWVudA4GAAABAQUAAAUBCwIEAgaAAgMFDAICBQwFDAaBAgMFDAICBQwFDAAA";
h3d_shader_VertexColorAlpha._MODULE = "h3d.shader.VertexColorAlpha";
h3d_shader_VolumeDecal.SRC = "HXSMFmgzZC5zaGFkZXIuVm9sdW1lRGVjYWwdAQZjYW1lcmENAQwCBHZpZXcHAAEAAwRwcm9qBwABAAQIcG9zaXRpb24FCwABAAUIcHJvakZsaXADAAEABghwcm9qRGlhZwULAAEABwh2aWV3UHJvagcAAQAIEHByZXZpb3VzVmlld1Byb2oHAAEACQ9pbnZlcnNlVmlld1Byb2oHAAEACgV6TmVhcgMAAQALBHpGYXIDAAEADANkaXIFCwMBAA0Naml0dGVyT2Zmc2V0cwUMAAEAAAAADgZnbG9iYWwNAgUPBHRpbWUDAA4AEAlwaXhlbFNpemUFCgAOABEJbW9kZWxWaWV3BwAOAQMSEG1vZGVsVmlld0ludmVyc2UHAA4BAxMRcHJldmlvdXNNb2RlbFZpZXcHAA4BAwAAABQFaW5wdXQNAwIVCHBvc2l0aW9uBQsBFAAWBm5vcm1hbAULARQAAQAAFwZvdXRwdXQNBAYYCHBvc2l0aW9uBQwEFwAZBWNvbG9yBQwEFwAaBWRlcHRoAwQXABsGbm9ybWFsBQsEFwAcCXdvcmxkRGlzdAMEFwAdCHZlbG9jaXR5BQoEFwAEAAAeEHJlbGF0aXZlUG9zaXRpb24FCwQAAB8TdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAIBtwcmV2aW91c1RyYW5zZm9ybWVkUG9zaXRpb24FCwQAACEYcGl4ZWxUcmFuc2Zvcm1lZFBvc2l0aW9uBQsEAAAiEXRyYW5zZm9ybWVkTm9ybWFsBQsEAAAjEXByb2plY3RlZFBvc2l0aW9uBQwEAAAkGXByZXZpb3VzUHJvamVjdGVkUG9zaXRpb24FDAQAACUKcGl4ZWxDb2xvcgUMBAAAJgVkZXB0aAMEAAAnC25kY1Bvc2l0aW9uBQoEAAAoE3ByZXZpb3VzTmRjUG9zaXRpb24FCgQAACkIc2NyZWVuVVYFCgQAACoJc3BlY1Bvd2VyAwQAACsJc3BlY0NvbG9yBQsEAAAsCXdvcmxkRGlzdAMEAAAtDXBpeGVsVmVsb2NpdHkFCgQAAC4IZGVwdGhNYXARAQAAAC8Fc2NhbGUFCgIAADAGbm9ybWFsBQsCAAAxB3RhbmdlbnQFCwIAADIKaXNDZW50ZXJlZAICAAEAAAAAADMMY2FsY3VsYXRlZFVWBQoEAAA0EnRyYW5zZm9ybWVkVGFuZ2VudAUMBAAANQ5fX2luaXRfX3ZlcnRleA4GAAA2CGZyYWdtZW50DgYAAAICNQAABQIGBAIiBQsJAyAOAQQGAQIwBQsJAzMOAQIRBwYFCwULBQsFCwYEAjQFDAkDKw4CCQMgDgEEBgECMQULCQMzDgECEQcGBQsFCwULAQMAAAAAAADwPwMFDAUMAAE2AAAFCQg3Bm1hdHJpeAcEAAAGAQIJBwISBwcACDgJc2NyZWVuUG9zBQoEAAAGAgoCIwUMEQAFCgoCIwUMDAADBQoACDkDcnV2BQwEAAAJAysOAwI4BQoJA0AOAgIuEQEJAzsOAQI4BQoFCgMBAwAAAAAAAPA/AwUMAAg6BHdwb3MFDAQAAAYBAjkFDAI3BwUMAAg7BHBwb3MFDAQAAAYBAjkFDAIJBwUMAAYEAiEFCwYCCgI7BQySAAULCgI7BQwMAAMFCwULBgQCMwUKBgECLwUKBAYCCgI6BQwRAAUKCgI6BQwMAAMFCgUKBQoFCgsCMgIGgAIzBQoBAwAAAAAAAOA/AwUKAAALBgkJAxUOAgkDFQ4CCgIzBQoAAAMKAjMFCgQAAwMJAxUOAgYDAQMAAAAAAADwPwMKAjMFCgAAAwMGAwEDAAAAAAAA8D8DCgIzBQoEAAMDAwMBAwAAAAAAAAAAAwIMAAAAAA";
h3d_shader_VolumeDecal._MODULE = "h3d.shader.VolumeDecal";
haxe_EntryPoint.pending = [];
haxe_EntryPoint.threadCount = 0;
haxe_Unserializer.DEFAULT_RESOLVER = new haxe__$Unserializer_DefaultResolver();
haxe_Unserializer.BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:";
haxe_crypto_Base64.CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
haxe_crypto_Base64.BYTES = haxe_io_Bytes.ofString(haxe_crypto_Base64.CHARS);
haxe_io_FPHelper.helper = new DataView(new ArrayBuffer(8));
haxe_xml_Parser.escapes = (function($this) {
	var $r;
	var h = new haxe_ds_StringMap();
	h.h["lt"] = "<";
	h.h["gt"] = ">";
	h.h["amp"] = "&";
	h.h["quot"] = "\"";
	h.h["apos"] = "'";
	$r = h;
	return $r;
}(this));
haxe_zip_InflateImpl.LEN_EXTRA_BITS_TBL = [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,-1,-1];
haxe_zip_InflateImpl.LEN_BASE_VAL_TBL = [3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258];
haxe_zip_InflateImpl.DIST_EXTRA_BITS_TBL = [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,-1,-1];
haxe_zip_InflateImpl.DIST_BASE_VAL_TBL = [1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577];
haxe_zip_InflateImpl.CODE_LENGTHS_POS = [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
hxd_Precision.F32 = 0;
hxd_Precision.F16 = 1;
hxd_Precision.U8 = 2;
hxd_Precision.S8 = 3;
hxd_Precision.SIZES = [4,2,1,1];
hxd_InputFormat.DFloat = 1;
hxd_InputFormat.DVec2 = 2;
hxd_InputFormat.DVec3 = 3;
hxd_InputFormat.DVec4 = 4;
hxd_InputFormat.DBytes4 = 9;
hxd_BufferFormat._UID = 0;
hxd_BufferFormat.ALL_FORMATS = new haxe_ds_StringMap();
hxd_MultiFormat.UID = 0;
hxd_MultiFormat.CACHE = new haxe_ds_IntMap();
hxd_MultiFormat._UID = 0;
hxd_MultiFormat.MAX_FORMATS = 16;
hxd_Charset.ASCII = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";
hxd_Charset.LATIN1 = "¡¢£¤¥¦§¨©ª«¬-®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿœæŒÆ€";
hxd_Charset.CYRILLIC = "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя—";
hxd_Charset.POLISH = "ĄĆĘŁŃÓŚŹŻąćęłńóśźż";
hxd_Charset.TURKISH = "ÂÇĞIİÎÖŞÜÛâçğıİîöşüû";
hxd_Charset.JP_KANA = "　あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわゐゑをんがぎぐげござじずぜぞだぢづでどばびぶべぼぱぴぷぺぽゃゅょアイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヰヱヲンガギグゲゴザジズゼゾダヂヅデドバビブベボパピプペポヴャぇっッュョァィゥェォ・ー「」、。『』“”！：？％＆（）－０１２３４５６７８９";
hxd_Charset.UNICODE_SPECIALS = "�□";
hxd_Charset.DEFAULT_CHARS = hxd_Charset.ASCII + hxd_Charset.LATIN1;
hxd_Charset.complementChars = (function($this) {
	var $r;
	var str = "ヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻。，";
	var _g = new haxe_ds_IntMap();
	{
		var _g1 = 0;
		var _g2 = str.length;
		while(_g1 < _g2) {
			var i = _g1++;
			_g.h[HxOverrides.cca(str,i)] = true;
		}
	}
	$r = _g;
	return $r;
}(this));
hxd_Key.BACKSPACE = 8;
hxd_Key.TAB = 9;
hxd_Key.ENTER = 13;
hxd_Key.SHIFT = 16;
hxd_Key.CTRL = 17;
hxd_Key.ALT = 18;
hxd_Key.ESCAPE = 27;
hxd_Key.SPACE = 32;
hxd_Key.PGUP = 33;
hxd_Key.PGDOWN = 34;
hxd_Key.END = 35;
hxd_Key.HOME = 36;
hxd_Key.LEFT = 37;
hxd_Key.UP = 38;
hxd_Key.RIGHT = 39;
hxd_Key.DOWN = 40;
hxd_Key.INSERT = 45;
hxd_Key.DELETE = 46;
hxd_Key.QWERTY_EQUALS = 187;
hxd_Key.QWERTY_MINUS = 189;
hxd_Key.QWERTY_TILDE = 192;
hxd_Key.QWERTY_BRACKET_LEFT = 219;
hxd_Key.QWERTY_BRACKET_RIGHT = 221;
hxd_Key.QWERTY_SEMICOLON = 186;
hxd_Key.QWERTY_QUOTE = 222;
hxd_Key.QWERTY_BACKSLASH = 220;
hxd_Key.QWERTY_COMMA = 188;
hxd_Key.QWERTY_PERIOD = 190;
hxd_Key.QWERTY_SLASH = 191;
hxd_Key.INTL_BACKSLASH = 226;
hxd_Key.LEFT_WINDOW_KEY = 91;
hxd_Key.RIGHT_WINDOW_KEY = 92;
hxd_Key.CONTEXT_MENU = 93;
hxd_Key.PAUSE_BREAK = 19;
hxd_Key.CAPS_LOCK = 20;
hxd_Key.NUM_LOCK = 144;
hxd_Key.SCROLL_LOCK = 145;
hxd_Key.NUMBER_0 = 48;
hxd_Key.NUMBER_1 = 49;
hxd_Key.NUMBER_2 = 50;
hxd_Key.NUMBER_3 = 51;
hxd_Key.NUMBER_4 = 52;
hxd_Key.NUMBER_5 = 53;
hxd_Key.NUMBER_6 = 54;
hxd_Key.NUMBER_7 = 55;
hxd_Key.NUMBER_8 = 56;
hxd_Key.NUMBER_9 = 57;
hxd_Key.NUMPAD_0 = 96;
hxd_Key.NUMPAD_1 = 97;
hxd_Key.NUMPAD_2 = 98;
hxd_Key.NUMPAD_3 = 99;
hxd_Key.NUMPAD_4 = 100;
hxd_Key.NUMPAD_5 = 101;
hxd_Key.NUMPAD_6 = 102;
hxd_Key.NUMPAD_7 = 103;
hxd_Key.NUMPAD_8 = 104;
hxd_Key.NUMPAD_9 = 105;
hxd_Key.A = 65;
hxd_Key.B = 66;
hxd_Key.C = 67;
hxd_Key.D = 68;
hxd_Key.E = 69;
hxd_Key.F = 70;
hxd_Key.G = 71;
hxd_Key.H = 72;
hxd_Key.I = 73;
hxd_Key.J = 74;
hxd_Key.K = 75;
hxd_Key.L = 76;
hxd_Key.M = 77;
hxd_Key.N = 78;
hxd_Key.O = 79;
hxd_Key.P = 80;
hxd_Key.Q = 81;
hxd_Key.R = 82;
hxd_Key.S = 83;
hxd_Key.T = 84;
hxd_Key.U = 85;
hxd_Key.V = 86;
hxd_Key.W = 87;
hxd_Key.X = 88;
hxd_Key.Y = 89;
hxd_Key.Z = 90;
hxd_Key.F1 = 112;
hxd_Key.F2 = 113;
hxd_Key.F3 = 114;
hxd_Key.F4 = 115;
hxd_Key.F5 = 116;
hxd_Key.F6 = 117;
hxd_Key.F7 = 118;
hxd_Key.F8 = 119;
hxd_Key.F9 = 120;
hxd_Key.F10 = 121;
hxd_Key.F11 = 122;
hxd_Key.F12 = 123;
hxd_Key.F13 = 124;
hxd_Key.F14 = 125;
hxd_Key.F15 = 126;
hxd_Key.F16 = 127;
hxd_Key.F17 = 128;
hxd_Key.F18 = 129;
hxd_Key.F19 = 130;
hxd_Key.F20 = 131;
hxd_Key.F21 = 132;
hxd_Key.F22 = 133;
hxd_Key.F23 = 134;
hxd_Key.F24 = 135;
hxd_Key.NUMPAD_MULT = 106;
hxd_Key.NUMPAD_ADD = 107;
hxd_Key.NUMPAD_ENTER = 108;
hxd_Key.NUMPAD_SUB = 109;
hxd_Key.NUMPAD_DOT = 110;
hxd_Key.NUMPAD_DIV = 111;
hxd_Key.MOUSE_LEFT = 0;
hxd_Key.MOUSE_RIGHT = 1;
hxd_Key.MOUSE_MIDDLE = 2;
hxd_Key.MOUSE_BACK = 3;
hxd_Key.MOUSE_FORWARD = 4;
hxd_Key.MOUSE_WHEEL_UP = 5;
hxd_Key.MOUSE_WHEEL_DOWN = 6;
hxd_Key.LOC_LEFT = 256;
hxd_Key.LOC_RIGHT = 512;
hxd_Key.LSHIFT = 272;
hxd_Key.RSHIFT = 528;
hxd_Key.LCTRL = 273;
hxd_Key.RCTRL = 529;
hxd_Key.LALT = 274;
hxd_Key.RALT = 530;
hxd_Key.initDone = false;
hxd_Key.keyPressed = [];
hxd_Key.ALLOW_KEY_REPEAT = false;
hxd_Math.PI = 3.14159265358979323;
hxd_Math.EPSILON = 1e-10;
hxd_Math.EPSILON2 = 1e-20;
hxd_Channel.R = 0;
hxd_Channel.G = 1;
hxd_Channel.B = 2;
hxd_Channel.A = 3;
hxd_Timer.wantedFPS = 60.;
hxd_Timer.maxDeltaTime = 0.5;
hxd_Timer.smoothFactor = 0.95;
hxd_Timer.lastTimeStamp = HxOverrides.now() / 1000;
hxd_Timer.elapsedTime = 0.;
hxd_Timer.frameCount = 0;
hxd_Timer.dt = 1 / hxd_Timer.wantedFPS;
hxd_Timer.currentDT = 1 / hxd_Timer.wantedFPS;
hxd_System.setCursor = hxd_System.setNativeCursor;
hxd_System.loopInit = false;
hxd_System.fpsLimit = -1;
hxd_clipper__$Clipper_ClipperBase.HORIZONTAL = -9007199254740992.;
hxd_clipper__$Clipper_ClipperBase.TOLERANCE = 1E-20;
hxd_clipper__$Clipper_ClipperBase.SKIP = -2;
hxd_clipper__$Clipper_ClipperBase.UNASSIGNED = -1;
hxd_fmt_hmd_Position.QTMP = new h3d_Quat();
hxd_fmt_hmd_Data.CURRENT_VERSION = 4;
hxd_fmt_hmd_Reader.BLEND = h2d_BlendMode.__empty_constructs__.slice();
hxd_fmt_hmd_Reader.CULLING = h3d_mat_Face.__empty_constructs__.slice();
hxd_fs_EmbedFileSystem.invalidChars = new EReg("[^A-Za-z0-9_]","g");
hxd_fs_SourceLoader.RELOAD_LFS = [];
hxd_impl_AllocPos.ENABLED = false;
hxd_impl_AllocPos.ENGINE_PACKAGES = ["h3d","hxd","h2d","haxe","sys","hrt"];
hxd_impl_BufferFlags.Dynamic = 0;
hxd_impl_BufferFlags.Static = 1;
hxd_impl_BufferFlags.UniformDynamic = 2;
hxd_impl_BufferFlags.UniformReadWrite = 3;
hxd_impl_BufferFlags.Uniform = 4;
hxd_poly2tri_Point.C_ID = 0;
hxd_res_Resource.LIVE_UPDATE = true;
hxd_res_ImageFormat.Jpg = 0;
hxd_res_ImageFormat.Png = 1;
hxd_res_ImageFormat.Gif = 2;
hxd_res_ImageFormat.Tga = 3;
hxd_res_ImageFormat.Dds = 4;
hxd_res_ImageFormat.Raw = 5;
hxd_res_ImageFormat.Hdr = 6;
hxd_res_Image.DEFAULT_FILTER = h3d_mat_Filter.Linear;
hxd_res_Image.MIPMAP_MAX_SIZE = 0;
hxd_res_Image.ENABLE_AUTO_WATCH = true;
hxd_res_Image.BLACK_1x1 = hxd_Pixels.alloc(1,1,hxd_PixelFormat.RGBA);
hxd_res_Image.LOG_TEXTURE_LOAD = false;
hxd_res_NanoJpeg.BLOCKSIZE = 64;
hxd_res_NanoJpeg.W1 = 2841;
hxd_res_NanoJpeg.W2 = 2676;
hxd_res_NanoJpeg.W3 = 2408;
hxd_res_NanoJpeg.W5 = 1609;
hxd_res_NanoJpeg.W6 = 1108;
hxd_res_NanoJpeg.W7 = 565;
hxd_res_NanoJpeg.CF4A = -9;
hxd_res_NanoJpeg.CF4B = 111;
hxd_res_NanoJpeg.CF4C = 29;
hxd_res_NanoJpeg.CF4D = -3;
hxd_res_NanoJpeg.CF3A = 28;
hxd_res_NanoJpeg.CF3B = 109;
hxd_res_NanoJpeg.CF3C = -9;
hxd_res_NanoJpeg.CF3X = 104;
hxd_res_NanoJpeg.CF3Y = 27;
hxd_res_NanoJpeg.CF3Z = -3;
hxd_res_NanoJpeg.CF2A = 139;
hxd_res_NanoJpeg.CF2B = -11;
hxd_res_Sound.ENABLE_AUTO_WATCH = true;
hxd_snd_Channel.ID = 0;
hxd_snd_Source.ID = 0;
hxd_snd_Manager.STREAM_DURATION = 5.;
hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT = 44100;
hxd_snd_Manager.BUFFER_QUEUE_LENGTH = 2;
hxd_snd_Manager.MAX_SOURCES = 16;
hxd_snd_Manager.SOUND_BUFFER_CACHE_SIZE = 256;
hxd_snd_Manager.VIRTUAL_VOLUME_THRESHOLD = 1e-5;
hxd_snd_Manager.BUFFER_STREAM_SPLIT = 16;
hxd_snd_webaudio_BufferPlayback.FADE_SAMPLES = 10;
hxsl_Tools.UID = 0;
hxsl_Tools.SWIZ = hxsl_Component.__empty_constructs__.slice();
hxsl_Tools.MAX_CHANNELS_BITS = 3;
hxsl_Tools.MAX_PARTIAL_MAPPINGS_BITS = 7;
hxsl_BatchShader.SRC = "HXSMEGh4c2wuQmF0Y2hTaGFkZXIFAQ9CYXRjaF9IYXNPZmZzZXQCAgABAAAAAAACEEJhdGNoX1VzZVN0b3JhZ2UCAgABAAAAAAADC0JhdGNoX0NvdW50AQIAAQAAEAAABAxCYXRjaF9CdWZmZXIQBQwDAgAABRNCYXRjaF9TdG9yYWdlQnVmZmVyEIIFDAAAAgAAAA";
hxsl_BatchShader._MODULE = "hxsl.BatchShader";
hxsl_Checker.vec2 = hxsl_Type.TVec(2,hxsl_VecType.VFloat);
hxsl_Checker.vec3 = hxsl_Type.TVec(3,hxsl_VecType.VFloat);
hxsl_Checker.vec4 = hxsl_Type.TVec(4,hxsl_VecType.VFloat);
hxsl_Checker.ivec2 = hxsl_Type.TVec(2,hxsl_VecType.VInt);
hxsl_Checker.ivec3 = hxsl_Type.TVec(3,hxsl_VecType.VInt);
hxsl_Checker.ivec4 = hxsl_Type.TVec(4,hxsl_VecType.VInt);
hxsl_Debug.VAR_IDS = false;
hxsl_Debug.TRACE = false;
hxsl_Flatten.SWIZ = [hxsl_Component.X,hxsl_Component.Y,hxsl_Component.Z,hxsl_Component.W];
hxsl_GlslOut.KWD_LIST = "attribute const uniform varying buffer shared\r\n\tcoherent volatile restrict readonly writeonly\r\n\tatomic_uint\r\n\tlayout\r\n\tcentroid flat smooth noperspective\r\n\tpatch sample\r\n\tbreak continue do for while switch case default\r\n\tif else\r\n\tsubroutine\r\n\tin out inout\r\n\tfloat double int void bool true false\r\n\tinvariant precise\r\n\tdiscard return\r\n\tmat2 mat3 mat4 dmat2 dmat3 dmat4\r\n\tmat2x2 mat2x3 mat2x4 dmat2x2 dmat2x3 dmat2x4\r\n\tmat3x2 mat3x3 mat3x4 dmat3x2 dmat3x3 dmat3x4\r\n\tmat4x2 mat4x3 mat4x4 dmat4x2 dmat4x3 dmat4x4\r\n\tvec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 dvec2 dvec3 dvec4\r\n\tuint uvec2 uvec3 uvec4\r\n\tlowp mediump highp precision\r\n\timage1D iimage1D uimage1D\r\n\timage2D iimage2D uimage2D\r\n\timage3D iimage3D uimage3D\r\n\tstruct\r\n\tcommon partition active\r\n\tasm\r\n\tclass union enum typedef template this packed\r\n\tresource\r\n\tgoto\r\n\tinline noinline public static extern external interface\r\n\tlong short half fixed unsigned superp\r\n\tinput output\r\n\thvec2 hvec3 hvec4 fvec2 fvec3 fvec4\r\n\tsampler3DRect\r\n\tfilter\r\n\tsizeof cast\r\n\tnamespace using\r\n\trow_major";
hxsl_GlslOut.KWDS = (function($this) {
	var $r;
	var _g = new haxe_ds_StringMap();
	{
		var _g1 = 0;
		var _g2 = new EReg("[ \t\r\n]+","g").split(hxsl_GlslOut.KWD_LIST);
		while(_g1 < _g2.length) {
			var k = _g2[_g1];
			++_g1;
			_g.h[k] = true;
		}
	}
	$r = _g;
	return $r;
}(this));
hxsl_GlslOut.GLOBALS = (function($this) {
	var $r;
	var gl = [];
	{
		var _g = 0;
		var _g1 = hxsl_TGlobal.__empty_constructs__.slice();
		while(_g < _g1.length) {
			var g = _g1[_g];
			++_g;
			var n = "" + Std.string(g);
			n = n.charAt(0).toLowerCase() + HxOverrides.substr(n,1,null);
			gl[g._hx_index] = n;
		}
	}
	gl[hxsl_TGlobal.ToInt._hx_index] = "int";
	gl[hxsl_TGlobal.ToFloat._hx_index] = "float";
	gl[hxsl_TGlobal.ToBool._hx_index] = "bool";
	gl[hxsl_TGlobal.LReflect._hx_index] = "reflect";
	gl[hxsl_TGlobal.Mat3x4._hx_index] = "_mat3x4";
	gl[hxsl_TGlobal.VertexID._hx_index] = "gl_VertexID";
	gl[hxsl_TGlobal.InstanceID._hx_index] = "gl_InstanceID";
	gl[hxsl_TGlobal.IVec2._hx_index] = "ivec2";
	gl[hxsl_TGlobal.IVec3._hx_index] = "ivec3";
	gl[hxsl_TGlobal.IVec4._hx_index] = "ivec4";
	gl[hxsl_TGlobal.BVec2._hx_index] = "bvec2";
	gl[hxsl_TGlobal.BVec3._hx_index] = "bvec3";
	gl[hxsl_TGlobal.BVec4._hx_index] = "bvec4";
	gl[hxsl_TGlobal.FragCoord._hx_index] = "gl_FragCoord";
	gl[hxsl_TGlobal.FrontFacing._hx_index] = "gl_FrontFacing";
	gl[hxsl_TGlobal.FloatBitsToUint._hx_index] = "_floatBitsToUint";
	gl[hxsl_TGlobal.UintBitsToFloat._hx_index] = "_uintBitsToFloat";
	gl[hxsl_TGlobal.ComputeVar_LocalInvocation._hx_index] = "ivec3(gl_LocalInvocationID)";
	gl[hxsl_TGlobal.ComputeVar_GlobalInvocation._hx_index] = "ivec3(gl_GlobalInvocationID)";
	gl[hxsl_TGlobal.ComputeVar_LocalInvocationIndex._hx_index] = "int(gl_LocalInvocationIndex)";
	gl[hxsl_TGlobal.ComputeVar_WorkGroup._hx_index] = "ivec3(gl_WorkGroupID)";
	{
		var _g = 0;
		while(_g < gl.length) {
			var g = gl[_g];
			++_g;
			hxsl_GlslOut.KWDS.h[g] = true;
		}
	}
	$r = gl;
	return $r;
}(this));
hxsl_GlslOut.MAT34 = "struct _mat3x4 { vec4 a; vec4 b; vec4 c; };";
hxsl__$Linker_ShaderInfos.UID = 0;
hxsl_Printer.SWIZ = ["x","y","z","w"];
hxsl_RuntimeShader.UID = 0;
hxsl_Serializer.TVECS = new haxe_ds_IntMap();
hxsl_Serializer.TDIMS = hxsl_TexDimension.__empty_constructs__.slice();
hxsl_Serializer.BOPS = (function($this) {
	var $r;
	var ops = haxe_macro_Binop.__empty_constructs__.slice();
	ops.splice(haxe_macro_Binop.OpAssignOp(null)._hx_index,0,null);
	$r = ops;
	return $r;
}(this));
hxsl_Serializer.UNOPS = haxe_macro_Unop.__empty_constructs__.slice();
hxsl_Serializer.TGLOBALS = hxsl_TGlobal.__empty_constructs__.slice();
hxsl_Serializer.TSWIZ = new haxe_ds_IntMap();
hxsl_Serializer.REGS = [hxsl_Component.X,hxsl_Component.Y,hxsl_Component.Z,hxsl_Component.W];
hxsl_Serializer.VKINDS = hxsl_VarKind.__empty_constructs__.slice();
hxsl_Serializer.PRECS = hxsl_Prec.__empty_constructs__.slice();
hxsl_Serializer.FKIND = hxsl_FunctionKind.__empty_constructs__.slice();
hxsl_Serializer.SIGN = 9204765;
hxsl_ShaderList.MAX_LIST_SIZE = 0;
hxsl_ShaderList.ALLOW_DUPLICATES = true;
hxsl_ShaderInstance.UID = 0;
hxsl_SharedShader.UNROLL_LOOPS = false;
hxsl_SharedShader.SHADER_RESOLVE = new haxe_ds_StringMap();
{
	Main.main();
	haxe_EntryPoint.run();
}
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);

//# sourceMappingURL=game.js.map